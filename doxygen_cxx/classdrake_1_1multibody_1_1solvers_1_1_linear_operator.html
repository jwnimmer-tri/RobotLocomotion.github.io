<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: LinearOperator&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LinearOperator&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::multibody::solvers::LinearOperator&lt; T &gt;</h3>

<p>This abstract class provides a generic interface for linear operators A ∈ ℝⁿˣᵐ defined by their application from ℝᵐ into ℝⁿ, y = A⋅x. </p>
<p>Derived classes must provide an implementation for this application with specifics that exploit the operator's structure, e.g. sparsity, block diagonal, etc. Since most solvers will only need the multiplication operator, subclasses are required to implement this operation in <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#ade99914ba82ad4655feaafd40db037b4" title="Performs y = A⋅x for this operator A.">DoMultiply()</a> for both dense and sparse multiplies. Some operators, typically contact Jacobians for instance, do require additional operations such as multiplication by their transpose. This will generally be a requirement documented by specific solvers but not enforced by this class. Therefore, the implementation of that operation in <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#ab46dc40b1c0df5add96fd1c42494affa" title="For this operator A, performs y = Aᵀ⋅x.">DoMultiplyByTranspose()</a> is optional, with the default implementation provided by this class throwing a runtime exception. Similarly for other operations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default nonsymbolic scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/multibody/solvers/linear_operator.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6cf9ee942f4dda24a5503c308be747c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a6cf9ee942f4dda24a5503c308be747c8">LinearOperator</a> (const std::string &amp;<a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#ad8227ba86a01f26e4f173cd5e219d5d1">name</a>)</td></tr>
<tr class="memdesc:a6cf9ee942f4dda24a5503c308be747c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operator with a given <code>name</code>.  <a href="#a6cf9ee942f4dda24a5503c308be747c8">More...</a><br /></td></tr>
<tr class="separator:a6cf9ee942f4dda24a5503c308be747c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7862d4d8110a2eb9ac304996fb7f5429"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a7862d4d8110a2eb9ac304996fb7f5429">~LinearOperator</a> ()=default</td></tr>
<tr class="separator:a7862d4d8110a2eb9ac304996fb7f5429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8227ba86a01f26e4f173cd5e219d5d1"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#ad8227ba86a01f26e4f173cd5e219d5d1">name</a> () const</td></tr>
<tr class="separator:ad8227ba86a01f26e4f173cd5e219d5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e156c602a813a0401eb10000cabd95"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a08e156c602a813a0401eb10000cabd95">rows</a> () const =0</td></tr>
<tr class="separator:a08e156c602a813a0401eb10000cabd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4da21282e98c5055ae0885078069b83"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#aa4da21282e98c5055ae0885078069b83">cols</a> () const =0</td></tr>
<tr class="separator:aa4da21282e98c5055ae0885078069b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204c87aa0b271fbacd23a9123c1e98e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a204c87aa0b271fbacd23a9123c1e98e3">Multiply</a> (const Eigen::Ref&lt; const Eigen::SparseVector&lt; T &gt;&gt; &amp;x, Eigen::SparseVector&lt; T &gt; *y) const</td></tr>
<tr class="memdesc:a204c87aa0b271fbacd23a9123c1e98e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs y = A⋅x for <code>this</code> operator A.  <a href="#a204c87aa0b271fbacd23a9123c1e98e3">More...</a><br /></td></tr>
<tr class="separator:a204c87aa0b271fbacd23a9123c1e98e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a69471781348bccb2a06b48e848b355"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a7a69471781348bccb2a06b48e848b355">Multiply</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;x, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *y) const</td></tr>
<tr class="memdesc:a7a69471781348bccb2a06b48e848b355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative signature that operates on dense vectors.  <a href="#a7a69471781348bccb2a06b48e848b355">More...</a><br /></td></tr>
<tr class="separator:a7a69471781348bccb2a06b48e848b355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3b19a3293afee194703263bfa3f9a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#aac3b19a3293afee194703263bfa3f9a1">MultiplyByTranspose</a> (const Eigen::Ref&lt; const Eigen::SparseVector&lt; T &gt;&gt; &amp;x, Eigen::SparseVector&lt; T &gt; *y) const</td></tr>
<tr class="memdesc:aac3b19a3293afee194703263bfa3f9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <code>this</code> operator A, performs y = Aᵀ⋅x.  <a href="#aac3b19a3293afee194703263bfa3f9a1">More...</a><br /></td></tr>
<tr class="separator:aac3b19a3293afee194703263bfa3f9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1b891cc2074ffe494637158d34dd67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a4e1b891cc2074ffe494637158d34dd67">MultiplyByTranspose</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;x, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *y) const</td></tr>
<tr class="memdesc:a4e1b891cc2074ffe494637158d34dd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative signature that operates on dense vectors.  <a href="#a4e1b891cc2074ffe494637158d34dd67">More...</a><br /></td></tr>
<tr class="separator:a4e1b891cc2074ffe494637158d34dd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac409c3126289bca9f71f0e087035d83a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#ac409c3126289bca9f71f0e087035d83a">AssembleMatrix</a> (Eigen::SparseMatrix&lt; T &gt; *A) const</td></tr>
<tr class="memdesc:ac409c3126289bca9f71f0e087035d83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembles the explicit matrix form for <code>this</code> operator into matrix A.  <a href="#ac409c3126289bca9f71f0e087035d83a">More...</a><br /></td></tr>
<tr class="separator:ac409c3126289bca9f71f0e087035d83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a64910c4c5e0fe8a9b37702b05a948cef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a64910c4c5e0fe8a9b37702b05a948cef">LinearOperator</a> (const <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a> &amp;)=delete</td></tr>
<tr class="separator:a64910c4c5e0fe8a9b37702b05a948cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a678b4165987e86b8d203243cda0251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a9a678b4165987e86b8d203243cda0251">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a> &amp;)=delete</td></tr>
<tr class="separator:a9a678b4165987e86b8d203243cda0251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534be7b5edfeca726e67a44787921321"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a534be7b5edfeca726e67a44787921321">LinearOperator</a> (<a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a534be7b5edfeca726e67a44787921321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95794d84fd085753c91534833610ce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#ac95794d84fd085753c91534833610ce4">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ac95794d84fd085753c91534833610ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ade99914ba82ad4655feaafd40db037b4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#ade99914ba82ad4655feaafd40db037b4">DoMultiply</a> (const Eigen::Ref&lt; const Eigen::SparseVector&lt; T &gt;&gt; &amp;x, Eigen::SparseVector&lt; T &gt; *y) const =0</td></tr>
<tr class="memdesc:ade99914ba82ad4655feaafd40db037b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs y = A⋅x for <code>this</code> operator A.  <a href="#ade99914ba82ad4655feaafd40db037b4">More...</a><br /></td></tr>
<tr class="separator:ade99914ba82ad4655feaafd40db037b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2025ed986f523f3ddfd4be29b34e621"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#ae2025ed986f523f3ddfd4be29b34e621">DoMultiply</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;x, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *y) const =0</td></tr>
<tr class="memdesc:ae2025ed986f523f3ddfd4be29b34e621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature to operate on dense vectors.  <a href="#ae2025ed986f523f3ddfd4be29b34e621">More...</a><br /></td></tr>
<tr class="separator:ae2025ed986f523f3ddfd4be29b34e621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46dc40b1c0df5add96fd1c42494affa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#ab46dc40b1c0df5add96fd1c42494affa">DoMultiplyByTranspose</a> (const Eigen::SparseVector&lt; T &gt; &amp;x, Eigen::SparseVector&lt; T &gt; *y) const</td></tr>
<tr class="memdesc:ab46dc40b1c0df5add96fd1c42494affa"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <code>this</code> operator A, performs y = Aᵀ⋅x.  <a href="#ab46dc40b1c0df5add96fd1c42494affa">More...</a><br /></td></tr>
<tr class="separator:ab46dc40b1c0df5add96fd1c42494affa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376d34f0398b7b4dca534f47b0c192ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a376d34f0398b7b4dca534f47b0c192ee">DoMultiplyByTranspose</a> (const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;x, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *y) const</td></tr>
<tr class="memdesc:a376d34f0398b7b4dca534f47b0c192ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate signature to operate on dense vectors.  <a href="#a376d34f0398b7b4dca534f47b0c192ee">More...</a><br /></td></tr>
<tr class="separator:a376d34f0398b7b4dca534f47b0c192ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944cc73e942344ca6f19d36a9c1f9e15"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a944cc73e942344ca6f19d36a9c1f9e15">DoAssembleMatrix</a> (Eigen::SparseMatrix&lt; T &gt; *A) const</td></tr>
<tr class="memdesc:a944cc73e942344ca6f19d36a9c1f9e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembles <code>this</code> operator into a sparse matrix A.  <a href="#a944cc73e942344ca6f19d36a9c1f9e15">More...</a><br /></td></tr>
<tr class="separator:a944cc73e942344ca6f19d36a9c1f9e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a64910c4c5e0fe8a9b37702b05a948cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64910c4c5e0fe8a9b37702b05a948cef">&#9670;&nbsp;</a></span>LinearOperator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a534be7b5edfeca726e67a44787921321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534be7b5edfeca726e67a44787921321">&#9670;&nbsp;</a></span>LinearOperator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6cf9ee942f4dda24a5503c308be747c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf9ee942f4dda24a5503c308be747c8">&#9670;&nbsp;</a></span>LinearOperator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an operator with a given <code>name</code>. </p>

</div>
</div>
<a id="a7862d4d8110a2eb9ac304996fb7f5429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7862d4d8110a2eb9ac304996fb7f5429">&#9670;&nbsp;</a></span>~LinearOperator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac409c3126289bca9f71f0e087035d83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac409c3126289bca9f71f0e087035d83a">&#9670;&nbsp;</a></span>AssembleMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AssembleMatrix </td>
          <td>(</td>
          <td class="paramtype">Eigen::SparseMatrix&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assembles the explicit matrix form for <code>this</code> operator into matrix A. </p>
<p>Some solvers might require this operation in order to use direct methods. Particularly useful for debugging sessions. Derived classes can provide an implementation through the virtual interface <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a944cc73e942344ca6f19d36a9c1f9e15" title="Assembles this operator into a sparse matrix A.">DoAssembleMatrix()</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>A is nullptr. </td></tr>
    <tr><td class="paramname">if</td><td>A-&gt;<a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a08e156c602a813a0401eb10000cabd95">rows()</a> does not equal this-&gt;<a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a08e156c602a813a0401eb10000cabd95">rows()</a> or if A-&gt;<a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#aa4da21282e98c5055ae0885078069b83">cols()</a> does not equal this-&gt;<a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#aa4da21282e98c5055ae0885078069b83">cols()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4da21282e98c5055ae0885078069b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4da21282e98c5055ae0885078069b83">&#9670;&nbsp;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classint.html">int</a> cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_sparse_linear_operator.html#a068e0403b14ab29ab5c02acc129b04ce">SparseLinearOperator&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a944cc73e942344ca6f19d36a9c1f9e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944cc73e942344ca6f19d36a9c1f9e15">&#9670;&nbsp;</a></span>DoAssembleMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoAssembleMatrix </td>
          <td>(</td>
          <td class="paramtype">Eigen::SparseMatrix&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assembles <code>this</code> operator into a sparse matrix A. </p>
<p>The default implementation throws a std::runtime_error exception. Its NVI already performed checks for a valid non-null pointer to a matrix of the proper size. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_sparse_linear_operator.html#a10399501bbfc384c39a45a9dad098273">SparseLinearOperator&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ade99914ba82ad4655feaafd40db037b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade99914ba82ad4655feaafd40db037b4">&#9670;&nbsp;</a></span>DoMultiply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoMultiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::SparseVector&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseVector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs y = A⋅x for <code>this</code> operator A. </p>
<p>Its NVI already performed checks for valid arguments. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_sparse_linear_operator.html#a23d6c669e10add3bf2f7e06abd0cdbc9">SparseLinearOperator&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ae2025ed986f523f3ddfd4be29b34e621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2025ed986f523f3ddfd4be29b34e621">&#9670;&nbsp;</a></span>DoMultiply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoMultiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate signature to operate on dense vectors. </p>
<p>Its NVI already performed checks for valid arguments. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_sparse_linear_operator.html#a192b01289b26e99c528eed6a07b9762b">SparseLinearOperator&lt; T &gt;</a>.</p>

</div>
</div>
<a id="ab46dc40b1c0df5add96fd1c42494affa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46dc40b1c0df5add96fd1c42494affa">&#9670;&nbsp;</a></span>DoMultiplyByTranspose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoMultiplyByTranspose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseVector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseVector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For <code>this</code> operator A, performs y = Aᵀ⋅x. </p>
<p>The default implementation throws a std::runtime_error exception. Its NVI already performed checks for valid arguments. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_sparse_linear_operator.html#a13ccb8c90e557754ba9774f3546a42d5">SparseLinearOperator&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a376d34f0398b7b4dca534f47b0c192ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376d34f0398b7b4dca534f47b0c192ee">&#9670;&nbsp;</a></span>DoMultiplyByTranspose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoMultiplyByTranspose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate signature to operate on dense vectors. </p>
<p>Its NVI already performed checks for valid arguments. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_sparse_linear_operator.html#ada159227cc502e4f4f53eee4449cef98">SparseLinearOperator&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a204c87aa0b271fbacd23a9123c1e98e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204c87aa0b271fbacd23a9123c1e98e3">&#9670;&nbsp;</a></span>Multiply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::SparseVector&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseVector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs y = A⋅x for <code>this</code> operator A. </p>
<p>Derived classes must provide an implementation of the virtual interface <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#ade99914ba82ad4655feaafd40db037b4" title="Performs y = A⋅x for this operator A.">DoMultiply()</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>y is nullptr. </td></tr>
    <tr><td class="paramname">if</td><td>x.size() does not equal this-&gt;<a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#aa4da21282e98c5055ae0885078069b83">cols()</a> or if y-&gt;size() does not equal this-&gt;<a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a08e156c602a813a0401eb10000cabd95">rows()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a69471781348bccb2a06b48e848b355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a69471781348bccb2a06b48e848b355">&#9670;&nbsp;</a></span>Multiply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternative signature that operates on dense vectors. </p>

</div>
</div>
<a id="aac3b19a3293afee194703263bfa3f9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3b19a3293afee194703263bfa3f9a1">&#9670;&nbsp;</a></span>MultiplyByTranspose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MultiplyByTranspose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::SparseVector&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseVector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For <code>this</code> operator A, performs y = Aᵀ⋅x. </p>
<p>The default implementation throws a std::runtime_error exception. Derived classes can provide an implementation through the virtual interface <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#ab46dc40b1c0df5add96fd1c42494affa" title="For this operator A, performs y = Aᵀ⋅x.">DoMultiplyByTranspose()</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>y is nullptr. </td></tr>
    <tr><td class="paramname">if</td><td>x.size() does not equal this-&gt;<a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#a08e156c602a813a0401eb10000cabd95">rows()</a> or if y-&gt;size() does not equal this-&gt;<a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html#aa4da21282e98c5055ae0885078069b83">cols()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e1b891cc2074ffe494637158d34dd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1b891cc2074ffe494637158d34dd67">&#9670;&nbsp;</a></span>MultiplyByTranspose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MultiplyByTranspose </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternative signature that operates on dense vectors. </p>

</div>
</div>
<a id="ad8227ba86a01f26e4f173cd5e219d5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8227ba86a01f26e4f173cd5e219d5d1">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac95794d84fd085753c91534833610ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95794d84fd085753c91534833610ce4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a678b4165987e86b8d203243cda0251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a678b4165987e86b8d203243cda0251">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08e156c602a813a0401eb10000cabd95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e156c602a813a0401eb10000cabd95">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classint.html">int</a> rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_sparse_linear_operator.html#a69f27d0bb0ff4f6b2c58a20a793b8f3c">SparseLinearOperator&lt; T &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/solvers/<a class="el" href="linear__operator_8h.html">linear_operator.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody_1_1solvers.html">solvers</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1solvers_1_1_linear_operator.html">LinearOperator</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
