<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::pydrake Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacedrake_1_1pydrake.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">drake::pydrake Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>For more high-level information, see the <a class="el" href="group__python__bindings.html">Python Bindings</a> technical notes. </p>
<p>Drake developers should prefer any aliases defined here over their full spellings in <code>pybind11</code>.</p>
<p><code>namespace py</code> is a shorthand alias to <code>pybind11</code> for consistency. (This symbol cannot be exposed directly in Doxygen.)</p>
<dl class="section note"><dt>Note</dt><dd>Downstream users should avoid <code>using namespace <a class="el" href="namespacedrake_1_1pydrake.html" title="For more high-level information, see the Python Bindings technical notes.">drake::pydrake</a></code>, as this may create ambiguous aliases (especially for GCC). Instead, consider using your own alias directly to the <code>pybind11</code> namespace. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedrake_1_1pydrake_1_1pysolvers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake_1_1pysolvers.html">pysolvers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1pydrake_1_1pysystems"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake_1_1pysystems.html">pysystems</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1pydrake_1_1_object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a publicly visible, but minimal, re-implementation of <code>py::object</code> so that a public type can be used with <code><a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">drake::Value</a>&lt;T&gt;</code>, while still maintaining the revelant semantics with its generic implementation (#13207).  <a href="classdrake_1_1pydrake_1_1_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1pydrake_1_1overload__cast__impl.html">overload_cast_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1pydrake_1_1wrap__arg__default.html">wrap_arg_default</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default case for argument wrapping, with pure pass-through.  <a href="structdrake_1_1pydrake_1_1wrap__arg__default.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a52292ed585da63084b8914356a744d04"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a52292ed585da63084b8914356a744d04">CommonScalarPack</a> = <a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; double, <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;</td></tr>
<tr class="memdesc:a52292ed585da63084b8914356a744d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type pack defining common scalar types.  <a href="#a52292ed585da63084b8914356a744d04">More...</a><br /></td></tr>
<tr class="separator:a52292ed585da63084b8914356a744d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69fa97ca5615e75170ca0274e32cba2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#aa69fa97ca5615e75170ca0274e32cba2">NonSymbolicScalarPack</a> = <a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; double, <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt;</td></tr>
<tr class="memdesc:aa69fa97ca5615e75170ca0274e32cba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type pack for non-symbolic common scalar types.  <a href="#aa69fa97ca5615e75170ca0274e32cba2">More...</a><br /></td></tr>
<tr class="separator:aa69fa97ca5615e75170ca0274e32cba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0999cb00e07db1ec4109413a82b6f4"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class wrap_arg_policy, typename Signature &gt; </td></tr>
<tr class="memitem:aab0999cb00e07db1ec4109413a82b6f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#aab0999cb00e07db1ec4109413a82b6f4">wrap_arg_function</a> = typename internal::wrap_function_impl&lt; wrap_arg_policy &gt;::template wrap_arg&lt; std::function&lt; Signature &gt; &gt;</td></tr>
<tr class="memdesc:aab0999cb00e07db1ec4109413a82b6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for explicitly wrapping functions for a given policy.  <a href="#aab0999cb00e07db1ec4109413a82b6f4">More...</a><br /></td></tr>
<tr class="separator:aab0999cb00e07db1ec4109413a82b6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e587c4c8d044dd6eee74dad65c203ed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a6e587c4c8d044dd6eee74dad65c203ed">py_rvp</a> = py::return_value_policy</td></tr>
<tr class="memdesc:a6e587c4c8d044dd6eee74dad65c203ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortened alias for py::return_value_policy.  <a href="#a6e587c4c8d044dd6eee74dad65c203ed">More...</a><br /></td></tr>
<tr class="separator:a6e587c4c8d044dd6eee74dad65c203ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2274d953c5404b3021085ef6c9891603"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a2274d953c5404b3021085ef6c9891603"><td class="memTemplItemLeft" align="right" valign="top">py::tuple&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a2274d953c5404b3021085ef6c9891603">GetPyParam</a> (<a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; Ts... &gt;={})</td></tr>
<tr class="memdesc:a2274d953c5404b3021085ef6c9891603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the canonical Python parameters for each C++ type.  <a href="#a2274d953c5404b3021085ef6c9891603">More...</a><br /></td></tr>
<tr class="separator:a2274d953c5404b3021085ef6c9891603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4790743839a4b041b37dc3820e2475ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4790743839a4b041b37dc3820e2475ae"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a4790743839a4b041b37dc3820e2475ae">TemporaryClassName</a> (const std::string &amp;name=&quot;TemporaryName&quot;)</td></tr>
<tr class="memdesc:a4790743839a4b041b37dc3820e2475ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a temporary, unique name for a class instantiation that will be passed to <code>AddTemplateClass</code>.  <a href="#a4790743839a4b041b37dc3820e2475ae">More...</a><br /></td></tr>
<tr class="separator:a4790743839a4b041b37dc3820e2475ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed2ec474b72c29e46e599da52c385dc"><td class="memItemLeft" align="right" valign="top">py::object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a0ed2ec474b72c29e46e599da52c385dc">AddTemplateClass</a> (py::handle scope, const std::string &amp;name, py::handle py_class, py::tuple param)</td></tr>
<tr class="memdesc:a0ed2ec474b72c29e46e599da52c385dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a template class instantiation.  <a href="#a0ed2ec474b72c29e46e599da52c385dc">More...</a><br /></td></tr>
<tr class="separator:a0ed2ec474b72c29e46e599da52c385dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8504fe03e622fa78dbbd4e7ce19fdb6"><td class="memTemplParams" colspan="2">template&lt;typename Class , typename... Options&gt; </td></tr>
<tr class="memitem:ab8504fe03e622fa78dbbd4e7ce19fdb6"><td class="memTemplItemLeft" align="right" valign="top">py::class_&lt; Class, Options... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ab8504fe03e622fa78dbbd4e7ce19fdb6">DefineTemplateClassWithDefault</a> (py::handle scope, const std::string &amp;default_name, py::tuple param, const char *doc_string=&quot;&quot;, const std::string &amp;template_suffix=&quot;_&quot;)</td></tr>
<tr class="memdesc:ab8504fe03e622fa78dbbd4e7ce19fdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a convenience wrapper for defining a template class instantiation and a default instantiation (if not already defined).  <a href="#ab8504fe03e622fa78dbbd4e7ce19fdb6">More...</a><br /></td></tr>
<tr class="separator:ab8504fe03e622fa78dbbd4e7ce19fdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590ec0531f7c675e373909bb758740db"><td class="memTemplParams" colspan="2">template&lt;typename Func , typename... Extra&gt; </td></tr>
<tr class="memitem:a590ec0531f7c675e373909bb758740db"><td class="memTemplItemLeft" align="right" valign="top">py::object&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a590ec0531f7c675e373909bb758740db">AddTemplateFunction</a> (py::handle scope, const std::string &amp;name, Func &amp;&amp;func, py::tuple param, Extra &amp;&amp;... extra)</td></tr>
<tr class="memdesc:a590ec0531f7c675e373909bb758740db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a template function.  <a href="#a590ec0531f7c675e373909bb758740db">More...</a><br /></td></tr>
<tr class="separator:a590ec0531f7c675e373909bb758740db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab5a60c764576412e9362aaf18cad93"><td class="memTemplParams" colspan="2">template&lt;typename Method , typename... Extra&gt; </td></tr>
<tr class="memitem:a9ab5a60c764576412e9362aaf18cad93"><td class="memTemplItemLeft" align="right" valign="top">py::object&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a9ab5a60c764576412e9362aaf18cad93">AddTemplateMethod</a> (py::handle scope, const std::string &amp;name, Method &amp;&amp;method, py::tuple param, Extra &amp;&amp;... extra)</td></tr>
<tr class="memdesc:a9ab5a60c764576412e9362aaf18cad93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a template method.  <a href="#a9ab5a60c764576412e9362aaf18cad93">More...</a><br /></td></tr>
<tr class="separator:a9ab5a60c764576412e9362aaf18cad93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65f25e300d8d606958b3df57c29f5fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad65f25e300d8d606958b3df57c29f5fe"><td class="memTemplItemLeft" align="right" valign="top">py::return_value_policy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ad65f25e300d8d606958b3df57c29f5fe">return_value_policy_for_scalar_type</a> ()</td></tr>
<tr class="memdesc:ad65f25e300d8d606958b3df57c29f5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permits referencing for builtin dtypes (e.g.  <a href="#ad65f25e300d8d606958b3df57c29f5fe">More...</a><br /></td></tr>
<tr class="separator:ad65f25e300d8d606958b3df57c29f5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6294e82ee237c93a7e6cbc2fb4d924b2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename PyClass , typename UPack  = typename internal::CastUPack&lt;T&gt;::Pack&gt; </td></tr>
<tr class="memitem:a6294e82ee237c93a7e6cbc2fb4d924b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a6294e82ee237c93a7e6cbc2fb4d924b2">DefCast</a> (PyClass *cls, const char *doc, UPack U_pack={})</td></tr>
<tr class="memdesc:a6294e82ee237c93a7e6cbc2fb4d924b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds <code>cast&lt;T&gt;()</code> explicitly.  <a href="#a6294e82ee237c93a7e6cbc2fb4d924b2">More...</a><br /></td></tr>
<tr class="separator:a6294e82ee237c93a7e6cbc2fb4d924b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b68ce63cf178e7d4e91f95e0e483e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ab0b68ce63cf178e7d4e91f95e0e483e1">DeprecateAttribute</a> (py::object cls, py::str name, py::str message, std::optional&lt; std::string &gt; date={})</td></tr>
<tr class="memdesc:ab0b68ce63cf178e7d4e91f95e0e483e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecates an attribute <code>name</code> of a class <code>cls</code>.  <a href="#ab0b68ce63cf178e7d4e91f95e0e483e1">More...</a><br /></td></tr>
<tr class="separator:ab0b68ce63cf178e7d4e91f95e0e483e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a20567ddf6e5978a874a3cb46353f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a88a20567ddf6e5978a874a3cb46353f4">WarnDeprecated</a> (py::str message, std::optional&lt; std::string &gt; date={})</td></tr>
<tr class="memdesc:a88a20567ddf6e5978a874a3cb46353f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises a deprecation warning.  <a href="#a88a20567ddf6e5978a874a3cb46353f4">More...</a><br /></td></tr>
<tr class="separator:a88a20567ddf6e5978a874a3cb46353f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cd6cd963823cafbc0068bacc7eeadd"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a13cd6cd963823cafbc0068bacc7eeadd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a13cd6cd963823cafbc0068bacc7eeadd">WrapDeprecated</a> (py::str message, Func &amp;&amp;func)</td></tr>
<tr class="memdesc:a13cd6cd963823cafbc0068bacc7eeadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps any callable (function pointer, method pointer, lambda, etc.) to emit a deprecation message.  <a href="#a13cd6cd963823cafbc0068bacc7eeadd">More...</a><br /></td></tr>
<tr class="separator:a13cd6cd963823cafbc0068bacc7eeadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e0f3795b29cfb57c0940ffc8780120"><td class="memTemplParams" colspan="2">template&lt;typename Class , typename... Args&gt; </td></tr>
<tr class="memitem:a36e0f3795b29cfb57c0940ffc8780120"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a36e0f3795b29cfb57c0940ffc8780120">py_init_deprecated</a> (py::str message)</td></tr>
<tr class="memdesc:a36e0f3795b29cfb57c0940ffc8780120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated wrapping of <code>py::init&lt;&gt;</code>.  <a href="#a36e0f3795b29cfb57c0940ffc8780120">More...</a><br /></td></tr>
<tr class="separator:a36e0f3795b29cfb57c0940ffc8780120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a674f4af53caa963b98daa8d85af39"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a40a674f4af53caa963b98daa8d85af39"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a40a674f4af53caa963b98daa8d85af39">py_init_deprecated</a> (py::str message, Func &amp;&amp;func)</td></tr>
<tr class="memdesc:a40a674f4af53caa963b98daa8d85af39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated wrapping of <code>py::init(factory)</code>.  <a href="#a40a674f4af53caa963b98daa8d85af39">More...</a><br /></td></tr>
<tr class="separator:a40a674f4af53caa963b98daa8d85af39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7582877591057ceea633df19d910fa"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a0d7582877591057ceea633df19d910fa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a0d7582877591057ceea633df19d910fa">ToEigenRef</a> (Eigen::VectorBlock&lt; Derived &gt; *derived)</td></tr>
<tr class="memdesc:a0d7582877591057ceea633df19d910fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a mutable Ref&lt;&gt; for a pointer.  <a href="#a0d7582877591057ceea633df19d910fa">More...</a><br /></td></tr>
<tr class="separator:a0d7582877591057ceea633df19d910fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c72466dd0066fa6ff539d65eaf1a01"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8c72466dd0066fa6ff539d65eaf1a01"><td class="memTemplItemLeft" align="right" valign="top">py::object&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ae8c72466dd0066fa6ff539d65eaf1a01">ToArray</a> (T *ptr, <a class="el" href="classint.html">int</a> size, py::tuple shape)</td></tr>
<tr class="memdesc:ae8c72466dd0066fa6ff539d65eaf1a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a raw array to a numpy array.  <a href="#ae8c72466dd0066fa6ff539d65eaf1a01">More...</a><br /></td></tr>
<tr class="separator:ae8c72466dd0066fa6ff539d65eaf1a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50a9a915770def7cbf4f78aa68235dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af50a9a915770def7cbf4f78aa68235dc"><td class="memTemplItemLeft" align="right" valign="top">py::object&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#af50a9a915770def7cbf4f78aa68235dc">ToArray</a> (const T *ptr, <a class="el" href="classint.html">int</a> size, py::tuple shape)</td></tr>
<tr class="memdesc:af50a9a915770def7cbf4f78aa68235dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a raw array to a numpy array (<code>const</code> variant).  <a href="#af50a9a915770def7cbf4f78aa68235dc">More...</a><br /></td></tr>
<tr class="separator:af50a9a915770def7cbf4f78aa68235dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f81d7315477aaa1694d9aa02a1346b"><td class="memItemLeft" align="right" valign="top">py::object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#af5f81d7315477aaa1694d9aa02a1346b">WrapToMatchInputShape</a> (py::handle func)</td></tr>
<tr class="memdesc:af5f81d7315477aaa1694d9aa02a1346b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a overload instance method to reshape the output to be the same as a given input argument.  <a href="#af5f81d7315477aaa1694d9aa02a1346b">More...</a><br /></td></tr>
<tr class="separator:af5f81d7315477aaa1694d9aa02a1346b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236143263d0a18d6ec439f707140d7e1"><td class="memTemplParams" colspan="2">template&lt;typename Class &gt; </td></tr>
<tr class="memitem:a236143263d0a18d6ec439f707140d7e1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a236143263d0a18d6ec439f707140d7e1">BindTypeSafeIndex</a> (py::module m, const std::string &amp;name, const std::string &amp;class_doc=&quot;&quot;)</td></tr>
<tr class="memdesc:a236143263d0a18d6ec439f707140d7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a <a class="el" href="classdrake_1_1_type_safe_index.html" title="A type-safe non-negative index class.">TypeSafeIndex</a> instantiation.  <a href="#a236143263d0a18d6ec439f707140d7e1">More...</a><br /></td></tr>
<tr class="separator:a236143263d0a18d6ec439f707140d7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210546c12706075cdd90f811470ac4b0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Class  = drake::Value&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a210546c12706075cdd90f811470ac4b0"><td class="memTemplItemLeft" align="right" valign="top">py::class_&lt; Class, <a class="el" href="classdrake_1_1_abstract_value.html">drake::AbstractValue</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a210546c12706075cdd90f811470ac4b0">AddValueInstantiation</a> (py::module scope)</td></tr>
<tr class="memdesc:a210546c12706075cdd90f811470ac4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an instantiation of <code>pydrake.common.value.Value[...]</code>.  <a href="#a210546c12706075cdd90f811470ac4b0">More...</a><br /></td></tr>
<tr class="separator:a210546c12706075cdd90f811470ac4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b03ea674322481f48a1262e0c607a2"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class wrap_arg_policy, bool use_functions = true, typename Func  = void&gt; </td></tr>
<tr class="memitem:a52b03ea674322481f48a1262e0c607a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a52b03ea674322481f48a1262e0c607a2">WrapFunction</a> (Func &amp;&amp;func)</td></tr>
<tr class="memdesc:a52b03ea674322481f48a1262e0c607a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the types used in a function signature to produce a new function with wrapped arguments and return value (if non-void).  <a href="#a52b03ea674322481f48a1262e0c607a2">More...</a><br /></td></tr>
<tr class="separator:a52b03ea674322481f48a1262e0c607a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455a0f794f758f800bce946f37c6be29"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a455a0f794f758f800bce946f37c6be29"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a455a0f794f758f800bce946f37c6be29">WrapCallbacks</a> (Func &amp;&amp;func)</td></tr>
<tr class="memdesc:a455a0f794f758f800bce946f37c6be29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that any <code>std::function&lt;&gt;</code> arguments are wrapped such that any <code>T&amp;</code> (which can infer for <code>T = const U</code>) is wrapped as <code>U*</code> (and conversely unwrapped when returned).  <a href="#a455a0f794f758f800bce946f37c6be29">More...</a><br /></td></tr>
<tr class="separator:a455a0f794f758f800bce946f37c6be29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d8c49a4502029d0167c2aa50f4b624"><td class="memTemplParams" colspan="2">template&lt;typename PyClass , typename Class , typename T &gt; </td></tr>
<tr class="memitem:a03d8c49a4502029d0167c2aa50f4b624"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a03d8c49a4502029d0167c2aa50f4b624">DefReadWriteKeepAlive</a> (PyClass *cls, const char *name, T Class::*member, const char *doc=&quot;&quot;)</td></tr>
<tr class="memdesc:a03d8c49a4502029d0167c2aa50f4b624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idempotent to pybind11's <code>def_readwrite()</code>, with the exception that the setter is protected with keep_alive on a <code>member</code> variable that is a bare pointer.  <a href="#a03d8c49a4502029d0167c2aa50f4b624">More...</a><br /></td></tr>
<tr class="separator:a03d8c49a4502029d0167c2aa50f4b624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a22cfe187c4d2e58dacdc4fddf69843"><td class="memTemplParams" colspan="2">template&lt;typename PyClass , typename Class , typename T &gt; </td></tr>
<tr class="memitem:a3a22cfe187c4d2e58dacdc4fddf69843"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a3a22cfe187c4d2e58dacdc4fddf69843">DefReadUniquePtr</a> (PyClass *cls, const char *name, const std::unique_ptr&lt; T &gt; Class::*member, const char *doc=&quot;&quot;)</td></tr>
<tr class="memdesc:a3a22cfe187c4d2e58dacdc4fddf69843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idempotent to pybind11's <code>def_readonly()</code>, which works for unique_ptr elements; the getter is protected with keep_alive on a <code>member</code> variable that is a unique_ptr.  <a href="#a3a22cfe187c4d2e58dacdc4fddf69843">More...</a><br /></td></tr>
<tr class="separator:a3a22cfe187c4d2e58dacdc4fddf69843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50864a5d92c08bf74cf16b6d004aaa6a"><td class="memTemplParams" colspan="2">template&lt;typename PyClass , typename Class , typename T &gt; </td></tr>
<tr class="memitem:a50864a5d92c08bf74cf16b6d004aaa6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a50864a5d92c08bf74cf16b6d004aaa6a">DefReadUniquePtr</a> (PyClass *cls, const char *name, const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; Class::*member, const char *doc=&quot;&quot;)</td></tr>
<tr class="separator:a50864a5d92c08bf74cf16b6d004aaa6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14724461c57557eb0646af0081b97ef2"><td class="memItemLeft" align="right" valign="top">py::object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a14724461c57557eb0646af0081b97ef2">py_keep_alive</a> (py::object nurse, py::object patient)</td></tr>
<tr class="memdesc:a14724461c57557eb0646af0081b97ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this when you must do manual casting - e.g.  <a href="#a14724461c57557eb0646af0081b97ef2">More...</a><br /></td></tr>
<tr class="separator:a14724461c57557eb0646af0081b97ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4937c776ae795edfe27824821a0d14a5"><td class="memTemplParams" colspan="2">template&lt;typename PyClass &gt; </td></tr>
<tr class="memitem:a4937c776ae795edfe27824821a0d14a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a4937c776ae795edfe27824821a0d14a5">DefCopyAndDeepCopy</a> (PyClass *ppy_class)</td></tr>
<tr class="memdesc:a4937c776ae795edfe27824821a0d14a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds Pythonic <code>__copy__</code> and <code>__deepcopy__</code> using class's copy constructor.  <a href="#a4937c776ae795edfe27824821a0d14a5">More...</a><br /></td></tr>
<tr class="separator:a4937c776ae795edfe27824821a0d14a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48601ea388e9d2a662aff6f8b42dca4"><td class="memTemplParams" colspan="2">template&lt;typename PyClass &gt; </td></tr>
<tr class="memitem:ad48601ea388e9d2a662aff6f8b42dca4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ad48601ea388e9d2a662aff6f8b42dca4">DefClone</a> (PyClass *ppy_class)</td></tr>
<tr class="memdesc:ad48601ea388e9d2a662aff6f8b42dca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds Pythonic <code>__copy__</code> and <code>__deepcopy__</code> for a class, as well as <code>Clone</code> method, using class's <code>Clone</code> method rather than the copy constructor.  <a href="#ad48601ea388e9d2a662aff6f8b42dca4">More...</a><br /></td></tr>
<tr class="separator:ad48601ea388e9d2a662aff6f8b42dca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82c192e2b875f6bd19163b69ba9075a"><td class="memTemplParams" colspan="2">template&lt;typename Class &gt; </td></tr>
<tr class="memitem:ad82c192e2b875f6bd19163b69ba9075a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ad82c192e2b875f6bd19163b69ba9075a">ParamInit</a> ()</td></tr>
<tr class="memdesc:ad82c192e2b875f6bd19163b69ba9075a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constructor for creating an instance of Class and initializing parameters (bound using <code>def_readwrite</code>).  <a href="#ad82c192e2b875f6bd19163b69ba9075a">More...</a><br /></td></tr>
<tr class="separator:ad82c192e2b875f6bd19163b69ba9075a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af804829ff8c00cbcacaff4b8ed1b83f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#af804829ff8c00cbcacaff4b8ed1b83f1">ExecuteExtraPythonCode</a> (py::module m)</td></tr>
<tr class="memdesc:af804829ff8c00cbcacaff4b8ed1b83f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Python code to introduce additional symbols for a given module.  <a href="#af804829ff8c00cbcacaff4b8ed1b83f1">More...</a><br /></td></tr>
<tr class="separator:af804829ff8c00cbcacaff4b8ed1b83f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b3fef8297fa00d68181a77b7da0d40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ae4b3fef8297fa00d68181a77b7da0d40">DefineFrameworkPySemantics</a> (py::module m)</td></tr>
<tr class="separator:ae4b3fef8297fa00d68181a77b7da0d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54960a906da6ad2f3b2509a4fd266f5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a54960a906da6ad2f3b2509a4fd266f5b">DefineFrameworkPySystems</a> (py::module m)</td></tr>
<tr class="separator:a54960a906da6ad2f3b2509a4fd266f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae073851bc679a64d47dc27c133b8d89d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ae073851bc679a64d47dc27c133b8d89d">DefineFrameworkPyValues</a> (py::module m)</td></tr>
<tr class="separator:ae073851bc679a64d47dc27c133b8d89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae9bdc6aba9aad5daab1513b39d2b34e7"><td class="memItemLeft" align="right" valign="top">const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#ae9bdc6aba9aad5daab1513b39d2b34e7">py_reference</a> = py::return_value_policy::reference</td></tr>
<tr class="memdesc:ae9bdc6aba9aad5daab1513b39d2b34e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used when returning <code>T&amp; or</code>const T&amp;`, as pybind's default behavior is to copy lvalue references.  <a href="#ae9bdc6aba9aad5daab1513b39d2b34e7">More...</a><br /></td></tr>
<tr class="separator:ae9bdc6aba9aad5daab1513b39d2b34e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e8cda2005c97af6a36240c45e67dd7"><td class="memItemLeft" align="right" valign="top">const auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a36e8cda2005c97af6a36240c45e67dd7">py_reference_internal</a> = py::return_value_policy::reference_internal</td></tr>
<tr class="memdesc:a36e8cda2005c97af6a36240c45e67dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used when returning references to objects that are internally owned by <code>self</code>.  <a href="#a36e8cda2005c97af6a36240c45e67dd7">More...</a><br /></td></tr>
<tr class="separator:a36e8cda2005c97af6a36240c45e67dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3001fa4c52ff2d0f13a58523f67be8e0"><td class="memTemplParams" colspan="2">template&lt;typename Return , typename... Args&gt; </td></tr>
<tr class="memitem:a3001fa4c52ff2d0f13a58523f67be8e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1pydrake.html#a3001fa4c52ff2d0f13a58523f67be8e0">overload_cast_explicit</a> = <a class="el" href="structdrake_1_1pydrake_1_1overload__cast__impl.html">overload_cast_impl</a>&lt;Return, Args...&gt;{}</td></tr>
<tr class="memdesc:a3001fa4c52ff2d0f13a58523f67be8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides option to provide explicit signature when <code>py::overload_cast&lt;Args...&gt;</code> fails to infer the Return argument.  <a href="#a3001fa4c52ff2d0f13a58523f67be8e0">More...</a><br /></td></tr>
<tr class="separator:a3001fa4c52ff2d0f13a58523f67be8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a52292ed585da63084b8914356a744d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52292ed585da63084b8914356a744d04">&#9670;&nbsp;</a></span>CommonScalarPack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1pydrake.html#a52292ed585da63084b8914356a744d04">CommonScalarPack</a> =  <a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; double, <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type pack defining common scalar types. </p>

</div>
</div>
<a id="aa69fa97ca5615e75170ca0274e32cba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69fa97ca5615e75170ca0274e32cba2">&#9670;&nbsp;</a></span>NonSymbolicScalarPack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1pydrake.html#aa69fa97ca5615e75170ca0274e32cba2">NonSymbolicScalarPack</a> =  <a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; double, <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type pack for non-symbolic common scalar types. </p>

</div>
</div>
<a id="a6e587c4c8d044dd6eee74dad65c203ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e587c4c8d044dd6eee74dad65c203ed">&#9670;&nbsp;</a></span>py_rvp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1pydrake.html#a6e587c4c8d044dd6eee74dad65c203ed">py_rvp</a> =  py::return_value_policy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortened alias for py::return_value_policy. </p>
<p>For more information, see the <a class="el" href="group__python__bindings.html#PydrakeReturnValuePolicy">Return Value Policy</a> section. </p>

</div>
</div>
<a id="aab0999cb00e07db1ec4109413a82b6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0999cb00e07db1ec4109413a82b6f4">&#9670;&nbsp;</a></span>wrap_arg_function</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1pydrake.html#aab0999cb00e07db1ec4109413a82b6f4">wrap_arg_function</a> =  typename internal::wrap_function_impl&lt; wrap_arg_policy&gt;::template wrap_arg&lt;std::function&lt;Signature&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Policy for explicitly wrapping functions for a given policy. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0ed2ec474b72c29e46e599da52c385dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed2ec474b72c29e46e599da52c385dc">&#9670;&nbsp;</a></span>AddTemplateClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::object drake::pydrake::AddTemplateClass </td>
          <td>(</td>
          <td class="paramtype">py::handle&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::handle&#160;</td>
          <td class="paramname"><em>py_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::tuple&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a template class instantiation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>Parent scope of the template. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the template. </td></tr>
    <tr><td class="paramname">py_class</td><td>Class instantiation to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The class name should be <em>unique</em>. If you would like automatic unique names, consider constructing the class binding as <code>py::class_&lt;Class, ...&gt;(m, TemporaryClassName&lt;Class&gt;().c_str())</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Parameters for the instantiation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a590ec0531f7c675e373909bb758740db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590ec0531f7c675e373909bb758740db">&#9670;&nbsp;</a></span>AddTemplateFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::object drake::pydrake::AddTemplateFunction </td>
          <td>(</td>
          <td class="paramtype">py::handle&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::tuple&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares a template function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>Parent scope of the template. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the template. </td></tr>
    <tr><td class="paramname">func</td><td>Function to be added. </td></tr>
    <tr><td class="paramname">param</td><td>Parameters for the instantiation. </td></tr>
    <tr><td class="paramname">extra...</td><td>Additional arguments to pass to <code>py::cpp_function</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ab5a60c764576412e9362aaf18cad93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab5a60c764576412e9362aaf18cad93">&#9670;&nbsp;</a></span>AddTemplateMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::object drake::pydrake::AddTemplateMethod </td>
          <td>(</td>
          <td class="paramtype">py::handle&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Method &amp;&amp;&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::tuple&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Extra &amp;&amp;...&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares a template method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>Parent scope of the template. This should be a class. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the template. </td></tr>
    <tr><td class="paramname">method</td><td>Method to be added. </td></tr>
    <tr><td class="paramname">param</td><td>Parameters for the instantiation. </td></tr>
    <tr><td class="paramname">extra...</td><td>Additional arguments to pass to <code>py::cpp_function</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a210546c12706075cdd90f811470ac4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210546c12706075cdd90f811470ac4b0">&#9670;&nbsp;</a></span>AddValueInstantiation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::class_&lt;Class, <a class="el" href="classdrake_1_1_abstract_value.html">drake::AbstractValue</a>&gt; drake::pydrake::AddValueInstantiation </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>scope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines an instantiation of <code>pydrake.common.value.Value[...]</code>. </p>
<p>This is only meant to bind <code><a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>&lt;T&gt;</code> (or specializations thereof). @prereq <code>T</code> must have already been exposed to <code>pybind11</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scope</td><td>Parent scope. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Inner parameter of <code><a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>&lt;T&gt;</code>. </td></tr>
    <tr><td class="paramname">Class</td><td>Class to be bound. By default, <code><a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>&lt;T&gt;</code> is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the registered Python type. </dd></dl>

</div>
</div>
<a id="a236143263d0a18d6ec439f707140d7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236143263d0a18d6ec439f707140d7e1">&#9670;&nbsp;</a></span>BindTypeSafeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::BindTypeSafeIndex </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>class_doc</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds a <a class="el" href="classdrake_1_1_type_safe_index.html" title="A type-safe non-negative index class.">TypeSafeIndex</a> instantiation. </p>

</div>
</div>
<a id="a6294e82ee237c93a7e6cbc2fb4d924b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6294e82ee237c93a7e6cbc2fb4d924b2">&#9670;&nbsp;</a></span>DefCast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefCast </td>
          <td>(</td>
          <td class="paramtype">PyClass *&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UPack&#160;</td>
          <td class="paramname"><em>U_pack</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds <code>cast&lt;T&gt;()</code> explicitly. </p>

</div>
</div>
<a id="ad48601ea388e9d2a662aff6f8b42dca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48601ea388e9d2a662aff6f8b42dca4">&#9670;&nbsp;</a></span>DefClone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefClone </td>
          <td>(</td>
          <td class="paramtype">PyClass *&#160;</td>
          <td class="paramname"><em>ppy_class</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds Pythonic <code>__copy__</code> and <code>__deepcopy__</code> for a class, as well as <code>Clone</code> method, using class's <code>Clone</code> method rather than the copy constructor. </p>

</div>
</div>
<a id="a4937c776ae795edfe27824821a0d14a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4937c776ae795edfe27824821a0d14a5">&#9670;&nbsp;</a></span>DefCopyAndDeepCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefCopyAndDeepCopy </td>
          <td>(</td>
          <td class="paramtype">PyClass *&#160;</td>
          <td class="paramname"><em>ppy_class</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds Pythonic <code>__copy__</code> and <code>__deepcopy__</code> using class's copy constructor. </p>
<dl class="section note"><dt>Note</dt><dd>Do not use this if the class's copy constructor does not imply a deep copy. </dd></dl>

</div>
</div>
<a id="ae4b3fef8297fa00d68181a77b7da0d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b3fef8297fa00d68181a77b7da0d40">&#9670;&nbsp;</a></span>DefineFrameworkPySemantics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefineFrameworkPySemantics </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54960a906da6ad2f3b2509a4fd266f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54960a906da6ad2f3b2509a4fd266f5b">&#9670;&nbsp;</a></span>DefineFrameworkPySystems()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefineFrameworkPySystems </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae073851bc679a64d47dc27c133b8d89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae073851bc679a64d47dc27c133b8d89d">&#9670;&nbsp;</a></span>DefineFrameworkPyValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefineFrameworkPyValues </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8504fe03e622fa78dbbd4e7ce19fdb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8504fe03e622fa78dbbd4e7ce19fdb6">&#9670;&nbsp;</a></span>DefineTemplateClassWithDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::class_&lt;Class, Options...&gt; drake::pydrake::DefineTemplateClassWithDefault </td>
          <td>(</td>
          <td class="paramtype">py::handle&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::tuple&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>doc_string</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>template_suffix</em> = <code>&quot;_&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a convenience wrapper for defining a template class instantiation and a default instantiation (if not already defined). </p>
<p>The default instantiation is named <code>default_name</code>, while the template is named <code>default_name + template_suffix</code>. </p><dl class="section return"><dt>Returns</dt><dd>pybind11 class </dd></dl>

</div>
</div>
<a id="a3a22cfe187c4d2e58dacdc4fddf69843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a22cfe187c4d2e58dacdc4fddf69843">&#9670;&nbsp;</a></span>DefReadUniquePtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefReadUniquePtr </td>
          <td>(</td>
          <td class="paramtype">PyClass *&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; Class::*&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>doc</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Idempotent to pybind11's <code>def_readonly()</code>, which works for unique_ptr elements; the getter is protected with keep_alive on a <code>member</code> variable that is a unique_ptr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PyClass</td><td>the python class. </td></tr>
    <tr><td class="paramname">Class</td><td>the C++ class. </td></tr>
    <tr><td class="paramname">T</td><td>type for the member we wish to apply keep alive semantics. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50864a5d92c08bf74cf16b6d004aaa6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50864a5d92c08bf74cf16b6d004aaa6a">&#9670;&nbsp;</a></span>DefReadUniquePtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefReadUniquePtr </td>
          <td>(</td>
          <td class="paramtype">PyClass *&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1copyable__unique__ptr.html">copyable_unique_ptr</a>&lt; T &gt; Class::*&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>doc</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03d8c49a4502029d0167c2aa50f4b624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d8c49a4502029d0167c2aa50f4b624">&#9670;&nbsp;</a></span>DefReadWriteKeepAlive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DefReadWriteKeepAlive </td>
          <td>(</td>
          <td class="paramtype">PyClass *&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T Class::*&#160;</td>
          <td class="paramname"><em>member</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>doc</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Idempotent to pybind11's <code>def_readwrite()</code>, with the exception that the setter is protected with keep_alive on a <code>member</code> variable that is a bare pointer. </p>
<p>Should not be used for unique_ptr members.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PyClass</td><td>the python class. </td></tr>
    <tr><td class="paramname">Class</td><td>the C++ class. </td></tr>
    <tr><td class="paramname">T</td><td>type for the member we wish to apply keep alive semantics. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0b68ce63cf178e7d4e91f95e0e483e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b68ce63cf178e7d4e91f95e0e483e1">&#9670;&nbsp;</a></span>DeprecateAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::DeprecateAttribute </td>
          <td>(</td>
          <td class="paramtype">py::object&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::str&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::str&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>date</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecates an attribute <code>name</code> of a class <code>cls</code>. </p>
<p>This <em>only</em> works with class attributes (unbound members or methods) as it is implemented with a Python property descriptor. </p>

</div>
</div>
<a id="af804829ff8c00cbcacaff4b8ed1b83f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af804829ff8c00cbcacaff4b8ed1b83f1">&#9670;&nbsp;</a></span>ExecuteExtraPythonCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::ExecuteExtraPythonCode </td>
          <td>(</td>
          <td class="paramtype">py::module&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Python code to introduce additional symbols for a given module. </p>
<p>For a module with local name <code>{name}</code>, the code executed will be <code>_{name}_extra.py</code>. See #9599 for relevant background. </p>

</div>
</div>
<a id="a2274d953c5404b3021085ef6c9891603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2274d953c5404b3021085ef6c9891603">&#9670;&nbsp;</a></span>GetPyParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::tuple drake::pydrake::GetPyParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdrake_1_1type__pack.html">type_pack</a>&lt; Ts... &gt;&#160;</td>
          <td class="paramname"> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the canonical Python parameters for each C++ type. </p>
<dl class="section return"><dt>Returns</dt><dd>Python tuple of canonical parameters. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>on the first type it encounters that is neither aliased nor registered in <code>pybind11</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>The types to get C++ types for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Ts must be public symbols. </dd>
<dd>
Ts cannot be a <code>py::</code> symbol (e.g. <code>py::object</code>). On Mac, this may cause failure depending on import order (e.g. trying to use <code><a class="el" href="classdrake_1_1_value.html" title="A container class for an arbitrary type T (with some restrictions).">Value</a>&lt;py::object&gt;</code> between different modules). See #8704 and #13207 for more details. </dd></dl>

</div>
</div>
<a id="ad82c192e2b875f6bd19163b69ba9075a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82c192e2b875f6bd19163b69ba9075a">&#9670;&nbsp;</a></span>ParamInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::ParamInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constructor for creating an instance of Class and initializing parameters (bound using <code>def_readwrite</code>). </p>
<p>This provides an alternative to manually enumerating each parameter as an argument using <code>py::init&lt;...&gt;</code> and <code>py::arg(...)</code>, and is useful when the C++ class only has a default constructor. Example: </p><div class="fragment"><div class="line"><span class="keyword">using</span> Class = ExampleClass;</div><div class="line">py::class_&lt;Class&gt;(m, <span class="stringliteral">&quot;ExampleClass&quot;</span>)  <span class="comment">// BR</span></div><div class="line">    .def(ParamInit&lt;Class&gt;());</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Class</td><td>The C++ class. Must have a default constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36e0f3795b29cfb57c0940ffc8780120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e0f3795b29cfb57c0940ffc8780120">&#9670;&nbsp;</a></span>py_init_deprecated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::py_init_deprecated </td>
          <td>(</td>
          <td class="paramtype">py::str&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated wrapping of <code>py::init&lt;&gt;</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Only for <code>unique_ptr</code> holders. If using <code>shared_ptr</code>, talk to Eric. </dd></dl>

</div>
</div>
<a id="a40a674f4af53caa963b98daa8d85af39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a674f4af53caa963b98daa8d85af39">&#9670;&nbsp;</a></span>py_init_deprecated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::py_init_deprecated </td>
          <td>(</td>
          <td class="paramtype">py::str&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated wrapping of <code>py::init(factory)</code>. </p>

</div>
</div>
<a id="a14724461c57557eb0646af0081b97ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14724461c57557eb0646af0081b97ef2">&#9670;&nbsp;</a></span>py_keep_alive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::object drake::pydrake::py_keep_alive </td>
          <td>(</td>
          <td class="paramtype">py::object&#160;</td>
          <td class="paramname"><em>nurse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::object&#160;</td>
          <td class="paramname"><em>patient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use this when you must do manual casting - e.g. </p>
<p>lists or tuples of nurses, where the container may get discarded but the items kept. Prefer this over <code>py::cast(obj, reference_internal, parent)</code> (pending full resolution of #11046). </p>

</div>
</div>
<a id="ad65f25e300d8d606958b3df57c29f5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65f25e300d8d606958b3df57c29f5fe">&#9670;&nbsp;</a></span>return_value_policy_for_scalar_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::return_value_policy drake::pydrake::return_value_policy_for_scalar_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permits referencing for builtin dtypes (e.g. </p>
<p>T = double), but then switches to copying for custom dtypes (T = {AutoDiffXd, Expression}). </p>

</div>
</div>
<a id="a4790743839a4b041b37dc3820e2475ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4790743839a4b041b37dc3820e2475ae">&#9670;&nbsp;</a></span>TemporaryClassName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::pydrake::TemporaryClassName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;TemporaryName&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a temporary, unique name for a class instantiation that will be passed to <code>AddTemplateClass</code>. </p>

</div>
</div>
<a id="ae8c72466dd0066fa6ff539d65eaf1a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c72466dd0066fa6ff539d65eaf1a01">&#9670;&nbsp;</a></span>ToArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::object drake::pydrake::ToArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::tuple&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a raw array to a numpy array. </p>

</div>
</div>
<a id="af50a9a915770def7cbf4f78aa68235dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50a9a915770def7cbf4f78aa68235dc">&#9670;&nbsp;</a></span>ToArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::object drake::pydrake::ToArray </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">py::tuple&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a raw array to a numpy array (<code>const</code> variant). </p>

</div>
</div>
<a id="a0d7582877591057ceea633df19d910fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7582877591057ceea633df19d910fa">&#9670;&nbsp;</a></span>ToEigenRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::ToEigenRef </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorBlock&lt; Derived &gt; *&#160;</td>
          <td class="paramname"><em>derived</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a mutable Ref&lt;&gt; for a pointer. </p>
<p>Meant to be used for decorating methods passed to <code>pybind11</code> (e.g. virtual function dispatch). </p>

</div>
</div>
<a id="a88a20567ddf6e5978a874a3cb46353f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a20567ddf6e5978a874a3cb46353f4">&#9670;&nbsp;</a></span>WarnDeprecated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::pydrake::WarnDeprecated </td>
          <td>(</td>
          <td class="paramtype">py::str&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>date</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises a deprecation warning. </p>
<dl class="section note"><dt>Note</dt><dd>If you are deprecating a class's member or method, please use <code>DeprecateAttribute</code> so that the warning is issued immediately when accessed, not only when it is called. </dd></dl>

</div>
</div>
<a id="a455a0f794f758f800bce946f37c6be29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455a0f794f758f800bce946f37c6be29">&#9670;&nbsp;</a></span>WrapCallbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::WrapCallbacks </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures that any <code>std::function&lt;&gt;</code> arguments are wrapped such that any <code>T&amp;</code> (which can infer for <code>T = const U</code>) is wrapped as <code>U*</code> (and conversely unwrapped when returned). </p>
<p>Use this when you have a callback in C++ that has a lvalue reference (const or mutable) to a C++ argument or return value. Otherwise, <code>pybind11</code> may try and copy the object, will be bad if either the type is a non-copyable or if you are trying to mutate the object; in this case, the copy is mutated, but not the original you care about. For more information, see: <a href="https://github.com/pybind/pybind11/issues/1241">https://github.com/pybind/pybind11/issues/1241</a> </p>

</div>
</div>
<a id="a13cd6cd963823cafbc0068bacc7eeadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cd6cd963823cafbc0068bacc7eeadd">&#9670;&nbsp;</a></span>WrapDeprecated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::WrapDeprecated </td>
          <td>(</td>
          <td class="paramtype">py::str&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps any callable (function pointer, method pointer, lambda, etc.) to emit a deprecation message. </p>

</div>
</div>
<a id="a52b03ea674322481f48a1262e0c607a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b03ea674322481f48a1262e0c607a2">&#9670;&nbsp;</a></span>WrapFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::pydrake::WrapFunction </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps the types used in a function signature to produce a new function with wrapped arguments and return value (if non-void). </p>
<p>The wrapping is based on <code>wrap_arg_policy</code>. Any types that are of the form <code>std::function&lt;F&gt;</code> will be recursively wrapped, such that callbacks will be of a wrapped form (arguments and return types wrapped). The original form of the callbacks will still be called in the wrapped callback. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">wrap_arg_policy</td><td>User-supplied argument wrapper, that must supply the static functions <code>wrap(Arg arg) -&gt; Wrapped</code> and <code>unwrap(Wrapped wrapped) -&gt; Arg</code>. <code>Arg arg</code> is the original argument, and <code>Wrapped wrapped</code> is the wrapped / transformed argument type. N.B. This template template parameter uses a parameter pack to allow for SFINAE. If passing a <code>using</code> template alias, ensure that the alias template template parameter uses a parameter pack of the <em>exact</em> same form. </td></tr>
    <tr><td class="paramname">use_functions</td><td>If true (default), will recursively wrap callbacks. If your policy provides handling for functions, then you should set this to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Functor to be wrapped. Returns a function with wrapped arguments and return type. If functor is a method pointer, it will return a function of the form <code>Return ([const] Class* self, ...)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Wrapped function lambda. N.B. Construct a <code>std::function&lt;&gt;</code> from this if you encounter inference issues downstream of this method. </dd></dl>

</div>
</div>
<a id="af5f81d7315477aaa1694d9aa02a1346b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f81d7315477aaa1694d9aa02a1346b">&#9670;&nbsp;</a></span>WrapToMatchInputShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">py::object drake::pydrake::WrapToMatchInputShape </td>
          <td>(</td>
          <td class="paramtype">py::handle&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps a overload instance method to reshape the output to be the same as a given input argument. </p>
<p>The input should be the first and only argument to trigger reshaping.</p>
<p>This preserves the original docstrings so that they still indicate the shapes of the input and output arrays.</p>
<p>Example:</p>
<div class="fragment"><div class="line">cls  <span class="comment">// BR</span></div><div class="line">  .def(<span class="stringliteral">&quot;multiply&quot;</span>, [](<span class="keyword">const</span> Class&amp; <span class="keyword">self</span>, <span class="keyword">const</span> Class&amp; other) { ... })</div><div class="line">  .def(<span class="stringliteral">&quot;multiply&quot;</span>, [](<span class="keyword">const</span> Class&amp; <span class="keyword">self</span>, <span class="keyword">const</span> Vector3&lt;T&gt;&amp; p) { ... })</div><div class="line">  .def(<span class="stringliteral">&quot;multiply&quot;</span>, [](<span class="keyword">const</span> Class&amp; <span class="keyword">self</span>, <span class="keyword">const</span> Matrix3X&lt;T&gt;&amp; plist) { ... });</div><div class="line">cls.attr(<span class="stringliteral">&quot;multiply&quot;</span>) = <a class="code" href="namespacedrake_1_1pydrake.html#af5f81d7315477aaa1694d9aa02a1346b">WrapToMatchInputShape</a>(cls.attr(<span class="stringliteral">&quot;multiply&quot;</span>));</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__python__bindings.html#PydrakeReturnVectorsOrMatrices">PydrakeReturnVectorsOrMatrices</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3001fa4c52ff2d0f13a58523f67be8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3001fa4c52ff2d0f13a58523f67be8e0">&#9670;&nbsp;</a></span>overload_cast_explicit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto overload_cast_explicit = <a class="el" href="structdrake_1_1pydrake_1_1overload__cast__impl.html">overload_cast_impl</a>&lt;Return, Args...&gt;{}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides option to provide explicit signature when <code>py::overload_cast&lt;Args...&gt;</code> fails to infer the Return argument. </p>

</div>
</div>
<a id="ae9bdc6aba9aad5daab1513b39d2b34e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bdc6aba9aad5daab1513b39d2b34e7">&#9670;&nbsp;</a></span>py_reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const auto py_reference = py::return_value_policy::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used when returning <code>T&amp; or</code>const T&amp;`, as pybind's default behavior is to copy lvalue references. </p>
<p>(Deprecated.) </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>"Please use py_rvp::reference instead" <br />
 This will be removed from Drake on or after "2020-11-01" .</dd></dl>

</div>
</div>
<a id="a36e8cda2005c97af6a36240c45e67dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e8cda2005c97af6a36240c45e67dd7">&#9670;&nbsp;</a></span>py_reference_internal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const auto py_reference_internal = py::return_value_policy::reference_internal</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used when returning references to objects that are internally owned by <code>self</code>. </p>
<p>Implies both <code>py_rvp::reference</code> and <code>py::keep_alive&lt;0, 1&gt;</code>, which implies "Keep alive, reference: `return` keeps` self` alive". (Deprecated.) </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>"Please use py_rvp::reference_internal instead" <br />
 This will be removed from Drake on or after "2020-11-01" .</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1pydrake.html">pydrake</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
