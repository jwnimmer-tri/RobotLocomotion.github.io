<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: ContactSurface&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1geometry_1_1_contact_surface.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdrake_1_1geometry_1_1_contact_surface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ContactSurface&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::geometry::ContactSurface&lt; T &gt;</h3>

<p>The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with a scalar field and a vector field, whose purpose is to support the hydroelastic pressure field contact model as described in: </p>
<pre class="fragment">R. Elandt, E. Drumwright, M. Sherman, and Andy Ruina. A pressure
field model for fast, robust approximation of net contact force
and moment between nominally rigid objects. IROS 2019: 8238-8245.
</pre><h2>Mathematical Concepts </h2>
<p>In this section, we give motivation for the concept of contact surface from the hydroelastic pressure field contact model. Here the mathematical discussion is coordinate-free (treatment of the topic without reference to any particular coordinate system); however, our implementation heavily relies on coordinate frames. We borrow terminology from differential geometry.</p>
<p>In this section, the mathematical term <em>compact set</em> (a subset of Euclidean space that is closed and bounded) corresponds to the term <em>geometry</em> (or the space occupied by the geometry) in <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>.</p>
<p>We describe the contact surface 𝕊ₘₙ between two intersecting compact subsets 𝕄 and ℕ of ℝ³ with the scalar fields eₘ and eₙ defined on 𝕄 ⊂ ℝ³ and ℕ ⊂ ℝ³ respectively: </p><pre class="fragment">           eₘ : 𝕄 → ℝ,
           eₙ : ℕ → ℝ.
</pre><p>The <em>contact surface</em> 𝕊ₘₙ is the surface of equilibrium eₘ = eₙ. It is the locus of points Q where eₘ(Q) equals eₙ(Q): </p><pre class="fragment">         𝕊ₘₙ = { Q ∈ 𝕄 ∩ ℕ : eₘ(Q) = eₙ(Q) }.
</pre><p>We can define the scalar field eₘₙ on the surface 𝕊ₘₙ as a scalar function that assigns Q ∈ 𝕊ₘₙ the value of eₘ(Q), which is the same as eₙ(Q): </p><pre class="fragment">         eₘₙ : 𝕊ₘₙ → ℝ,
         eₘₙ(Q) = eₘ(Q) = eₙ(Q).
</pre><p>We can also define the scalar field hₘₙ on 𝕄 ∩ ℕ as the difference between eₘ and eₙ: </p><pre class="fragment">         hₘₙ : 𝕄 ∩ ℕ → ℝ,
         hₘₙ(Q) = eₘ(Q) - eₙ(Q).
</pre><p>It follows that the gradient vector field ∇hₘₙ on 𝕄 ∩ ℕ equals the difference between the the gradient vector fields ∇eₘ and ∇eₙ: </p><pre class="fragment">         ∇hₘₙ : 𝕄 ∩ ℕ → ℝ³,
         ∇hₘₙ(Q) = ∇eₘ(Q) - ∇eₙ(Q).
</pre><p>By construction, Q ∈ 𝕊ₘₙ if and only if hₘₙ(Q) = 0. In other words, 𝕊ₘₙ is the zero level set of hₘₙ. It follows that, for Q ∈ 𝕊ₘₙ, ∇hₘₙ(Q) is orthogonal to the surface 𝕊ₘₙ at Q in the direction of increasing eₘ - eₙ.</p>
<p>Notice that the domain of eₘₙ is the two-dimensional surface 𝕊ₘₙ, while the domain of ∇hₘₙ is the three-dimensional compact set 𝕄 ∩ ℕ. Even though eₘₙ and ∇hₘₙ are defined on different domains (𝕊ₘₙ and 𝕄 ∩ ℕ), our implementation only represents them on their common domain, i.e., 𝕊ₘₙ.</p>
<h2>Discrete Representation </h2>
<p>In practice, the contact surface is approximated with a discrete triangle mesh. The triangle mesh's normals are defined <em>per face</em>. The normal of each face is guaranteed to point "out of" N and "into" M. They can be accessed via <code><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#abbcabe20d928e4b98b17f9336301134b" title="Returns a reference to the surface mesh whose vertex positions are measured and expressed in the worl...">mesh_W()</a>.face_normal(face_index)</code>.</p>
<p>The pressure values on the contact surface are represented as a continuous, piecewise-linear function, accessed via <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a39fd8b8e0451098440f1c43783443d07" title="Returns a reference to the scalar field eₘₙ.">e_MN()</a>.</p>
<p>The normals of the mesh are discontinuous at triangle boundaries, but the pressure can be meaningfully evaluated over the entire domain of the mesh.</p>
<p>When available, the values of ∇eₘ and ∇eₙ are represented as a discontinuous, piecewise-constant function over the triangles &ndash; one vector per triangle. These quantities are accessed via <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a393a6630f6cd898d5cf6b2df407d9807" title="Returns the value of ∇eₘ for the triangle with index index.">EvaluateGradE_M_W()</a> and <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a58c68925ce5de96a17ac36604d27bd47" title="Returns the value of ∇eₙ for the triangle with index index.">EvaluateGradE_N_W()</a>, respectively.</p>
<h2>Barycentric Coordinates </h2>
<p>For Point Q on the surface mesh of the contact surface between Geometry M and Geometry N, r_WQ = (x,y,z) is the displacement vector from the origin of the world frame to Q expressed in the coordinate frame of W. We also have the <em>barycentric coordinates</em> (b0, b1, b2) on a triangle of the surface mesh that contains Q. With vertices of the triangle labeled as v₀, v₁, v₂, we can map (b0, b1, b2) to r_WQ by: </p><pre class="fragment">         r_WQ = b0 * r_Wv₀ + b1 * r_Wv₁ + b2 * r_Wv₂,
         b0 + b1 + b2 = 1, bᵢ ∈ [0,1],
</pre><p>where r_Wvᵢ is the displacement vector of the vertex labeled as vᵢ from the origin of the world frame, expressed in the world frame.</p>
<p>We use the barycentric coordinates to evaluate the field values.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default nonsymbolic scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/geometry/query_results/contact_surface.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9e1465537ee24fd7a053d0a117024011"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a9e1465537ee24fd7a053d0a117024011">ContactSurface</a> (const <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> &amp;surface)</td></tr>
<tr class="separator:a9e1465537ee24fd7a053d0a117024011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be7c6c77842e11a97c3f72352762b5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a8be7c6c77842e11a97c3f72352762b5a">operator=</a> (const <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> &amp;surface)</td></tr>
<tr class="separator:a8be7c6c77842e11a97c3f72352762b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bba298d00b3ca9aaccbcaa73ad3901d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a1bba298d00b3ca9aaccbcaa73ad3901d">ContactSurface</a> (<a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a1bba298d00b3ca9aaccbcaa73ad3901d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a52b778bb77c0f15e6ad48cbe43bb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#ac9a52b778bb77c0f15e6ad48cbe43bb0">operator=</a> (<a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ac9a52b778bb77c0f15e6ad48cbe43bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1f23c16b5552c721c8d6e7984966b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a4f1f23c16b5552c721c8d6e7984966b9">ContactSurface</a> (<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a9d19415980a599e76803d1c2ac6954cd">id_M</a>, <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a643bdff7b47f07604755e0a7e0707fee">id_N</a>, std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt;&gt; <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#abbcabe20d928e4b98b17f9336301134b">mesh_W</a>, std::unique_ptr&lt; <a class="el" href="namespacedrake_1_1geometry.html#aeb8521ca427b948bf56882cae0363bd4">SurfaceMeshFieldLinear</a>&lt; T, T &gt;&gt; <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a39fd8b8e0451098440f1c43783443d07">e_MN</a>)</td></tr>
<tr class="memdesc:a4f1f23c16b5552c721c8d6e7984966b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a>.  <a href="#a4f1f23c16b5552c721c8d6e7984966b9">More...</a><br /></td></tr>
<tr class="separator:a4f1f23c16b5552c721c8d6e7984966b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad653267fe2eaafc9cc585137122c6869"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#ad653267fe2eaafc9cc585137122c6869">ContactSurface</a> (<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a9d19415980a599e76803d1c2ac6954cd">id_M</a>, <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a643bdff7b47f07604755e0a7e0707fee">id_N</a>, std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt;&gt; <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#abbcabe20d928e4b98b17f9336301134b">mesh_W</a>, std::unique_ptr&lt; <a class="el" href="namespacedrake_1_1geometry.html#aeb8521ca427b948bf56882cae0363bd4">SurfaceMeshFieldLinear</a>&lt; T, T &gt;&gt; <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a39fd8b8e0451098440f1c43783443d07">e_MN</a>, std::unique_ptr&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt;&gt; grad_eM_W, std::unique_ptr&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt;&gt; grad_eN_W)</td></tr>
<tr class="memdesc:ad653267fe2eaafc9cc585137122c6869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> with the optional gradients of the constituent scalar fields.  <a href="#ad653267fe2eaafc9cc585137122c6869">More...</a><br /></td></tr>
<tr class="separator:ad653267fe2eaafc9cc585137122c6869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d19415980a599e76803d1c2ac6954cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a9d19415980a599e76803d1c2ac6954cd">id_M</a> () const</td></tr>
<tr class="memdesc:a9d19415980a599e76803d1c2ac6954cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the geometry id of Geometry M.  <a href="#a9d19415980a599e76803d1c2ac6954cd">More...</a><br /></td></tr>
<tr class="separator:a9d19415980a599e76803d1c2ac6954cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643bdff7b47f07604755e0a7e0707fee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a643bdff7b47f07604755e0a7e0707fee">id_N</a> () const</td></tr>
<tr class="memdesc:a643bdff7b47f07604755e0a7e0707fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the geometry id of Geometry N.  <a href="#a643bdff7b47f07604755e0a7e0707fee">More...</a><br /></td></tr>
<tr class="separator:a643bdff7b47f07604755e0a7e0707fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaff112482dbeec4be3eba755202bac3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#aeaff112482dbeec4be3eba755202bac3">EvaluateE_MN</a> (<a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a> face, const typename <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt;::Barycentric &amp;barycentric) const</td></tr>
<tr class="memdesc:aeaff112482dbeec4be3eba755202bac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the scalar field eₘₙ at Point Q in a triangle.  <a href="#aeaff112482dbeec4be3eba755202bac3">More...</a><br /></td></tr>
<tr class="separator:aeaff112482dbeec4be3eba755202bac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50475632b661f5cd129d19eafe98c874"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a50475632b661f5cd129d19eafe98c874">EvaluateE_MN</a> (<a class="el" href="namespacedrake_1_1geometry.html#a4b6bae4ff910e57daa4b0ac8e4f481b8">SurfaceVertexIndex</a> vertex) const</td></tr>
<tr class="memdesc:a50475632b661f5cd129d19eafe98c874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the scalar field eₘₙ at the given vertex on the contact surface mesh.  <a href="#a50475632b661f5cd129d19eafe98c874">More...</a><br /></td></tr>
<tr class="separator:a50475632b661f5cd129d19eafe98c874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcabe20d928e4b98b17f9336301134b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#abbcabe20d928e4b98b17f9336301134b">mesh_W</a> () const</td></tr>
<tr class="memdesc:abbcabe20d928e4b98b17f9336301134b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the surface mesh whose vertex positions are measured and expressed in the world frame.  <a href="#abbcabe20d928e4b98b17f9336301134b">More...</a><br /></td></tr>
<tr class="separator:abbcabe20d928e4b98b17f9336301134b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fd8b8e0451098440f1c43783443d07"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html">MeshField</a>&lt; T, <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a39fd8b8e0451098440f1c43783443d07">e_MN</a> () const</td></tr>
<tr class="memdesc:a39fd8b8e0451098440f1c43783443d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the scalar field eₘₙ.  <a href="#a39fd8b8e0451098440f1c43783443d07">More...</a><br /></td></tr>
<tr class="separator:a39fd8b8e0451098440f1c43783443d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162b2f40894082b5057435796adf2c04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a162b2f40894082b5057435796adf2c04">Equal</a> (const <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &amp;surface) const</td></tr>
<tr class="memdesc:a162b2f40894082b5057435796adf2c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see whether the given <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> object is equal via deep exact comparison.  <a href="#a162b2f40894082b5057435796adf2c04">More...</a><br /></td></tr>
<tr class="separator:a162b2f40894082b5057435796adf2c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Evaluation of constituent pressure fields</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The ContactSurface <em>provisionally</em> includes the gradients of the constituent pressure fields (∇eₘ and ∇eₙ) sampled on the contact surface.</p>
<p>In order for these values to be included in an instance, the gradient for the corresponding mesh must be well defined. For example a rigid mesh will not have a well-defined pressure gradient; as stiffness goes to infinity, the geometry becomes rigid and the gradient <em>direction</em> converges to the direction of the rigid mesh's surface normals, but the magnitude goes to infinity, producing a pressure gradient that would be some variant of <code>&lt;∞, ∞, ∞&gt;</code>.</p>
<p>Accessing the gradient values must be pre-conditioned on a test that the particular instance of ContactSurface actually contains the gradient data. The presence of gradient data for each geometry must be confirmed separately.</p>
<p>The values ∇eₘ and ∇eₘ are piecewise constant over the ContactSurface and can only be evaluate on a per-triangle basis. </p>
</div></td></tr>
<tr class="memitem:a9e133d23830a9b6ffaa3652b26c417d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a9e133d23830a9b6ffaa3652b26c417d3">HasGradE_M</a> () const</td></tr>
<tr class="separator:a9e133d23830a9b6ffaa3652b26c417d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127d93d3788af836f8fbded056377db2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a127d93d3788af836f8fbded056377db2">HasGradE_N</a> () const</td></tr>
<tr class="separator:a127d93d3788af836f8fbded056377db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393a6630f6cd898d5cf6b2df407d9807"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a393a6630f6cd898d5cf6b2df407d9807">EvaluateGradE_M_W</a> (<a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a> index) const</td></tr>
<tr class="memdesc:a393a6630f6cd898d5cf6b2df407d9807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of ∇eₘ for the triangle with index <code>index</code>.  <a href="#a393a6630f6cd898d5cf6b2df407d9807">More...</a><br /></td></tr>
<tr class="separator:a393a6630f6cd898d5cf6b2df407d9807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c68925ce5de96a17ac36604d27bd47"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a58c68925ce5de96a17ac36604d27bd47">EvaluateGradE_N_W</a> (<a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a> index) const</td></tr>
<tr class="memdesc:a58c68925ce5de96a17ac36604d27bd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of ∇eₙ for the triangle with index <code>index</code>.  <a href="#a58c68925ce5de96a17ac36604d27bd47">More...</a><br /></td></tr>
<tr class="separator:a58c68925ce5de96a17ac36604d27bd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4e24704419c5448aa572060e183dde80"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a4e24704419c5448aa572060e183dde80"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a4e24704419c5448aa572060e183dde80">ContactSurfaceTester</a></td></tr>
<tr class="separator:a4e24704419c5448aa572060e183dde80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9e1465537ee24fd7a053d0a117024011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1465537ee24fd7a053d0a117024011">&#9670;&nbsp;</a></span>ContactSurface() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1bba298d00b3ca9aaccbcaa73ad3901d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bba298d00b3ca9aaccbcaa73ad3901d">&#9670;&nbsp;</a></span>ContactSurface() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f1f23c16b5552c721c8d6e7984966b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1f23c16b5552c721c8d6e7984966b9">&#9670;&nbsp;</a></span>ContactSurface() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>&#160;</td>
          <td class="paramname"><em>id_M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>&#160;</td>
          <td class="paramname"><em>id_N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>mesh_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="namespacedrake_1_1geometry.html#aeb8521ca427b948bf56882cae0363bd4">SurfaceMeshFieldLinear</a>&lt; T, T &gt;&gt;&#160;</td>
          <td class="paramname"><em>e_MN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_M</td><td>The id of the first geometry M. </td></tr>
    <tr><td class="paramname">id_N</td><td>The id of the second geometry N. </td></tr>
    <tr><td class="paramname">mesh_W</td><td>The surface mesh of the contact surface 𝕊ₘₙ between M and N. The mesh vertices are defined in the world frame. </td></tr>
    <tr><td class="paramname">e_MN</td><td>Represents the scalar field eₘₙ on the surface mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The face normals in <code>mesh_W</code> point <em>out of</em> geometry N and <em>into</em> M. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>id_M &gt; id_N</code>, the labels will be swapped and the normals of the mesh reversed (to maintain the documented invariants). Comparing the input parameters with the members of the resulting ContactSurface will reveal if such a swap has occurred. </dd></dl>

</div>
</div>
<a id="ad653267fe2eaafc9cc585137122c6869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad653267fe2eaafc9cc585137122c6869">&#9670;&nbsp;</a></span>ContactSurface() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>&#160;</td>
          <td class="paramname"><em>id_M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>&#160;</td>
          <td class="paramname"><em>id_N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>mesh_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="namespacedrake_1_1geometry.html#aeb8521ca427b948bf56882cae0363bd4">SurfaceMeshFieldLinear</a>&lt; T, T &gt;&gt;&#160;</td>
          <td class="paramname"><em>e_MN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>grad_eM_W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; std::vector&lt; <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>grad_eN_W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> with the optional gradients of the constituent scalar fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_M</td><td>The id of the first geometry M. </td></tr>
    <tr><td class="paramname">id_N</td><td>The id of the second geometry N. </td></tr>
    <tr><td class="paramname">mesh_W</td><td>The surface mesh of the contact surface 𝕊ₘₙ between M and N. The mesh vertices are defined in the world frame. </td></tr>
    <tr><td class="paramname">e_MN</td><td>Represents the scalar field eₘₙ on the surface mesh. </td></tr>
    <tr><td class="paramname">grad_eM_W</td><td>∇eₘ sampled once per face, expressed in the world frame. </td></tr>
    <tr><td class="paramname">grad_eN_W</td><td>∇eₙ sampled once per face, expressed in the world frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The face normals in <code>mesh_W</code> point <em>out of</em> geometry N and <em>into</em> M. </dd>
<dd>
If given, <code>grad_eM_W</code> and <code>grad_eN_W</code> must have as many entries as <code>mesh_W</code> has faces and the ith entry in each should correspond to the ith face in <code>mesh_W</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>id_M &gt; id_N</code>, the labels will be swapped and the normals of the mesh reversed (to maintain the documented invariants). Comparing the input parameters with the members of the resulting ContactSurface will reveal if such a swap has occurred. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a39fd8b8e0451098440f1c43783443d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fd8b8e0451098440f1c43783443d07">&#9670;&nbsp;</a></span>e_MN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html">MeshField</a>&lt;T, <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt;T&gt; &gt;&amp; e_MN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the scalar field eₘₙ. </p>

</div>
</div>
<a id="a162b2f40894082b5057435796adf2c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162b2f40894082b5057435796adf2c04">&#9670;&nbsp;</a></span>Equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see whether the given <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> object is equal via deep exact comparison. </p>
<p>NaNs are treated as not equal as per the IEEE standard. </p><dl class="section note"><dt>Note</dt><dd>Currently requires the fields of the objects to be of type <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a>, otherwise the current simple checking of equal values at vertices is insufficient. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>The contact surface for comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given contact surface is equal. </dd></dl>

</div>
</div>
<a id="aeaff112482dbeec4be3eba755202bac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaff112482dbeec4be3eba755202bac3">&#9670;&nbsp;</a></span>EvaluateE_MN() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T EvaluateE_MN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt; T &gt;::Barycentric &amp;&#160;</td>
          <td class="paramname"><em>barycentric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the scalar field eₘₙ at Point Q in a triangle. </p>
<p>Point Q is specified by its barycentric coordinates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The face index of the triangle. </td></tr>
    <tr><td class="paramname">barycentric</td><td>The barycentric coordinates of Q on the triangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50475632b661f5cd129d19eafe98c874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50475632b661f5cd129d19eafe98c874">&#9670;&nbsp;</a></span>EvaluateE_MN() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T EvaluateE_MN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a4b6bae4ff910e57daa4b0ac8e4f481b8">SurfaceVertexIndex</a>&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the scalar field eₘₙ at the given vertex on the contact surface mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>The index of the vertex in the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a393a6630f6cd898d5cf6b2df407d9807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393a6630f6cd898d5cf6b2df407d9807">&#9670;&nbsp;</a></span>EvaluateGradE_M_W()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;&amp; EvaluateGradE_M_W </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of ∇eₘ for the triangle with index <code>index</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a9e133d23830a9b6ffaa3652b26c417d3">HasGradE_M()</a> returns false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58c68925ce5de96a17ac36604d27bd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c68925ce5de96a17ac36604d27bd47">&#9670;&nbsp;</a></span>EvaluateGradE_N_W()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt;&amp; EvaluateGradE_N_W </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a831785d5225564e2a531b4fd2445e1d6">SurfaceFaceIndex</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of ∇eₙ for the triangle with index <code>index</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html#a127d93d3788af836f8fbded056377db2">HasGradE_N()</a> returns false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e133d23830a9b6ffaa3652b26c417d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e133d23830a9b6ffaa3652b26c417d3">&#9670;&nbsp;</a></span>HasGradE_M()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasGradE_M </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>this</code> contains values for ∇eₘ. </dd></dl>

</div>
</div>
<a id="a127d93d3788af836f8fbded056377db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127d93d3788af836f8fbded056377db2">&#9670;&nbsp;</a></span>HasGradE_N()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasGradE_N </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>this</code> contains values for ∇eₙ. </dd></dl>

</div>
</div>
<a id="a9d19415980a599e76803d1c2ac6954cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d19415980a599e76803d1c2ac6954cd">&#9670;&nbsp;</a></span>id_M()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> id_M </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the geometry id of Geometry M. </p>

</div>
</div>
<a id="a643bdff7b47f07604755e0a7e0707fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643bdff7b47f07604755e0a7e0707fee">&#9670;&nbsp;</a></span>id_N()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> id_N </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the geometry id of Geometry N. </p>

</div>
</div>
<a id="abbcabe20d928e4b98b17f9336301134b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcabe20d928e4b98b17f9336301134b">&#9670;&nbsp;</a></span>mesh_W()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html">SurfaceMesh</a>&lt;T&gt;&amp; mesh_W </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the surface mesh whose vertex positions are measured and expressed in the world frame. </p>

</div>
</div>
<a id="a8be7c6c77842e11a97c3f72352762b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be7c6c77842e11a97c3f72352762b5a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9a52b778bb77c0f15e6ad48cbe43bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a52b778bb77c0f15e6ad48cbe43bb0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a4e24704419c5448aa572060e183dde80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e24704419c5448aa572060e183dde80">&#9670;&nbsp;</a></span>ContactSurfaceTester</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ContactSurfaceTester</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/geometry/query_results/<a class="el" href="contact__surface_8h.html">contact_surface.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
