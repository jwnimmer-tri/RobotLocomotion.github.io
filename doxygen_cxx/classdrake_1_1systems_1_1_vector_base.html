<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: VectorBase&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1systems_1_1_vector_base.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classdrake_1_1systems_1_1_vector_base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">VectorBase&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::systems::VectorBase&lt; T &gt;</h3>

<p><a class="el" href="classdrake_1_1systems_1_1_vector_base.html" title="VectorBase is an abstract base class that real-valued signals between Systems and real-valued System ...">VectorBase</a> is an abstract base class that real-valued signals between Systems and real-valued <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> state vectors must implement. </p>
<p>Classes that inherit from <a class="el" href="classdrake_1_1systems_1_1_vector_base.html" title="VectorBase is an abstract base class that real-valued signals between Systems and real-valued System ...">VectorBase</a> will typically provide names for the elements of the vector, and may also provide other computations for the convenience of Systems handling the signal. The vector is always a column vector. It may or may not be contiguous in memory. Contiguous subclasses should typically inherit from <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html" title="BasicVector is a semantics-free wrapper around an Eigen vector that satisfies VectorBase.">BasicVector</a>, not from <a class="el" href="classdrake_1_1systems_1_1_vector_base.html" title="VectorBase is an abstract base class that real-valued signals between Systems and real-valued System ...">VectorBase</a> directly.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/systems/framework/vector_base.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abc19c2584a73f03bd1e31277d11315b4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#abc19c2584a73f03bd1e31277d11315b4">~VectorBase</a> ()</td></tr>
<tr class="separator:abc19c2584a73f03bd1e31277d11315b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b716289158c33f86a8cf30219be68c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a36b716289158c33f86a8cf30219be68c">size</a> () const =0</td></tr>
<tr class="memdesc:a36b716289158c33f86a8cf30219be68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the vector.  <a href="#a36b716289158c33f86a8cf30219be68c">More...</a><br /></td></tr>
<tr class="separator:a36b716289158c33f86a8cf30219be68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4b36a43041d6505f82836a6aeccd52"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a2d4b36a43041d6505f82836a6aeccd52">operator[]</a> (<a class="el" href="classint.html">int</a> index)</td></tr>
<tr class="memdesc:a2d4b36a43041d6505f82836a6aeccd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at the given index in the vector.  <a href="#a2d4b36a43041d6505f82836a6aeccd52">More...</a><br /></td></tr>
<tr class="separator:a2d4b36a43041d6505f82836a6aeccd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f0073680dabba9d2778d9a6f35aed7"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#ab3f0073680dabba9d2778d9a6f35aed7">operator[]</a> (<a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="memdesc:ab3f0073680dabba9d2778d9a6f35aed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at the given index in the vector.  <a href="#ab3f0073680dabba9d2778d9a6f35aed7">More...</a><br /></td></tr>
<tr class="separator:ab3f0073680dabba9d2778d9a6f35aed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79ea848ba1a3e2a87da1777b3f399cc"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#ae79ea848ba1a3e2a87da1777b3f399cc">GetAtIndex</a> (<a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="memdesc:ae79ea848ba1a3e2a87da1777b3f399cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at the given index in the vector.  <a href="#ae79ea848ba1a3e2a87da1777b3f399cc">More...</a><br /></td></tr>
<tr class="separator:ae79ea848ba1a3e2a87da1777b3f399cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7a4ff282156d6974f47912756265b4"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#aef7a4ff282156d6974f47912756265b4">GetAtIndex</a> (<a class="el" href="classint.html">int</a> index)</td></tr>
<tr class="memdesc:aef7a4ff282156d6974f47912756265b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at the given index in the vector.  <a href="#aef7a4ff282156d6974f47912756265b4">More...</a><br /></td></tr>
<tr class="separator:aef7a4ff282156d6974f47912756265b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5902bbfda44607fda562f0c3956520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a5c5902bbfda44607fda562f0c3956520">SetAtIndex</a> (<a class="el" href="classint.html">int</a> index, const T &amp;value)</td></tr>
<tr class="memdesc:a5c5902bbfda44607fda562f0c3956520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the state at the given index with the value.  <a href="#a5c5902bbfda44607fda562f0c3956520">More...</a><br /></td></tr>
<tr class="separator:a5c5902bbfda44607fda562f0c3956520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8364f71b762045df41bfcb58927fe5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a3a8364f71b762045df41bfcb58927fe5">SetFrom</a> (const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:a3a8364f71b762045df41bfcb58927fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the entire vector with the contents of <code>value</code>.  <a href="#a3a8364f71b762045df41bfcb58927fe5">More...</a><br /></td></tr>
<tr class="separator:a3a8364f71b762045df41bfcb58927fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9d9b7396dccc9374d87a9be04a2597"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#aea9d9b7396dccc9374d87a9be04a2597">SetFromVector</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;value)</td></tr>
<tr class="memdesc:aea9d9b7396dccc9374d87a9be04a2597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the entire vector with the contents of <code>value</code>.  <a href="#aea9d9b7396dccc9374d87a9be04a2597">More...</a><br /></td></tr>
<tr class="separator:aea9d9b7396dccc9374d87a9be04a2597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04797332f4fa1889d462e5c7aacf1400"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a04797332f4fa1889d462e5c7aacf1400">SetZero</a> ()</td></tr>
<tr class="separator:a04797332f4fa1889d462e5c7aacf1400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23751ea78ff51179a9b3ed90317c922d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a23751ea78ff51179a9b3ed90317c922d">CopyToVector</a> () const</td></tr>
<tr class="memdesc:a23751ea78ff51179a9b3ed90317c922d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies this entire VectorBase into a contiguous Eigen Vector.  <a href="#a23751ea78ff51179a9b3ed90317c922d">More...</a><br /></td></tr>
<tr class="separator:a23751ea78ff51179a9b3ed90317c922d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f65de06c90fe4b0a0cd427032313218"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a9f65de06c90fe4b0a0cd427032313218">CopyToPreSizedVector</a> (<a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; vec) const</td></tr>
<tr class="memdesc:a9f65de06c90fe4b0a0cd427032313218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies this entire VectorBase into a pre-sized Eigen Vector.  <a href="#a9f65de06c90fe4b0a0cd427032313218">More...</a><br /></td></tr>
<tr class="separator:a9f65de06c90fe4b0a0cd427032313218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe595692eca6a4b16cd0344195d54599"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#abe595692eca6a4b16cd0344195d54599">ScaleAndAddToVector</a> (const T &amp;scale, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; vec) const</td></tr>
<tr class="memdesc:abe595692eca6a4b16cd0344195d54599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scaled version of this vector to Eigen vector <code>vec</code>, which must be the same size.  <a href="#abe595692eca6a4b16cd0344195d54599">More...</a><br /></td></tr>
<tr class="separator:abe595692eca6a4b16cd0344195d54599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb348d2ee8136278c64e180f4af21b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#aecb348d2ee8136278c64e180f4af21b7">PlusEqScaled</a> (const T &amp;scale, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aecb348d2ee8136278c64e180f4af21b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in scaled vector <code>rhs</code> to this vector.  <a href="#aecb348d2ee8136278c64e180f4af21b7">More...</a><br /></td></tr>
<tr class="separator:aecb348d2ee8136278c64e180f4af21b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32def866adfc4d6ce3dfe3255881651c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a32def866adfc4d6ce3dfe3255881651c">PlusEqScaled</a> (const std::initializer_list&lt; std::pair&lt; T, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp; &gt;&gt; &amp;rhs_scale)</td></tr>
<tr class="memdesc:a32def866adfc4d6ce3dfe3255881651c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in multiple scaled vectors to this vector.  <a href="#a32def866adfc4d6ce3dfe3255881651c">More...</a><br /></td></tr>
<tr class="separator:a32def866adfc4d6ce3dfe3255881651c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc86d5305584bc7cb96971f60220125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#accc86d5305584bc7cb96971f60220125">operator+=</a> (const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:accc86d5305584bc7cb96971f60220125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in vector <code>rhs</code> to this vector.  <a href="#accc86d5305584bc7cb96971f60220125">More...</a><br /></td></tr>
<tr class="separator:accc86d5305584bc7cb96971f60220125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb91f3ae2b66473a274073f56c5fbec0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#acb91f3ae2b66473a274073f56c5fbec0">operator-=</a> (const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:acb91f3ae2b66473a274073f56c5fbec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract in vector <code>rhs</code> to this vector.  <a href="#acb91f3ae2b66473a274073f56c5fbec0">More...</a><br /></td></tr>
<tr class="separator:acb91f3ae2b66473a274073f56c5fbec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd23700f1c0e51cb736750eb3fafa51"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#afcd23700f1c0e51cb736750eb3fafa51">GetElementBounds</a> (Eigen::VectorXd *lower, Eigen::VectorXd *upper) const</td></tr>
<tr class="memdesc:afcd23700f1c0e51cb736750eb3fafa51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bounds for the elements.  <a href="#afcd23700f1c0e51cb736750eb3fafa51">More...</a><br /></td></tr>
<tr class="separator:afcd23700f1c0e51cb736750eb3fafa51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:aa84df3c9367e9d410bfa85761b241986"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#aa84df3c9367e9d410bfa85761b241986">VectorBase</a> (const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;)=delete</td></tr>
<tr class="separator:aa84df3c9367e9d410bfa85761b241986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9241a7663c3b91834cb25850cf0d2d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a9241a7663c3b91834cb25850cf0d2d8f">operator=</a> (const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;)=delete</td></tr>
<tr class="separator:a9241a7663c3b91834cb25850cf0d2d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8a6afc05d041ccb78c000e578b0e81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#afb8a6afc05d041ccb78c000e578b0e81">VectorBase</a> (<a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:afb8a6afc05d041ccb78c000e578b0e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263f433b6b65dbda74b1e1f43870d0f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a263f433b6b65dbda74b1e1f43870d0f5">operator=</a> (<a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a263f433b6b65dbda74b1e1f43870d0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a146b52fc4bf3790ed55a6c097ca3e76b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a146b52fc4bf3790ed55a6c097ca3e76b">VectorBase</a> ()</td></tr>
<tr class="separator:a146b52fc4bf3790ed55a6c097ca3e76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ecb18ae72fe3a2eb5b377e849277e9"><td class="memItemLeft" align="right" valign="top">virtual const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#ad2ecb18ae72fe3a2eb5b377e849277e9">DoGetAtIndex</a> (<a class="el" href="classint.html">int</a> index) const =0</td></tr>
<tr class="memdesc:ad2ecb18ae72fe3a2eb5b377e849277e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations should ensure this operation is O(1) and allocates no memory.  <a href="#ad2ecb18ae72fe3a2eb5b377e849277e9">More...</a><br /></td></tr>
<tr class="separator:ad2ecb18ae72fe3a2eb5b377e849277e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca66dfc12acee980b8d8d5c75d281433"><td class="memItemLeft" align="right" valign="top">virtual T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#aca66dfc12acee980b8d8d5c75d281433">DoGetAtIndex</a> (<a class="el" href="classint.html">int</a> index)=0</td></tr>
<tr class="memdesc:aca66dfc12acee980b8d8d5c75d281433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations should ensure this operation is O(1) and allocates no memory.  <a href="#aca66dfc12acee980b8d8d5c75d281433">More...</a><br /></td></tr>
<tr class="separator:aca66dfc12acee980b8d8d5c75d281433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe79641d14373b863f2bb2a6bf40d14"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a2fe79641d14373b863f2bb2a6bf40d14">DoPlusEqScaled</a> (const std::initializer_list&lt; std::pair&lt; T, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp; &gt;&gt; &amp;rhs_scale)</td></tr>
<tr class="memdesc:a2fe79641d14373b863f2bb2a6bf40d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds in multiple scaled vectors to this vector.  <a href="#a2fe79641d14373b863f2bb2a6bf40d14">More...</a><br /></td></tr>
<tr class="separator:a2fe79641d14373b863f2bb2a6bf40d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa84df3c9367e9d410bfa85761b241986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84df3c9367e9d410bfa85761b241986">&#9670;&nbsp;</a></span>VectorBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb8a6afc05d041ccb78c000e578b0e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8a6afc05d041ccb78c000e578b0e81">&#9670;&nbsp;</a></span>VectorBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abc19c2584a73f03bd1e31277d11315b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc19c2584a73f03bd1e31277d11315b4">&#9670;&nbsp;</a></span>~VectorBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a146b52fc4bf3790ed55a6c097ca3e76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146b52fc4bf3790ed55a6c097ca3e76b">&#9670;&nbsp;</a></span>VectorBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9f65de06c90fe4b0a0cd427032313218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f65de06c90fe4b0a0cd427032313218">&#9670;&nbsp;</a></span>CopyToPreSizedVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void CopyToPreSizedVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies this entire VectorBase into a pre-sized Eigen Vector. </p>
<p>Implementations should ensure this operation is O(N) in the size of the value. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>vec</code> is the wrong size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23751ea78ff51179a9b3ed90317c922d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23751ea78ff51179a9b3ed90317c922d">&#9670;&nbsp;</a></span>CopyToVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; CopyToVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies this entire VectorBase into a contiguous Eigen Vector. </p>
<p>Implementations should ensure this operation is O(N) in the size of the value and allocates only the O(N) memory that it returns. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a02900660573acdccd6d1e4b711a1e5e0">BasicVector&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a02900660573acdccd6d1e4b711a1e5e0">BasicVector&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a02900660573acdccd6d1e4b711a1e5e0">BasicVector&lt; AutoDiffXd &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a02900660573acdccd6d1e4b711a1e5e0">BasicVector&lt; drake::symbolic::Expression &gt;</a>.</p>

</div>
</div>
<a id="ad2ecb18ae72fe3a2eb5b377e849277e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ecb18ae72fe3a2eb5b377e849277e9">&#9670;&nbsp;</a></span>DoGetAtIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T&amp; DoGetAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementations should ensure this operation is O(1) and allocates no memory. </p>
<p>The index has already been checked for negative, but not size. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a0107f456ef8dc0b64bcebcdcabf812e5">BasicVector&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a0107f456ef8dc0b64bcebcdcabf812e5">BasicVector&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a0107f456ef8dc0b64bcebcdcabf812e5">BasicVector&lt; AutoDiffXd &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a0107f456ef8dc0b64bcebcdcabf812e5">BasicVector&lt; drake::symbolic::Expression &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_subvector.html#a2dd76d9d8b56c2121f37277fa00f023f">Subvector&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_supervector.html#a2dd76d9d8b56c2121f37277fa00f023f">Supervector&lt; T &gt;</a>.</p>

</div>
</div>
<a id="aca66dfc12acee980b8d8d5c75d281433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca66dfc12acee980b8d8d5c75d281433">&#9670;&nbsp;</a></span>DoGetAtIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T&amp; DoGetAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementations should ensure this operation is O(1) and allocates no memory. </p>
<p>The index has already been checked for negative, but not size. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ac5fff24e719b2bdc456bf2c3cd963b63">BasicVector&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ac5fff24e719b2bdc456bf2c3cd963b63">BasicVector&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ac5fff24e719b2bdc456bf2c3cd963b63">BasicVector&lt; AutoDiffXd &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#ac5fff24e719b2bdc456bf2c3cd963b63">BasicVector&lt; drake::symbolic::Expression &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_subvector.html#a48e66f6acd6f9273fbcae0a42e9a34f3">Subvector&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_supervector.html#a48e66f6acd6f9273fbcae0a42e9a34f3">Supervector&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a2fe79641d14373b863f2bb2a6bf40d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe79641d14373b863f2bb2a6bf40d14">&#9670;&nbsp;</a></span>DoPlusEqScaled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void DoPlusEqScaled </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::pair&lt; T, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp; &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds in multiple scaled vectors to this vector. </p>
<p>All vectors are guaranteed to be the same size.</p>
<p>You should override this method if possible with a more efficient approach that leverages structure; the default implementation performs element-by-element computations that are likely inefficient, but even this implementation minimizes memory accesses for efficiency. If the vector is contiguous, for example, implementations that leverage SIMD operations should be far more efficient. Overriding implementations should ensure that this operation remains O(N) in the size of the value and allocates no memory. </p>

</div>
</div>
<a id="ae79ea848ba1a3e2a87da1777b3f399cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79ea848ba1a3e2a87da1777b3f399cc">&#9670;&nbsp;</a></span>GetAtIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; GetAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element at the given index in the vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the index is &gt;= <a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a36b716289158c33f86a8cf30219be68c" title="Returns the number of elements in the vector.">size()</a> or negative. Consider <a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a2d4b36a43041d6505f82836a6aeccd52" title="Returns the element at the given index in the vector.">operator[]()</a> instead if bounds-checking is unwanted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef7a4ff282156d6974f47912756265b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7a4ff282156d6974f47912756265b4">&#9670;&nbsp;</a></span>GetAtIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; GetAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element at the given index in the vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the index is &gt;= <a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a36b716289158c33f86a8cf30219be68c" title="Returns the number of elements in the vector.">size()</a> or negative. Consider <a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a2d4b36a43041d6505f82836a6aeccd52" title="Returns the element at the given index in the vector.">operator[]()</a> instead if bounds-checking is unwanted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcd23700f1c0e51cb736750eb3fafa51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd23700f1c0e51cb736750eb3fafa51">&#9670;&nbsp;</a></span>GetElementBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GetElementBounds </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd *&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd *&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the bounds for the elements. </p>
<p>If lower and upper are both empty size vectors, then there are no bounds. Otherwise, the bounds are (*lower)(i) &lt;= GetAtIndex(i) &lt;= (*upper)(i) The default output is no bounds. </p>

</div>
</div>
<a id="accc86d5305584bc7cb96971f60220125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc86d5305584bc7cb96971f60220125">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in vector <code>rhs</code> to this vector. </p>

</div>
</div>
<a id="acb91f3ae2b66473a274073f56c5fbec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb91f3ae2b66473a274073f56c5fbec0">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract in vector <code>rhs</code> to this vector. </p>

</div>
</div>
<a id="a263f433b6b65dbda74b1e1f43870d0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263f433b6b65dbda74b1e1f43870d0f5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9241a7663c3b91834cb25850cf0d2d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9241a7663c3b91834cb25850cf0d2d8f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d4b36a43041d6505f82836a6aeccd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4b36a43041d6505f82836a6aeccd52">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element at the given index in the vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <code>index</code> &lt; <a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a36b716289158c33f86a8cf30219be68c" title="Returns the number of elements in the vector.">size()</a> </dd></dl>

</div>
</div>
<a id="ab3f0073680dabba9d2778d9a6f35aed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f0073680dabba9d2778d9a6f35aed7">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element at the given index in the vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <code>index</code> &lt; <a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a36b716289158c33f86a8cf30219be68c" title="Returns the number of elements in the vector.">size()</a> </dd></dl>

</div>
</div>
<a id="aecb348d2ee8136278c64e180f4af21b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb348d2ee8136278c64e180f4af21b7">&#9670;&nbsp;</a></span>PlusEqScaled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&amp; PlusEqScaled </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in scaled vector <code>rhs</code> to this vector. </p>
<p>Both vectors must be the same size. </p>

</div>
</div>
<a id="a32def866adfc4d6ce3dfe3255881651c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32def866adfc4d6ce3dfe3255881651c">&#9670;&nbsp;</a></span>PlusEqScaled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&amp; PlusEqScaled </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::pair&lt; T, const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp; &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in multiple scaled vectors to this vector. </p>
<p>All vectors must be the same size. </p>

</div>
</div>
<a id="abe595692eca6a4b16cd0344195d54599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe595692eca6a4b16cd0344195d54599">&#9670;&nbsp;</a></span>ScaleAndAddToVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ScaleAndAddToVector </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a scaled version of this vector to Eigen vector <code>vec</code>, which must be the same size. </p>
<p>Implementations may override this default implementation with a more efficient approach, for instance if this vector is contiguous. Implementations should ensure this operation remains O(N) in the size of the value and allocates no memory. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a343fa4902e5cfcf181706fd72abdf5d0">BasicVector&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a343fa4902e5cfcf181706fd72abdf5d0">BasicVector&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a343fa4902e5cfcf181706fd72abdf5d0">BasicVector&lt; AutoDiffXd &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a343fa4902e5cfcf181706fd72abdf5d0">BasicVector&lt; drake::symbolic::Expression &gt;</a>.</p>

</div>
</div>
<a id="a5c5902bbfda44607fda562f0c3956520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5902bbfda44607fda562f0c3956520">&#9670;&nbsp;</a></span>SetAtIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the state at the given index with the value. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the index is &gt;= <a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a36b716289158c33f86a8cf30219be68c" title="Returns the number of elements in the vector.">size()</a>. Consider <a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a2d4b36a43041d6505f82836a6aeccd52" title="Returns the element at the given index in the vector.">operator[]()</a> instead if bounds-checking is unwanted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a8364f71b762045df41bfcb58927fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8364f71b762045df41bfcb58927fe5">&#9670;&nbsp;</a></span>SetFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the entire vector with the contents of <code>value</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>value</code> is not a column vector with <a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a36b716289158c33f86a8cf30219be68c" title="Returns the number of elements in the vector.">size()</a> rows.</td></tr>
  </table>
  </dd>
</dl>
<p>Implementations should ensure this operation is O(N) in the size of the value and allocates no memory. </p>

</div>
</div>
<a id="aea9d9b7396dccc9374d87a9be04a2597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9d9b7396dccc9374d87a9be04a2597">&#9670;&nbsp;</a></span>SetFromVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetFromVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the entire vector with the contents of <code>value</code>. </p>
<p>Throws std::runtime_error if <code>value</code> is not a column vector with <a class="el" href="classdrake_1_1systems_1_1_vector_base.html#a36b716289158c33f86a8cf30219be68c" title="Returns the number of elements in the vector.">size()</a> rows.</p>
<p>Implementations should ensure this operation is O(N) in the size of the value and allocates no memory. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a0a9c44911481db46e0c8c8ee8708ae70">BasicVector&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a0a9c44911481db46e0c8c8ee8708ae70">BasicVector&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a0a9c44911481db46e0c8c8ee8708ae70">BasicVector&lt; AutoDiffXd &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a0a9c44911481db46e0c8c8ee8708ae70">BasicVector&lt; drake::symbolic::Expression &gt;</a>.</p>

</div>
</div>
<a id="a04797332f4fa1889d462e5c7aacf1400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04797332f4fa1889d462e5c7aacf1400">&#9670;&nbsp;</a></span>SetZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SetZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a15f4b55a146f2033a2a1d44054829f3f">BasicVector&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a15f4b55a146f2033a2a1d44054829f3f">BasicVector&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a15f4b55a146f2033a2a1d44054829f3f">BasicVector&lt; AutoDiffXd &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a15f4b55a146f2033a2a1d44054829f3f">BasicVector&lt; drake::symbolic::Expression &gt;</a>.</p>

</div>
</div>
<a id="a36b716289158c33f86a8cf30219be68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b716289158c33f86a8cf30219be68c">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classint.html">int</a> size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the vector. </p>
<p>Implementations should ensure this operation is O(1) and allocates no memory. </p>

<p>Implemented in <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a00f794bc20ca26b81a247bcee7c7f6a4">BasicVector&lt; T &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a00f794bc20ca26b81a247bcee7c7f6a4">BasicVector&lt; double &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a00f794bc20ca26b81a247bcee7c7f6a4">BasicVector&lt; AutoDiffXd &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_basic_vector.html#a00f794bc20ca26b81a247bcee7c7f6a4">BasicVector&lt; drake::symbolic::Expression &gt;</a>, <a class="el" href="classdrake_1_1systems_1_1_subvector.html#a4538a1305a44cbf7a5bd9a536b55eaad">Subvector&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1systems_1_1_supervector.html#a4538a1305a44cbf7a5bd9a536b55eaad">Supervector&lt; T &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/systems/framework/<a class="el" href="vector__base_8h.html">vector_base.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1systems.html">systems</a></li><li class="navelem"><a class="el" href="classdrake_1_1systems_1_1_vector_base.html">VectorBase</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
