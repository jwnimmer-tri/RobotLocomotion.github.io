<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::multibody Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacedrake_1_1multibody.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">drake::multibody Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedrake_1_1multibody_1_1benchmarks"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1benchmarks.html">benchmarks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1multibody_1_1constraint"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1constraint.html">constraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1multibody_1_1hydroelastics"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1hydroelastics.html">hydroelastics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1multibody_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1multibody_1_1test__utilities"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody_1_1test__utilities.html">test_utilities</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1_add_multibody_plant_scene_graph_result.html">AddMultibodyPlantSceneGraphResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary result from <code>AddMultibodyPlantSceneGraph</code>.  <a href="structdrake_1_1multibody_1_1_add_multibody_plant_scene_graph_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_angle_between_vectors_constraint.html">AngleBetweenVectorsConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains that the angle between a vector <code>a</code> and another vector <code>b</code> is between [θ_lower, θ_upper].  <a href="classdrake_1_1multibody_1_1_angle_between_vectors_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_articulated_body_inertia.html">ArticulatedBodyInertia</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Articulated Body Inertia</em> is the inertia that a body appears to have when it is the base (or root) of a rigid-body system, also referred to as <em>Articulated Body</em> in the context of articulated body algorithms.  <a href="classdrake_1_1multibody_1_1_articulated_body_inertia.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_ball_rpy_joint.html">BallRpyJoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> allows two bodies to rotate freely relative to one another.  <a href="classdrake_1_1multibody_1_1_ball_rpy_joint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Body provides the general abstraction of a body with an API that makes no assumption about whether a body is rigid or deformable and neither does it make any assumptions about the underlying physical model or approximation.  <a href="classdrake_1_1multibody_1_1_body.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_body_frame.html">BodyFrame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BodyFrame is a material <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame),...">Frame</a> that serves as the unique reference frame for a <a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a>.  <a href="classdrake_1_1multibody_1_1_body_frame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_contact_results.html">ContactResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container class storing the contact results information for each contact pair for a given state of the simulation.  <a href="classdrake_1_1multibody_1_1_contact_results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_contact_results_to_lcm_system.html">ContactResultsToLcmSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A System that encodes <a class="el" href="classdrake_1_1multibody_1_1_contact_results.html" title="A container class storing the contact results information for each contact pair for a given state of ...">ContactResults</a> into a lcmt_contact_results_for_viz message.  <a href="classdrake_1_1multibody_1_1_contact_results_to_lcm_system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1_contact_wrench.html">ContactWrench</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the contact wrench (spatial force) from <a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a> A to <a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a> B applied at point Cb.  <a href="structdrake_1_1multibody_1_1_contact_wrench.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_contact_wrench_evaluator.html">ContactWrenchEvaluator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_contact_wrench_from_force_in_world_frame_evaluator.html">ContactWrenchFromForceInWorldFrameEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contact wrench is τ_AB_W = 0, f_AB_W = λ Namely we assume that λ is the contact force from A to B, applied directly at B's witness point.  <a href="classdrake_1_1multibody_1_1_contact_wrench_from_force_in_world_frame_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for Coulomb's Law of Friction, namely:  <a href="classdrake_1_1multibody_1_1_coulomb_friction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_distance_constraint.html">DistanceConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains the distance between a pair of geometries to be within a range [distance_lower, distance_upper].  <a href="classdrake_1_1multibody_1_1_distance_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_door_hinge.html">DoorHinge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This ForceElement models a revolute <a class="el" href="classdrake_1_1multibody_1_1_door_hinge.html" title="This ForceElement models a revolute DoorHinge joint that could exhibit different force/torque charact...">DoorHinge</a> joint that could exhibit different force/torque characteristics at different states due to the existence of different type of torques on the joint.  <a href="classdrake_1_1multibody_1_1_door_hinge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1_door_hinge_config.html">DoorHingeConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration structure for the <a class="el" href="classdrake_1_1multibody_1_1_door_hinge.html" title="This ForceElement models a revolute DoorHinge joint that could exhibit different force/torque charact...">DoorHinge</a>.  <a href="structdrake_1_1multibody_1_1_door_hinge_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1_externally_applied_spatial_force.html">ExternallyAppliedSpatialForce</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html">FixedOffsetFrame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FixedOffsetFrame represents a material frame F whose pose is fixed with respect to a <em>parent</em> material frame P.  <a href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_force_element.html">ForceElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.  <a href="classdrake_1_1multibody_1_1_force_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frame is an abstract class representing a <em>material frame</em> (also called a <em>physical frame</em>), meaning that it is associated with a material point of a <a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a>.  <a href="classdrake_1_1multibody_1_1_frame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame_base.html">FrameBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FrameBase is an abstract representation of the concept of a <em>frame</em> in multibody dynamics.  <a href="classdrake_1_1multibody_1_1_frame_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_gaussian_triangle_quadrature_rule.html">GaussianTriangleQuadratureRule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_gaze_target_constraint.html">GazeTargetConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains a target point T to be within a cone K.  <a href="classdrake_1_1multibody_1_1_gaze_target_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_hydroelastic_contact_info.html">HydroelasticContactInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class containing information regarding contact and contact response between two geometries attached to a pair of bodies.  <a href="classdrake_1_1multibody_1_1_hydroelastic_contact_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1_hydroelastic_quadrature_point_data.html">HydroelasticQuadraturePointData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results from intermediate calculations used during the quadrature routine.  <a href="structdrake_1_1multibody_1_1_hydroelastic_quadrature_point_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves an inverse kinematics (IK) problem on a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>, to find the postures of the robot satisfying certain constraints.  <a href="classdrake_1_1multibody_1_1_inverse_kinematics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Joint models the kinematical relationship which characterizes the possible relative motion between two bodies.  <a href="classdrake_1_1multibody_1_1_joint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a given <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a>.  <a href="classdrake_1_1multibody_1_1_joint_actuator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_linear_bushing_roll_pitch_yaw.html">LinearBushingRollPitchYaw</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> models a massless flexible bushing that connects a frame A of a link (body) L0 to a frame C of a link (body) L1.  <a href="classdrake_1_1multibody_1_1_linear_bushing_roll_pitch_yaw.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_linear_spring_damper.html">LinearSpringDamper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This ForceElement models a spring-damper attached between two points on two different bodies.  <a href="classdrake_1_1multibody_1_1_linear_spring_damper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_manipulator_equation_constraint.html">ManipulatorEquationConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Constraint to impose the manipulator equation: 0 = (Buₙ₊₁ + ∑ᵢ (Jᵢ_WBᵀ(qₙ₊₁)ᵀ * Fᵢ_AB_W(λᵢ,ₙ₊₁))  <a href="classdrake_1_1multibody_1_1_manipulator_equation_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_minimum_distance_constraint.html">MinimumDistanceConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrain the signed distance between all candidate pairs of geometries (according to the logic of SceneGraphInspector::GetCollisionCandidates()) to be no smaller than a specified minimum distance.  <a href="classdrake_1_1multibody_1_1_minimum_distance_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html">MultibodyElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing an element (subcomponent) of a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> or (internally) a MultibodyTree.  <a href="classdrake_1_1multibody_1_1_multibody_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to hold a set of forces applied to a MultibodyTree system.  <a href="classdrake_1_1multibody_1_1_multibody_forces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MultibodyPlant is a Drake system framework representation (see <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">systems::System</a>) for the model of a physical system consisting of a collection of interconnected bodies.  <a href="classdrake_1_1multibody_1_1_multibody_plant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant_tester.html">MultibodyPlantTester</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_orientation_constraint.html">OrientationConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains that the angle difference θ between the orientation of frame A and the orientation of frame B to satisfy θ ≤ θ_bound.  <a href="classdrake_1_1multibody_1_1_orientation_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_package_map.html">PackageMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps ROS package names to their full path on the local file system.  <a href="classdrake_1_1multibody_1_1_package_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_parser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses SDF and URDF input files into a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> and (optionally) a SceneGraph.  <a href="classdrake_1_1multibody_1_1_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_planar_joint.html">PlanarJoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This joint models a planar joint allowing two bodies to translate and rotate relative to one another in a plane with three degrees of freedom.  <a href="classdrake_1_1multibody_1_1_planar_joint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_point_pair_contact_info.html">PointPairContactInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class containing information regarding contact response between two bodies including:  <a href="classdrake_1_1multibody_1_1_point_pair_contact_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_point_to_point_distance_constraint.html">PointToPointDistanceConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrain that the distance between a point P1 on frame B1 and another point P2 on frame B2 is within a range [distance_lower, distance_upper].  <a href="classdrake_1_1multibody_1_1_point_to_point_distance_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_position_constraint.html">PositionConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains the position of a point Q, rigidly attached to a frame B, to be within a bounding box measured and expressed in frame A.  <a href="classdrake_1_1multibody_1_1_position_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_prismatic_joint.html">PrismaticJoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> allows two bodies to translate relative to one another along a common axis.  <a href="classdrake_1_1multibody_1_1_prismatic_joint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_propeller.html">Propeller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A System that connects to the <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> in order to model the effects of one or more controlled propellers acting on a <a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a>.  <a href="classdrake_1_1multibody_1_1_propeller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1_propeller_info.html">PropellerInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters that describe the kinematic frame and force-production properties of a single propeller.  <a href="structdrake_1_1multibody_1_1_propeller_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_revolute_joint.html">RevoluteJoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> allows two bodies to rotate relatively to one another around a common axis.  <a href="classdrake_1_1multibody_1_1_revolute_joint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_revolute_spring.html">RevoluteSpring</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This ForceElement models a torsional spring attached to a <a class="el" href="classdrake_1_1multibody_1_1_revolute_joint.html" title="This Joint allows two bodies to rotate relatively to one another around a common axis.">RevoluteJoint</a> and applies a torque to that joint.  <a href="classdrake_1_1multibody_1_1_revolute_spring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The term <b>rigid body</b> implies that the deformations of the body under consideration are so small that they have no significant effect on the overall motions of the body and therefore deformations can be neglected.  <a href="classdrake_1_1multibody_1_1_rigid_body.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_rotational_inertia.html">RotationalInertia</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes the mass distribution (inertia properties) of a body or composite body about a particular point.  <a href="classdrake_1_1multibody_1_1_rotational_inertia.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1_signed_distance_with_time_derivative.html">SignedDistanceWithTimeDerivative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The struct containing the signed distance and its time derivative between a pair of geometries.  <a href="structdrake_1_1multibody_1_1_signed_distance_with_time_derivative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to represent a <em>spatial acceleration</em> that combines rotational (angular acceleration) and translational (linear acceleration) components.  <a href="classdrake_1_1multibody_1_1_spatial_acceleration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_force.html">SpatialForce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to represent a <em>spatial force</em> (also called a <em>wrench</em>) that combines both rotational (torque) and translational force components.  <a href="classdrake_1_1multibody_1_1_spatial_force.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the physical concept of a <em>Spatial Inertia</em>.  <a href="classdrake_1_1multibody_1_1_spatial_inertia.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_momentum.html">SpatialMomentum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to represent the <em>spatial momentum</em> of a particle, system of particles or body (whether rigid or soft.) The linear momentum <code>l_NS</code> of a system of particles S in a reference frame N is defined by:  <a href="classdrake_1_1multibody_1_1_spatial_momentum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_vector.html">SpatialVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to represent physical quantities that correspond to spatial vectors such as spatial velocities, spatial accelerations and spatial forces.  <a href="classdrake_1_1multibody_1_1_spatial_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to represent a <em>spatial velocity</em> (also called a <em>twist</em>) that combines rotational (angular) and translational (linear) velocity components.  <a href="classdrake_1_1multibody_1_1_spatial_velocity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_static_equilibrium_constraint.html">StaticEquilibriumConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose the static equilibrium constraint 0 = τ_g + Bu + ∑J_WBᵀ(q) * Fapp_B_W.  <a href="classdrake_1_1multibody_1_1_static_equilibrium_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_static_equilibrium_problem.html">StaticEquilibriumProblem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the static equilibrium pose of a multibody system through optimization.  <a href="classdrake_1_1multibody_1_1_static_equilibrium_problem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_static_friction_cone_constraint.html">StaticFrictionConeConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formulates the nonlinear friction cone constraint |fₜ| ≤ μ*fₙ, where fₜ is the tangential contact force, fₙ is the normal contact force, and μ is the friction coefficient.  <a href="classdrake_1_1multibody_1_1_static_friction_cone_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1_tamsi_solver_iteration_stats.html">TamsiSolverIterationStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct used to store information about the iteration process performed by <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a>.  <a href="structdrake_1_1multibody_1_1_tamsi_solver_iteration_stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1multibody_1_1_tamsi_solver_parameters.html">TamsiSolverParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the parameters controlling the iteration process of the <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html">TamsiSolver</a> solver.  <a href="structdrake_1_1multibody_1_1_tamsi_solver_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_triangle_quadrature.html">TriangleQuadrature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for integrating a function using numerical quadrature over triangular domains.  <a href="classdrake_1_1multibody_1_1_triangle_quadrature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_triangle_quadrature_rule.html">TriangleQuadratureRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "rule" (weights and quadrature points) for computing quadrature over triangular domains.  <a href="classdrake_1_1multibody_1_1_triangle_quadrature_rule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html">UniformGravityFieldElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> allows modeling the effect of a uniform gravity field as felt by bodies on the surface of the Earth.  <a href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_unit_inertia.html">UnitInertia</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to represent rotational inertias for unit mass bodies.  <a href="classdrake_1_1multibody_1_1_unit_inertia.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_universal_joint.html">UniversalJoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This joint models a universal joint allowing two bodies to rotate relative to one another with two degrees of freedom.  <a href="classdrake_1_1multibody_1_1_universal_joint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html">WeldJoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> fixes the relative pose between two frames as if "welding" them together.  <a href="classdrake_1_1multibody_1_1_weld_joint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9b7dce3eb33772802af322ca25ef4864"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#a9b7dce3eb33772802af322ca25ef4864">MinimumDistancePenaltyFunction</a> = <a class="el" href="namespacedrake_1_1solvers.html#adc2a57e87ae4e4088e12967a25a7c229">solvers::MinimumValuePenaltyFunction</a></td></tr>
<tr class="memdesc:a9b7dce3eb33772802af322ca25ef4864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the penalty function φ(x) and its derivatives dφ(x)/dx.  <a href="#a9b7dce3eb33772802af322ca25ef4864">More...</a><br /></td></tr>
<tr class="separator:a9b7dce3eb33772802af322ca25ef4864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c69848adb64ae45eebc1e5af5dbaa6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a> = <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; class FrameTag &gt;</td></tr>
<tr class="memdesc:a51c69848adb64ae45eebc1e5af5dbaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to identify frames by index in a multibody tree system.  <a href="#a51c69848adb64ae45eebc1e5af5dbaa6">More...</a><br /></td></tr>
<tr class="separator:a51c69848adb64ae45eebc1e5af5dbaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe033def48af7bf4857957f70f4d3e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> = <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; class BodyTag &gt;</td></tr>
<tr class="memdesc:acbe033def48af7bf4857957f70f4d3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to identify bodies by index in a multibody tree system.  <a href="#acbe033def48af7bf4857957f70f4d3e0">More...</a><br /></td></tr>
<tr class="separator:acbe033def48af7bf4857957f70f4d3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add80e949328b179d78312d1455319868"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#add80e949328b179d78312d1455319868">ForceElementIndex</a> = <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; class ForceElementTag &gt;</td></tr>
<tr class="memdesc:add80e949328b179d78312d1455319868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to identify force elements by index within a multibody tree system.  <a href="#add80e949328b179d78312d1455319868">More...</a><br /></td></tr>
<tr class="separator:add80e949328b179d78312d1455319868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27485be8a33f5ed2ee7f3f8de9dd40c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> = <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; class JointElementTag &gt;</td></tr>
<tr class="memdesc:a27485be8a33f5ed2ee7f3f8de9dd40c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to identify joints by index within a multibody tree system.  <a href="#a27485be8a33f5ed2ee7f3f8de9dd40c0">More...</a><br /></td></tr>
<tr class="separator:a27485be8a33f5ed2ee7f3f8de9dd40c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc810ff385ed4dede2e011b0b6fd3f2c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> = <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; class JointActuatorElementTag &gt;</td></tr>
<tr class="memdesc:acc810ff385ed4dede2e011b0b6fd3f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to identify actuators by index within a multibody tree system.  <a href="#acc810ff385ed4dede2e011b0b6fd3f2c">More...</a><br /></td></tr>
<tr class="separator:acc810ff385ed4dede2e011b0b6fd3f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65439a17091283a89eb12f1955c6db0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> = <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt; class ModelInstanceTag &gt;</td></tr>
<tr class="memdesc:af65439a17091283a89eb12f1955c6db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to identify model instances by index within a multibody tree system.  <a href="#af65439a17091283a89eb12f1955c6db0">More...</a><br /></td></tr>
<tr class="separator:af65439a17091283a89eb12f1955c6db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6f6e054758d34b83e86bea87d65dfe4e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4e">ContactModel</a> { <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea0f9136530df40294d8404d10cc150423">kHydroelasticsOnly</a>, 
<a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea24d742e384e4b818c113620a6aebe0e5">kPointContactOnly</a>, 
<a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea8ad3adce463edb0d2843e1f1c0057d4a">kHydroelasticWithFallback</a>
 }</td></tr>
<tr class="memdesc:a6f6e054758d34b83e86bea87d65dfe4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration for contact model options.  <a href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4e">More...</a><br /></td></tr>
<tr class="separator:a6f6e054758d34b83e86bea87d65dfe4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6144c2c8d4494bcb283f3f9e5841bfd2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#a6144c2c8d4494bcb283f3f9e5841bfd2">TamsiSolverResult</a> { <a class="el" href="namespacedrake_1_1multibody.html#a6144c2c8d4494bcb283f3f9e5841bfd2a8c632159fa131f09d04f94e3cbcd8782">kSuccess</a> = 0, 
<a class="el" href="namespacedrake_1_1multibody.html#a6144c2c8d4494bcb283f3f9e5841bfd2a1131fdd052242dd97fe2fe1d7a9a804a">kMaxIterationsReached</a> = 1, 
<a class="el" href="namespacedrake_1_1multibody.html#a6144c2c8d4494bcb283f3f9e5841bfd2a03dd71797c3ae46b778a3ab8591a9727">kLinearSolverFailed</a> = 2
 }</td></tr>
<tr class="memdesc:a6144c2c8d4494bcb283f3f9e5841bfd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result from TamsiSolver::SolveWithGuess() used to report the success or failure of the solver.  <a href="namespacedrake_1_1multibody.html#a6144c2c8d4494bcb283f3f9e5841bfd2">More...</a><br /></td></tr>
<tr class="separator:a6144c2c8d4494bcb283f3f9e5841bfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95b5f6a8d72582ad91a1aca26d76658"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> { <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b">kQDot</a>, 
<a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a">kV</a>
 }</td></tr>
<tr class="memdesc:ad95b5f6a8d72582ad91a1aca26d76658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration that indicates whether the Jacobian is partial differentiation with respect to q̇ (time-derivatives of generalized positions) or with respect to v (generalized velocities).  <a href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">More...</a><br /></td></tr>
<tr class="separator:ad95b5f6a8d72582ad91a1aca26d76658"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa1fd44e85ab30519ef7a904a4ebeb82d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; internal::SlidingFrictionComplementarityNonlinearConstraint &gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1multibody_1_1_static_friction_cone_constraint.html">StaticFrictionConeConstraint</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#aa1fd44e85ab30519ef7a904a4ebeb82d">AddSlidingFrictionComplementarityExplicitContactConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_contact_wrench_evaluator.html">ContactWrenchEvaluator</a> *contact_wrench_evaluator, double complementarity_tolerance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;q_vars, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;v_vars, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;lambda_vars, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *prog)</td></tr>
<tr class="memdesc:aa1fd44e85ab30519ef7a904a4ebeb82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a pair of geometries in explicit contact, adds the sliding friction complementarity constraint explained in <a class="el" href="sliding__friction__complementarity__constraint_8h.html#sliding_friction_complementarity_constraint">sliding_friction_complementarity_constraint</a> to an optimization program.  <a href="#aa1fd44e85ab30519ef7a904a4ebeb82d">More...</a><br /></td></tr>
<tr class="separator:aa1fd44e85ab30519ef7a904a4ebeb82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad168321c6009ddda8ee2ca9abbef90b1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; internal::SlidingFrictionComplementarityNonlinearConstraint &gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; internal::StaticFrictionConeComplementarityNonlinearConstraint &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#ad168321c6009ddda8ee2ca9abbef90b1">AddSlidingFrictionComplementarityImplicitContactConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_contact_wrench_evaluator.html">ContactWrenchEvaluator</a> *contact_wrench_evaluator, double complementarity_tolerance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;q_vars, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;v_vars, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;lambda_vars, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *prog)</td></tr>
<tr class="memdesc:ad168321c6009ddda8ee2ca9abbef90b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a pair of geometries in implicit contact (they may or may not be in contact, adds the sliding friction complementarity constraint explained in <a class="el" href="sliding__friction__complementarity__constraint_8h.html#sliding_friction_complementarity_constraint">sliding_friction_complementarity_constraint</a>.  <a href="#ad168321c6009ddda8ee2ca9abbef90b1">More...</a><br /></td></tr>
<tr class="separator:ad168321c6009ddda8ee2ca9abbef90b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4508ec670196c3fe45e9b52af8a73d4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; internal::StaticFrictionConeComplementarityNonlinearConstraint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#a4508ec670196c3fe45e9b52af8a73d4a">AddStaticFrictionConeComplementarityConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_contact_wrench_evaluator.html">ContactWrenchEvaluator</a> *contact_wrench_evaluator, double complementarity_tolerance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;q_vars, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;lambda_vars, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *prog)</td></tr>
<tr class="memdesc:a4508ec670196c3fe45e9b52af8a73d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the complementarity constraint on the static friction force between a pair of contacts |ft_W| &lt;= μ * n_Wᵀ * f_W (static friction force in the friction cone).  <a href="#a4508ec670196c3fe45e9b52af8a73d4a">More...</a><br /></td></tr>
<tr class="separator:a4508ec670196c3fe45e9b52af8a73d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57577cfb87838e5b949fd703e227acfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1multibody_1_1_signed_distance_with_time_derivative.html">SignedDistanceWithTimeDerivative</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#a57577cfb87838e5b949fd703e227acfc">CalcDistanceAndTimeDerivative</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">multibody::MultibodyPlant</a>&lt; double &gt; &amp;plant, const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> &gt; &amp;geometry_pair, const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; &amp;context)</td></tr>
<tr class="memdesc:a57577cfb87838e5b949fd703e227acfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a pair of geometries and the generalized position/velocity of the plant, compute the signed distance between the pair of geometries and the time derivative of the signed distance.  <a href="#a57577cfb87838e5b949fd703e227acfc">More...</a><br /></td></tr>
<tr class="separator:a57577cfb87838e5b949fd703e227acfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7c07596e19e7537c3f08fd94ba8e153"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1lcm_1_1_lcm_publisher_system.html">systems::lcm::LcmPublisherSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__visualization.html#gac7c07596e19e7537c3f08fd94ba8e153">ConnectContactResultsToDrakeVisualizer</a> (<a class="el" href="classdrake_1_1systems_1_1_diagram_builder.html">systems::DiagramBuilder</a>&lt; double &gt; *builder, const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; double &gt; &amp;multibody_plant, <a class="el" href="classdrake_1_1lcm_1_1_drake_lcm_interface.html">lcm::DrakeLcmInterface</a> *lcm=nullptr)</td></tr>
<tr class="memdesc:gac7c07596e19e7537c3f08fd94ba8e153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends a Diagram with the required components to publish contact results to drake_visualizer.  <a href="group__visualization.html#gac7c07596e19e7537c3f08fd94ba8e153">More...</a><br /></td></tr>
<tr class="separator:gac7c07596e19e7537c3f08fd94ba8e153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga198e1dbf7f5bae86fc8052374ba08e5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1lcm_1_1_lcm_publisher_system.html">systems::lcm::LcmPublisherSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__visualization.html#ga198e1dbf7f5bae86fc8052374ba08e5f">ConnectContactResultsToDrakeVisualizer</a> (<a class="el" href="classdrake_1_1systems_1_1_diagram_builder.html">systems::DiagramBuilder</a>&lt; double &gt; *builder, const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; double &gt; &amp;multibody_plant, const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; double &gt; &amp;contact_results_port, <a class="el" href="classdrake_1_1lcm_1_1_drake_lcm_interface.html">lcm::DrakeLcmInterface</a> *lcm=nullptr)</td></tr>
<tr class="memdesc:ga198e1dbf7f5bae86fc8052374ba08e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements ConnectContactResultsToDrakeVisualizer, but using explicitly specified <code>contact_results_port</code> and <code>geometry_input_port</code> arguments.  <a href="group__visualization.html#ga198e1dbf7f5bae86fc8052374ba08e5f">More...</a><br /></td></tr>
<tr class="separator:ga198e1dbf7f5bae86fc8052374ba08e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada1fb90629198ff0ee920969d517335"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aada1fb90629198ff0ee920969d517335"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#aada1fb90629198ff0ee920969d517335">CalcContactFrictionFromSurfaceProperties</a> (const <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; T &gt; &amp;surface_properties1, const <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; T &gt; &amp;surface_properties2)</td></tr>
<tr class="memdesc:aada1fb90629198ff0ee920969d517335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the surface properties of two different surfaces, this method computes the Coulomb's law coefficients of friction characterizing the interaction by friction of the given surface pair.  <a href="#aada1fb90629198ff0ee920969d517335">More...</a><br /></td></tr>
<tr class="separator:aada1fb90629198ff0ee920969d517335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0833cf112bc08569736e6aca2251ebaf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0833cf112bc08569736e6aca2251ebaf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#a0833cf112bc08569736e6aca2251ebaf">operator==</a> (const <a class="el" href="structdrake_1_1multibody_1_1_hydroelastic_quadrature_point_data.html">HydroelasticQuadraturePointData</a>&lt; T &gt; &amp;data1, const <a class="el" href="structdrake_1_1multibody_1_1_hydroelastic_quadrature_point_data.html">HydroelasticQuadraturePointData</a>&lt; T &gt; &amp;data2)</td></tr>
<tr class="memdesc:a0833cf112bc08569736e6aca2251ebaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if all of the corresponding individual fields of <code>data1</code> and <code>data2</code> are equal (i.e., using their corresponding <code><a class="el" href="namespacedrake_1_1multibody.html#a0833cf112bc08569736e6aca2251ebaf" title="Returns true if all of the corresponding individual fields of data1 and data2 are equal (i....">operator==()</a></code> functions).  <a href="#a0833cf112bc08569736e6aca2251ebaf">More...</a><br /></td></tr>
<tr class="separator:a0833cf112bc08569736e6aca2251ebaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ac5ea10f28d336caaced34735b6dc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#ad1ac5ea10f28d336caaced34735b6dc9">world_index</a> ()</td></tr>
<tr class="memdesc:ad1ac5ea10f28d336caaced34735b6dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For every MultibodyTree the <b>world</b> body <em>always</em> has this unique index and it is always zero.  <a href="#ad1ac5ea10f28d336caaced34735b6dc9">More...</a><br /></td></tr>
<tr class="separator:ad1ac5ea10f28d336caaced34735b6dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777a2894881e59d27fc9eb7b4413406f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#a777a2894881e59d27fc9eb7b4413406f">world_model_instance</a> ()</td></tr>
<tr class="memdesc:a777a2894881e59d27fc9eb7b4413406f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the model instance containing the <em>world</em> body.  <a href="#a777a2894881e59d27fc9eb7b4413406f">More...</a><br /></td></tr>
<tr class="separator:a777a2894881e59d27fc9eb7b4413406f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786cd667a624e8cbd915cf50b02c8792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1multibody.html#a786cd667a624e8cbd915cf50b02c8792">default_model_instance</a> ()</td></tr>
<tr class="memdesc:a786cd667a624e8cbd915cf50b02c8792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the model instance which contains all tree elements with no explicit model instance specified.  <a href="#a786cd667a624e8cbd915cf50b02c8792">More...</a><br /></td></tr>
<tr class="separator:a786cd667a624e8cbd915cf50b02c8792"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="acbe033def48af7bf4857957f70f4d3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe033def48af7bf4857957f70f4d3e0">&#9670;&nbsp;</a></span>BodyIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> =  <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt;class BodyTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to identify bodies by index in a multibody tree system. </p>

</div>
</div>
<a id="add80e949328b179d78312d1455319868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add80e949328b179d78312d1455319868">&#9670;&nbsp;</a></span>ForceElementIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1multibody.html#add80e949328b179d78312d1455319868">ForceElementIndex</a> =  <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt;class ForceElementTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to identify force elements by index within a multibody tree system. </p>

</div>
</div>
<a id="a51c69848adb64ae45eebc1e5af5dbaa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c69848adb64ae45eebc1e5af5dbaa6">&#9670;&nbsp;</a></span>FrameIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a> =  <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt;class FrameTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to identify frames by index in a multibody tree system. </p>

</div>
</div>
<a id="acc810ff385ed4dede2e011b0b6fd3f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc810ff385ed4dede2e011b0b6fd3f2c">&#9670;&nbsp;</a></span>JointActuatorIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> =  <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt;class JointActuatorElementTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to identify actuators by index within a multibody tree system. </p>

</div>
</div>
<a id="a27485be8a33f5ed2ee7f3f8de9dd40c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27485be8a33f5ed2ee7f3f8de9dd40c0">&#9670;&nbsp;</a></span>JointIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> =  <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt;class JointElementTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to identify joints by index within a multibody tree system. </p>

</div>
</div>
<a id="a9b7dce3eb33772802af322ca25ef4864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7dce3eb33772802af322ca25ef4864">&#9670;&nbsp;</a></span>MinimumDistancePenaltyFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1multibody.html#a9b7dce3eb33772802af322ca25ef4864">MinimumDistancePenaltyFunction</a> =  <a class="el" href="namespacedrake_1_1solvers.html#adc2a57e87ae4e4088e12967a25a7c229">solvers::MinimumValuePenaltyFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the penalty function φ(x) and its derivatives dφ(x)/dx. </p>
<p>Valid penalty functions must meet the following criteria:</p>
<ol type="1">
<li>φ(x) ≥ 0 ∀ x ∈ ℝ.</li>
<li>dφ(x)/dx ≤ 0 ∀ x ∈ ℝ.</li>
<li>φ(x) = 0 ∀ x ≥ 0.</li>
<li>dφ(x)/dx &lt; 0 ∀ x &lt; 0. </li>
</ol>

</div>
</div>
<a id="af65439a17091283a89eb12f1955c6db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65439a17091283a89eb12f1955c6db0">&#9670;&nbsp;</a></span>ModelInstanceIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> =  <a class="el" href="classdrake_1_1_type_safe_index.html">TypeSafeIndex</a>&lt;class ModelInstanceTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used to identify model instances by index within a multibody tree system. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6f6e054758d34b83e86bea87d65dfe4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6e054758d34b83e86bea87d65dfe4e">&#9670;&nbsp;</a></span>ContactModel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4e">ContactModel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration for contact model options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6f6e054758d34b83e86bea87d65dfe4ea0f9136530df40294d8404d10cc150423"></a>kHydroelasticsOnly&#160;</td><td class="fielddoc"><p>Contact forces are computed using the Hydroelastic model. </p>
<p>Conctact between unsupported geometries will cause a runtime exception. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6f6e054758d34b83e86bea87d65dfe4ea24d742e384e4b818c113620a6aebe0e5"></a>kPointContactOnly&#160;</td><td class="fielddoc"><p>Contact forces are computed using a point contact model, see <a class="el" href="group__drake__contacts.html#point_contact_approximation">Numerical Approximation of Point Contact</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6f6e054758d34b83e86bea87d65dfe4ea8ad3adce463edb0d2843e1f1c0057d4a"></a>kHydroelasticWithFallback&#160;</td><td class="fielddoc"><p>Contact forces are computed using the hydroelastic model, where possible. </p>
<p>For most other unsupported colliding pairs, the point model from kPointContactOnly is used. See <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry.">geometry::QueryObject</a>:ComputeContactSurfacesWithFallback for more details. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad95b5f6a8d72582ad91a1aca26d76658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95b5f6a8d72582ad91a1aca26d76658">&#9670;&nbsp;</a></span>JacobianWrtVariable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration that indicates whether the Jacobian is partial differentiation with respect to q̇ (time-derivatives of generalized positions) or with respect to v (generalized velocities). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b"></a>kQDot&#160;</td><td class="fielddoc"><p>J = ∂V/∂q̇ </p>
</td></tr>
<tr><td class="fieldname"><a id="ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a"></a>kV&#160;</td><td class="fielddoc"><p>J = ∂V/∂v. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6144c2c8d4494bcb283f3f9e5841bfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6144c2c8d4494bcb283f3f9e5841bfd2">&#9670;&nbsp;</a></span>TamsiSolverResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1multibody.html#a6144c2c8d4494bcb283f3f9e5841bfd2">TamsiSolverResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The result from <a class="el" href="classdrake_1_1multibody_1_1_tamsi_solver.html#a032d564905879232190e6b62afd0b8d0" title="Given an initial guess v_guess, this method uses a Newton-Raphson iteration to find a solution for th...">TamsiSolver::SolveWithGuess()</a> used to report the success or failure of the solver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6144c2c8d4494bcb283f3f9e5841bfd2a8c632159fa131f09d04f94e3cbcd8782"></a>kSuccess&#160;</td><td class="fielddoc"><p>Successful computation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6144c2c8d4494bcb283f3f9e5841bfd2a1131fdd052242dd97fe2fe1d7a9a804a"></a>kMaxIterationsReached&#160;</td><td class="fielddoc"><p>The maximum number of iterations was reached. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6144c2c8d4494bcb283f3f9e5841bfd2a03dd71797c3ae46b778a3ab8591a9727"></a>kLinearSolverFailed&#160;</td><td class="fielddoc"><p>The linear solver used within the Newton-Raphson loop failed. </p>
<p>This might be caused by a divergent iteration that led to an invalid Jacobian matrix. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa1fd44e85ab30519ef7a904a4ebeb82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fd44e85ab30519ef7a904a4ebeb82d">&#9670;&nbsp;</a></span>AddSlidingFrictionComplementarityExplicitContactConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; internal::SlidingFrictionComplementarityNonlinearConstraint&gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1multibody_1_1_static_friction_cone_constraint.html">StaticFrictionConeConstraint</a>&gt; &gt; drake::multibody::AddSlidingFrictionComplementarityExplicitContactConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_contact_wrench_evaluator.html">ContactWrenchEvaluator</a> *&#160;</td>
          <td class="paramname"><em>contact_wrench_evaluator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>complementarity_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a pair of geometries in explicit contact, adds the sliding friction complementarity constraint explained in <a class="el" href="sliding__friction__complementarity__constraint_8h.html#sliding_friction_complementarity_constraint">sliding_friction_complementarity_constraint</a> to an optimization program. </p>
<p>This function adds the slack variables (f_static, f_sliding, c), and impose all the constraints in <a class="el" href="sliding__friction__complementarity__constraint_8h.html#sliding_friction_complementarity_constraint">sliding_friction_complementarity_constraint</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contact_wrench_evaluator</td><td>Evaluates the contact wrench between a pair of geometries. </td></tr>
    <tr><td class="paramname">complementarity_tolerance</td><td>The tolerance on the complementarity constraint. </td></tr>
    <tr><td class="paramname">q_vars</td><td>The variable for the generalized position q in <code>prog</code>. </td></tr>
    <tr><td class="paramname">v_vars</td><td>The variable for the generalized velocity v in <code>prog</code>. </td></tr>
    <tr><td class="paramname">lambda_vars</td><td>The variables to parameterize the contact wrench between this pair of geometry. </td></tr>
    <tr><td class="paramname">prog</td><td>The optimization program to which the sliding friction complementarity constraint is imposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(sliding_friction_complementarity_constraint, static_friction_cone_constraint), the pair of constraint that imposes (1)-(4) and (6) in <a class="el" href="sliding__friction__complementarity__constraint_8h.html#sliding_friction_complementarity_constraint">sliding_friction_complementarity_constraint</a>. </dd></dl>

</div>
</div>
<a id="ad168321c6009ddda8ee2ca9abbef90b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad168321c6009ddda8ee2ca9abbef90b1">&#9670;&nbsp;</a></span>AddSlidingFrictionComplementarityImplicitContactConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; internal::SlidingFrictionComplementarityNonlinearConstraint&gt;, <a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; internal::StaticFrictionConeComplementarityNonlinearConstraint&gt; &gt; drake::multibody::AddSlidingFrictionComplementarityImplicitContactConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_contact_wrench_evaluator.html">ContactWrenchEvaluator</a> *&#160;</td>
          <td class="paramname"><em>contact_wrench_evaluator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>complementarity_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a pair of geometries in implicit contact (they may or may not be in contact, adds the sliding friction complementarity constraint explained in <a class="el" href="sliding__friction__complementarity__constraint_8h.html#sliding_friction_complementarity_constraint">sliding_friction_complementarity_constraint</a>. </p>
<p>The input arguments are the same as those in <a class="el" href="namespacedrake_1_1multibody.html#aa1fd44e85ab30519ef7a904a4ebeb82d" title="For a pair of geometries in explicit contact, adds the sliding friction complementarity constraint ex...">AddSlidingFrictionComplementarityExplicitContactConstraint()</a>. The difference is that the returned argument includes the nonlinear complementarity binding 0 ≤ φ(q) ⊥ fₙ≥ 0, which imposes the constraint for implicit contact. </p>

</div>
</div>
<a id="a4508ec670196c3fe45e9b52af8a73d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4508ec670196c3fe45e9b52af8a73d4a">&#9670;&nbsp;</a></span>AddStaticFrictionConeComplementarityConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;internal::StaticFrictionConeComplementarityNonlinearConstraint&gt; drake::multibody::AddStaticFrictionConeComplementarityConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_contact_wrench_evaluator.html">ContactWrenchEvaluator</a> *&#160;</td>
          <td class="paramname"><em>contact_wrench_evaluator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>complementarity_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>q_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the complementarity constraint on the static friction force between a pair of contacts |ft_W| &lt;= μ * n_Wᵀ * f_W (static friction force in the friction cone). </p>
<p>fn_W * sdf = 0 (complementarity condition) sdf &gt;= 0 (no penetration) where sdf stands for signed distance function, ft_W stands for the tangential friction force expressed in the world frame.</p>
<p>Mathematically, we add the following constraints to the optimization program </p><pre class="fragment">f_Wᵀ * ((μ² + 1)* n_W * n_Wᵀ - I) * f_W ≥ 0                    (1)
n_Wᵀ * f_W = α                                                 (2)
sdf(q) = β                                                     (3)
0 ≤ α * β ≤ ε                                                  (4)
α ≥ 0                                                          (5)
β ≥ 0                                                          (6)
</pre><p> the slack variables α and β are added to the optimization program as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">contact_wrench_evaluator</td><td>The evaluator to compute the contact wrench expressed in the world frame. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">complementarity_tolerance</td><td>ε in the documentation above. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">q_vars</td><td>The decision variable for the generalized configuration q. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lambda_vars</td><td>The decision variable to parameterize the contact wrench. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">prog</td><td>The optimization program to which the constraint is added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>binding The binding containing the nonlinear constraints (1)-(4). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Both <code>q_vars</code> and <code>lambda_vars</code> have been added to <code>prog</code> before calling this function. </dd></dl>

</div>
</div>
<a id="aada1fb90629198ff0ee920969d517335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada1fb90629198ff0ee920969d517335">&#9670;&nbsp;</a></span>CalcContactFrictionFromSurfaceProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt;T&gt; drake::multibody::CalcContactFrictionFromSurfaceProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>surface_properties1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>surface_properties2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the surface properties of two different surfaces, this method computes the Coulomb's law coefficients of friction characterizing the interaction by friction of the given surface pair. </p>
<p>The surface properties are specified by individual Coulomb's law coefficients of friction. As outlined in the class's documentation for <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html" title="Parameters for Coulomb&#39;s Law of Friction, namely:">CoulombFriction</a>, friction coefficients characterize a surface pair and not individual surfaces. However, we find it useful in practice to associate the abstract <b>idea</b> of friction coefficients to a single surface. Please refer to the documentation for <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html" title="Parameters for Coulomb&#39;s Law of Friction, namely:">CoulombFriction</a> for details on this topic.</p>
<p>More specifically, this method computes the contact coefficients for the given surface pair as: </p><pre>
  μ = 2μₘμₙ/(μₘ + μₙ)
</pre><p> where the operation above is performed separately on the static and dynamic friction coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">surface_properties1</td><td>Surface properties for surface 1. Specified as an individual set of Coulomb's law coefficients of friction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface_properties2</td><td>Surface properties for surface 2. Specified as an individual set of Coulomb's law coefficients of friction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combined friction coefficients for the interacting surfaces. </dd></dl>

</div>
</div>
<a id="a57577cfb87838e5b949fd703e227acfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57577cfb87838e5b949fd703e227acfc">&#9670;&nbsp;</a></span>CalcDistanceAndTimeDerivative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1multibody_1_1_signed_distance_with_time_derivative.html">SignedDistanceWithTimeDerivative</a> drake::multibody::CalcDistanceAndTimeDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">multibody::MultibodyPlant</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>plant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>geometry_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a pair of geometries and the generalized position/velocity of the plant, compute the signed distance between the pair of geometries and the time derivative of the signed distance. </p>
<p>This function is similar to QueryObject::ComputeSignedDistancePairClosestPoints(), but it also provides the time derivative of the signed distance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">plant</td><td>The plant on which the geometries are attached. This plant must have been connected to a SceneGraph. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">geometry_pair</td><td>The pair of geometries whose distance and time derivative are computed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>The context of the plant. This must store both q and v. This context must have been extracted from the diagram context which contains both <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> and SceneGraph contexts. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distance</td><td>The signed distance between the pair of geometry. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distance_time_derivative</td><td>The time derivative of the signed distance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a786cd667a624e8cbd915cf50b02c8792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786cd667a624e8cbd915cf50b02c8792">&#9670;&nbsp;</a></span>default_model_instance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> drake::multibody::default_model_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the model instance which contains all tree elements with no explicit model instance specified. </p>

</div>
</div>
<a id="a0833cf112bc08569736e6aca2251ebaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0833cf112bc08569736e6aca2251ebaf">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::multibody::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1_hydroelastic_quadrature_point_data.html">HydroelasticQuadraturePointData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1multibody_1_1_hydroelastic_quadrature_point_data.html">HydroelasticQuadraturePointData</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if all of the corresponding individual fields of <code>data1</code> and <code>data2</code> are equal (i.e., using their corresponding <code><a class="el" href="namespacedrake_1_1multibody.html#a0833cf112bc08569736e6aca2251ebaf" title="Returns true if all of the corresponding individual fields of data1 and data2 are equal (i....">operator==()</a></code> functions). </p>

</div>
</div>
<a id="ad1ac5ea10f28d336caaced34735b6dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ac5ea10f28d336caaced34735b6dc9">&#9670;&nbsp;</a></span>world_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> drake::multibody::world_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For every MultibodyTree the <b>world</b> body <em>always</em> has this unique index and it is always zero. </p>

</div>
</div>
<a id="a777a2894881e59d27fc9eb7b4413406f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777a2894881e59d27fc9eb7b4413406f">&#9670;&nbsp;</a></span>world_model_instance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> drake::multibody::world_model_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the model instance containing the <em>world</em> body. </p>
<p>For every MultibodyTree the <b>world</b> body <em>always</em> has this unique model instance and it is always zero (as described in #3088). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
