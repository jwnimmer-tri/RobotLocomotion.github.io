<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: InverseKinematics Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_inverse_kinematics.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdrake_1_1multibody_1_1_inverse_kinematics-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">InverseKinematics Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Solves an inverse kinematics (IK) problem on a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>, to find the postures of the robot satisfying certain constraints. </p>
<p>The decision variables include the generalized position of the robot. </p>
</div>
<p><code>#include &lt;drake/multibody/inverse_kinematics/inverse_kinematics.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a17e545f30ae2d1bf7fd15e14f6198fa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#a17e545f30ae2d1bf7fd15e14f6198fa9">~InverseKinematics</a> ()</td></tr>
<tr class="separator:a17e545f30ae2d1bf7fd15e14f6198fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491bed91ae956de434888dd68594b7a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#a491bed91ae956de434888dd68594b7a3">InverseKinematics</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; double &gt; &amp;plant, bool with_joint_limits=true)</td></tr>
<tr class="memdesc:a491bed91ae956de434888dd68594b7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an inverse kinematics problem for a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>.  <a href="#a491bed91ae956de434888dd68594b7a3">More...</a><br /></td></tr>
<tr class="separator:a491bed91ae956de434888dd68594b7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a352889e2c30877b432e49e8d191efd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#a8a352889e2c30877b432e49e8d191efd">InverseKinematics</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; double &gt; &amp;plant, <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; *plant_context, bool with_joint_limits=true)</td></tr>
<tr class="memdesc:a8a352889e2c30877b432e49e8d191efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an inverse kinematics problem for a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>.  <a href="#a8a352889e2c30877b432e49e8d191efd">More...</a><br /></td></tr>
<tr class="separator:a8a352889e2c30877b432e49e8d191efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c669013ee2890d3a8c457668541cdba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#a7c669013ee2890d3a8c457668541cdba">AddPositionConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;frameB, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_BQ, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;frameA, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_AQ_lower, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_AQ_upper)</td></tr>
<tr class="memdesc:a7c669013ee2890d3a8c457668541cdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the kinematic constraint that a point Q, fixed in frame B, should lie within a bounding box expressed in another frame A as p_AQ_lower &lt;= p_AQ &lt;= p_AQ_upper, where p_AQ is the position of point Q measured and expressed in frame A.  <a href="#a7c669013ee2890d3a8c457668541cdba">More...</a><br /></td></tr>
<tr class="separator:a7c669013ee2890d3a8c457668541cdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693b3a9627e08ae92d2978b4ca516b3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#a693b3a9627e08ae92d2978b4ca516b3c">AddOrientationConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;frameAbar, const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; double &gt; &amp;R_AbarA, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;frameBbar, const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; double &gt; &amp;R_BbarB, double theta_bound)</td></tr>
<tr class="memdesc:a693b3a9627e08ae92d2978b4ca516b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains that the angle difference θ between the orientation of frame A and the orientation of frame B to satisfy θ ≤ θ_bound.  <a href="#a693b3a9627e08ae92d2978b4ca516b3c">More...</a><br /></td></tr>
<tr class="separator:a693b3a9627e08ae92d2978b4ca516b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb60b773199c651ab8c8802501d4391"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#a0bb60b773199c651ab8c8802501d4391">AddGazeTargetConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;frameA, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_AS, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;n_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;frameB, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_BT, double cone_half_angle)</td></tr>
<tr class="memdesc:a0bb60b773199c651ab8c8802501d4391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains a target point T to be within a cone K.  <a href="#a0bb60b773199c651ab8c8802501d4391">More...</a><br /></td></tr>
<tr class="separator:a0bb60b773199c651ab8c8802501d4391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2be002de90894ce104c602cf7273da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#ada2be002de90894ce104c602cf7273da">AddAngleBetweenVectorsConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;frameA, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;na_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;frameB, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;nb_B, double angle_lower, double angle_upper)</td></tr>
<tr class="memdesc:ada2be002de90894ce104c602cf7273da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains that the angle between a vector na and another vector nb is between [θ_lower, θ_upper].  <a href="#ada2be002de90894ce104c602cf7273da">More...</a><br /></td></tr>
<tr class="separator:ada2be002de90894ce104c602cf7273da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7e39fc0e8059b4894a60982bec5ee6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#a7d7e39fc0e8059b4894a60982bec5ee6">AddMinimumDistanceConstraint</a> (double minimum_distance, double influence_distance_offset=1)</td></tr>
<tr class="memdesc:a7d7e39fc0e8059b4894a60982bec5ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint that the pairwise distance between objects should be no smaller than <code>minimum_distance</code>.  <a href="#a7d7e39fc0e8059b4894a60982bec5ee6">More...</a><br /></td></tr>
<tr class="separator:a7d7e39fc0e8059b4894a60982bec5ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d998f612ea10349d08164d55d20ed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#ae5d998f612ea10349d08164d55d20ed8">AddDistanceConstraint</a> (const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> &gt; &amp;geometry_pair, double distance_lower, double distance_upper)</td></tr>
<tr class="memdesc:ae5d998f612ea10349d08164d55d20ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the constraint that the distance between a pair of geometries is within some bounds.  <a href="#ae5d998f612ea10349d08164d55d20ed8">More...</a><br /></td></tr>
<tr class="separator:ae5d998f612ea10349d08164d55d20ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52548b9b4f07c155cb5ecf46d1088ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#ae52548b9b4f07c155cb5ecf46d1088ae">AddPointToPointDistanceConstraint</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;frame1, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_B1P1, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;frame2, const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;p_B2P2, double distance_lower, double distance_upper)</td></tr>
<tr class="memdesc:ae52548b9b4f07c155cb5ecf46d1088ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constraint that the distance between point P1 attached to frame 1 and point P2 attached to frame 2 is within the range [distance_lower, distance_upper].  <a href="#ae52548b9b4f07c155cb5ecf46d1088ae">More...</a><br /></td></tr>
<tr class="separator:ae52548b9b4f07c155cb5ecf46d1088ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d4dcb28c6cfb63f69b03e0d3e98571"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#af0d4dcb28c6cfb63f69b03e0d3e98571">q</a> () const</td></tr>
<tr class="memdesc:af0d4dcb28c6cfb63f69b03e0d3e98571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for q.  <a href="#af0d4dcb28c6cfb63f69b03e0d3e98571">More...</a><br /></td></tr>
<tr class="separator:af0d4dcb28c6cfb63f69b03e0d3e98571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc8c6b2091ff4447ee2951bb7907de8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#afcc8c6b2091ff4447ee2951bb7907de8">prog</a> () const</td></tr>
<tr class="memdesc:afcc8c6b2091ff4447ee2951bb7907de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the optimization program constructed by <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html" title="Solves an inverse kinematics (IK) problem on a MultibodyPlant, to find the postures of the robot sati...">InverseKinematics</a>.  <a href="#afcc8c6b2091ff4447ee2951bb7907de8">More...</a><br /></td></tr>
<tr class="separator:afcc8c6b2091ff4447ee2951bb7907de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727804209642a450777a561df6d98d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#a727804209642a450777a561df6d98d9b">get_mutable_prog</a> () const</td></tr>
<tr class="memdesc:a727804209642a450777a561df6d98d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the optimization program constructed by <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html" title="Solves an inverse kinematics (IK) problem on a MultibodyPlant, to find the postures of the robot sati...">InverseKinematics</a>.  <a href="#a727804209642a450777a561df6d98d9b">More...</a><br /></td></tr>
<tr class="separator:a727804209642a450777a561df6d98d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a9785ab329b6bc3294b6720a29a167"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#a45a9785ab329b6bc3294b6720a29a167">context</a> () const</td></tr>
<tr class="memdesc:a45a9785ab329b6bc3294b6720a29a167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the plant context.  <a href="#a45a9785ab329b6bc3294b6720a29a167">More...</a><br /></td></tr>
<tr class="separator:a45a9785ab329b6bc3294b6720a29a167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598885fb0868bd7d67fde74776cc2b9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#a598885fb0868bd7d67fde74776cc2b9e">get_mutable_context</a> ()</td></tr>
<tr class="memdesc:a598885fb0868bd7d67fde74776cc2b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the mutable plant context.  <a href="#a598885fb0868bd7d67fde74776cc2b9e">More...</a><br /></td></tr>
<tr class="separator:a598885fb0868bd7d67fde74776cc2b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a67f334d691594767c3ac1f81e96a7b0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#a67f334d691594767c3ac1f81e96a7b0f">InverseKinematics</a> (const <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;)=delete</td></tr>
<tr class="separator:a67f334d691594767c3ac1f81e96a7b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb09a7496a0b0ed1c358fb31a21ab4c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#acb09a7496a0b0ed1c358fb31a21ab4c1">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;)=delete</td></tr>
<tr class="separator:acb09a7496a0b0ed1c358fb31a21ab4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfec066e251fc2acc3980f272c934aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#a7bfec066e251fc2acc3980f272c934aa">InverseKinematics</a> (<a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a7bfec066e251fc2acc3980f272c934aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069b08fb67eeeb99c807dfc823ea3154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html#a069b08fb67eeeb99c807dfc823ea3154">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a069b08fb67eeeb99c807dfc823ea3154"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a67f334d691594767c3ac1f81e96a7b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f334d691594767c3ac1f81e96a7b0f">&#9670;&nbsp;</a></span>InverseKinematics() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bfec066e251fc2acc3980f272c934aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfec066e251fc2acc3980f272c934aa">&#9670;&nbsp;</a></span>InverseKinematics() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17e545f30ae2d1bf7fd15e14f6198fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e545f30ae2d1bf7fd15e14f6198fa9">&#9670;&nbsp;</a></span>~InverseKinematics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a491bed91ae956de434888dd68594b7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491bed91ae956de434888dd68594b7a3">&#9670;&nbsp;</a></span>InverseKinematics() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>plant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_joint_limits</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an inverse kinematics problem for a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </p>
<p>This constructor will create and own a context for</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plant.</td><td></td></tr>
    <tr><td class="paramname">plant</td><td>The robot on which the inverse kinematics problem will be solved. </td></tr>
    <tr><td class="paramname">with_joint_limits</td><td>If set to true, then the constructor imposes the joint limit (obtained from plant.GetPositionLowerLimits() and plant.GetPositionUpperLimits(). If set to false, then the constructor does not impose the joint limit constraints in the constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The inverse kinematics problem constructed in this way doesn't permit collision related constraint (such as calling AddMinimumDistanceConstraint). To enable collision related constraint, call <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html" title="Solves an inverse kinematics (IK) problem on a MultibodyPlant, to find the postures of the robot sati...">InverseKinematics</a>(const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant&lt;double&gt;</a>&amp; plant, systems::Context&lt;double&gt;* plant_context); </dd></dl>

</div>
</div>
<a id="a8a352889e2c30877b432e49e8d191efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a352889e2c30877b432e49e8d191efd">&#9670;&nbsp;</a></span>InverseKinematics() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>plant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>plant_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>with_joint_limits</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an inverse kinematics problem for a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </p>
<p>If the user wants to solve the problem with collision related constraint (like calling AddMinimumDistanceConstraint), please use this constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plant</td><td>The robot on which the inverse kinematics problem will be solved. This plant should have been connected to a SceneGraph within a Diagram </td></tr>
    <tr><td class="paramname">context</td><td>The context for the plant. This context should be a part of the Diagram context. To construct a plant connected to a SceneGraph, with the corresponding plant_context, the steps are // 1. Add a diagram containing the <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> and SceneGraph systems::DiagramBuilder&lt;double&gt; builder; auto items = AddMultibodyPlantSceneGraph(&amp;builder, 0.0); // 2. Add collision geometries to the plant <a class="el" href="classdrake_1_1multibody_1_1_parser.html" title="Parses SDF and URDF input files into a MultibodyPlant and (optionally) a SceneGraph.">Parser</a>(&amp;(items.plant)).AddModelFromFile("model.sdf"); // 3. Construct the diagram auto diagram = builder.Build(); // 4. Create diagram context. auto diagram_context= diagram-&gt;CreateDefaultContext(); // 5. Get the context for the plant. auto plant_context = &amp;(diagram-&gt;GetMutableSubsystemContext(items.plant, diagram_context.get())); This context will be modified during calling ik.prog.Solve(...). When <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> returns <code>result</code>, context will store the optimized posture, namely plant.GetPositions(*context) will be the same as in result.GetSolution(ik.q()). The user could then use this context to perform kinematic computation (like computing the position of the end-effector etc.). </td></tr>
    <tr><td class="paramname">with_joint_limits</td><td>If set to true, then the constructor imposes the joint limit (obtained from plant.GetPositionLowerLimits() and plant.GetPositionUpperLimits(). If set to false, then the constructor does not impose the joint limit constraints in the constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ada2be002de90894ce104c602cf7273da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2be002de90894ce104c602cf7273da">&#9670;&nbsp;</a></span>AddAngleBetweenVectorsConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a>&gt; AddAngleBetweenVectorsConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>frameA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>na_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>frameB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>nb_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrains that the angle between a vector na and another vector nb is between [θ_lower, θ_upper]. </p>
<p>na is fixed to a frame A, while nb is fixed to a frame B. Mathematically, if we denote na_unit_A as na expressed in frame A after normalization (na_unit_A has unit length), and nb_unit_B as nb expressed in frame B after normalization, the constraint is cos(θ_upper) ≤ na_unit_Aᵀ * R_AB * nb_unit_B ≤ cos(θ_lower), where R_AB is the rotation matrix, representing the orientation of frame B expressed in frame A. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameA</td><td>The frame to which na is fixed. </td></tr>
    <tr><td class="paramname">na_A</td><td>The vector na fixed to frame A, expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>na_A should be a non-zero vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if na_A is close to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameB</td><td>The frame to which nb is fixed. </td></tr>
    <tr><td class="paramname">nb_B</td><td>The vector nb fixed to frame B, expressed in frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>nb_B should be a non-zero vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if nb_B is close to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle_lower</td><td>The lower bound on the angle between na and nb. It is denoted as θ_lower in the documentation. <code>angle_lower</code> is in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>angle_lower &gt;= 0. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if angle_lower is negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle_upper</td><td>The upper bound on the angle between na and nb. it is denoted as θ_upper in the class documentation. <code>angle_upper</code> is in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>angle_lower &lt;= angle_upper &lt;= pi. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if angle_upper is outside the bounds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5d998f612ea10349d08164d55d20ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d998f612ea10349d08164d55d20ed8">&#9670;&nbsp;</a></span>AddDistanceConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a>&gt; AddDistanceConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>geometry_pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance_lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance_upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the constraint that the distance between a pair of geometries is within some bounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geometry_pair</td><td>The pair of geometries between which the distance is constrained. Notice that we only consider the distance between a static geometry and a dynamic geometry, or a pair of dynamic geometries. We don't allow constraining the distance between two static geometries. </td></tr>
    <tr><td class="paramname">distance_lower</td><td>The lower bound on the distance. </td></tr>
    <tr><td class="paramname">distance_upper</td><td>The upper bound on the distance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bb60b773199c651ab8c8802501d4391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb60b773199c651ab8c8802501d4391">&#9670;&nbsp;</a></span>AddGazeTargetConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a>&gt; AddGazeTargetConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>frameA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_AS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>frameB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cone_half_angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrains a target point T to be within a cone K. </p>
<p>The point T ("T" stands for "target") is fixed in a frame B, with position p_BT. The cone originates from a point S ("S" stands for "source"), fixed in frame A with position p_AS, with the axis of the cone being n, also fixed in frame A. The half angle of the cone is θ. A common usage of this constraint is that a camera should gaze at some target; namely the target falls within a gaze cone, originating from the camera eye. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameA</td><td>The frame where the gaze cone is fixed to. </td></tr>
    <tr><td class="paramname">p_AS</td><td>The position of the cone source point S, measured and expressed in frame A. </td></tr>
    <tr><td class="paramname">n_A</td><td>The directional vector representing the center ray of the cone, expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>n_A</code> cannot be a zero vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>is n_A is close to a zero vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameB</td><td>The frame where the target point T is fixed to. </td></tr>
    <tr><td class="paramname">p_BT</td><td>The position of the target point T, measured and expressed in frame B. </td></tr>
    <tr><td class="paramname">cone_half_angle</td><td>The half angle of the cone. We denote it as θ in the documentation. <code>cone_half_angle</code> is in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>0</code> &lt;= cone_half_angle &lt;= pi. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if cone_half_angle is outside of the bound. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d7e39fc0e8059b4894a60982bec5ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d7e39fc0e8059b4894a60982bec5ee6">&#9670;&nbsp;</a></span>AddMinimumDistanceConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a>&gt; AddMinimumDistanceConstraint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minimum_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>influence_distance_offset</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the constraint that the pairwise distance between objects should be no smaller than <code>minimum_distance</code>. </p>
<p>We consider the distance between pairs of</p><ol type="1">
<li>Anchored (static) object and a dynamic object.</li>
<li>A dynamic object and another dynamic object, if one is not the parent link of the other. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minimum_distance</td><td>The minimum allowed value, dₘᵢₙ, of the signed distance between any candidate pair of geometries. </td></tr>
    <tr><td class="paramname">influence_distance_offset</td><td>The difference (in meters) between the influence distance, d_influence, and the minimum distance, dₘᵢₙ. This value must be finite and strictly positive, as it is used to scale the signed distances between pairs of geometries. Smaller values may improve performance, as fewer pairs of geometries need to be considered in each constraint evaluation. <br />
 <em>Default:</em> 1 meter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_minimum_distance_constraint.html" title="Constrain the signed distance between all candidate pairs of geometries (according to the logic of Sc...">MinimumDistanceConstraint</a> for more details on the constraint formulation. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> passed to the constructor of <code>this</code> has registered its geometry with a SceneGraph. </dd>
<dd>
0 &lt; <code>influence_distance_offset</code> &lt; ∞ </dd></dl>
</li>
</ol>

</div>
</div>
<a id="a693b3a9627e08ae92d2978b4ca516b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693b3a9627e08ae92d2978b4ca516b3c">&#9670;&nbsp;</a></span>AddOrientationConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a>&gt; AddOrientationConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>frameAbar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_AbarA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>frameBbar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_BbarB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrains that the angle difference θ between the orientation of frame A and the orientation of frame B to satisfy θ ≤ θ_bound. </p>
<p><a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame),...">Frame</a> A is fixed to frame A_bar, with orientation R_AbarA measured in frame A_bar. <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame),...">Frame</a> B is fixed to frame B_bar, with orientation R_BbarB measured in frame B_bar. The angle difference between frame A's orientation R_WA and B's orientation R_WB is θ, (θ ∈ [0, π]), if there exists a rotation axis a, such that rotating frame A by angle θ about axis a aligns it with frame B. Namely R_AB = I + sinθ â + (1-cosθ)â² (1) where R_AB is the orientation of frame B expressed in frame A. â is the skew symmetric matrix of the rotation axis a. Equation (1) is the Rodrigues formula that computes the rotation matrix from a rotation axis a and an angle θ, <a href="https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula">https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula</a> If the users want frame A and frame B to align perfectly, they can set θ_bound = 0. Mathematically, this constraint is imposed as trace(R_AB) ≥ 2cos(θ_bound) + 1 (1) To derive (1), using Rodrigues formula R_AB = I + sinθ â + (1-cosθ)â² where trace(R_AB) = 2cos(θ) + 1 ≥ 2cos(θ_bound) + 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameAbar</td><td>frame A_bar, the frame A is fixed to frame A_bar. </td></tr>
    <tr><td class="paramname">R_AbarA</td><td>The orientation of frame A measured in frame A_bar. </td></tr>
    <tr><td class="paramname">frameBbar</td><td>frame B_bar, the frame B is fixed to frame B_bar. </td></tr>
    <tr><td class="paramname">R_BbarB</td><td>The orientation of frame B measured in frame B_bar. </td></tr>
    <tr><td class="paramname">theta_bound</td><td>The bound on the angle difference between frame A's orientation and frame B's orientation. It is denoted as θ_bound in the documentation. <code>theta_bound</code> is in radians. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae52548b9b4f07c155cb5ecf46d1088ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52548b9b4f07c155cb5ecf46d1088ae">&#9670;&nbsp;</a></span>AddPointToPointDistanceConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a>&gt; AddPointToPointDistanceConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_B1P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_B2P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance_lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance_upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a constraint that the distance between point P1 attached to frame 1 and point P2 attached to frame 2 is within the range [distance_lower, distance_upper]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame1</td><td>The frame to which P1 is attached. </td></tr>
    <tr><td class="paramname">p_B1P1</td><td>The position of P1 measured and expressed in frame 1. </td></tr>
    <tr><td class="paramname">frame2</td><td>The frame to which P2 is attached. </td></tr>
    <tr><td class="paramname">p_B2P2</td><td>The position of P2 measured and expressed in frame 2. </td></tr>
    <tr><td class="paramname">distance_lower</td><td>The lower bound on the distance. </td></tr>
    <tr><td class="paramname">distance_upper</td><td>The upper bound on the distance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c669013ee2890d3a8c457668541cdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c669013ee2890d3a8c457668541cdba">&#9670;&nbsp;</a></span>AddPositionConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">solvers::Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_constraint.html">solvers::Constraint</a>&gt; AddPositionConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>frameB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>frameA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_AQ_lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_AQ_upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the kinematic constraint that a point Q, fixed in frame B, should lie within a bounding box expressed in another frame A as p_AQ_lower &lt;= p_AQ &lt;= p_AQ_upper, where p_AQ is the position of point Q measured and expressed in frame A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameB</td><td>The frame in which point Q is fixed. </td></tr>
    <tr><td class="paramname">p_BQ</td><td>The position of the point Q, rigidly attached to frame B, measured and expressed in frame B. </td></tr>
    <tr><td class="paramname">frameA</td><td>The frame in which the bounding box p_AQ_lower &lt;= p_AQ &lt;= p_AQ_upper is expressed. </td></tr>
    <tr><td class="paramname">p_AQ_lower</td><td>The lower bound on the position of point Q, measured and expressed in frame A. </td></tr>
    <tr><td class="paramname">p_AQ_upper</td><td>The upper bound on the position of point Q, measured and expressed in frame A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45a9785ab329b6bc3294b6720a29a167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a9785ab329b6bc3294b6720a29a167">&#9670;&nbsp;</a></span>context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt;double&gt;&amp; context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the plant context. </p>

</div>
</div>
<a id="a598885fb0868bd7d67fde74776cc2b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598885fb0868bd7d67fde74776cc2b9e">&#9670;&nbsp;</a></span>get_mutable_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt;double&gt;* get_mutable_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the mutable plant context. </p>

</div>
</div>
<a id="a727804209642a450777a561df6d98d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727804209642a450777a561df6d98d9b">&#9670;&nbsp;</a></span>get_mutable_prog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a>* get_mutable_prog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the optimization program constructed by <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html" title="Solves an inverse kinematics (IK) problem on a MultibodyPlant, to find the postures of the robot sati...">InverseKinematics</a>. </p>

</div>
</div>
<a id="a069b08fb67eeeb99c807dfc823ea3154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069b08fb67eeeb99c807dfc823ea3154">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb09a7496a0b0ed1c358fb31a21ab4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb09a7496a0b0ed1c358fb31a21ab4c1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afcc8c6b2091ff4447ee2951bb7907de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc8c6b2091ff4447ee2951bb7907de8">&#9670;&nbsp;</a></span>prog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">solvers::MathematicalProgram</a>&amp; prog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the optimization program constructed by <a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html" title="Solves an inverse kinematics (IK) problem on a MultibodyPlant, to find the postures of the robot sati...">InverseKinematics</a>. </p>

</div>
</div>
<a id="af0d4dcb28c6cfb63f69b03e0d3e98571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d4dcb28c6cfb63f69b03e0d3e98571">&#9670;&nbsp;</a></span>q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">solvers::VectorXDecisionVariable</a>&amp; q </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for q. </p>
<p>q is the decision variable for the generalized positions of the robot. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/inverse_kinematics/<a class="el" href="inverse__kinematics_8h.html">inverse_kinematics.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_inverse_kinematics.html">InverseKinematics</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
