<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Simulator&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1systems_1_1_simulator.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdrake_1_1systems_1_1_simulator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Simulator&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a> &raquo; <a class="el" href="group__simulation.html">Simulation</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::systems::Simulator&lt; T &gt;</h3>

<p>A class for advancing the state of hybrid dynamic systems, represented by <code><a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>&lt;T&gt;</code> objects, forward in time. </p>
<p>Starting with an initial <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> for a given <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>, Simulator advances time and produces a series of <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> values that forms a trajectory satisfying the system's dynamic equations to a specified accuracy. Only the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> is modified by a Simulator; the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> is const.</p>
<p>A Drake <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> is a continuous/discrete/hybrid dynamic system where the continuous part is a DAE, that is, it is expected to consist of a set of differential equations and bilateral algebraic constraints. The set of active constraints may change as a result of particular events, such as contact.</p>
<p>Given a current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, we expect a <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> to provide us with</p><ul>
<li>derivatives for the continuous differential equations that already satisfy the differentiated form of the constraints (typically, acceleration constraints),</li>
<li>a projection method for least-squares correction of violated higher-level constraints (position and velocity level),</li>
<li>a time-of-next-update method that can be used to adjust the integrator step size in preparation for a discrete update,</li>
<li>methods that can update discrete variables when their update time is reached,</li>
<li>witness (guard) functions for event isolation,</li>
<li>event handlers (reset functions) for making appropriate changes to state and mode variables when an event has been isolated.</li>
</ul>
<p>The continuous parts of the trajectory are advanced using a numerical integrator. Different integrators have different properties; you can choose the one that is most appropriate for your application or use the default which is adequate for most systems.</p>
<h3>How the simulation is stepped: simulation mechanics for authors of discrete and hybrid systems</h3>
<p>This section is targeted toward users who have created a <a class="el" href="classdrake_1_1systems_1_1_leaf_system.html" title="A superclass template that extends System with some convenience utilities that are not applicable to ...">LeafSystem</a> implementing a discrete or hybrid system. For authors of such systems, it can be useful to understand the simulation details in order to attain the desired state behavior over time. This behavior is dependent on the ordering in which discrete events and continuous updates are processed. (By "discrete events" we mean to include any of Drake's event handlers.) The basic issues and terminology are introduced in the <a class="el" href="group__discrete__systems.html">Discrete Systems</a> module; please look there first before proceeding.</p>
<p>As pictured in <a class="el" href="group__discrete__systems.html">Discrete Systems</a>, when a continuous-time system has discrete events, the state x can have two significant values at the event time t. These are</p><ul>
<li>x⁻(t), the value of x <em>before</em> the discrete update occurs (○ markers), and</li>
<li>x⁺(t), the value of x <em>after</em> the discrete update occurs (● markers).</li>
</ul>
<p>Thus the value of the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, which contains both time and state, advances from {t, x⁻(t)} to {t, x⁺(t)} as a result of the update. While those <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> values are user-visible, the details of stepping here require an intermediate value which we'll denote {t, x*(t)}.</p>
<p>Recall that Drake's state x is partitioned into continuous, discrete, and abstract partitions xc, xd, and xa, so <code>x = { xc, xd, xa }</code>. Within a single step, these are updated in three stages:</p><ol type="1">
<li>Unrestricted update (can change x)</li>
<li>Discrete update (can change only xd)</li>
<li>Continuous update (changes t and xc)</li>
</ol>
<p>Where needed, we extend the above notation to xc⁻, xa⁺, etc. to indicate the value of an individual partition at a particular stage of the stepping algorithm.</p>
<p>The following pseudocode uses the above notation to describe the algorithm "Step()" that the Simulator uses to incrementally advance the system trajectory (time t and state x). The <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a>'s <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a> method will be defined in terms of Step below. In general, the length of a step is not known a priori and is determined by the Step() algorithm. Each step consists of zero or more unrestricted updates, followed by zero or more discrete updates, followed by (possibly zero-length) continuous time and state advancement, followed by zero or more publishes, and then a call to the monitor() function if one has been defined. Updates, publishes, and the monitor can report errors or detect a termination condition; that is not shown in the pseudocode below.</p>
<p>The pseudocode will clarify the effects on time and state of each of the update stages above. This algorithm is given a starting <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> value <code>{tₛ, x⁻(tₛ)}</code> and returns an end <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> value <code>{tₑ, x⁻(tₑ)}</code>, where tₑ is <em>no later</em> than a given tₘₐₓ. </p><div class="fragment"><div class="line"><span class="comment">// Advance the trajectory (time and state) from start value {tₛ, x⁻(tₛ)} to an</span></div><div class="line"><span class="comment">// end value {tₑ, x⁻(tₑ)}, where tₛ ≤ tₑ ≤ tₘₐₓ.</span></div><div class="line">procedure Step(tₛ, x⁻(tₛ), tₘₐₓ)</div><div class="line"></div><div class="line">  <span class="comment">// Update any variables (no restrictions).</span></div><div class="line">  x*(tₛ) ← DoAnyUnrestrictedUpdates(tₛ, x⁻(tₛ))</div><div class="line"></div><div class="line">  <span class="comment">// ----------------------------------</span></div><div class="line">  <span class="comment">// Time and state are at {tₛ, x*(tₛ)}</span></div><div class="line">  <span class="comment">// ----------------------------------</span></div><div class="line"></div><div class="line">  <span class="comment">// Update discrete variables.</span></div><div class="line">  xd⁺(tₛ) ← DoAnyDiscreteUpdates(tₛ, x*(tₛ))</div><div class="line"></div><div class="line">  xc⁺(tₛ) ← xc*(tₛ)  <span class="comment">// These values carry over from x*(tₛ).</span></div><div class="line">  xa⁺(tₛ) ← xa*(tₛ)</div><div class="line"></div><div class="line">  <span class="comment">// ----------------------------------</span></div><div class="line">  <span class="comment">// Time and state are at {tₛ, x⁺(tₛ)}</span></div><div class="line">  <span class="comment">// ----------------------------------</span></div><div class="line"></div><div class="line">  <span class="comment">// See how far it is safe to integrate without missing any events.</span></div><div class="line">  tₑᵥₑₙₜ ← CalcNextEventTime(tₛ, x⁺(tₛ))</div><div class="line"></div><div class="line">  <span class="comment">// Integrate continuous variables forward in time. Integration may terminate</span></div><div class="line">  <span class="comment">// before reaching tₛₜₒₚ due to witnessed events.</span></div><div class="line">  tₛₜₒₚ ← <a class="code" href="namespacedrake_1_1symbolic.html#a368c7616ccd2ce8d1587aa7343575d52">min</a>(tₑᵥₑₙₜ, tₘₐₓ)</div><div class="line">  tₑ, xc⁻(tₑ) ← Integrate(tₛ, x⁺(tₛ), tₛₜₒₚ)</div><div class="line"></div><div class="line">  xd⁻(tₑ) ← xd⁺(tₛ)  <span class="comment">// Discrete values are held from x⁺(tₛ).</span></div><div class="line">  xa⁻(tₑ) ← xa⁺(tₛ)</div><div class="line"></div><div class="line">  <span class="comment">// ----------------------------------</span></div><div class="line">  <span class="comment">// Time and state are at {tₑ, x⁻(tₑ)}</span></div><div class="line">  <span class="comment">// ----------------------------------</span></div><div class="line"></div><div class="line">  DoAnyPublishes(tₑ, x⁻(tₑ))</div><div class="line">  CallMonitor(tₑ, x⁻(tₑ))</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> {tₑ, x⁻(tₑ)}</div></div><!-- fragment --><p>We can use the notation and pseudocode to flesh out the <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a>, <a class="el" href="classdrake_1_1systems_1_1_simulator.html#ad8252b9d897ed041c44c301cfcd8c5ce" title="(Advanced) Handles discrete and abstract state update events that are pending from the previous Advan...">AdvancePendingEvents()</a>, and <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> functions. Termination and error conditions detected by event handlers or the monitor are reported as status returns from these methods. </p><div class="fragment"><div class="line"><span class="comment">// Advance the simulation until time tₘₐₓ.</span></div><div class="line">procedure <a class="code" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d">AdvanceTo</a>(tₘₐₓ) → status</div><div class="line">  t ← current_time</div><div class="line">  <span class="keywordflow">while</span> t &lt; tₘₐₓ</div><div class="line">    {tₑ, x⁻(tₑ)} ← Step(t, x⁻(t), tₘₐₓ)</div><div class="line">    {t, x⁻(t)} ← {tₑ, x⁻(tₑ)}</div><div class="line">  endwhile</div><div class="line"></div><div class="line"><span class="comment">// AdvancePendingEvents() is an advanced method, not commonly used.</span></div><div class="line"><span class="comment">// Perform just the start-of-step update to advance from x⁻(t) to x⁺(t).</span></div><div class="line">procedure <a class="code" href="classdrake_1_1systems_1_1_simulator.html#ad8252b9d897ed041c44c301cfcd8c5ce">AdvancePendingEvents</a>() → status</div><div class="line">  t ≜ current_time, x⁻(t) ≜ current_state</div><div class="line">  x⁺(t) ← DoAnyPendingUpdates(t, x⁻(t)) as in Step()</div><div class="line">  x(t) ← x⁺(t)  <span class="comment">// No continuous update needed.</span></div><div class="line">  DoAnyPublishes(t, x(t))</div><div class="line">  CallMonitor(t, x(t))</div><div class="line"></div><div class="line"><span class="comment">// Update time and state to {t₀, x⁻(t₀)}, which is the starting value of the</span></div><div class="line"><span class="comment">// trajectory, and thus the value the Context should contain at the start of the</span></div><div class="line"><span class="comment">// first simulation step.</span></div><div class="line">procedure <a class="code" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21">Initialize</a>(t₀, x₀) → status</div><div class="line">  <span class="comment">// Initialization events can be optionally suppressed.</span></div><div class="line">  x⁺(t₀) ← DoAnyInitializationUpdates as in Step()</div><div class="line">  x⁻(t₀) ← x⁺(t₀)  <span class="comment">// No continuous update needed.</span></div><div class="line"></div><div class="line">  <span class="comment">// ----------------------------------</span></div><div class="line">  <span class="comment">// Time and state are at {t₀, x⁻(t₀)}</span></div><div class="line">  <span class="comment">// ----------------------------------</span></div><div class="line"></div><div class="line">  DoAnyPublishes(t₀, x⁻(t₀))</div><div class="line">  CallMonitor(t₀, x⁻(t₀))</div></div><!-- fragment --><p><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> can be viewed as a "0ᵗʰ step" that occurs before the first Step() call as described above. Like Step(), <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> first performs pending updates (in this case only initialization events can be "pending", and even those may be optionally suppressed). Time doesn't advance so there is no continuous update phase and witnesses cannot trigger. Finally, again like Step(), the initial trajectory point <code>{t₀, x⁻(t₀)}</code> is provided to the handlers for any triggered publish events. That includes initialization publish events (if not suppressed), per-step publish events, and periodic or timed publish events that trigger at t₀, followed by a call to the monitor() function if one has been defined (a monitor is semantically identical to a per-step publish).</p>
<p>Optionally, initialization events can be suppressed. This can be useful when reusing the simulator over the same system and time span.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default nonsymbolic scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/systems/analysis/simulator.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4d06ba94298e2cf918910bcc9238f16b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a4d06ba94298e2cf918910bcc9238f16b">Simulator</a> (const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;system, std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt;&gt; context=nullptr)</td></tr>
<tr class="memdesc:a4d06ba94298e2cf918910bcc9238f16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Simulator that can advance a given <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> through time to produce a trajectory consisting of a sequence of <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> values.  <a href="#a4d06ba94298e2cf918910bcc9238f16b">More...</a><br /></td></tr>
<tr class="separator:a4d06ba94298e2cf918910bcc9238f16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849ba63358ef13597faad1be04a999ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a849ba63358ef13597faad1be04a999ec">Simulator</a> (std::unique_ptr&lt; const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt;&gt; system, std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt;&gt; context=nullptr)</td></tr>
<tr class="memdesc:a849ba63358ef13597faad1be04a999ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Simulator which additionally maintains ownership of the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>.  <a href="#a849ba63358ef13597faad1be04a999ec">More...</a><br /></td></tr>
<tr class="separator:a849ba63358ef13597faad1be04a999ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1862c2aeab9862e391194d157a96c21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_simulator_status.html">SimulatorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21">Initialize</a> (const <a class="el" href="structdrake_1_1systems_1_1_initialize_params.html">InitializeParams</a> &amp;params={})</td></tr>
<tr class="memdesc:aa1862c2aeab9862e391194d157a96c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares the Simulator for a simulation.  <a href="#aa1862c2aeab9862e391194d157a96c21">More...</a><br /></td></tr>
<tr class="separator:aa1862c2aeab9862e391194d157a96c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4b04299c9b1d41d9dd85563600012d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_simulator_status.html">SimulatorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d">AdvanceTo</a> (const T &amp;boundary_time)</td></tr>
<tr class="memdesc:aba4b04299c9b1d41d9dd85563600012d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>'s trajectory until <code>boundary_time</code> is reached in the context or some other termination condition occurs.  <a href="#aba4b04299c9b1d41d9dd85563600012d">More...</a><br /></td></tr>
<tr class="separator:aba4b04299c9b1d41d9dd85563600012d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8252b9d897ed041c44c301cfcd8c5ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_simulator_status.html">SimulatorStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#ad8252b9d897ed041c44c301cfcd8c5ce">AdvancePendingEvents</a> ()</td></tr>
<tr class="memdesc:ad8252b9d897ed041c44c301cfcd8c5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Handles discrete and abstract state update events that are pending from the previous <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a> call, without advancing time.  <a href="#ad8252b9d897ed041c44c301cfcd8c5ce">More...</a><br /></td></tr>
<tr class="separator:ad8252b9d897ed041c44c301cfcd8c5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92bce4d4205f51b3b17bcaae09566f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa92bce4d4205f51b3b17bcaae09566f7">set_monitor</a> (std::function&lt; <a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a>(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;)&gt; monitor)</td></tr>
<tr class="memdesc:aa92bce4d4205f51b3b17bcaae09566f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a monitoring function that will be invoked at the end of every step.  <a href="#aa92bce4d4205f51b3b17bcaae09566f7">More...</a><br /></td></tr>
<tr class="separator:aa92bce4d4205f51b3b17bcaae09566f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde4863b417b9fe4e4e326991460d6df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#afde4863b417b9fe4e4e326991460d6df">clear_monitor</a> ()</td></tr>
<tr class="memdesc:afde4863b417b9fe4e4e326991460d6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the monitoring function if there is one.  <a href="#afde4863b417b9fe4e4e326991460d6df">More...</a><br /></td></tr>
<tr class="separator:afde4863b417b9fe4e4e326991460d6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50317748c65310dfaed94e8e79cfe07c"><td class="memItemLeft" align="right" valign="top">const std::function&lt; <a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a>(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;)&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a50317748c65310dfaed94e8e79cfe07c">get_monitor</a> () const</td></tr>
<tr class="memdesc:a50317748c65310dfaed94e8e79cfe07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a reference to the monitoring function, which may be empty.  <a href="#a50317748c65310dfaed94e8e79cfe07c">More...</a><br /></td></tr>
<tr class="separator:a50317748c65310dfaed94e8e79cfe07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda3671ab5939691e7e39fcba568174b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#abda3671ab5939691e7e39fcba568174b">set_target_realtime_rate</a> (double realtime_rate)</td></tr>
<tr class="memdesc:abda3671ab5939691e7e39fcba568174b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slow the simulation down to <em>approximately</em> synchronize with real time when it would otherwise run too fast.  <a href="#abda3671ab5939691e7e39fcba568174b">More...</a><br /></td></tr>
<tr class="separator:abda3671ab5939691e7e39fcba568174b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49b5416e03527dc9a06ac3668f56d77"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#ad49b5416e03527dc9a06ac3668f56d77">get_target_realtime_rate</a> () const</td></tr>
<tr class="memdesc:ad49b5416e03527dc9a06ac3668f56d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the real time rate target currently in effect.  <a href="#ad49b5416e03527dc9a06ac3668f56d77">More...</a><br /></td></tr>
<tr class="separator:ad49b5416e03527dc9a06ac3668f56d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47ea3591d78251f7a2b3d8c8e942421"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#af47ea3591d78251f7a2b3d8c8e942421">get_actual_realtime_rate</a> () const</td></tr>
<tr class="memdesc:af47ea3591d78251f7a2b3d8c8e942421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rate that simulated time has progressed relative to real time.  <a href="#af47ea3591d78251f7a2b3d8c8e942421">More...</a><br /></td></tr>
<tr class="separator:af47ea3591d78251f7a2b3d8c8e942421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1dc6aeb821503379ab1dd8c6044562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aef1dc6aeb821503379ab1dd8c6044562">set_publish_every_time_step</a> (bool publish)</td></tr>
<tr class="memdesc:aef1dc6aeb821503379ab1dd8c6044562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the simulation should trigger a forced-Publish event on the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> under simulation at the end of every trajectory-advancing step.  <a href="#aef1dc6aeb821503379ab1dd8c6044562">More...</a><br /></td></tr>
<tr class="separator:aef1dc6aeb821503379ab1dd8c6044562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac210a235b5e0865efb51fdd27c4b58ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#ac210a235b5e0865efb51fdd27c4b58ae">set_publish_at_initialization</a> (bool publish)</td></tr>
<tr class="memdesc:ac210a235b5e0865efb51fdd27c4b58ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the simulation should trigger a forced-Publish at the end of <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a>.  <a href="#ac210a235b5e0865efb51fdd27c4b58ae">More...</a><br /></td></tr>
<tr class="separator:ac210a235b5e0865efb51fdd27c4b58ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66775683e61fc461dec4f76bb8e5c7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#ae66775683e61fc461dec4f76bb8e5c7a">get_publish_every_time_step</a> () const</td></tr>
<tr class="memdesc:ae66775683e61fc461dec4f76bb8e5c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aef1dc6aeb821503379ab1dd8c6044562" title="Sets whether the simulation should trigger a forced-Publish event on the System under simulation at t...">set_publish_every_time_step()</a> option has been enabled.  <a href="#ae66775683e61fc461dec4f76bb8e5c7a">More...</a><br /></td></tr>
<tr class="separator:ae66775683e61fc461dec4f76bb8e5c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca73e48fb4c24fcf1893459f57eb86a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a0ca73e48fb4c24fcf1893459f57eb86a">get_context</a> () const</td></tr>
<tr class="memdesc:a0ca73e48fb4c24fcf1893459f57eb86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> holding the most recent step in the trajectory.  <a href="#a0ca73e48fb4c24fcf1893459f57eb86a">More...</a><br /></td></tr>
<tr class="separator:a0ca73e48fb4c24fcf1893459f57eb86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8c4e5521ff905e6ab84e9e8bd6719e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#afe8c4e5521ff905e6ab84e9e8bd6719e">get_mutable_context</a> ()</td></tr>
<tr class="memdesc:afe8c4e5521ff905e6ab84e9e8bd6719e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> holding the most recent step in the trajectory.  <a href="#afe8c4e5521ff905e6ab84e9e8bd6719e">More...</a><br /></td></tr>
<tr class="separator:afe8c4e5521ff905e6ab84e9e8bd6719e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7916f5c954d724ee084c41cc371a17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a1c7916f5c954d724ee084c41cc371a17">has_context</a> () const</td></tr>
<tr class="memdesc:a1c7916f5c954d724ee084c41cc371a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> has an internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.  <a href="#a1c7916f5c954d724ee084c41cc371a17">More...</a><br /></td></tr>
<tr class="separator:a1c7916f5c954d724ee084c41cc371a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa85ab3036e9c0c5f6c841a346d70d93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#afa85ab3036e9c0c5f6c841a346d70d93">reset_context</a> (std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt;&gt; context)</td></tr>
<tr class="memdesc:afa85ab3036e9c0c5f6c841a346d70d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> with a different one.  <a href="#afa85ab3036e9c0c5f6c841a346d70d93">More...</a><br /></td></tr>
<tr class="separator:afa85ab3036e9c0c5f6c841a346d70d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ecc40cda7115ce6a66ba4737bd62a6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#af0ecc40cda7115ce6a66ba4737bd62a6">release_context</a> ()</td></tr>
<tr class="memdesc:af0ecc40cda7115ce6a66ba4737bd62a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer ownership of this Simulator's internal <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> to the caller.  <a href="#af0ecc40cda7115ce6a66ba4737bd62a6">More...</a><br /></td></tr>
<tr class="separator:af0ecc40cda7115ce6a66ba4737bd62a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a01ac56f8a0086cc6ed335ee9e5caa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a64a01ac56f8a0086cc6ed335ee9e5caa">ResetStatistics</a> ()</td></tr>
<tr class="memdesc:a64a01ac56f8a0086cc6ed335ee9e5caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forget accumulated statistics.  <a href="#a64a01ac56f8a0086cc6ed335ee9e5caa">More...</a><br /></td></tr>
<tr class="separator:a64a01ac56f8a0086cc6ed335ee9e5caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d02ccfa59f02fe7c9d44067ec83772"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a00d02ccfa59f02fe7c9d44067ec83772">get_num_publishes</a> () const</td></tr>
<tr class="memdesc:a00d02ccfa59f02fe7c9d44067ec83772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of publishes made since the last <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> or <a class="el" href="classdrake_1_1systems_1_1_simulator.html#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics.">ResetStatistics()</a> call.  <a href="#a00d02ccfa59f02fe7c9d44067ec83772">More...</a><br /></td></tr>
<tr class="separator:a00d02ccfa59f02fe7c9d44067ec83772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215741958afe19af17a62470f883878b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a215741958afe19af17a62470f883878b">get_num_steps_taken</a> () const</td></tr>
<tr class="memdesc:a215741958afe19af17a62470f883878b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of steps since the last <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> call.  <a href="#a215741958afe19af17a62470f883878b">More...</a><br /></td></tr>
<tr class="separator:a215741958afe19af17a62470f883878b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b82739f0ab9a29da8aae954e1664fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a31b82739f0ab9a29da8aae954e1664fc">get_num_discrete_updates</a> () const</td></tr>
<tr class="memdesc:a31b82739f0ab9a29da8aae954e1664fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of discrete variable updates performed since the last <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> call.  <a href="#a31b82739f0ab9a29da8aae954e1664fc">More...</a><br /></td></tr>
<tr class="separator:a31b82739f0ab9a29da8aae954e1664fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45565cd97e9be5fd11d76b01a9b467ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a45565cd97e9be5fd11d76b01a9b467ee">get_num_unrestricted_updates</a> () const</td></tr>
<tr class="memdesc:a45565cd97e9be5fd11d76b01a9b467ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of "unrestricted" updates performed since the last <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> call.  <a href="#a45565cd97e9be5fd11d76b01a9b467ee">More...</a><br /></td></tr>
<tr class="separator:a45565cd97e9be5fd11d76b01a9b467ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc3bf152afe75736c6b8b3ecf8cd65e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#adbc3bf152afe75736c6b8b3ecf8cd65e">get_integrator</a> () const</td></tr>
<tr class="memdesc:adbc3bf152afe75736c6b8b3ecf8cd65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the integrator used to advance the continuous aspects of the system.  <a href="#adbc3bf152afe75736c6b8b3ecf8cd65e">More...</a><br /></td></tr>
<tr class="separator:adbc3bf152afe75736c6b8b3ecf8cd65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c4ee8378a24e575a176dfb7d308ae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#af7c4ee8378a24e575a176dfb7d308ae9">get_mutable_integrator</a> ()</td></tr>
<tr class="memdesc:af7c4ee8378a24e575a176dfb7d308ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reference to the mutable integrator used to advance the continuous state of the system.  <a href="#af7c4ee8378a24e575a176dfb7d308ae9">More...</a><br /></td></tr>
<tr class="separator:af7c4ee8378a24e575a176dfb7d308ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9131a4f2e685ca0dafe9872f24ef11"><td class="memTemplParams" colspan="2">template&lt;class Integrator &gt; </td></tr>
<tr class="memitem:a5a9131a4f2e685ca0dafe9872f24ef11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_integrator.html">Integrator</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a5a9131a4f2e685ca0dafe9872f24ef11">reset_integrator</a> ()</td></tr>
<tr class="memdesc:a5a9131a4f2e685ca0dafe9872f24ef11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the integrator with a new one using factory construction.  <a href="#a5a9131a4f2e685ca0dafe9872f24ef11">More...</a><br /></td></tr>
<tr class="separator:a5a9131a4f2e685ca0dafe9872f24ef11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8a90974f072c44ced288c9036c3716"><td class="memTemplParams" colspan="2">template&lt;class Integrator &gt; </td></tr>
<tr class="memitem:a6e8a90974f072c44ced288c9036c3716"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_integrator.html">Integrator</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a6e8a90974f072c44ced288c9036c3716">reset_integrator</a> (const T max_step_size)</td></tr>
<tr class="memdesc:a6e8a90974f072c44ced288c9036c3716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the integrator with a new one using factory construction and a maximum step size argument (which is required for constructing fixed-step integrators).  <a href="#a6e8a90974f072c44ced288c9036c3716">More...</a><br /></td></tr>
<tr class="separator:a6e8a90974f072c44ced288c9036c3716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ca2f66796e3ec16ce492ec68669bfb"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a18ca2f66796e3ec16ce492ec68669bfb">GetCurrentWitnessTimeIsolation</a> () const</td></tr>
<tr class="memdesc:a18ca2f66796e3ec16ce492ec68669bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of the interval used for witness function time isolation.  <a href="#a18ca2f66796e3ec16ce492ec68669bfb">More...</a><br /></td></tr>
<tr class="separator:a18ca2f66796e3ec16ce492ec68669bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c403016877fd5f6291208aeb9a8063c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a5c403016877fd5f6291208aeb9a8063c">get_system</a> () const</td></tr>
<tr class="memdesc:a5c403016877fd5f6291208aeb9a8063c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a constant reference to the system.  <a href="#a5c403016877fd5f6291208aeb9a8063c">More...</a><br /></td></tr>
<tr class="separator:a5c403016877fd5f6291208aeb9a8063c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:aa33b3ce4aeb5d29ac4a16de084bd307b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa33b3ce4aeb5d29ac4a16de084bd307b">Simulator</a> (const <a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a> &amp;)=delete</td></tr>
<tr class="separator:aa33b3ce4aeb5d29ac4a16de084bd307b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52b9a3d9e687fc51a489fff8bb26233"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#ab52b9a3d9e687fc51a489fff8bb26233">operator=</a> (const <a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a> &amp;)=delete</td></tr>
<tr class="separator:ab52b9a3d9e687fc51a489fff8bb26233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ea7987a4acd8c4f32226f33fe9dbe4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a12ea7987a4acd8c4f32226f33fe9dbe4">Simulator</a> (<a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a12ea7987a4acd8c4f32226f33fe9dbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8575d9029f7febab0a5d347b8ac502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1systems_1_1_simulator.html#a9e8575d9029f7febab0a5d347b8ac502">operator=</a> (<a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a9e8575d9029f7febab0a5d347b8ac502"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa33b3ce4aeb5d29ac4a16de084bd307b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33b3ce4aeb5d29ac4a16de084bd307b">&#9670;&nbsp;</a></span>Simulator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12ea7987a4acd8c4f32226f33fe9dbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ea7987a4acd8c4f32226f33fe9dbe4">&#9670;&nbsp;</a></span>Simulator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d06ba94298e2cf918910bcc9238f16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d06ba94298e2cf918910bcc9238f16b">&#9670;&nbsp;</a></span>Simulator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>context</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a Simulator that can advance a given <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> through time to produce a trajectory consisting of a sequence of <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> values. </p>
<p>The <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> must not have unresolved input ports if the values of those ports are necessary for computations performed during simulation (see class documentation).</p>
<p>The <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> holds an internal, non-owned reference to the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> object so you must ensure that <code>system</code> has a longer lifetime than the Simulator. It also owns a compatible <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> internally that takes on each of the trajectory values. You may optionally provide a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> that will be used as the initial condition for the simulation; otherwise the Simulator will obtain a default <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> from <code>system</code>. </p>

</div>
</div>
<a id="a849ba63358ef13597faad1be04a999ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849ba63358ef13597faad1be04a999ec">&#9670;&nbsp;</a></span>Simulator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a> </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>context</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Simulator which additionally maintains ownership of the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad8252b9d897ed041c44c301cfcd8c5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8252b9d897ed041c44c301cfcd8c5ce">&#9670;&nbsp;</a></span>AdvancePendingEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_simulator_status.html">SimulatorStatus</a> AdvancePendingEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Handles discrete and abstract state update events that are pending from the previous <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a> call, without advancing time. </p>
<p>See the Simulator class description for details about how Simulator advances time and handles events. In the terminology used there, this method advances the internal <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> from <code>{t, x⁻(t)}</code> to <code>{t, x⁺(t)}</code>.</p>
<p>Normally, these update events would be handled at the start of the next <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a> call, so this method is rarely needed. It can be useful at the end of a simulation or to get intermediate results when you are specifically interested in the <code>x⁺(t)</code> result.</p>
<p>This method is equivalent to <code>AdvanceTo(current_time)</code>, where <code>current_time=simulator.get_context().get_time())</code>. If there are no pending events, nothing happens except possibly a final per-step publish call (if enabled) followed by a call to the monitor() function (if one has been provided).</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">status</td><td>A <a class="el" href="classdrake_1_1systems_1_1_simulator_status.html" title="Holds the status return value from a call to Simulator::AdvanceTo() and related methods.">SimulatorStatus</a> object indicating success, termination, or an error condition as reported by event handlers or the monitor function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a>, <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a>, <a class="el" href="classdrake_1_1systems_1_1_simulator_status.html" title="Holds the status return value from a call to Simulator::AdvanceTo() and related methods.">SimulatorStatus</a> </dd></dl>

</div>
</div>
<a id="aba4b04299c9b1d41d9dd85563600012d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4b04299c9b1d41d9dd85563600012d">&#9670;&nbsp;</a></span>AdvanceTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_simulator_status.html">SimulatorStatus</a> AdvanceTo </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>boundary_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a>'s trajectory until <code>boundary_time</code> is reached in the context or some other termination condition occurs. </p>
<p>A variety of <code>std::runtime_error</code> conditions are possible here, as well as error conditions that may be thrown by the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> when it is asked to perform computations. Be sure to enclose your simulation in a <code>try-catch</code> block and display the <code>what()</code> message.</p>
<p>We recommend that you call <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> prior to making the first call to <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a>. However, if you don't it will be called for you the first time that you attempt a step, possibly resulting in unexpected error conditions. See documentation for <code><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a></code> for the error conditions it might produce.</p>
<dl class="section warning"><dt>Warning</dt><dd>You should consider calling <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> if you alter the the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> or <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> options between successive <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a> calls. See <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> for more information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundary_time</td><td>The maximum time to which the trajectory will be advanced by this call to AdvanceTo(). The method may return earlier if an event or the monitor function requests termination or reports an error condition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">status</td><td>A <a class="el" href="classdrake_1_1systems_1_1_simulator_status.html" title="Holds the status return value from a call to Simulator::AdvanceTo() and related methods.">SimulatorStatus</a> object indicating success, termination, or an error condition as reported by event handlers or the monitor function. The time in the context will be set either to the boundary_time or the time a termination or error was first detected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The internal <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> satisfies all <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> constraints or will after pending <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> updates are performed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a>, <a class="el" href="classdrake_1_1systems_1_1_simulator.html#ad8252b9d897ed041c44c301cfcd8c5ce" title="(Advanced) Handles discrete and abstract state update events that are pending from the previous Advan...">AdvancePendingEvents()</a>, <a class="el" href="classdrake_1_1systems_1_1_simulator_status.html" title="Holds the status return value from a call to Simulator::AdvanceTo() and related methods.">SimulatorStatus</a> </dd></dl>

</div>
</div>
<a id="afde4863b417b9fe4e4e326991460d6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde4863b417b9fe4e4e326991460d6df">&#9670;&nbsp;</a></span>clear_monitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear_monitor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the monitoring function if there is one. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa92bce4d4205f51b3b17bcaae09566f7" title="Provides a monitoring function that will be invoked at the end of every step.">set_monitor()</a> </dd></dl>

</div>
</div>
<a id="af47ea3591d78251f7a2b3d8c8e942421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47ea3591d78251f7a2b3d8c8e942421">&#9670;&nbsp;</a></span>get_actual_realtime_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_actual_realtime_rate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the rate that simulated time has progressed relative to real time. </p>
<p>A return of 1 means the simulation just matched real time, 2 means the simulation was twice as fast as real time, 0.5 means it was running in 2X slow motion, etc.</p>
<p>The value returned here is calculated as follows: </p><pre></pre><pre>         simulated_time_now - initial_simulated_time
  rate = -------------------------------------------
               realtime_now - initial_realtime
</pre><p> The <code>initial</code> times are recorded when <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> or <a class="el" href="classdrake_1_1systems_1_1_simulator.html#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics.">ResetStatistics()</a> is called. The returned rate is undefined if <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> has not yet been called.</p>
<dl class="section return"><dt>Returns</dt><dd>The rate achieved since the last <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> or <a class="el" href="classdrake_1_1systems_1_1_simulator.html#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics.">ResetStatistics()</a> call.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_simulator.html#abda3671ab5939691e7e39fcba568174b" title="Slow the simulation down to approximately synchronize with real time when it would otherwise run too ...">set_target_realtime_rate()</a> </dd></dl>

</div>
</div>
<a id="a0ca73e48fb4c24fcf1893459f57eb86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca73e48fb4c24fcf1893459f57eb86a">&#9670;&nbsp;</a></span>get_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt;T&gt;&amp; get_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reference to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> holding the most recent step in the trajectory. </p>
<p>This is suitable for publishing or extracting information about this trajectory step. Do not call this method if there is no <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>

</div>
</div>
<a id="adbc3bf152afe75736c6b8b3ecf8cd65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc3bf152afe75736c6b8b3ecf8cd65e">&#9670;&nbsp;</a></span>get_integrator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt;T&gt;&amp; get_integrator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a reference to the integrator used to advance the continuous aspects of the system. </p>

</div>
</div>
<a id="a50317748c65310dfaed94e8e79cfe07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50317748c65310dfaed94e8e79cfe07c">&#9670;&nbsp;</a></span>get_monitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::function&lt;<a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a>(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt;T&gt;&amp;)&gt;&amp; get_monitor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a reference to the monitoring function, which may be empty. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa92bce4d4205f51b3b17bcaae09566f7" title="Provides a monitoring function that will be invoked at the end of every step.">set_monitor()</a> </dd></dl>

</div>
</div>
<a id="afe8c4e5521ff905e6ab84e9e8bd6719e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8c4e5521ff905e6ab84e9e8bd6719e">&#9670;&nbsp;</a></span>get_mutable_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt;T&gt;&amp; get_mutable_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable reference to the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> holding the most recent step in the trajectory. </p>
<p>This is suitable for use in updates, sampling operations, event handlers, and constraint projection. You can also modify this prior to calling <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> to set initial conditions. Do not call this method if there is no <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>

</div>
</div>
<a id="af7c4ee8378a24e575a176dfb7d308ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c4ee8378a24e575a176dfb7d308ae9">&#9670;&nbsp;</a></span>get_mutable_integrator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_integrator_base.html">IntegratorBase</a>&lt;T&gt;&amp; get_mutable_integrator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a reference to the mutable integrator used to advance the continuous state of the system. </p>

</div>
</div>
<a id="a31b82739f0ab9a29da8aae954e1664fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b82739f0ab9a29da8aae954e1664fc">&#9670;&nbsp;</a></span>get_num_discrete_updates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> get_num_discrete_updates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of discrete variable updates performed since the last <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> call. </p>

</div>
</div>
<a id="a00d02ccfa59f02fe7c9d44067ec83772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d02ccfa59f02fe7c9d44067ec83772">&#9670;&nbsp;</a></span>get_num_publishes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> get_num_publishes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of publishes made since the last <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> or <a class="el" href="classdrake_1_1systems_1_1_simulator.html#a64a01ac56f8a0086cc6ed335ee9e5caa" title="Forget accumulated statistics.">ResetStatistics()</a> call. </p>

</div>
</div>
<a id="a215741958afe19af17a62470f883878b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215741958afe19af17a62470f883878b">&#9670;&nbsp;</a></span>get_num_steps_taken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> get_num_steps_taken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of steps since the last <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> call. </p>
<p>(We're not counting the <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> 0-length "step".) Note that every <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a> call can potentially take many steps. </p>

</div>
</div>
<a id="a45565cd97e9be5fd11d76b01a9b467ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45565cd97e9be5fd11d76b01a9b467ee">&#9670;&nbsp;</a></span>get_num_unrestricted_updates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> get_num_unrestricted_updates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of "unrestricted" updates performed since the last <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> call. </p>

</div>
</div>
<a id="ae66775683e61fc461dec4f76bb8e5c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66775683e61fc461dec4f76bb8e5c7a">&#9670;&nbsp;</a></span>get_publish_every_time_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool get_publish_every_time_step </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aef1dc6aeb821503379ab1dd8c6044562" title="Sets whether the simulation should trigger a forced-Publish event on the System under simulation at t...">set_publish_every_time_step()</a> option has been enabled. </p>
<p>By default, returns false. </p>

</div>
</div>
<a id="a5c403016877fd5f6291208aeb9a8063c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c403016877fd5f6291208aeb9a8063c">&#9670;&nbsp;</a></span>get_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>&lt;T&gt;&amp; get_system </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a constant reference to the system. </p>
<dl class="section note"><dt>Note</dt><dd>a mutable reference is not available. </dd></dl>

</div>
</div>
<a id="ad49b5416e03527dc9a06ac3668f56d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49b5416e03527dc9a06ac3668f56d77">&#9670;&nbsp;</a></span>get_target_realtime_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_target_realtime_rate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the real time rate target currently in effect. </p>
<p>The default is zero, meaning the Simulator runs as fast as possible. You can change the target with <a class="el" href="classdrake_1_1systems_1_1_simulator.html#abda3671ab5939691e7e39fcba568174b" title="Slow the simulation down to approximately synchronize with real time when it would otherwise run too ...">set_target_realtime_rate()</a>. </p>

</div>
</div>
<a id="a18ca2f66796e3ec16ce492ec68669bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ca2f66796e3ec16ce492ec68669bfb">&#9670;&nbsp;</a></span>GetCurrentWitnessTimeIsolation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;T&gt; GetCurrentWitnessTimeIsolation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of the interval used for witness function time isolation. </p>
<p>The length of the interval is computed differently, depending on context, to support multiple applications, as described below:</p>
<ul>
<li><b>Simulations using error controlled integrators</b>: the isolation time interval will be scaled by the product of the system's characteristic time and the accuracy stored in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>.</li>
<li><b>Simulations using integrators taking fixed steps</b>: the isolation time interval will be determined differently depending on whether the accuracy is set in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> or not. If the accuracy <em>is</em> set in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, the nominally fixed steps for integrating continuous state will be subdivided until events have been isolated to the requisite interval length, which is scaled by the step size times the accuracy in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. If accuracy is not set in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, event isolation will not be performed.</li>
</ul>
<p>The isolation window length will never be smaller than the integrator's working minimum tolerance (see <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#a47399e48a6a661ce1b8252d86a305b54" title="Gets the current value of the working minimum step size h_work(t) for this integrator,...">IntegratorBase::get_working_minimum_step_size()</a>);</p>
<dl class="section return"><dt>Returns</dt><dd>the isolation window if the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> should be isolating witness-triggered events in time, or returns empty otherwise (indicating that any witness-triggered events should trigger at the end of a time interval over which continuous state is integrated). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the accuracy is not set in the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> and the integrator is not operating in fixed step mode (see <a class="el" href="classdrake_1_1systems_1_1_integrator_base.html#ae35b01e013bbfa64d9cdccfa01f034fe" title="Gets whether an integrator is running in fixed step mode.">IntegratorBase::get_fixed_step_mode()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c7916f5c954d724ee084c41cc371a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7916f5c954d724ee084c41cc371a17">&#9670;&nbsp;</a></span>has_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool has_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> has an internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p>
<p>This is always true unless <code><a class="el" href="classdrake_1_1systems_1_1_simulator.html#afa85ab3036e9c0c5f6c841a346d70d93" title="Replace the internally-maintained Context with a different one.">reset_context()</a></code> has been called. </p>

</div>
</div>
<a id="aa1862c2aeab9862e391194d157a96c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1862c2aeab9862e391194d157a96c21">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_simulator_status.html">SimulatorStatus</a> Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1systems_1_1_initialize_params.html">InitializeParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares the Simulator for a simulation. </p>
<p>In order, the sequence of actions taken here are:</p><ul>
<li>The active integrator's <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> method is invoked.</li>
<li>Statistics are reset.</li>
<li>By default, initialization update events are triggered and handled to produce the initial trajectory value <code>{t₀, x(t₀)}</code>. If initialization events are suppressed, it is the caller's responsibility to ensure the desired initial state. - Then that initial value is provided to the handlers for any publish events that have triggered, including initialization events if any, and per-step publish events, periodic or other time-triggered publish events that are scheduled for the initial time t₀, and finally a call to the monitor() function if one has been defined. See the class documentation for more information. We recommend calling <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> explicitly prior to beginning a simulation so that error conditions will be discovered early. However, <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> will be called automatically by the first <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a> call if it hasn't already been called.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If you make a change to the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> or to <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> options between <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a> calls you should consider whether to call <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> before resuming; <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a> will not do that automatically for you. Whether to do so depends on whether you want the above initialization operations performed.</dd>
<dd>
In particular, if you changed the time you must call <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a>. The time-triggered events must be recalculated in case one is due at the new starting time. Currently, the <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a> call will print a warning for the first violation; after 2020-12-01 the warning will become a hard error.</dd>
<dd>
The only way to suppress initialization events is by calling <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> explicitly. The most common scenario for this is when reusing a <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> object. In this case, the caller is responsible for ensuring the correctness of the initial state.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> does not automatically attempt to satisfy <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> constraints &ndash; it is up to you to make sure that constraints are satisfied by the initial conditions.</dd></dl>
<p>This method will throw <code>std::logic_error</code> if the combination of options doesn't make sense. Other failures are possible from the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> and integrator in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>(optional) a parameter structure (</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structdrake_1_1systems_1_1_initialize_params.html" title="Parameters for fine control of simulator initialization.">InitializeParams</a>).</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">status</td><td>A <a class="el" href="classdrake_1_1systems_1_1_simulator_status.html" title="Holds the status return value from a call to Simulator::AdvanceTo() and related methods.">SimulatorStatus</a> object indicating success, termination, or an error condition as reported by event handlers or the monitor function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a>, <a class="el" href="classdrake_1_1systems_1_1_simulator.html#ad8252b9d897ed041c44c301cfcd8c5ce" title="(Advanced) Handles discrete and abstract state update events that are pending from the previous Advan...">AdvancePendingEvents()</a>, <a class="el" href="classdrake_1_1systems_1_1_simulator_status.html" title="Holds the status return value from a call to Simulator::AdvanceTo() and related methods.">SimulatorStatus</a> </dd></dl>

</div>
</div>
<a id="a9e8575d9029f7febab0a5d347b8ac502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8575d9029f7febab0a5d347b8ac502">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab52b9a3d9e687fc51a489fff8bb26233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab52b9a3d9e687fc51a489fff8bb26233">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0ecc40cda7115ce6a66ba4737bd62a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ecc40cda7115ce6a66ba4737bd62a6">&#9670;&nbsp;</a></span>release_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt;T&gt; &gt; release_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer ownership of this Simulator's internal <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> to the caller. </p>
<p>The Simulator will no longer contain a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. The caller must not attempt to advance the simulator in time after that point. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_simulator.html#afa85ab3036e9c0c5f6c841a346d70d93" title="Replace the internally-maintained Context with a different one.">reset_context()</a> </dd></dl>

</div>
</div>
<a id="afa85ab3036e9c0c5f6c841a346d70d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa85ab3036e9c0c5f6c841a346d70d93">&#9670;&nbsp;</a></span>reset_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reset_context </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the internally-maintained <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> with a different one. </p>
<p>The current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> is deleted. This is useful for supplying a new set of initial conditions. You should invoke <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> after replacing the <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The new context, which may be null. If the context is null, a new context must be set before attempting to step the system forward. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a9131a4f2e685ca0dafe9872f24ef11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9131a4f2e685ca0dafe9872f24ef11">&#9670;&nbsp;</a></span>reset_integrator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_integrator.html">Integrator</a>&amp; reset_integrator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the integrator with a new one using factory construction. </p>
<div class="fragment"><div class="line">simulator.reset_integrator&lt;RungeKutta3Integrator&lt;double&gt;&gt;().</div></div><!-- fragment --><p> Resetting the integrator resets the Simulator such that it needs to be initialized again &ndash; see <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> for details. </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator.html" title="An integrator for a continuous vector input.">Integrator</a> needs a constructor of the form Integrator(const System&amp;, Context*); this constructor is usually associated with error-controlled integrators. </dd></dl>

</div>
</div>
<a id="a6e8a90974f072c44ced288c9036c3716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8a90974f072c44ced288c9036c3716">&#9670;&nbsp;</a></span>reset_integrator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1systems_1_1_integrator.html">Integrator</a>&amp; reset_integrator </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>max_step_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the integrator with a new one using factory construction and a maximum step size argument (which is required for constructing fixed-step integrators). </p>
<div class="fragment"><div class="line">simulator.reset_integrator&lt;RungeKutta2Integrator&lt;double&gt;&gt;(0.1).</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>argument-less version of <a class="el" href="classdrake_1_1systems_1_1_simulator.html#a5a9131a4f2e685ca0dafe9872f24ef11" title="Resets the integrator with a new one using factory construction.">reset_integrator()</a> for note about initialization. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classdrake_1_1systems_1_1_integrator.html" title="An integrator for a continuous vector input.">Integrator</a> needs a constructor of the form Integrator(const System&amp;, const T&amp;, Context*); this constructor is usually associated with fixed-step integrators (i.e., integrators which do not support error estimation). </dd></dl>

</div>
</div>
<a id="a64a01ac56f8a0086cc6ed335ee9e5caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a01ac56f8a0086cc6ed335ee9e5caa">&#9670;&nbsp;</a></span>ResetStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ResetStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forget accumulated statistics. </p>
<p>Statistics are reset to the values they have post construction or immediately after <code><a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a></code>. </p>

</div>
</div>
<a id="aa92bce4d4205f51b3b17bcaae09566f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92bce4d4205f51b3b17bcaae09566f7">&#9670;&nbsp;</a></span>set_monitor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_monitor </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="classdrake_1_1systems_1_1_event_status.html">EventStatus</a>(const <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>&lt; T &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>monitor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a monitoring function that will be invoked at the end of every step. </p>
<p>(See the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> class documentation for a precise definition of "step".) A monitor() function can be used to capture the trajectory, to terminate the simulation, or to detect error conditions. The monitor() function is invoked by the Simulator with a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> whose value is a point along the simulated trajectory. The monitor can be any functor and should capture any <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> references it needs to operate correctly.</p>
<p>A monitor() function behaves the same as would a per-step Publish event handler included in the top-level <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> or <a class="el" href="classdrake_1_1systems_1_1_diagram.html" title="Diagram is a System composed of one or more constituent Systems, arranged in a directed graph where t...">Diagram</a> being simulated. As in the case of <a class="el" href="namespacedrake_1_1lcm.html#a7f10e39fd5048940095d76f21bdf760d" title="Publishes an LCM message on channel channel.">Publish()</a>, the monitor is called at the end of every step taken internally by <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a>, and also at the end of <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a> and <a class="el" href="classdrake_1_1systems_1_1_simulator.html#ad8252b9d897ed041c44c301cfcd8c5ce" title="(Advanced) Handles discrete and abstract state update events that are pending from the previous Advan...">AdvancePendingEvents()</a>. (See the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a> class documentation for more detail about what happens when in these methods.) The monitor receives the top-level (root) <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a>, from which any sub-Context can be obtained using <code>subsystem.GetMyContextFromRoot()</code>, provided the necessary subsystem reference has been captured for use in the monitor.</p>
<h4>Examples</h4>
<p>Output time and continuous states whenever the trajectory is advanced: </p><div class="fragment"><div class="line">simulator.set_monitor([](<span class="keyword">const</span> Context&lt;T&gt;&amp; root_context) {</div><div class="line">  std::cout &lt;&lt; root_context.get_time() &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div><div class="line">            &lt;&lt; root_context.get_continuous_state_vector()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classdrake_1_1systems_1_1_event_status.html#a3a4f9a8cd5a2983e3f2dd498cfe70318">EventStatus::Succeeded</a>();</div><div class="line">});</div></div><!-- fragment --><p>Terminate early but successfully on a condition in a subsystem of the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> diagram being simulated: </p><div class="fragment"><div class="line">simulator.set_monitor([&amp;my_subsystem](<span class="keyword">const</span> Context&lt;T&gt;&amp; root_context) {</div><div class="line">  <span class="keyword">const</span> Context&lt;T&gt;&amp; subcontext =</div><div class="line">      my_subsystem.GetMyContextFromRoot(root_context);</div><div class="line">  <span class="keywordflow">if</span> (my_subsystem.GoalReached(subcontext)) {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classdrake_1_1systems_1_1_event_status.html#a6912cef3a362910036f9b5eb31e977ce">EventStatus::ReachedTermination</a>(my_subsystem,</div><div class="line">        <span class="stringliteral">&quot;Simulation achieved the desired goal.&quot;</span>);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classdrake_1_1systems_1_1_event_status.html#a3a4f9a8cd5a2983e3f2dd498cfe70318">EventStatus::Succeeded</a>();</div><div class="line">});</div></div><!-- fragment --><p> In the above case, the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a>'s <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a> method will return early when the subsystem reports that it has reached its goal. The returned status will indicate the termination reason, and a human-readable termination message containing the message provided by the monitor can be obtained with status.FormatMessage().</p>
<p>Failure due to plant center of mass falling below a threshold: </p><div class="fragment"><div class="line">simulator.set_monitor([&amp;plant](<span class="keyword">const</span> Context&lt;T&gt;&amp; root_context) {</div><div class="line">  <span class="keyword">const</span> Context&lt;T&gt;&amp; plant_context =</div><div class="line">      plant.GetMyContextFromRoot(root_context);</div><div class="line">  <span class="keyword">const</span> Vector3&lt;T&gt; com = plant.CalcCenterOfMassPosition(plant_context);</div><div class="line">  <span class="keywordflow">if</span> (com[2] &lt; 0.1) {  <span class="comment">// Check z height of com.</span></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classdrake_1_1systems_1_1_event_status.html#ae3e0adfccd544505d326a579ac65fba5">EventStatus::Failed</a>(plant, <span class="stringliteral">&quot;System fell over.&quot;</span>);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classdrake_1_1systems_1_1_event_status.html#a3a4f9a8cd5a2983e3f2dd498cfe70318">EventStatus::Succeeded</a>();</div><div class="line">});</div></div><!-- fragment --><p> In the above case the <a class="el" href="classdrake_1_1systems_1_1_simulator.html" title="A class for advancing the state of hybrid dynamic systems, represented by System&lt;T&gt; objects,...">Simulator</a>'s <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a> method will throw an std::runtime_error containing a human-readable message including the text provided in the monitor.</p>
<dl class="section note"><dt>Note</dt><dd>monitor() is called every time the trajectory is advanced by a step, which can mean it is called many times during a single <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aba4b04299c9b1d41d9dd85563600012d" title="Advances the System&#39;s trajectory until boundary_time is reached in the context or some other terminat...">AdvanceTo()</a> call.</dd>
<dd>
The presence of a monitor has no effect on the step sizes taken, so a termination or error condition will be discovered only when first observed after a step is complete; it will not be further localized. Use witness-triggered events instead if you need precise isolation. </dd></dl>

</div>
</div>
<a id="ac210a235b5e0865efb51fdd27c4b58ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac210a235b5e0865efb51fdd27c4b58ae">&#9670;&nbsp;</a></span>set_publish_at_initialization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_publish_at_initialization </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>publish</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the simulation should trigger a forced-Publish at the end of <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aa1862c2aeab9862e391194d157a96c21" title="Prepares the Simulator for a simulation.">Initialize()</a>. </p>
<p>See <a class="el" href="classdrake_1_1systems_1_1_simulator.html#aef1dc6aeb821503379ab1dd8c6044562" title="Sets whether the simulation should trigger a forced-Publish event on the System under simulation at t...">set_publish_every_time_step()</a> documentation for more information. </p>

</div>
</div>
<a id="aef1dc6aeb821503379ab1dd8c6044562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1dc6aeb821503379ab1dd8c6044562">&#9670;&nbsp;</a></span>set_publish_every_time_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_publish_every_time_step </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>publish</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the simulation should trigger a forced-Publish event on the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> under simulation at the end of every trajectory-advancing step. </p>
<p>Specifically, that means the <a class="el" href="classdrake_1_1systems_1_1_system.html#a31898e0276f6bbc4edf7111f809afb01" title="This method is the public entry point for dispatching all publish event handlers.">System::Publish()</a> event dispatcher will be invoked on each subsystem of the <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">System</a> and passed the current <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">Context</a> and a forced-publish <a class="el" href="classdrake_1_1systems_1_1_event.html" title="Abstract base class that represents an event.">Event</a>. If a subsystem has declared a forced-publish event handler, that will be called. Otherwise, nothing will happen unless the DoPublish() dispatcher has been overridden.</p>
<p>Enabling this option does not cause a forced-publish to be triggered at initialization; if you want that you should also call <code>set_publish_at_initialization(true)</code>. If you want a forced-publish at the end of every step, you will usually also want one at the end of initialization, requiring both options to be enabled.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1systems_1_1_leaf_system.html#a79bf931890fb3c7e9e4fd0f2696ca994" title="Declares a function that is called whenever a user directly calls Publish(const Context&amp;).">LeafSystem::DeclareForcedPublishEvent()</a> </dd></dl>

</div>
</div>
<a id="abda3671ab5939691e7e39fcba568174b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda3671ab5939691e7e39fcba568174b">&#9670;&nbsp;</a></span>set_target_realtime_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_target_realtime_rate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>realtime_rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slow the simulation down to <em>approximately</em> synchronize with real time when it would otherwise run too fast. </p>
<p>Normally the Simulator takes steps as quickly as it can. You can request that it slow down to synchronize with real time by providing a realtime rate greater than zero here.</p>
<dl class="section warning"><dt>Warning</dt><dd>No guarantees can be made about how accurately the simulation can be made to track real time, even if computation is fast enough. That's because the system utilities used to implement this do not themselves provide such guarantees. So this is likely to work nicely for visualization purposes where human perception is the only concern. For any other uses you should consider whether approximate real time is adequate for your purposes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the full-speed simulation is already slower than real time you can't speed it up with this call! Instead consider requesting less integration accuracy, using a faster integration method or fixed time step, or using a simpler model.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">realtime_rate</td><td>Desired rate relative to real time. Set to 1 to track real time, 2 to run twice as fast as real time, 0.5 for half speed, etc. Zero or negative restores the rate to its default of 0, meaning the simulation will proceed as fast as possible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/systems/analysis/<a class="el" href="simulator_8h.html">simulator.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1systems.html">systems</a></li><li class="navelem"><a class="el" href="classdrake_1_1systems_1_1_simulator.html">Simulator</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
