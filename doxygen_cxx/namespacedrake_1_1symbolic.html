<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::symbolic Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacedrake_1_1symbolic.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">drake::symbolic Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedrake_1_1symbolic_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1symbolic_1_1_basis_element_graded_reverse_lex_order.html">BasisElementGradedReverseLexOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Graded reverse lexicographic order.  <a href="structdrake_1_1symbolic_1_1_basis_element_graded_reverse_lex_order.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for binary expressions.  <a href="classdrake_1_1symbolic_1_1_binary_expression_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> represents an element of Chebyshev polynomial basis, written as the product of Chebyshev polynomials, in the form Tₚ₀(x₀)Tₚ₁(x₁)...Tₚₙ(xₙ), where each Tₚᵢ(xᵢ) is a (univariate) Chebyshev polynomial of degree pᵢ.  <a href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_polynomial.html">ChebyshevPolynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the Chebyshev polynomial of the first kind Tₙ(x).  <a href="classdrake_1_1symbolic_1_1_chebyshev_polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_code_gen_visitor.html">CodeGenVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor class for code generation.  <a href="classdrake_1_1symbolic_1_1_code_gen_visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic environment (mapping from a variable to a value).  <a href="classdrake_1_1symbolic_1_1_environment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic form of an expression.  <a href="classdrake_1_1symbolic_1_1_expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing absolute value function.  <a href="classdrake_1_1symbolic_1_1_expression_abs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing arccosine function.  <a href="classdrake_1_1symbolic_1_1_expression_acos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing an addition which is a sum of products.  <a href="classdrake_1_1symbolic_1_1_expression_add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_add_factory.html">ExpressionAddFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory class to help build <a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html" title="Symbolic expression representing an addition which is a sum of products.">ExpressionAdd</a> expressions.  <a href="classdrake_1_1symbolic_1_1_expression_add_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing arcsine function.  <a href="classdrake_1_1symbolic_1_1_expression_asin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing arctangent function.  <a href="classdrake_1_1symbolic_1_1_expression_atan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing atan2 function (arctangent function with two arguments).  <a href="classdrake_1_1symbolic_1_1_expression_atan2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing ceil function.  <a href="classdrake_1_1symbolic_1_1_expression_ceiling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an abstract class which is the base of concrete symbolic-expression classes.  <a href="classdrake_1_1symbolic_1_1_expression_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html">ExpressionConstant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing a constant.  <a href="classdrake_1_1symbolic_1_1_expression_constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing cosine function.  <a href="classdrake_1_1symbolic_1_1_expression_cos.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing hyperbolic cosine function.  <a href="classdrake_1_1symbolic_1_1_expression_cosh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing division.  <a href="classdrake_1_1symbolic_1_1_expression_div.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing exponentiation using the base of natural logarithms.  <a href="classdrake_1_1symbolic_1_1_expression_exp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing floor function.  <a href="classdrake_1_1symbolic_1_1_expression_floor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing if-then-else expression.  <a href="classdrake_1_1symbolic_1_1_expression_if_then_else.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing logarithms.  <a href="classdrake_1_1symbolic_1_1_expression_log.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing max function.  <a href="classdrake_1_1symbolic_1_1_expression_max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing min function.  <a href="classdrake_1_1symbolic_1_1_expression_min.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing a multiplication of powers.  <a href="classdrake_1_1symbolic_1_1_expression_mul.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_mul_factory.html">ExpressionMulFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory class to help build <a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html" title="Symbolic expression representing a multiplication of powers.">ExpressionMul</a> expressions.  <a href="classdrake_1_1symbolic_1_1_expression_mul_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_na_n.html">ExpressionNaN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing NaN (not-a-number).  <a href="classdrake_1_1symbolic_1_1_expression_na_n.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing power function.  <a href="classdrake_1_1symbolic_1_1_expression_pow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing sine function.  <a href="classdrake_1_1symbolic_1_1_expression_sin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing hyperbolic sine function.  <a href="classdrake_1_1symbolic_1_1_expression_sinh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing square-root.  <a href="classdrake_1_1symbolic_1_1_expression_sqrt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing tangent function.  <a href="classdrake_1_1symbolic_1_1_expression_tan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing hyperbolic tangent function.  <a href="classdrake_1_1symbolic_1_1_expression_tanh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing an uninterpreted function.  <a href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression representing a variable.  <a href="classdrake_1_1symbolic_1_1_expression_var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic form of a first-order logic formula.  <a href="classdrake_1_1symbolic_1_1_formula.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing conjunctions (f1 ∧ ...  <a href="classdrake_1_1symbolic_1_1_formula_and.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an abstract class which is the base of concrete symbolic-formula classes (i.e.  <a href="classdrake_1_1symbolic_1_1_formula_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing equality (e1 = e2).  <a href="classdrake_1_1symbolic_1_1_formula_eq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing false.  <a href="classdrake_1_1symbolic_1_1_formula_false.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing universal quantifications (∀ x₁, ..., * xn.  <a href="classdrake_1_1symbolic_1_1_formula_forall.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'greater-than-or-equal-to' (e1 ≥ e2).  <a href="classdrake_1_1symbolic_1_1_formula_geq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'greater-than' (e1 &gt; e2).  <a href="classdrake_1_1symbolic_1_1_formula_gt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing isnan predicate.  <a href="classdrake_1_1symbolic_1_1_formula_isnan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'less-than-or-equal-to' (e1 ≤ e2).  <a href="classdrake_1_1symbolic_1_1_formula_leq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing 'less-than' (e1 &lt; e2).  <a href="classdrake_1_1symbolic_1_1_formula_lt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing disequality (e1 ≠ e2).  <a href="classdrake_1_1symbolic_1_1_formula_neq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing negations (¬f).  <a href="classdrake_1_1symbolic_1_1_formula_not.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing disjunctions (f1 ∨ ...  <a href="classdrake_1_1symbolic_1_1_formula_or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing positive-semidefinite (PSD) constraint.  <a href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing true.  <a href="classdrake_1_1symbolic_1_1_formula_true.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic formula representing a Boolean variable.  <a href="classdrake_1_1symbolic_1_1_formula_var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1symbolic_1_1_graded_reverse_lex_order.html">GradedReverseLexOrder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Graded reverse lexicographic order.  <a href="structdrake_1_1symbolic_1_1_graded_reverse_lex_order.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a monomial, a product of powers of variables with non-negative integer exponents.  <a href="classdrake_1_1symbolic_1_1_monomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html" title="MonomialBasisElement represents a monomial, a product of powers of variables with non-negative intege...">MonomialBasisElement</a> represents a monomial, a product of powers of variables with non-negative integer exponents.  <a href="classdrake_1_1symbolic_1_1_monomial_basis_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for N-ary logic operators (∧ and ∨).  <a href="classdrake_1_1symbolic_1_1_nary_formula_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents symbolic polynomials.  <a href="classdrake_1_1symbolic_1_1_polynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html">PolynomialBasisElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each polynomial p(x) can be written as a linear combination of its basis elements p(x) = ∑ᵢ cᵢ * ϕᵢ(x), where ϕᵢ(x) is the i'th element in the basis, cᵢ is the coefficient of that element.  <a href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents symbolic rational function.  <a href="classdrake_1_1symbolic_1_1_rational_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for relational operators (==, !=, &lt;, &lt;=, &gt;, &gt;=).  <a href="classdrake_1_1symbolic_1_1_relational_formula_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html">RewritingRule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html" title="A RewritingRule, lhs =&gt; rhs, consists of two Patterns lhs and rhs.">RewritingRule</a></code>, <code>lhs =&gt; rhs</code>, consists of two Patterns <code>lhs</code> and <code>rhs</code>.  <a href="classdrake_1_1symbolic_1_1_rewriting_rule.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the base class for unary expressions.  <a href="classdrake_1_1symbolic_1_1_unary_expression_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a symbolic variable.  <a href="classdrake_1_1symbolic_1_1_variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of variables.  <a href="classdrake_1_1symbolic_1_1_variables.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acbfe43d34e6c71c503d4de11da53bbb7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acbfe43d34e6c71c503d4de11da53bbb7">Substitution</a> = std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;</td></tr>
<tr class="separator:acbfe43d34e6c71c503d4de11da53bbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb27ddf30420e620beb8e6725d83208f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aeb27ddf30420e620beb8e6725d83208f">Pattern</a> = <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td></tr>
<tr class="memdesc:aeb27ddf30420e620beb8e6725d83208f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern is an expression which possibly includes variables which represent placeholders.  <a href="#aeb27ddf30420e620beb8e6725d83208f">More...</a><br /></td></tr>
<tr class="separator:aeb27ddf30420e620beb8e6725d83208f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134e54042165751a5e5369b4631c90eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a134e54042165751a5e5369b4631c90eb">Rewriter</a> = std::function&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>(const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a134e54042165751a5e5369b4631c90eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>Rewriter</code> is a function from an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">Expression</a> to an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">Expression</a>.  <a href="#a134e54042165751a5e5369b4631c90eb">More...</a><br /></td></tr>
<tr class="separator:a134e54042165751a5e5369b4631c90eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aebde9bdda9a428ef1bab6175954d30fa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30fa">ExpressionKind</a> { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faacb17869fe51048b5a5c4c6106551a255">Constant</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa5a92344ee95acf10c31901b36418be77">Var</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faaec211f7c20af43e742bf2570c3cb84f9">Add</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa62b6d55816cf737bfc6f42e60df1a3f2">Mul</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa43d11850893d2fe84a1e618121c1cc0a">Div</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faace0be71e33226e4c1db2bcea5959f16b">Log</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa1e34af023adeb7d5f484f8eb4b9826b6">Abs</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faacad39a154bffb61175f674d6eefaf6d0">Exp</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faaae77f3ad25595e35b327334d89410054">Sqrt</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa8be6d3e955290ee50c00a4bc92aa7749">Pow</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa0986d137604183312e6d3599578bc6cd">Sin</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faaffca562be079b9e4e41ea9d6a86c582b">Cos</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa1266b4e6f81e60733ec6c717e0181f60">Tan</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa76cfc54de4e2b9cde17334c821217d11">Asin</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faaed4629033ecb516ed7d1536e162030bb">Acos</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faac9968ab1fa8103acbb3a4f22265f2def">Atan</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa5816dfcaf3b6dbb486ef9c8c006ff613">Atan2</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa98ed804abf4edd1f3be3fa894fa8cc3d">Sinh</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa4371c3565b771b40c187487cc0190392">Cosh</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faacc132a41cab5676334f353a22a0aa5c5">Tanh</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa78d811e98514cd165dda532286610fd2">Min</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa6a061313d22e51e0f25b7cd4dc065233">Max</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faab95a01ffffa8fcdd2a9af961937c097c">Ceil</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faaf3f6d0343d56ce88ce7958170ed05cb3">Floor</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faaaff6933d8331eca27edc911467980c9c">IfThenElse</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa7ecfb3bf076a6a9635f975fe96ac97fd">NaN</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30faa2e59a51ac43bc3415c1b8ce7b3f98579">UninterpretedFunction</a>
<br />
 }</td></tr>
<tr class="memdesc:aebde9bdda9a428ef1bab6175954d30fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kinds of symbolic expressions.  <a href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30fa">More...</a><br /></td></tr>
<tr class="separator:aebde9bdda9a428ef1bab6175954d30fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6869e7044dd90be5d972ee7dd4e821b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a> { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6af8320b26d30ab433c5a54546d21f414c">False</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6af827cf462f62848df37c5e1e94a4da74">True</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a5a92344ee95acf10c31901b36418be77">Var</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a3718b5ecf60aa0dba49e150e96cb1fc3">Eq</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6ae4ecc5da3c6dbb4448f25990dc609727">Neq</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a086cb8308e5a36e7c4ed1f8873ad801f">Gt</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a5dabfebb89e6e45a8cf8573d92746ed3">Geq</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a50033c15af7795cd6617f117b29d6922">Lt</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6abe5721bf93d718a79358217ec9b88176">Leq</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6ac33315685a0cba3ce53be378b3c7874b">And</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a3a2d5fe857d8f9541136a124c2edec6c">Or</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6aa74c05d080620f087c4e523977230666">Not</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a43cfe3c750a08acb91df1e3384548078">Forall</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6afd116e3418522ffc34d7423bc601510d">Isnan</a>, 
<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6a1fbc164d3e50b7fd20690a21f1b7b2f2">PositiveSemidefinite</a>
<br />
 }</td></tr>
<tr class="memdesc:a6869e7044dd90be5d972ee7dd4e821b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kinds of symbolic formulas.  <a href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">More...</a><br /></td></tr>
<tr class="separator:a6869e7044dd90be5d972ee7dd4e821b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a76deccd3cd3f64d9b875dd5116792c07"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a>, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a76deccd3cd3f64d9b875dd5116792c07">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;a, const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;b)</td></tr>
<tr class="memdesc:a76deccd3cd3f64d9b875dd5116792c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of two Chebyshev basis elements.  <a href="#a76deccd3cd3f64d9b875dd5116792c07">More...</a><br /></td></tr>
<tr class="separator:a76deccd3cd3f64d9b875dd5116792c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af975c2571c59b1d8b03b213a15096336"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af975c2571c59b1d8b03b213a15096336">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;m)</td></tr>
<tr class="separator:af975c2571c59b1d8b03b213a15096336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d454a069abf89b2a0b6c71222ec221"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a31d454a069abf89b2a0b6c71222ec221">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_polynomial.html">ChebyshevPolynomial</a> &amp;p)</td></tr>
<tr class="separator:a31d454a069abf89b2a0b6c71222ec221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b9a5af49a6b9d6140189a132c4c2d7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a87b9a5af49a6b9d6140189a132c4c2d7">EvaluateChebyshevPolynomial</a> (double variable_val, <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="memdesc:a87b9a5af49a6b9d6140189a132c4c2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a Chebyshev polynomial at a given value.  <a href="#a87b9a5af49a6b9d6140189a132c4c2d7">More...</a><br /></td></tr>
<tr class="separator:a87b9a5af49a6b9d6140189a132c4c2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d07751d060ddf51dad4702d441f651a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__codegen.html#ga2d07751d060ddf51dad4702d441f651a">CodeGen</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;parameters, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ga2d07751d060ddf51dad4702d441f651a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given symbolic expression <code>e</code>, generates two C functions, <code>&lt;function_name&gt;</code> and <code>&lt;function_name&gt;_meta</code>.  <a href="group__codegen.html#ga2d07751d060ddf51dad4702d441f651a">More...</a><br /></td></tr>
<tr class="separator:ga2d07751d060ddf51dad4702d441f651a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga141de7c1e3ce45784c62e57a034a71ac"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ga141de7c1e3ce45784c62e57a034a71ac"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__codegen.html#ga141de7c1e3ce45784c62e57a034a71ac">CodeGen</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;parameters, const Eigen::PlainObjectBase&lt; Derived &gt; &amp;M)</td></tr>
<tr class="memdesc:ga141de7c1e3ce45784c62e57a034a71ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given symbolic dense matrix <code>M</code>, generates two C functions, <code>&lt;function_name&gt;</code> and <code>&lt;function_name&gt;_meta</code>.  <a href="group__codegen.html#ga141de7c1e3ce45784c62e57a034a71ac">More...</a><br /></td></tr>
<tr class="separator:ga141de7c1e3ce45784c62e57a034a71ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada538db5c08eaa47546d2df1c6f442cb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__codegen.html#gada538db5c08eaa47546d2df1c6f442cb">CodeGen</a> (const std::string &amp;function_name, const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;parameters, const Eigen::Ref&lt; const Eigen::SparseMatrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Eigen::ColMajor &gt;&gt; &amp;M)</td></tr>
<tr class="memdesc:gada538db5c08eaa47546d2df1c6f442cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given symbolic column-major sparse matrix <code>M</code>, generates two C functions, <code>&lt;function_name&gt;</code> and <code>&lt;function_name&gt;_meta</code>.  <a href="group__codegen.html#gada538db5c08eaa47546d2df1c6f442cb">More...</a><br /></td></tr>
<tr class="separator:gada538db5c08eaa47546d2df1c6f442cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c01361f464b3eae396f7d1a0e92c85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa6c01361f464b3eae396f7d1a0e92c85">DecomposeLinearExpressions</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;expressions, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;vars, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt; M)</td></tr>
<tr class="memdesc:aa6c01361f464b3eae396f7d1a0e92c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes <code>expressions</code> into <code>M</code> * <code>vars</code>.  <a href="#aa6c01361f464b3eae396f7d1a0e92c85">More...</a><br /></td></tr>
<tr class="separator:aa6c01361f464b3eae396f7d1a0e92c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c152941a4e06624bac5926fac2d4e32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0c152941a4e06624bac5926fac2d4e32">DecomposeAffineExpressions</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;expressions, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;vars, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt; M, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt; v)</td></tr>
<tr class="memdesc:a0c152941a4e06624bac5926fac2d4e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes <code>expressions</code> into <code>M</code> * <code>vars</code> + <code>v</code>.  <a href="#a0c152941a4e06624bac5926fac2d4e32">More...</a><br /></td></tr>
<tr class="separator:a0c152941a4e06624bac5926fac2d4e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50e3bc4e34ea64ae4d7065ad1fc72ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af50e3bc4e34ea64ae4d7065ad1fc72ac">PopulateRandomVariables</a> (<a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> env, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;variables, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *random_generator)</td></tr>
<tr class="memdesc:af50e3bc4e34ea64ae4d7065ad1fc72ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the environment <code>env</code> by sampling values for the unassigned random variables in <code>variables</code> using <code>random_generator</code>.  <a href="#af50e3bc4e34ea64ae4d7065ad1fc72ac">More...</a><br /></td></tr>
<tr class="separator:af50e3bc4e34ea64ae4d7065ad1fc72ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b5e99a86a85837124c6a006f7ec60a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a70b5e99a86a85837124c6a006f7ec60a">operator&lt;</a> (<a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30fa">ExpressionKind</a> k1, <a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30fa">ExpressionKind</a> k2)</td></tr>
<tr class="memdesc:a70b5e99a86a85837124c6a006f7ec60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total ordering between ExpressionKinds.  <a href="#a70b5e99a86a85837124c6a006f7ec60a">More...</a><br /></td></tr>
<tr class="separator:a70b5e99a86a85837124c6a006f7ec60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3293ffe3812fbfa2dbd63263fcf6c4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af3293ffe3812fbfa2dbd63263fcf6c4c">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:af3293ffe3812fbfa2dbd63263fcf6c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1519bc7275ec68c904b395067f8ff775"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1519bc7275ec68c904b395067f8ff775">operator+=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a1519bc7275ec68c904b395067f8ff775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105ae15b8e85984cf3ae81a7b67de38c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a105ae15b8e85984cf3ae81a7b67de38c">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a105ae15b8e85984cf3ae81a7b67de38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d3a7da7b3275333a0f2d67d649ead8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab8d3a7da7b3275333a0f2d67d649ead8">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:ab8d3a7da7b3275333a0f2d67d649ead8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380b68d6baf2cb5ab4212e435d1104ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a380b68d6baf2cb5ab4212e435d1104ee">operator-=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a380b68d6baf2cb5ab4212e435d1104ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554e434566b78163855f96829c244e37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a554e434566b78163855f96829c244e37">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a554e434566b78163855f96829c244e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbec6a09664cb563d86071a7be38913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1dbec6a09664cb563d86071a7be38913">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a1dbec6a09664cb563d86071a7be38913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee2268a69d74bce563c043848528741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6ee2268a69d74bce563c043848528741">operator *=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a6ee2268a69d74bce563c043848528741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e7c74e8b9ea1c9c5843c590e388009"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a43e7c74e8b9ea1c9c5843c590e388009">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a43e7c74e8b9ea1c9c5843c590e388009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5d6073354479ca8e507536cd36f844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1c5d6073354479ca8e507536cd36f844">operator/=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;lhs, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a1c5d6073354479ca8e507536cd36f844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6702577f951bca3006ab02f3313484e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab6702577f951bca3006ab02f3313484e">log</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:ab6702577f951bca3006ab02f3313484e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ba050d5b6f088d5fe578396b3ad646"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a24ba050d5b6f088d5fe578396b3ad646">abs</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a24ba050d5b6f088d5fe578396b3ad646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683b7c0db1ce737fc0e3af3323a4fed1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a683b7c0db1ce737fc0e3af3323a4fed1">exp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a683b7c0db1ce737fc0e3af3323a4fed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a5c97c514e6a5cb74438c6c2f5e760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a65a5c97c514e6a5cb74438c6c2f5e760">sqrt</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a65a5c97c514e6a5cb74438c6c2f5e760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abe49c1083796a8b370bab55535aa72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3abe49c1083796a8b370bab55535aa72">pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a3abe49c1083796a8b370bab55535aa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90efdc7cf4be8bddc1fa365fb78b8e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a90efdc7cf4be8bddc1fa365fb78b8e4a">sin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a90efdc7cf4be8bddc1fa365fb78b8e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4d1b24311f37c799ef18498b95020c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6b4d1b24311f37c799ef18498b95020c">cos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a6b4d1b24311f37c799ef18498b95020c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9900f71e1c1ceb9d59553adfa2db2b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab9900f71e1c1ceb9d59553adfa2db2b5">tan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:ab9900f71e1c1ceb9d59553adfa2db2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12acbb0b86d35d1de9280e699d3999d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa12acbb0b86d35d1de9280e699d3999d">asin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:aa12acbb0b86d35d1de9280e699d3999d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6244fef922874b743a272fe683cf068b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6244fef922874b743a272fe683cf068b">acos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a6244fef922874b743a272fe683cf068b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5beb575f1104a060ab02a89544fef1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab5beb575f1104a060ab02a89544fef1d">atan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:ab5beb575f1104a060ab02a89544fef1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d536a13db7de62414f5279c60148aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a03d536a13db7de62414f5279c60148aa">atan2</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a03d536a13db7de62414f5279c60148aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d1119f8ec23bd6d918a984ce5820b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a96d1119f8ec23bd6d918a984ce5820b9">sinh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a96d1119f8ec23bd6d918a984ce5820b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d98cdd1dd5802fe6c341ecfe9c6cce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a79d98cdd1dd5802fe6c341ecfe9c6cce">cosh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a79d98cdd1dd5802fe6c341ecfe9c6cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb3ea44b1cf2fd877d782b8486d5aeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acbb3ea44b1cf2fd877d782b8486d5aeb">tanh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:acbb3ea44b1cf2fd877d782b8486d5aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368c7616ccd2ce8d1587aa7343575d52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a368c7616ccd2ce8d1587aa7343575d52">min</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a368c7616ccd2ce8d1587aa7343575d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6413d336e52ed76599cc96a8c87eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3f6413d336e52ed76599cc96a8c87eee">max</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a3f6413d336e52ed76599cc96a8c87eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4ba82d6dffb1c0c6f40a768f86eae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9d4ba82d6dffb1c0c6f40a768f86eae7">ceil</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a9d4ba82d6dffb1c0c6f40a768f86eae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b28c66fdf5d2b582a677660936abca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a56b28c66fdf5d2b582a677660936abca">floor</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a56b28c66fdf5d2b582a677660936abca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfe436e1c70779badecad19c8a039fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1dfe436e1c70779badecad19c8a039fe">if_then_else</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f_cond, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e_then, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e_else)</td></tr>
<tr class="separator:a1dfe436e1c70779badecad19c8a039fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986094e62cf81f5b0c1d4f33df8f8e3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a986094e62cf81f5b0c1d4f33df8f8e3f">uninterpreted_function</a> (std::string name, std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; arguments)</td></tr>
<tr class="memdesc:a986094e62cf81f5b0c1d4f33df8f8e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an uninterpreted-function expression with <code>name</code> and <code>arguments</code>.  <a href="#a986094e62cf81f5b0c1d4f33df8f8e3f">More...</a><br /></td></tr>
<tr class="separator:a986094e62cf81f5b0c1d4f33df8f8e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78354ef5dda9c52bbc103d57712c303e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a78354ef5dda9c52bbc103d57712c303e">swap</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;a, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;b)</td></tr>
<tr class="separator:a78354ef5dda9c52bbc103d57712c303e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a0c468c43eb087bc5e98af3c3ad278"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a30a0c468c43eb087bc5e98af3c3ad278">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="separator:a30a0c468c43eb087bc5e98af3c3ad278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f809da2a5c679df2b90aadedde5350"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae0f809da2a5c679df2b90aadedde5350">is_constant</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ae0f809da2a5c679df2b90aadedde5350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a constant expression.  <a href="#ae0f809da2a5c679df2b90aadedde5350">More...</a><br /></td></tr>
<tr class="separator:ae0f809da2a5c679df2b90aadedde5350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993384c5125c55ca3f5a11586a9bb675"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a993384c5125c55ca3f5a11586a9bb675">is_constant</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, double v)</td></tr>
<tr class="memdesc:a993384c5125c55ca3f5a11586a9bb675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a constant expression representing <code>v</code>.  <a href="#a993384c5125c55ca3f5a11586a9bb675">More...</a><br /></td></tr>
<tr class="separator:a993384c5125c55ca3f5a11586a9bb675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717f1ae4a1d038bc7870416276167f19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a717f1ae4a1d038bc7870416276167f19">is_zero</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a717f1ae4a1d038bc7870416276167f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is 0.0.  <a href="#a717f1ae4a1d038bc7870416276167f19">More...</a><br /></td></tr>
<tr class="separator:a717f1ae4a1d038bc7870416276167f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f342ca12fff0fb252625b2f62afe97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a45f342ca12fff0fb252625b2f62afe97">is_one</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a45f342ca12fff0fb252625b2f62afe97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is 1.0.  <a href="#a45f342ca12fff0fb252625b2f62afe97">More...</a><br /></td></tr>
<tr class="separator:a45f342ca12fff0fb252625b2f62afe97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef684b8834080c14e7dc13d497db9c22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aef684b8834080c14e7dc13d497db9c22">is_neg_one</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aef684b8834080c14e7dc13d497db9c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is -1.0.  <a href="#aef684b8834080c14e7dc13d497db9c22">More...</a><br /></td></tr>
<tr class="separator:aef684b8834080c14e7dc13d497db9c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c7e1bd2b1367487d36a6cd6871af0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a71c7e1bd2b1367487d36a6cd6871af0c">is_two</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a71c7e1bd2b1367487d36a6cd6871af0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is 2.0.  <a href="#a71c7e1bd2b1367487d36a6cd6871af0c">More...</a><br /></td></tr>
<tr class="separator:a71c7e1bd2b1367487d36a6cd6871af0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b9f0534ca861f03dbaa96ec1712f7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a92b9f0534ca861f03dbaa96ec1712f7f">is_nan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a92b9f0534ca861f03dbaa96ec1712f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is NaN.  <a href="#a92b9f0534ca861f03dbaa96ec1712f7f">More...</a><br /></td></tr>
<tr class="separator:a92b9f0534ca861f03dbaa96ec1712f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184038d04f0ab628e12fb53a6f7cb5d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a184038d04f0ab628e12fb53a6f7cb5d9">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a184038d04f0ab628e12fb53a6f7cb5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a variable expression.  <a href="#a184038d04f0ab628e12fb53a6f7cb5d9">More...</a><br /></td></tr>
<tr class="separator:a184038d04f0ab628e12fb53a6f7cb5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaf0abb22b9280fc9622bd2d488a3e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acdaf0abb22b9280fc9622bd2d488a3e1">is_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:acdaf0abb22b9280fc9622bd2d488a3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an addition expression.  <a href="#acdaf0abb22b9280fc9622bd2d488a3e1">More...</a><br /></td></tr>
<tr class="separator:acdaf0abb22b9280fc9622bd2d488a3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7c3de3be1c5f350b439dcdc7e8b24d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aee7c3de3be1c5f350b439dcdc7e8b24d">is_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aee7c3de3be1c5f350b439dcdc7e8b24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a multiplication expression.  <a href="#aee7c3de3be1c5f350b439dcdc7e8b24d">More...</a><br /></td></tr>
<tr class="separator:aee7c3de3be1c5f350b439dcdc7e8b24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ddcd6effc0d16b4ab5e71008a84fd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a60ddcd6effc0d16b4ab5e71008a84fd5">is_division</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a60ddcd6effc0d16b4ab5e71008a84fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a division expression.  <a href="#a60ddcd6effc0d16b4ab5e71008a84fd5">More...</a><br /></td></tr>
<tr class="separator:a60ddcd6effc0d16b4ab5e71008a84fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5dcbc71dc0b20b3debbeafdd5f1614"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8f5dcbc71dc0b20b3debbeafdd5f1614">is_log</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a8f5dcbc71dc0b20b3debbeafdd5f1614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a log expression.  <a href="#a8f5dcbc71dc0b20b3debbeafdd5f1614">More...</a><br /></td></tr>
<tr class="separator:a8f5dcbc71dc0b20b3debbeafdd5f1614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942b47a07cae421b3152f11536e6579c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a942b47a07cae421b3152f11536e6579c">is_abs</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a942b47a07cae421b3152f11536e6579c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an abs expression.  <a href="#a942b47a07cae421b3152f11536e6579c">More...</a><br /></td></tr>
<tr class="separator:a942b47a07cae421b3152f11536e6579c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f471231c119fee48c6dba7a2d5ab18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa8f471231c119fee48c6dba7a2d5ab18">is_exp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa8f471231c119fee48c6dba7a2d5ab18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an exp expression.  <a href="#aa8f471231c119fee48c6dba7a2d5ab18">More...</a><br /></td></tr>
<tr class="separator:aa8f471231c119fee48c6dba7a2d5ab18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe3f1787c60c08adf6af1e1f29ff6cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acfe3f1787c60c08adf6af1e1f29ff6cf">is_sqrt</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:acfe3f1787c60c08adf6af1e1f29ff6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a square-root expression.  <a href="#acfe3f1787c60c08adf6af1e1f29ff6cf">More...</a><br /></td></tr>
<tr class="separator:acfe3f1787c60c08adf6af1e1f29ff6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceba5fef90cbd2790037fa685e3ffdce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aceba5fef90cbd2790037fa685e3ffdce">is_pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aceba5fef90cbd2790037fa685e3ffdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a power-function expression.  <a href="#aceba5fef90cbd2790037fa685e3ffdce">More...</a><br /></td></tr>
<tr class="separator:aceba5fef90cbd2790037fa685e3ffdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b9105cdfbe657bfe90eaf47d9e8f11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a23b9105cdfbe657bfe90eaf47d9e8f11">is_sin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a23b9105cdfbe657bfe90eaf47d9e8f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a sine expression.  <a href="#a23b9105cdfbe657bfe90eaf47d9e8f11">More...</a><br /></td></tr>
<tr class="separator:a23b9105cdfbe657bfe90eaf47d9e8f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208a1c5a02e5bff9ba66d7b7db588ba0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a208a1c5a02e5bff9ba66d7b7db588ba0">is_cos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a208a1c5a02e5bff9ba66d7b7db588ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a cosine expression.  <a href="#a208a1c5a02e5bff9ba66d7b7db588ba0">More...</a><br /></td></tr>
<tr class="separator:a208a1c5a02e5bff9ba66d7b7db588ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd352ee762ef421653cd8941fa5ce22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8dd352ee762ef421653cd8941fa5ce22">is_tan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a8dd352ee762ef421653cd8941fa5ce22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a tangent expression.  <a href="#a8dd352ee762ef421653cd8941fa5ce22">More...</a><br /></td></tr>
<tr class="separator:a8dd352ee762ef421653cd8941fa5ce22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa5bc007d1b065d2afc30e2f6ced7a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acfa5bc007d1b065d2afc30e2f6ced7a9">is_asin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:acfa5bc007d1b065d2afc30e2f6ced7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an arcsine expression.  <a href="#acfa5bc007d1b065d2afc30e2f6ced7a9">More...</a><br /></td></tr>
<tr class="separator:acfa5bc007d1b065d2afc30e2f6ced7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fcf1da78e47a4afb20e0a4e85ac7dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac2fcf1da78e47a4afb20e0a4e85ac7dd">is_acos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ac2fcf1da78e47a4afb20e0a4e85ac7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an arccosine expression.  <a href="#ac2fcf1da78e47a4afb20e0a4e85ac7dd">More...</a><br /></td></tr>
<tr class="separator:ac2fcf1da78e47a4afb20e0a4e85ac7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a94b6eea9d24d8415703bfc07a1c05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af5a94b6eea9d24d8415703bfc07a1c05">is_atan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:af5a94b6eea9d24d8415703bfc07a1c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an arctangent expression.  <a href="#af5a94b6eea9d24d8415703bfc07a1c05">More...</a><br /></td></tr>
<tr class="separator:af5a94b6eea9d24d8415703bfc07a1c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac54d0c8fa80bf084505f90528c9f5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4ac54d0c8fa80bf084505f90528c9f5e">is_atan2</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a4ac54d0c8fa80bf084505f90528c9f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an arctangent2 expression.  <a href="#a4ac54d0c8fa80bf084505f90528c9f5e">More...</a><br /></td></tr>
<tr class="separator:a4ac54d0c8fa80bf084505f90528c9f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66cbc3a6c390d0d04bf3839e4377850"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa66cbc3a6c390d0d04bf3839e4377850">is_sinh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa66cbc3a6c390d0d04bf3839e4377850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a hyperbolic-sine expression.  <a href="#aa66cbc3a6c390d0d04bf3839e4377850">More...</a><br /></td></tr>
<tr class="separator:aa66cbc3a6c390d0d04bf3839e4377850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e09e7b40ee56f60a121014f02603fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a93e09e7b40ee56f60a121014f02603fb">is_cosh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a93e09e7b40ee56f60a121014f02603fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a hyperbolic-cosine expression.  <a href="#a93e09e7b40ee56f60a121014f02603fb">More...</a><br /></td></tr>
<tr class="separator:a93e09e7b40ee56f60a121014f02603fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da61282d0c5ccefeaa2068d84a19273"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9da61282d0c5ccefeaa2068d84a19273">is_tanh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a9da61282d0c5ccefeaa2068d84a19273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a hyperbolic-tangent expression.  <a href="#a9da61282d0c5ccefeaa2068d84a19273">More...</a><br /></td></tr>
<tr class="separator:a9da61282d0c5ccefeaa2068d84a19273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911dd37b6ac155198d923500bbc97135"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a911dd37b6ac155198d923500bbc97135">is_min</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a911dd37b6ac155198d923500bbc97135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a min expression.  <a href="#a911dd37b6ac155198d923500bbc97135">More...</a><br /></td></tr>
<tr class="separator:a911dd37b6ac155198d923500bbc97135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a84ca31e769b94d1adcc69789826934"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0a84ca31e769b94d1adcc69789826934">is_max</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a0a84ca31e769b94d1adcc69789826934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a max expression.  <a href="#a0a84ca31e769b94d1adcc69789826934">More...</a><br /></td></tr>
<tr class="separator:a0a84ca31e769b94d1adcc69789826934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1525a5e26f678130b369bc1414d9891a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1525a5e26f678130b369bc1414d9891a">is_ceil</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a1525a5e26f678130b369bc1414d9891a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a ceil expression.  <a href="#a1525a5e26f678130b369bc1414d9891a">More...</a><br /></td></tr>
<tr class="separator:a1525a5e26f678130b369bc1414d9891a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7a6656f58842adedcc8024b14bc06c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abc7a6656f58842adedcc8024b14bc06c">is_floor</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:abc7a6656f58842adedcc8024b14bc06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is a floor expression.  <a href="#abc7a6656f58842adedcc8024b14bc06c">More...</a><br /></td></tr>
<tr class="separator:abc7a6656f58842adedcc8024b14bc06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12b990bcc72a788e6d8176894d0d8a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa12b990bcc72a788e6d8176894d0d8a2">is_if_then_else</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa12b990bcc72a788e6d8176894d0d8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an if-then-else expression.  <a href="#aa12b990bcc72a788e6d8176894d0d8a2">More...</a><br /></td></tr>
<tr class="separator:aa12b990bcc72a788e6d8176894d0d8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c97ad4e8b82b5c045695eb76fc1256"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab6c97ad4e8b82b5c045695eb76fc1256">is_uninterpreted_function</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ab6c97ad4e8b82b5c045695eb76fc1256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>e</code> is an uninterpreted-function expression.  <a href="#ab6c97ad4e8b82b5c045695eb76fc1256">More...</a><br /></td></tr>
<tr class="separator:ab6c97ad4e8b82b5c045695eb76fc1256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b317498b02b74b0937f7cdb31b0ef52"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1b317498b02b74b0937f7cdb31b0ef52">get_constant_value</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a1b317498b02b74b0937f7cdb31b0ef52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant value of the constant expression <code>e</code>.  <a href="#a1b317498b02b74b0937f7cdb31b0ef52">More...</a><br /></td></tr>
<tr class="separator:a1b317498b02b74b0937f7cdb31b0ef52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd6758ef1c73c0ab835a7e8c6aad187"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aebd6758ef1c73c0ab835a7e8c6aad187">get_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aebd6758ef1c73c0ab835a7e8c6aad187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the embedded variable in the variable expression <code>e</code>.  <a href="#aebd6758ef1c73c0ab835a7e8c6aad187">More...</a><br /></td></tr>
<tr class="separator:aebd6758ef1c73c0ab835a7e8c6aad187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af785f16951e394debcd11a9225ef469c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af785f16951e394debcd11a9225ef469c">get_argument</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:af785f16951e394debcd11a9225ef469c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the argument in the unary expression <code>e</code>.  <a href="#af785f16951e394debcd11a9225ef469c">More...</a><br /></td></tr>
<tr class="separator:af785f16951e394debcd11a9225ef469c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f904009d1e4f9ad6f5ed22a4e4c41b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a38f904009d1e4f9ad6f5ed22a4e4c41b">get_first_argument</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a38f904009d1e4f9ad6f5ed22a4e4c41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first argument of the binary expression <code>e</code>.  <a href="#a38f904009d1e4f9ad6f5ed22a4e4c41b">More...</a><br /></td></tr>
<tr class="separator:a38f904009d1e4f9ad6f5ed22a4e4c41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da800513f72f528dffddd89f9263b3a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8da800513f72f528dffddd89f9263b3a">get_second_argument</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a8da800513f72f528dffddd89f9263b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the second argument of the binary expression <code>e</code>.  <a href="#a8da800513f72f528dffddd89f9263b3a">More...</a><br /></td></tr>
<tr class="separator:a8da800513f72f528dffddd89f9263b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3d5ca2b76943558837ffa2a47162e1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afe3d5ca2b76943558837ffa2a47162e1">get_constant_in_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:afe3d5ca2b76943558837ffa2a47162e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant part of the addition expression <code>e</code>.  <a href="#afe3d5ca2b76943558837ffa2a47162e1">More...</a><br /></td></tr>
<tr class="separator:afe3d5ca2b76943558837ffa2a47162e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20be18c2d4942e2e64987a30c7e37c1d"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a20be18c2d4942e2e64987a30c7e37c1d">get_expr_to_coeff_map_in_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a20be18c2d4942e2e64987a30c7e37c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map from an expression to its coefficient in the addition expression <code>e</code>.  <a href="#a20be18c2d4942e2e64987a30c7e37c1d">More...</a><br /></td></tr>
<tr class="separator:a20be18c2d4942e2e64987a30c7e37c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56c1d979ba67b0eceaac7f0ba54235c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af56c1d979ba67b0eceaac7f0ba54235c">get_constant_in_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:af56c1d979ba67b0eceaac7f0ba54235c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant part of the multiplication expression <code>e</code>.  <a href="#af56c1d979ba67b0eceaac7f0ba54235c">More...</a><br /></td></tr>
<tr class="separator:af56c1d979ba67b0eceaac7f0ba54235c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffaee70b54f60b4d1b9f1771f78ddf7"><td class="memItemLeft" align="right" valign="top">const std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acffaee70b54f60b4d1b9f1771f78ddf7">get_base_to_exponent_map_in_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:acffaee70b54f60b4d1b9f1771f78ddf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map from a base expression to its exponent expression in the multiplication expression <code>e</code>.  <a href="#acffaee70b54f60b4d1b9f1771f78ddf7">More...</a><br /></td></tr>
<tr class="separator:acffaee70b54f60b4d1b9f1771f78ddf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901d5aa27994e415a1eb4145968dc25c"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a901d5aa27994e415a1eb4145968dc25c">get_uninterpreted_function_name</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a901d5aa27994e415a1eb4145968dc25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of an uninterpreted-function expression <code>e</code>.  <a href="#a901d5aa27994e415a1eb4145968dc25c">More...</a><br /></td></tr>
<tr class="separator:a901d5aa27994e415a1eb4145968dc25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374ac54710c8173da5ca4b2d7eeec520"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a374ac54710c8173da5ca4b2d7eeec520">get_uninterpreted_function_arguments</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a374ac54710c8173da5ca4b2d7eeec520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the arguments of an uninterpreted-function expression <code>e</code>.  <a href="#a374ac54710c8173da5ca4b2d7eeec520">More...</a><br /></td></tr>
<tr class="separator:a374ac54710c8173da5ca4b2d7eeec520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251f0e1c8ae1894d0a09ccaeb5e79a41"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a251f0e1c8ae1894d0a09ccaeb5e79a41">get_conditional_formula</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a251f0e1c8ae1894d0a09ccaeb5e79a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conditional formula in the if-then-else expression <code>e</code>.  <a href="#a251f0e1c8ae1894d0a09ccaeb5e79a41">More...</a><br /></td></tr>
<tr class="separator:a251f0e1c8ae1894d0a09ccaeb5e79a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd312bc518c0dd20a656021aef3e3c37"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abd312bc518c0dd20a656021aef3e3c37">get_then_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:abd312bc518c0dd20a656021aef3e3c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'then' expression in the if-then-else expression <code>e</code>.  <a href="#abd312bc518c0dd20a656021aef3e3c37">More...</a><br /></td></tr>
<tr class="separator:abd312bc518c0dd20a656021aef3e3c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a1c7093f3e8d89930f0aa748ee188c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae1a1c7093f3e8d89930f0aa748ee188c">get_else_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ae1a1c7093f3e8d89930f0aa748ee188c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'else' expression in the if-then-else expression <code>e</code>.  <a href="#ae1a1c7093f3e8d89930f0aa748ee188c">More...</a><br /></td></tr>
<tr class="separator:ae1a1c7093f3e8d89930f0aa748ee188c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9084a43cdfa02b10cb216c7bfff0dcb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9084a43cdfa02b10cb216c7bfff0dcb3">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="separator:a9084a43cdfa02b10cb216c7bfff0dcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac306b9a9b7ace256330ae3ab8deaafef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac306b9a9b7ace256330ae3ab8deaafef">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="separator:ac306b9a9b7ace256330ae3ab8deaafef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2857d827b306fc80cf6c23e14f211c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aed2857d827b306fc80cf6c23e14f211c">TaylorExpand</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;a, <a class="el" href="classint.html">int</a> order)</td></tr>
<tr class="memdesc:aed2857d827b306fc80cf6c23e14f211c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Taylor series expansion of <code>f</code> around <code>a</code> of order <code>order</code>.  <a href="#aed2857d827b306fc80cf6c23e14f211c">More...</a><br /></td></tr>
<tr class="separator:aed2857d827b306fc80cf6c23e14f211c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9672ecf8933b210eeedda1d56e670c8"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:af9672ecf8933b210eeedda1d56e670c8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt;::value &amp;&amp;std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt;::value &amp;&amp;std::is_same&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::value &amp;&amp;std::is_same&lt; typename MatrixR::Scalar, double &gt;::value, Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af9672ecf8933b210eeedda1d56e670c8">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:af9672ecf8933b210eeedda1d56e670c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following seven operations:  <a href="#af9672ecf8933b210eeedda1d56e670c8">More...</a><br /></td></tr>
<tr class="separator:af9672ecf8933b210eeedda1d56e670c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106c3f1e5e8ffaf1d667a7c1858753ad"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:a106c3f1e5e8ffaf1d667a7c1858753ad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt;::value &amp;&amp;std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt;::value &amp;&amp;std::is_same&lt; typename MatrixL::Scalar, double &gt;::value &amp;&amp;std::is_same&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::value, Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a106c3f1e5e8ffaf1d667a7c1858753ad">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a106c3f1e5e8ffaf1d667a7c1858753ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following seven operations:  <a href="#a106c3f1e5e8ffaf1d667a7c1858753ad">More...</a><br /></td></tr>
<tr class="separator:a106c3f1e5e8ffaf1d667a7c1858753ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9128a895c3456d01b9c3c5b76bedf68b"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:a9128a895c3456d01b9c3c5b76bedf68b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt;::value &amp;&amp;std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt;::value &amp;&amp;std::is_same&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::value &amp;&amp;std::is_same&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::value, Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9128a895c3456d01b9c3c5b76bedf68b">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a9128a895c3456d01b9c3c5b76bedf68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following seven operations:  <a href="#a9128a895c3456d01b9c3c5b76bedf68b">More...</a><br /></td></tr>
<tr class="separator:a9128a895c3456d01b9c3c5b76bedf68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd1b0e780b38b3c3538e516ba979f89"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:a9bd1b0e780b38b3c3538e516ba979f89"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt;::value &amp;&amp;std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt;::value &amp;&amp;std::is_same&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::value &amp;&amp;std::is_same&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::value, Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9bd1b0e780b38b3c3538e516ba979f89">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a9bd1b0e780b38b3c3538e516ba979f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following seven operations:  <a href="#a9bd1b0e780b38b3c3538e516ba979f89">More...</a><br /></td></tr>
<tr class="separator:a9bd1b0e780b38b3c3538e516ba979f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa379ca3565b4c97f5124bc78599febf4"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:aa379ca3565b4c97f5124bc78599febf4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt;::value &amp;&amp;std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt;::value &amp;&amp;std::is_same&lt; typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::value &amp;&amp;std::is_same&lt; typename MatrixR::Scalar, double &gt;::value, Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa379ca3565b4c97f5124bc78599febf4">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:aa379ca3565b4c97f5124bc78599febf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following seven operations:  <a href="#aa379ca3565b4c97f5124bc78599febf4">More...</a><br /></td></tr>
<tr class="separator:aa379ca3565b4c97f5124bc78599febf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c03c6df6e36906365f51623fd53bdb6"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:a4c03c6df6e36906365f51623fd53bdb6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixL &gt;, MatrixL &gt;::value &amp;&amp;std::is_base_of&lt; Eigen::MatrixBase&lt; MatrixR &gt;, MatrixR &gt;::value &amp;&amp;std::is_same&lt; typename MatrixL::Scalar, double &gt;::value &amp;&amp;std::is_same&lt; typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::value, Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4c03c6df6e36906365f51623fd53bdb6">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a4c03c6df6e36906365f51623fd53bdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following seven operations:  <a href="#a4c03c6df6e36906365f51623fd53bdb6">More...</a><br /></td></tr>
<tr class="separator:a4c03c6df6e36906365f51623fd53bdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac78e96efaa07849f158591192b2dca"><td class="memTemplParams" colspan="2">template&lt;int Dim, int LhsMode, int RhsMode, int LhsOptions, int RhsOptions&gt; </td></tr>
<tr class="memitem:adac78e96efaa07849f158591192b2dca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adac78e96efaa07849f158591192b2dca">operator *</a> (const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, LhsMode, LhsOptions &gt; &amp;t1, const Eigen::Transform&lt; double, Dim, RhsMode, RhsOptions &gt; &amp;t2)</td></tr>
<tr class="memdesc:adac78e96efaa07849f158591192b2dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform&lt;double&gt; * Transform&lt;Expression&gt; =&gt; Transform&lt;Expression&gt;  <a href="#adac78e96efaa07849f158591192b2dca">More...</a><br /></td></tr>
<tr class="separator:adac78e96efaa07849f158591192b2dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac410f7e82c9d06e796d7fcb4508f5e4"><td class="memTemplParams" colspan="2">template&lt;int Dim, int LhsMode, int RhsMode, int LhsOptions, int RhsOptions&gt; </td></tr>
<tr class="memitem:aac410f7e82c9d06e796d7fcb4508f5e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aac410f7e82c9d06e796d7fcb4508f5e4">operator *</a> (const Eigen::Transform&lt; double, Dim, LhsMode, LhsOptions &gt; &amp;t1, const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, RhsMode, RhsOptions &gt; &amp;t2)</td></tr>
<tr class="memdesc:aac410f7e82c9d06e796d7fcb4508f5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform&lt;Expression&gt; * Transform&lt;double&gt; =&gt; Transform&lt;Expression&gt;  <a href="#aac410f7e82c9d06e796d7fcb4508f5e4">More...</a><br /></td></tr>
<tr class="separator:aac410f7e82c9d06e796d7fcb4508f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac085a32409b678f96a69f5e50fc00ed7"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac085a32409b678f96a69f5e50fc00ed7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::value, Eigen::Matrix&lt; double, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac085a32409b678f96a69f5e50fc00ed7">Evaluate</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;env=<a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>{}, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *random_generator=nullptr)</td></tr>
<tr class="memdesc:ac085a32409b678f96a69f5e50fc00ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a symbolic matrix <code>m</code> using <code>env</code> and <code>random_generator</code>.  <a href="#ac085a32409b678f96a69f5e50fc00ed7">More...</a><br /></td></tr>
<tr class="separator:ac085a32409b678f96a69f5e50fc00ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0355c03127b4d0312e5f761a0f530a"><td class="memItemLeft" align="right" valign="top">Eigen::SparseMatrix&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8f0355c03127b4d0312e5f761a0f530a">Evaluate</a> (const Eigen::Ref&lt; const Eigen::SparseMatrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;env=<a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>{})</td></tr>
<tr class="memdesc:a8f0355c03127b4d0312e5f761a0f530a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates <code>m</code> using a given environment (by default, an empty environment).  <a href="#a8f0355c03127b4d0312e5f761a0f530a">More...</a><br /></td></tr>
<tr class="separator:a8f0355c03127b4d0312e5f761a0f530a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9d2f72a70233db108561adf734ecdd"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a6d9d2f72a70233db108561adf734ecdd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6d9d2f72a70233db108561adf734ecdd">Substitute</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const <a class="el" href="namespacedrake_1_1symbolic.html#acbfe43d34e6c71c503d4de11da53bbb7">Substitution</a> &amp;subst)</td></tr>
<tr class="memdesc:a6d9d2f72a70233db108561adf734ecdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes a symbolic matrix <code>m</code> using a given substitution <code>subst</code>.  <a href="#a6d9d2f72a70233db108561adf734ecdd">More...</a><br /></td></tr>
<tr class="separator:a6d9d2f72a70233db108561adf734ecdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d45b86ae4b7872576bb3fac8b22ca94"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a7d45b86ae4b7872576bb3fac8b22ca94"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7d45b86ae4b7872576bb3fac8b22ca94">Substitute</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a7d45b86ae4b7872576bb3fac8b22ca94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitutes <code>var</code> with <code>e</code> in a symbolic matrix <code>m</code>.  <a href="#a7d45b86ae4b7872576bb3fac8b22ca94">More...</a><br /></td></tr>
<tr class="separator:a7d45b86ae4b7872576bb3fac8b22ca94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb71f55634f4f2430d1abb2df5b92d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7eb71f55634f4f2430d1abb2df5b92d8">GetVariableVector</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;evec)</td></tr>
<tr class="memdesc:a7eb71f55634f4f2430d1abb2df5b92d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a vector of variables from the vector of variable expressions.  <a href="#a7eb71f55634f4f2430d1abb2df5b92d8">More...</a><br /></td></tr>
<tr class="separator:a7eb71f55634f4f2430d1abb2df5b92d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f56048cec3e53d98346a36df54a006"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad0f56048cec3e53d98346a36df54a006">Jacobian</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;f, const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;vars)</td></tr>
<tr class="memdesc:ad0f56048cec3e53d98346a36df54a006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>.  <a href="#ad0f56048cec3e53d98346a36df54a006">More...</a><br /></td></tr>
<tr class="separator:ad0f56048cec3e53d98346a36df54a006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a3b8e65cfeb6d57deb7fe9d70f1d4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a71a3b8e65cfeb6d57deb7fe9d70f1d4d">Jacobian</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;f, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;vars)</td></tr>
<tr class="memdesc:a71a3b8e65cfeb6d57deb7fe9d70f1d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>.  <a href="#a71a3b8e65cfeb6d57deb7fe9d70f1d4d">More...</a><br /></td></tr>
<tr class="separator:a71a3b8e65cfeb6d57deb7fe9d70f1d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c0db41d89c9257d2fbfc4928fa5bd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a13c0db41d89c9257d2fbfc4928fa5bd7">IsAffine</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars)</td></tr>
<tr class="memdesc:a13c0db41d89c9257d2fbfc4928fa5bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if every element in <code>m</code> is affine in <code>vars</code>.  <a href="#a13c0db41d89c9257d2fbfc4928fa5bd7">More...</a><br /></td></tr>
<tr class="separator:a13c0db41d89c9257d2fbfc4928fa5bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8e94c7598bd59e6a5314ffbc3c7f59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9d8e94c7598bd59e6a5314ffbc3c7f59">IsAffine</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;m)</td></tr>
<tr class="memdesc:a9d8e94c7598bd59e6a5314ffbc3c7f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if every element in <code>m</code> is affine.  <a href="#a9d8e94c7598bd59e6a5314ffbc3c7f59">More...</a><br /></td></tr>
<tr class="separator:a9d8e94c7598bd59e6a5314ffbc3c7f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ebc87f878cdb6a3f0339711d591a26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab1ebc87f878cdb6a3f0339711d591a26">GetDistinctVariables</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:ab1ebc87f878cdb6a3f0339711d591a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distinct variables in the matrix of expressions.  <a href="#ab1ebc87f878cdb6a3f0339711d591a26">More...</a><br /></td></tr>
<tr class="separator:ab1ebc87f878cdb6a3f0339711d591a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d55ec6a55f554174d9bc45d7ed7f5c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ac3d55ec6a55f554174d9bc45d7ed7f5c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; Eigen::MatrixBase&lt; DerivedA &gt;, DerivedA &gt;::value &amp;&amp;std::is_base_of&lt; Eigen::MatrixBase&lt; DerivedB &gt;, DerivedB &gt;::value &amp;&amp;std::is_same&lt; typename DerivedA::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::value &amp;&amp;std::is_same&lt; typename DerivedB::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac3d55ec6a55f554174d9bc45d7ed7f5c">CheckStructuralEquality</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:ac3d55ec6a55f554174d9bc45d7ed7f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two Eigen::Matrix&lt;Expression&gt; <code>m1</code> and <code>m2</code> are structurally equal.  <a href="#ac3d55ec6a55f554174d9bc45d7ed7f5c">More...</a><br /></td></tr>
<tr class="separator:ac3d55ec6a55f554174d9bc45d7ed7f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0aaf128d1ed75cbab9c4ca238e0ae6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad0aaf128d1ed75cbab9c4ca238e0ae6c">is_integer</a> (double v)</td></tr>
<tr class="separator:ad0aaf128d1ed75cbab9c4ca238e0ae6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859d0e7196b00ffd99a347ff8a7d4d76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a859d0e7196b00ffd99a347ff8a7d4d76">is_positive_integer</a> (double v)</td></tr>
<tr class="separator:a859d0e7196b00ffd99a347ff8a7d4d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0169dcd3572d7e3c626f154d1db8b7a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0169dcd3572d7e3c626f154d1db8b7a3">is_non_negative_integer</a> (double v)</td></tr>
<tr class="separator:a0169dcd3572d7e3c626f154d1db8b7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0cfbc77e62d7ffd76914817afcfbb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2b0cfbc77e62d7ffd76914817afcfbb8">is_constant</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a2b0cfbc77e62d7ffd76914817afcfbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a constant expression.  <a href="#a2b0cfbc77e62d7ffd76914817afcfbb8">More...</a><br /></td></tr>
<tr class="separator:a2b0cfbc77e62d7ffd76914817afcfbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2196a9e544a94c2e7c277b18c7b7716b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2196a9e544a94c2e7c277b18c7b7716b">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a2196a9e544a94c2e7c277b18c7b7716b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a variable expression.  <a href="#a2196a9e544a94c2e7c277b18c7b7716b">More...</a><br /></td></tr>
<tr class="separator:a2196a9e544a94c2e7c277b18c7b7716b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dfc929a3e771ece5e5d20312e96abd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae9dfc929a3e771ece5e5d20312e96abd">is_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ae9dfc929a3e771ece5e5d20312e96abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an addition expression.  <a href="#ae9dfc929a3e771ece5e5d20312e96abd">More...</a><br /></td></tr>
<tr class="separator:ae9dfc929a3e771ece5e5d20312e96abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a56ae8b296df9d9285c93e00b82dc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a19a56ae8b296df9d9285c93e00b82dc7">is_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a19a56ae8b296df9d9285c93e00b82dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an multiplication expression.  <a href="#a19a56ae8b296df9d9285c93e00b82dc7">More...</a><br /></td></tr>
<tr class="separator:a19a56ae8b296df9d9285c93e00b82dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eddc430d6a33fc13db8d53a51bdfd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac1eddc430d6a33fc13db8d53a51bdfd3">is_division</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ac1eddc430d6a33fc13db8d53a51bdfd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a division expression.  <a href="#ac1eddc430d6a33fc13db8d53a51bdfd3">More...</a><br /></td></tr>
<tr class="separator:ac1eddc430d6a33fc13db8d53a51bdfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee17d0564b198d4c784811945707ddbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aee17d0564b198d4c784811945707ddbf">is_log</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:aee17d0564b198d4c784811945707ddbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a log expression.  <a href="#aee17d0564b198d4c784811945707ddbf">More...</a><br /></td></tr>
<tr class="separator:aee17d0564b198d4c784811945707ddbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6c5829257cf5c28c162ffad2bd3f58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8e6c5829257cf5c28c162ffad2bd3f58">is_abs</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a8e6c5829257cf5c28c162ffad2bd3f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an absolute-value-function expression.  <a href="#a8e6c5829257cf5c28c162ffad2bd3f58">More...</a><br /></td></tr>
<tr class="separator:a8e6c5829257cf5c28c162ffad2bd3f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1633315c1c26cbd8411a7ea0d860a9c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1633315c1c26cbd8411a7ea0d860a9c2">is_exp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a1633315c1c26cbd8411a7ea0d860a9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an exp expression.  <a href="#a1633315c1c26cbd8411a7ea0d860a9c2">More...</a><br /></td></tr>
<tr class="separator:a1633315c1c26cbd8411a7ea0d860a9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a645e5342fb66cd3fc7de8c38eac6b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6a645e5342fb66cd3fc7de8c38eac6b4">is_sqrt</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a6a645e5342fb66cd3fc7de8c38eac6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a square-root expression.  <a href="#a6a645e5342fb66cd3fc7de8c38eac6b4">More...</a><br /></td></tr>
<tr class="separator:a6a645e5342fb66cd3fc7de8c38eac6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae3c8118eef15cc3a9dafe14c6d48c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1ae3c8118eef15cc3a9dafe14c6d48c2">is_pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a1ae3c8118eef15cc3a9dafe14c6d48c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a power-function expression.  <a href="#a1ae3c8118eef15cc3a9dafe14c6d48c2">More...</a><br /></td></tr>
<tr class="separator:a1ae3c8118eef15cc3a9dafe14c6d48c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790f1dea22ffa64d7c75849403aae060"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a790f1dea22ffa64d7c75849403aae060">is_sin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a790f1dea22ffa64d7c75849403aae060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a sine expression.  <a href="#a790f1dea22ffa64d7c75849403aae060">More...</a><br /></td></tr>
<tr class="separator:a790f1dea22ffa64d7c75849403aae060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78259c13b2add79a1ad23e2cc8f5b314"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a78259c13b2add79a1ad23e2cc8f5b314">is_cos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a78259c13b2add79a1ad23e2cc8f5b314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a cosine expression.  <a href="#a78259c13b2add79a1ad23e2cc8f5b314">More...</a><br /></td></tr>
<tr class="separator:a78259c13b2add79a1ad23e2cc8f5b314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaf3f36c1f3fdf51121f77083894794"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7eaf3f36c1f3fdf51121f77083894794">is_tan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a7eaf3f36c1f3fdf51121f77083894794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a tangent expression.  <a href="#a7eaf3f36c1f3fdf51121f77083894794">More...</a><br /></td></tr>
<tr class="separator:a7eaf3f36c1f3fdf51121f77083894794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f6cc91aa5d1f9133526887cec35cd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab3f6cc91aa5d1f9133526887cec35cd4">is_asin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ab3f6cc91aa5d1f9133526887cec35cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an arcsine expression.  <a href="#ab3f6cc91aa5d1f9133526887cec35cd4">More...</a><br /></td></tr>
<tr class="separator:ab3f6cc91aa5d1f9133526887cec35cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70b034dae56512552b00315c20edaf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa70b034dae56512552b00315c20edaf4">is_acos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:aa70b034dae56512552b00315c20edaf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an arccosine expression.  <a href="#aa70b034dae56512552b00315c20edaf4">More...</a><br /></td></tr>
<tr class="separator:aa70b034dae56512552b00315c20edaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4927daffb66b9bd137c174d41d94444"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae4927daffb66b9bd137c174d41d94444">is_atan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ae4927daffb66b9bd137c174d41d94444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an arctangent expression.  <a href="#ae4927daffb66b9bd137c174d41d94444">More...</a><br /></td></tr>
<tr class="separator:ae4927daffb66b9bd137c174d41d94444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb998316cfc15506d72b2f2843b4fa62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acb998316cfc15506d72b2f2843b4fa62">is_atan2</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:acb998316cfc15506d72b2f2843b4fa62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a arctangent2 expression.  <a href="#acb998316cfc15506d72b2f2843b4fa62">More...</a><br /></td></tr>
<tr class="separator:acb998316cfc15506d72b2f2843b4fa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0373300d4207624b99351d0f7c347b85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0373300d4207624b99351d0f7c347b85">is_sinh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a0373300d4207624b99351d0f7c347b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a hyperbolic-sine expression.  <a href="#a0373300d4207624b99351d0f7c347b85">More...</a><br /></td></tr>
<tr class="separator:a0373300d4207624b99351d0f7c347b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9729350280d57ceaa1fd4c01c46ab48c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9729350280d57ceaa1fd4c01c46ab48c">is_cosh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a9729350280d57ceaa1fd4c01c46ab48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a hyperbolic-cosine expression.  <a href="#a9729350280d57ceaa1fd4c01c46ab48c">More...</a><br /></td></tr>
<tr class="separator:a9729350280d57ceaa1fd4c01c46ab48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06c87629b60cbdc34b8e2a9f715cd41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac06c87629b60cbdc34b8e2a9f715cd41">is_tanh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:ac06c87629b60cbdc34b8e2a9f715cd41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a hyperbolic-tangent expression.  <a href="#ac06c87629b60cbdc34b8e2a9f715cd41">More...</a><br /></td></tr>
<tr class="separator:ac06c87629b60cbdc34b8e2a9f715cd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429537da181b9861e8e1b51648691059"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a429537da181b9861e8e1b51648691059">is_min</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a429537da181b9861e8e1b51648691059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a min expression.  <a href="#a429537da181b9861e8e1b51648691059">More...</a><br /></td></tr>
<tr class="separator:a429537da181b9861e8e1b51648691059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409d972b3926adbbb031a5c3aef3d153"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a409d972b3926adbbb031a5c3aef3d153">is_max</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a409d972b3926adbbb031a5c3aef3d153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a max expression.  <a href="#a409d972b3926adbbb031a5c3aef3d153">More...</a><br /></td></tr>
<tr class="separator:a409d972b3926adbbb031a5c3aef3d153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358f01574b969ec8e0b75498929b9d95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a358f01574b969ec8e0b75498929b9d95">is_ceil</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a358f01574b969ec8e0b75498929b9d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a ceil expression.  <a href="#a358f01574b969ec8e0b75498929b9d95">More...</a><br /></td></tr>
<tr class="separator:a358f01574b969ec8e0b75498929b9d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568d4712bfb6ef78d4908efce797ebd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a568d4712bfb6ef78d4908efce797ebd2">is_floor</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:a568d4712bfb6ef78d4908efce797ebd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is a floor expression.  <a href="#a568d4712bfb6ef78d4908efce797ebd2">More...</a><br /></td></tr>
<tr class="separator:a568d4712bfb6ef78d4908efce797ebd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9473fec0f5aba36ac7c89281bf4d524"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af9473fec0f5aba36ac7c89281bf4d524">is_if_then_else</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:af9473fec0f5aba36ac7c89281bf4d524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an if-then-else expression.  <a href="#af9473fec0f5aba36ac7c89281bf4d524">More...</a><br /></td></tr>
<tr class="separator:af9473fec0f5aba36ac7c89281bf4d524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47a95b03c275d9687461839c5612472"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa47a95b03c275d9687461839c5612472">is_uninterpreted_function</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;c)</td></tr>
<tr class="memdesc:aa47a95b03c275d9687461839c5612472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>c</code> is an uninterpreted-function expression.  <a href="#aa47a95b03c275d9687461839c5612472">More...</a><br /></td></tr>
<tr class="separator:aa47a95b03c275d9687461839c5612472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2708aa3cdfbd35a6c8dfdf846102093"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html">ExpressionConstant</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af2708aa3cdfbd35a6c8dfdf846102093">to_constant</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:af2708aa3cdfbd35a6c8dfdf846102093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionConstant&gt;</code>.  <a href="#af2708aa3cdfbd35a6c8dfdf846102093">More...</a><br /></td></tr>
<tr class="separator:af2708aa3cdfbd35a6c8dfdf846102093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a80e99d12d93faa0ac6d5d7e322f3b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html">ExpressionConstant</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a61a80e99d12d93faa0ac6d5d7e322f3b">to_constant</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a61a80e99d12d93faa0ac6d5d7e322f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionConstant&gt;</code>.  <a href="#a61a80e99d12d93faa0ac6d5d7e322f3b">More...</a><br /></td></tr>
<tr class="separator:a61a80e99d12d93faa0ac6d5d7e322f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe2b1e3ee3c9df2e69bb00df0dee547"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html">ExpressionConstant</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aefe2b1e3ee3c9df2e69bb00df0dee547">to_constant</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:aefe2b1e3ee3c9df2e69bb00df0dee547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionConstant&gt;</code>.  <a href="#aefe2b1e3ee3c9df2e69bb00df0dee547">More...</a><br /></td></tr>
<tr class="separator:aefe2b1e3ee3c9df2e69bb00df0dee547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb2ff65bada4e39d74027f409d240e6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0fb2ff65bada4e39d74027f409d240e6">to_variable</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a0fb2ff65bada4e39d74027f409d240e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionVar&gt;</code>.  <a href="#a0fb2ff65bada4e39d74027f409d240e6">More...</a><br /></td></tr>
<tr class="separator:a0fb2ff65bada4e39d74027f409d240e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3298ef04e0d64a1e1780f4213f626e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aee3298ef04e0d64a1e1780f4213f626e">to_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aee3298ef04e0d64a1e1780f4213f626e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionVar&gt;</code>.  <a href="#aee3298ef04e0d64a1e1780f4213f626e">More...</a><br /></td></tr>
<tr class="separator:aee3298ef04e0d64a1e1780f4213f626e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac955d0c955ceefc130d72ba1445b77cd"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac955d0c955ceefc130d72ba1445b77cd">to_variable</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:ac955d0c955ceefc130d72ba1445b77cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionVar&gt;</code>.  <a href="#ac955d0c955ceefc130d72ba1445b77cd">More...</a><br /></td></tr>
<tr class="separator:ac955d0c955ceefc130d72ba1445b77cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765d0812ec1409b35dd5a483d6d8e145"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a765d0812ec1409b35dd5a483d6d8e145">to_unary</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a765d0812ec1409b35dd5a483d6d8e145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;UnaryExpressionCell&gt;</code>.  <a href="#a765d0812ec1409b35dd5a483d6d8e145">More...</a><br /></td></tr>
<tr class="separator:a765d0812ec1409b35dd5a483d6d8e145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1501b8c956fb9e788ec6a3b69db7051"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad1501b8c956fb9e788ec6a3b69db7051">to_unary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ad1501b8c956fb9e788ec6a3b69db7051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const UnaryExpressionCell&gt;</code>.  <a href="#ad1501b8c956fb9e788ec6a3b69db7051">More...</a><br /></td></tr>
<tr class="separator:ad1501b8c956fb9e788ec6a3b69db7051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2783fd40888e09c46ab6641902488156"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2783fd40888e09c46ab6641902488156">to_unary</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a2783fd40888e09c46ab6641902488156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;UnaryExpressionCell&gt;</code>.  <a href="#a2783fd40888e09c46ab6641902488156">More...</a><br /></td></tr>
<tr class="separator:a2783fd40888e09c46ab6641902488156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9e480e796a36c2988ef23e83f24a08"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aee9e480e796a36c2988ef23e83f24a08">to_binary</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:aee9e480e796a36c2988ef23e83f24a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;BinaryExpressionCell&gt;</code>.  <a href="#aee9e480e796a36c2988ef23e83f24a08">More...</a><br /></td></tr>
<tr class="separator:aee9e480e796a36c2988ef23e83f24a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844f455ce08d059f1bd69f2765e22d6a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a844f455ce08d059f1bd69f2765e22d6a">to_binary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a844f455ce08d059f1bd69f2765e22d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const BinaryExpressionCell&gt;</code>.  <a href="#a844f455ce08d059f1bd69f2765e22d6a">More...</a><br /></td></tr>
<tr class="separator:a844f455ce08d059f1bd69f2765e22d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9a716129fbcdd8a274085e04ca26c1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5a9a716129fbcdd8a274085e04ca26c1">to_binary</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a5a9a716129fbcdd8a274085e04ca26c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;BinaryExpressionCell&gt;</code>.  <a href="#a5a9a716129fbcdd8a274085e04ca26c1">More...</a><br /></td></tr>
<tr class="separator:a5a9a716129fbcdd8a274085e04ca26c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aee978a40d6518b2821b2c1a91f43b6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6aee978a40d6518b2821b2c1a91f43b6">to_addition</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a6aee978a40d6518b2821b2c1a91f43b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionAdd&gt;</code>.  <a href="#a6aee978a40d6518b2821b2c1a91f43b6">More...</a><br /></td></tr>
<tr class="separator:a6aee978a40d6518b2821b2c1a91f43b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5cbe2fa0a4c27ba7da0be48683a728"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0f5cbe2fa0a4c27ba7da0be48683a728">to_addition</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a0f5cbe2fa0a4c27ba7da0be48683a728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAdd&gt;</code>.  <a href="#a0f5cbe2fa0a4c27ba7da0be48683a728">More...</a><br /></td></tr>
<tr class="separator:a0f5cbe2fa0a4c27ba7da0be48683a728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2448e8f4c4ffb7c764c9b8bdddfbd3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aca2448e8f4c4ffb7c764c9b8bdddfbd3">to_addition</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:aca2448e8f4c4ffb7c764c9b8bdddfbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionAdd&gt;</code>.  <a href="#aca2448e8f4c4ffb7c764c9b8bdddfbd3">More...</a><br /></td></tr>
<tr class="separator:aca2448e8f4c4ffb7c764c9b8bdddfbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf591075325809961d0975a0bad30a0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7cf591075325809961d0975a0bad30a0">to_multiplication</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a7cf591075325809961d0975a0bad30a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionMul&gt;</code>.  <a href="#a7cf591075325809961d0975a0bad30a0">More...</a><br /></td></tr>
<tr class="separator:a7cf591075325809961d0975a0bad30a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91059e637eb041b04786808c970c0ed7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a91059e637eb041b04786808c970c0ed7">to_multiplication</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a91059e637eb041b04786808c970c0ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionMul&gt;</code>.  <a href="#a91059e637eb041b04786808c970c0ed7">More...</a><br /></td></tr>
<tr class="separator:a91059e637eb041b04786808c970c0ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572832161aa30d231e6ad34194feb033"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a572832161aa30d231e6ad34194feb033">to_multiplication</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a572832161aa30d231e6ad34194feb033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionMul&gt;</code>.  <a href="#a572832161aa30d231e6ad34194feb033">More...</a><br /></td></tr>
<tr class="separator:a572832161aa30d231e6ad34194feb033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66792167f2936394301f9322b77104f8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a66792167f2936394301f9322b77104f8">to_division</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a66792167f2936394301f9322b77104f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionDiv&gt;</code>.  <a href="#a66792167f2936394301f9322b77104f8">More...</a><br /></td></tr>
<tr class="separator:a66792167f2936394301f9322b77104f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26a3824f44065547e3416df989e4d3e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad26a3824f44065547e3416df989e4d3e">to_division</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ad26a3824f44065547e3416df989e4d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionDiv&gt;</code>.  <a href="#ad26a3824f44065547e3416df989e4d3e">More...</a><br /></td></tr>
<tr class="separator:ad26a3824f44065547e3416df989e4d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72af3ed882189fd2f5a48214214fdf9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac72af3ed882189fd2f5a48214214fdf9">to_division</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:ac72af3ed882189fd2f5a48214214fdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionDiv&gt;</code>.  <a href="#ac72af3ed882189fd2f5a48214214fdf9">More...</a><br /></td></tr>
<tr class="separator:ac72af3ed882189fd2f5a48214214fdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42be92856b50af12f40ccffe4a8634da"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a42be92856b50af12f40ccffe4a8634da">to_log</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a42be92856b50af12f40ccffe4a8634da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionLog&gt;</code>.  <a href="#a42be92856b50af12f40ccffe4a8634da">More...</a><br /></td></tr>
<tr class="separator:a42be92856b50af12f40ccffe4a8634da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e9c0798e8cd0fb86b8ea9bf0ee1594"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a47e9c0798e8cd0fb86b8ea9bf0ee1594">to_log</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a47e9c0798e8cd0fb86b8ea9bf0ee1594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionLog&gt;</code>.  <a href="#a47e9c0798e8cd0fb86b8ea9bf0ee1594">More...</a><br /></td></tr>
<tr class="separator:a47e9c0798e8cd0fb86b8ea9bf0ee1594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab44805086e06cfec55cf7554202eb2e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aab44805086e06cfec55cf7554202eb2e">to_log</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:aab44805086e06cfec55cf7554202eb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionLog&gt;</code>.  <a href="#aab44805086e06cfec55cf7554202eb2e">More...</a><br /></td></tr>
<tr class="separator:aab44805086e06cfec55cf7554202eb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4518fb7cc38ea2cd3efc4a3bead3e82e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4518fb7cc38ea2cd3efc4a3bead3e82e">to_exp</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a4518fb7cc38ea2cd3efc4a3bead3e82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionExp&gt;</code>.  <a href="#a4518fb7cc38ea2cd3efc4a3bead3e82e">More...</a><br /></td></tr>
<tr class="separator:a4518fb7cc38ea2cd3efc4a3bead3e82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918dcfa4e1c6bf30473602e582553fb7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a918dcfa4e1c6bf30473602e582553fb7">to_exp</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a918dcfa4e1c6bf30473602e582553fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionExp&gt;</code>.  <a href="#a918dcfa4e1c6bf30473602e582553fb7">More...</a><br /></td></tr>
<tr class="separator:a918dcfa4e1c6bf30473602e582553fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c2b13ce0db5f3f1bcf93baec1b862d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a19c2b13ce0db5f3f1bcf93baec1b862d">to_exp</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a19c2b13ce0db5f3f1bcf93baec1b862d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionExp&gt;</code>.  <a href="#a19c2b13ce0db5f3f1bcf93baec1b862d">More...</a><br /></td></tr>
<tr class="separator:a19c2b13ce0db5f3f1bcf93baec1b862d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1daeae1984840b825c4a2a00bad31ac"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac1daeae1984840b825c4a2a00bad31ac">to_abs</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:ac1daeae1984840b825c4a2a00bad31ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionAbs&gt;</code>.  <a href="#ac1daeae1984840b825c4a2a00bad31ac">More...</a><br /></td></tr>
<tr class="separator:ac1daeae1984840b825c4a2a00bad31ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6681bd6eee8a596b9d010a4374a18026"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6681bd6eee8a596b9d010a4374a18026">to_abs</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a6681bd6eee8a596b9d010a4374a18026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAbs&gt;</code>.  <a href="#a6681bd6eee8a596b9d010a4374a18026">More...</a><br /></td></tr>
<tr class="separator:a6681bd6eee8a596b9d010a4374a18026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b359eaa31c38d5b94b47e2befd7d72"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a39b359eaa31c38d5b94b47e2befd7d72">to_abs</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a39b359eaa31c38d5b94b47e2befd7d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionAbs&gt;</code>.  <a href="#a39b359eaa31c38d5b94b47e2befd7d72">More...</a><br /></td></tr>
<tr class="separator:a39b359eaa31c38d5b94b47e2befd7d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce18aa6183f7c0c9109f6217fed8e69"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6ce18aa6183f7c0c9109f6217fed8e69">to_sqrt</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a6ce18aa6183f7c0c9109f6217fed8e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionSqrt&gt;</code>.  <a href="#a6ce18aa6183f7c0c9109f6217fed8e69">More...</a><br /></td></tr>
<tr class="separator:a6ce18aa6183f7c0c9109f6217fed8e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d693b2bf5346dc1f4092a1bbc77d790"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7d693b2bf5346dc1f4092a1bbc77d790">to_sqrt</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a7d693b2bf5346dc1f4092a1bbc77d790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionSqrt&gt;</code>.  <a href="#a7d693b2bf5346dc1f4092a1bbc77d790">More...</a><br /></td></tr>
<tr class="separator:a7d693b2bf5346dc1f4092a1bbc77d790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcfc6237d1d5d86e8d9a36b4bd3a5c7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9fcfc6237d1d5d86e8d9a36b4bd3a5c7">to_sqrt</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a9fcfc6237d1d5d86e8d9a36b4bd3a5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionSqrt&gt;</code>.  <a href="#a9fcfc6237d1d5d86e8d9a36b4bd3a5c7">More...</a><br /></td></tr>
<tr class="separator:a9fcfc6237d1d5d86e8d9a36b4bd3a5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd9338e5ca18182888de1ea5f5da1b9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0bd9338e5ca18182888de1ea5f5da1b9">to_pow</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a0bd9338e5ca18182888de1ea5f5da1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionPow&gt;</code>.  <a href="#a0bd9338e5ca18182888de1ea5f5da1b9">More...</a><br /></td></tr>
<tr class="separator:a0bd9338e5ca18182888de1ea5f5da1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2370032c0c398a96e44d7f00008cd566"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2370032c0c398a96e44d7f00008cd566">to_pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a2370032c0c398a96e44d7f00008cd566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionPow&gt;</code>.  <a href="#a2370032c0c398a96e44d7f00008cd566">More...</a><br /></td></tr>
<tr class="separator:a2370032c0c398a96e44d7f00008cd566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ec5117d285c57a7232dc2507c09456"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a37ec5117d285c57a7232dc2507c09456">to_pow</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a37ec5117d285c57a7232dc2507c09456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionPow&gt;</code>.  <a href="#a37ec5117d285c57a7232dc2507c09456">More...</a><br /></td></tr>
<tr class="separator:a37ec5117d285c57a7232dc2507c09456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f0ee9736a5612de981fc34c959b83a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a63f0ee9736a5612de981fc34c959b83a">to_sin</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a63f0ee9736a5612de981fc34c959b83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionSin&gt;</code>.  <a href="#a63f0ee9736a5612de981fc34c959b83a">More...</a><br /></td></tr>
<tr class="separator:a63f0ee9736a5612de981fc34c959b83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3598b5d3b102aaf9f2bcfd267096c3d4"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3598b5d3b102aaf9f2bcfd267096c3d4">to_sin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a3598b5d3b102aaf9f2bcfd267096c3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionSin&gt;</code>.  <a href="#a3598b5d3b102aaf9f2bcfd267096c3d4">More...</a><br /></td></tr>
<tr class="separator:a3598b5d3b102aaf9f2bcfd267096c3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82193c006ad9f4d178f9eca0c3eff288"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a82193c006ad9f4d178f9eca0c3eff288">to_sin</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a82193c006ad9f4d178f9eca0c3eff288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionSin&gt;</code>.  <a href="#a82193c006ad9f4d178f9eca0c3eff288">More...</a><br /></td></tr>
<tr class="separator:a82193c006ad9f4d178f9eca0c3eff288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacb0e6cb526379b60fd156af4b527cf"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abacb0e6cb526379b60fd156af4b527cf">to_cos</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:abacb0e6cb526379b60fd156af4b527cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionCos&gt;</code>.  <a href="#abacb0e6cb526379b60fd156af4b527cf">More...</a><br /></td></tr>
<tr class="separator:abacb0e6cb526379b60fd156af4b527cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf44cbe131d42d4cca59fd098e62dbe"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afdf44cbe131d42d4cca59fd098e62dbe">to_cos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:afdf44cbe131d42d4cca59fd098e62dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionCos&gt;</code>.  <a href="#afdf44cbe131d42d4cca59fd098e62dbe">More...</a><br /></td></tr>
<tr class="separator:afdf44cbe131d42d4cca59fd098e62dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abdc81f10cc7d9c2dad5f809d6d1905"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7abdc81f10cc7d9c2dad5f809d6d1905">to_cos</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a7abdc81f10cc7d9c2dad5f809d6d1905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionCos&gt;</code>.  <a href="#a7abdc81f10cc7d9c2dad5f809d6d1905">More...</a><br /></td></tr>
<tr class="separator:a7abdc81f10cc7d9c2dad5f809d6d1905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04f9840044b92df4e44eca238c8cd62"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af04f9840044b92df4e44eca238c8cd62">to_tan</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:af04f9840044b92df4e44eca238c8cd62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionTan&gt;</code>.  <a href="#af04f9840044b92df4e44eca238c8cd62">More...</a><br /></td></tr>
<tr class="separator:af04f9840044b92df4e44eca238c8cd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f4ed90783040b2bf23b79c781a7594"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac4f4ed90783040b2bf23b79c781a7594">to_tan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ac4f4ed90783040b2bf23b79c781a7594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionTan&gt;</code>.  <a href="#ac4f4ed90783040b2bf23b79c781a7594">More...</a><br /></td></tr>
<tr class="separator:ac4f4ed90783040b2bf23b79c781a7594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff629d72d92c6f5ec6add9800c41267f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aff629d72d92c6f5ec6add9800c41267f">to_tan</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:aff629d72d92c6f5ec6add9800c41267f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionTan&gt;</code>.  <a href="#aff629d72d92c6f5ec6add9800c41267f">More...</a><br /></td></tr>
<tr class="separator:aff629d72d92c6f5ec6add9800c41267f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec94d5786975e5d7a7e1b7946e4fcb3f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aec94d5786975e5d7a7e1b7946e4fcb3f">to_asin</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:aec94d5786975e5d7a7e1b7946e4fcb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionAsin&gt;</code>.  <a href="#aec94d5786975e5d7a7e1b7946e4fcb3f">More...</a><br /></td></tr>
<tr class="separator:aec94d5786975e5d7a7e1b7946e4fcb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad623f73697227858e57831d5271f2361"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad623f73697227858e57831d5271f2361">to_asin</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ad623f73697227858e57831d5271f2361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAsin&gt;</code>.  <a href="#ad623f73697227858e57831d5271f2361">More...</a><br /></td></tr>
<tr class="separator:ad623f73697227858e57831d5271f2361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303f958f845f5a16daeea10a72007098"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a303f958f845f5a16daeea10a72007098">to_asin</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a303f958f845f5a16daeea10a72007098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionAsin&gt;</code>.  <a href="#a303f958f845f5a16daeea10a72007098">More...</a><br /></td></tr>
<tr class="separator:a303f958f845f5a16daeea10a72007098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecd824b675e48cb348b880f5023673e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0ecd824b675e48cb348b880f5023673e">to_acos</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a0ecd824b675e48cb348b880f5023673e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionAcos&gt;</code>.  <a href="#a0ecd824b675e48cb348b880f5023673e">More...</a><br /></td></tr>
<tr class="separator:a0ecd824b675e48cb348b880f5023673e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12a22a9717c9a2a50245cab09adceec"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa12a22a9717c9a2a50245cab09adceec">to_acos</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa12a22a9717c9a2a50245cab09adceec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAcos&gt;</code>.  <a href="#aa12a22a9717c9a2a50245cab09adceec">More...</a><br /></td></tr>
<tr class="separator:aa12a22a9717c9a2a50245cab09adceec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6734fb6733ffdcb5b084c7b0f19114"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8f6734fb6733ffdcb5b084c7b0f19114">to_acos</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a8f6734fb6733ffdcb5b084c7b0f19114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionAcos&gt;</code>.  <a href="#a8f6734fb6733ffdcb5b084c7b0f19114">More...</a><br /></td></tr>
<tr class="separator:a8f6734fb6733ffdcb5b084c7b0f19114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abe6ed64006a6caf5b8ffd016d9d564"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4abe6ed64006a6caf5b8ffd016d9d564">to_atan</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a4abe6ed64006a6caf5b8ffd016d9d564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionAtan&gt;</code>.  <a href="#a4abe6ed64006a6caf5b8ffd016d9d564">More...</a><br /></td></tr>
<tr class="separator:a4abe6ed64006a6caf5b8ffd016d9d564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4790cb5947f9d886463912b44dc53f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afd4790cb5947f9d886463912b44dc53f">to_atan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:afd4790cb5947f9d886463912b44dc53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAtan&gt;</code>.  <a href="#afd4790cb5947f9d886463912b44dc53f">More...</a><br /></td></tr>
<tr class="separator:afd4790cb5947f9d886463912b44dc53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c636513383a9a3ab3f8fd92064932c6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5c636513383a9a3ab3f8fd92064932c6">to_atan</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a5c636513383a9a3ab3f8fd92064932c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionAtan&gt;</code>.  <a href="#a5c636513383a9a3ab3f8fd92064932c6">More...</a><br /></td></tr>
<tr class="separator:a5c636513383a9a3ab3f8fd92064932c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be1d5cbdfe80024dcbf36264504f720"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7be1d5cbdfe80024dcbf36264504f720">to_atan2</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a7be1d5cbdfe80024dcbf36264504f720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionAtan2&gt;</code>.  <a href="#a7be1d5cbdfe80024dcbf36264504f720">More...</a><br /></td></tr>
<tr class="separator:a7be1d5cbdfe80024dcbf36264504f720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7e04a20dd742f4b319659a7bcca24f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abe7e04a20dd742f4b319659a7bcca24f">to_atan2</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:abe7e04a20dd742f4b319659a7bcca24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAtan2&gt;</code>.  <a href="#abe7e04a20dd742f4b319659a7bcca24f">More...</a><br /></td></tr>
<tr class="separator:abe7e04a20dd742f4b319659a7bcca24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8910f7e2d4fece2b78bb57c45e62b125"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8910f7e2d4fece2b78bb57c45e62b125">to_atan2</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a8910f7e2d4fece2b78bb57c45e62b125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionAtan2&gt;</code>.  <a href="#a8910f7e2d4fece2b78bb57c45e62b125">More...</a><br /></td></tr>
<tr class="separator:a8910f7e2d4fece2b78bb57c45e62b125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97fb68eaad141cc6177a44b2e77135f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae97fb68eaad141cc6177a44b2e77135f">to_sinh</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:ae97fb68eaad141cc6177a44b2e77135f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionSinh&gt;</code>.  <a href="#ae97fb68eaad141cc6177a44b2e77135f">More...</a><br /></td></tr>
<tr class="separator:ae97fb68eaad141cc6177a44b2e77135f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10890b71ebe07e3e230460dfaaeaf877"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a10890b71ebe07e3e230460dfaaeaf877">to_sinh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a10890b71ebe07e3e230460dfaaeaf877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionSinh&gt;</code>.  <a href="#a10890b71ebe07e3e230460dfaaeaf877">More...</a><br /></td></tr>
<tr class="separator:a10890b71ebe07e3e230460dfaaeaf877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d369e2ad6befa385e41b0eb350bdd3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a10d369e2ad6befa385e41b0eb350bdd3">to_sinh</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a10d369e2ad6befa385e41b0eb350bdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionSinh&gt;</code>.  <a href="#a10d369e2ad6befa385e41b0eb350bdd3">More...</a><br /></td></tr>
<tr class="separator:a10d369e2ad6befa385e41b0eb350bdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e124af49dfeefbaecdb2b062413e40"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae9e124af49dfeefbaecdb2b062413e40">to_cosh</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:ae9e124af49dfeefbaecdb2b062413e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionCosh&gt;</code>.  <a href="#ae9e124af49dfeefbaecdb2b062413e40">More...</a><br /></td></tr>
<tr class="separator:ae9e124af49dfeefbaecdb2b062413e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab651038b9eb8bfe5e9eee3a972d5e3db"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab651038b9eb8bfe5e9eee3a972d5e3db">to_cosh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ab651038b9eb8bfe5e9eee3a972d5e3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionCosh&gt;</code>.  <a href="#ab651038b9eb8bfe5e9eee3a972d5e3db">More...</a><br /></td></tr>
<tr class="separator:ab651038b9eb8bfe5e9eee3a972d5e3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819f238f0c2b84e91a214a85e89920de"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a819f238f0c2b84e91a214a85e89920de">to_cosh</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a819f238f0c2b84e91a214a85e89920de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionCosh&gt;</code>.  <a href="#a819f238f0c2b84e91a214a85e89920de">More...</a><br /></td></tr>
<tr class="separator:a819f238f0c2b84e91a214a85e89920de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9539581f8f57306f69ae74a4e2b50a0b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9539581f8f57306f69ae74a4e2b50a0b">to_tanh</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a9539581f8f57306f69ae74a4e2b50a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionTanh&gt;</code>.  <a href="#a9539581f8f57306f69ae74a4e2b50a0b">More...</a><br /></td></tr>
<tr class="separator:a9539581f8f57306f69ae74a4e2b50a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d60ce5e8e142a1919eedfd4fbfac7b7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6d60ce5e8e142a1919eedfd4fbfac7b7">to_tanh</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a6d60ce5e8e142a1919eedfd4fbfac7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionTanh&gt;</code>.  <a href="#a6d60ce5e8e142a1919eedfd4fbfac7b7">More...</a><br /></td></tr>
<tr class="separator:a6d60ce5e8e142a1919eedfd4fbfac7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08efb29f84b54b9a3a642e45a147baa"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae08efb29f84b54b9a3a642e45a147baa">to_tanh</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:ae08efb29f84b54b9a3a642e45a147baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionTanh&gt;</code>.  <a href="#ae08efb29f84b54b9a3a642e45a147baa">More...</a><br /></td></tr>
<tr class="separator:ae08efb29f84b54b9a3a642e45a147baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe59d85af6a0957d2ffedf731cd2c518"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afe59d85af6a0957d2ffedf731cd2c518">to_min</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:afe59d85af6a0957d2ffedf731cd2c518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionMin&gt;</code>.  <a href="#afe59d85af6a0957d2ffedf731cd2c518">More...</a><br /></td></tr>
<tr class="separator:afe59d85af6a0957d2ffedf731cd2c518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777fe08a1a50861c1dc53b14be414de8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a777fe08a1a50861c1dc53b14be414de8">to_min</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a777fe08a1a50861c1dc53b14be414de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionMin&gt;</code>.  <a href="#a777fe08a1a50861c1dc53b14be414de8">More...</a><br /></td></tr>
<tr class="separator:a777fe08a1a50861c1dc53b14be414de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40abc776ecff931414b48d3070d27a6b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a40abc776ecff931414b48d3070d27a6b">to_min</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a40abc776ecff931414b48d3070d27a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionMin&gt;</code>.  <a href="#a40abc776ecff931414b48d3070d27a6b">More...</a><br /></td></tr>
<tr class="separator:a40abc776ecff931414b48d3070d27a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ef10c460bfd3356304cfc4ddd45871"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad3ef10c460bfd3356304cfc4ddd45871">to_max</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:ad3ef10c460bfd3356304cfc4ddd45871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionMax&gt;</code>.  <a href="#ad3ef10c460bfd3356304cfc4ddd45871">More...</a><br /></td></tr>
<tr class="separator:ad3ef10c460bfd3356304cfc4ddd45871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3ef858fc84394fa03779f31117cfc3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aca3ef858fc84394fa03779f31117cfc3">to_max</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aca3ef858fc84394fa03779f31117cfc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionMax&gt;</code>.  <a href="#aca3ef858fc84394fa03779f31117cfc3">More...</a><br /></td></tr>
<tr class="separator:aca3ef858fc84394fa03779f31117cfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b19c2ecb35334ffe962c6f81928a59"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab2b19c2ecb35334ffe962c6f81928a59">to_max</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:ab2b19c2ecb35334ffe962c6f81928a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionMax&gt;</code>.  <a href="#ab2b19c2ecb35334ffe962c6f81928a59">More...</a><br /></td></tr>
<tr class="separator:ab2b19c2ecb35334ffe962c6f81928a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b27dc7be5ef0b7ed9d9da76141fd06"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a67b27dc7be5ef0b7ed9d9da76141fd06">to_ceil</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a67b27dc7be5ef0b7ed9d9da76141fd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionCeiling&gt;</code>.  <a href="#a67b27dc7be5ef0b7ed9d9da76141fd06">More...</a><br /></td></tr>
<tr class="separator:a67b27dc7be5ef0b7ed9d9da76141fd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34e2eb22a1480475985c1c893762a4e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa34e2eb22a1480475985c1c893762a4e">to_ceil</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa34e2eb22a1480475985c1c893762a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionCeiling&gt;</code>.  <a href="#aa34e2eb22a1480475985c1c893762a4e">More...</a><br /></td></tr>
<tr class="separator:aa34e2eb22a1480475985c1c893762a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0301c6eb6243d84b5f3a55a65d067e98"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0301c6eb6243d84b5f3a55a65d067e98">to_ceil</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:a0301c6eb6243d84b5f3a55a65d067e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionCeiling&gt;</code>.  <a href="#a0301c6eb6243d84b5f3a55a65d067e98">More...</a><br /></td></tr>
<tr class="separator:a0301c6eb6243d84b5f3a55a65d067e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca6d0b50c8894d1c59c94f738a86d8e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1ca6d0b50c8894d1c59c94f738a86d8e">to_floor</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a1ca6d0b50c8894d1c59c94f738a86d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionFloor&gt;</code>.  <a href="#a1ca6d0b50c8894d1c59c94f738a86d8e">More...</a><br /></td></tr>
<tr class="separator:a1ca6d0b50c8894d1c59c94f738a86d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c41c2b040c7e7c734456761fa0a34f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad1c41c2b040c7e7c734456761fa0a34f">to_floor</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ad1c41c2b040c7e7c734456761fa0a34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionFloor&gt;</code>.  <a href="#ad1c41c2b040c7e7c734456761fa0a34f">More...</a><br /></td></tr>
<tr class="separator:ad1c41c2b040c7e7c734456761fa0a34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb90175340b5282809d4a3710145e758"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adb90175340b5282809d4a3710145e758">to_floor</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:adb90175340b5282809d4a3710145e758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionFloor&gt;</code>.  <a href="#adb90175340b5282809d4a3710145e758">More...</a><br /></td></tr>
<tr class="separator:adb90175340b5282809d4a3710145e758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6913fad5224e9e1eab2396bdd20db92b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6913fad5224e9e1eab2396bdd20db92b">to_if_then_else</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a6913fad5224e9e1eab2396bdd20db92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionIfThenElse&gt;</code>.  <a href="#a6913fad5224e9e1eab2396bdd20db92b">More...</a><br /></td></tr>
<tr class="separator:a6913fad5224e9e1eab2396bdd20db92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331dd3f183e945974f4cb1bfee8eb54f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a331dd3f183e945974f4cb1bfee8eb54f">to_if_then_else</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a331dd3f183e945974f4cb1bfee8eb54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionIfThenElse&gt;</code>.  <a href="#a331dd3f183e945974f4cb1bfee8eb54f">More...</a><br /></td></tr>
<tr class="separator:a331dd3f183e945974f4cb1bfee8eb54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e7c6adb035b5360d0065cd5b1a6e7b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae8e7c6adb035b5360d0065cd5b1a6e7b">to_if_then_else</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:ae8e7c6adb035b5360d0065cd5b1a6e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionIfThenElse&gt;</code>.  <a href="#ae8e7c6adb035b5360d0065cd5b1a6e7b">More...</a><br /></td></tr>
<tr class="separator:ae8e7c6adb035b5360d0065cd5b1a6e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de0c0fabeedb18688b94ce9d85a21d1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4de0c0fabeedb18688b94ce9d85a21d1">to_uninterpreted_function</a> (const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;expr_ptr)</td></tr>
<tr class="memdesc:a4de0c0fabeedb18688b94ce9d85a21d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionUninterpretedFunction&gt;</code>.  <a href="#a4de0c0fabeedb18688b94ce9d85a21d1">More...</a><br /></td></tr>
<tr class="separator:a4de0c0fabeedb18688b94ce9d85a21d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faed8e01e77e2e45b88050b550b934e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4faed8e01e77e2e45b88050b550b934e">to_uninterpreted_function</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:a4faed8e01e77e2e45b88050b550b934e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionUninterpretedFunction&gt;</code>.  <a href="#a4faed8e01e77e2e45b88050b550b934e">More...</a><br /></td></tr>
<tr class="separator:a4faed8e01e77e2e45b88050b550b934e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6363c5c8a48f4960af65936434237c7"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac6363c5c8a48f4960af65936434237c7">to_uninterpreted_function</a> (<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *e)</td></tr>
<tr class="memdesc:ac6363c5c8a48f4960af65936434237c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>e</code> to <code>shared_ptr&lt;ExpressionUninterpretedFunction&gt;</code>.  <a href="#ac6363c5c8a48f4960af65936434237c7">More...</a><br /></td></tr>
<tr class="separator:ac6363c5c8a48f4960af65936434237c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a61c45c20176e91159639186b26e35e"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Visitor , typename... Args&gt; </td></tr>
<tr class="memitem:a0a61c45c20176e91159639186b26e35e"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0a61c45c20176e91159639186b26e35e">VisitPolynomial</a> (Visitor *v, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0a61c45c20176e91159639186b26e35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls visitor object <code>v</code> with a polynomial symbolic-expression <code>e</code>, and arguments <code>args</code>.  <a href="#a0a61c45c20176e91159639186b26e35e">More...</a><br /></td></tr>
<tr class="separator:a0a61c45c20176e91159639186b26e35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58092344918003fc7e186b1c57bbc7f"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Visitor , typename... Args&gt; </td></tr>
<tr class="memitem:ab58092344918003fc7e186b1c57bbc7f"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab58092344918003fc7e186b1c57bbc7f">VisitExpression</a> (Visitor *v, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab58092344918003fc7e186b1c57bbc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls visitor object <code>v</code> with a symbolic-expression <code>e</code>, and arguments <code>args</code>.  <a href="#ab58092344918003fc7e186b1c57bbc7f">More...</a><br /></td></tr>
<tr class="separator:ab58092344918003fc7e186b1c57bbc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1245bbf1795b4f97ec4c04cd79dcde3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad1245bbf1795b4f97ec4c04cd79dcde3">operator&lt;</a> (<a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a> k1, <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a> k2)</td></tr>
<tr class="separator:ad1245bbf1795b4f97ec4c04cd79dcde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6d2ea09c3aa020cf408bc9472ec9eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1c6d2ea09c3aa020cf408bc9472ec9eb">forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a1c6d2ea09c3aa020cf408bc9472ec9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a formula <code>f</code>, universally quantified by variables <code>vars</code>.  <a href="#a1c6d2ea09c3aa020cf408bc9472ec9eb">More...</a><br /></td></tr>
<tr class="separator:a1c6d2ea09c3aa020cf408bc9472ec9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aaadf953e1753ea5c2ff78a3bb030ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5aaadf953e1753ea5c2ff78a3bb030ec">make_conjunction</a> (const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;formulas)</td></tr>
<tr class="memdesc:a5aaadf953e1753ea5c2ff78a3bb030ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a conjunction of <code>formulas</code>.  <a href="#a5aaadf953e1753ea5c2ff78a3bb030ec">More...</a><br /></td></tr>
<tr class="separator:a5aaadf953e1753ea5c2ff78a3bb030ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e40924c21a4f08a5cc274eaf7ddebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a71e40924c21a4f08a5cc274eaf7ddebd">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f1, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f2)</td></tr>
<tr class="separator:a71e40924c21a4f08a5cc274eaf7ddebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39da4f4e5f916079f201f92852399f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a39da4f4e5f916079f201f92852399f45">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="separator:a39da4f4e5f916079f201f92852399f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea3ce465525b0c357d1c5115e49a626"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aaea3ce465525b0c357d1c5115e49a626">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:aaea3ce465525b0c357d1c5115e49a626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4758fb8f36a1a85b9fa932003216fe2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4758fb8f36a1a85b9fa932003216fe2e">operator &amp;&amp;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v1, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v2)</td></tr>
<tr class="separator:a4758fb8f36a1a85b9fa932003216fe2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6dff8519d02993c6699ddb3ebb28cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afc6dff8519d02993c6699ddb3ebb28cf">make_disjunction</a> (const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;formulas)</td></tr>
<tr class="memdesc:afc6dff8519d02993c6699ddb3ebb28cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a disjunction of <code>formulas</code>.  <a href="#afc6dff8519d02993c6699ddb3ebb28cf">More...</a><br /></td></tr>
<tr class="separator:afc6dff8519d02993c6699ddb3ebb28cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600c585cf975dd9a8dd94b118f0bd161"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a600c585cf975dd9a8dd94b118f0bd161">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f1, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f2)</td></tr>
<tr class="separator:a600c585cf975dd9a8dd94b118f0bd161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41223d30845a91ba757f6277ad8f8a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac41223d30845a91ba757f6277ad8f8a1">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="separator:ac41223d30845a91ba757f6277ad8f8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc2f3979d06df08b80d2b280b9728c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aafc2f3979d06df08b80d2b280b9728c7">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:aafc2f3979d06df08b80d2b280b9728c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237ee4f068e65a6a4614af59482889eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a237ee4f068e65a6a4614af59482889eb">operator||</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v1, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v2)</td></tr>
<tr class="separator:a237ee4f068e65a6a4614af59482889eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489c472556030b17c10028a04ba70aad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a489c472556030b17c10028a04ba70aad">operator!</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="separator:a489c472556030b17c10028a04ba70aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f34a1136227779b18433cd0a2f4dde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac9f34a1136227779b18433cd0a2f4dde">operator!</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:ac9f34a1136227779b18433cd0a2f4dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463b86323b82db42856d70b2537759e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a463b86323b82db42856d70b2537759e3">operator==</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a463b86323b82db42856d70b2537759e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c1c4bfd4434de52e240126b78853c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac5c1c4bfd4434de52e240126b78853c0">operator!=</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:ac5c1c4bfd4434de52e240126b78853c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad84d6691fb2bf9627d894d56b8ef6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0ad84d6691fb2bf9627d894d56b8ef6f">operator&lt;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a0ad84d6691fb2bf9627d894d56b8ef6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba9db65867379d7603eeaeb9be56451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aaba9db65867379d7603eeaeb9be56451">operator&lt;=</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:aaba9db65867379d7603eeaeb9be56451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a12a5db3a9b2e8520e002e437354717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5a12a5db3a9b2e8520e002e437354717">operator&gt;</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a5a12a5db3a9b2e8520e002e437354717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642d11dbe47e027614a5a3bcfe12d34e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a642d11dbe47e027614a5a3bcfe12d34e">operator&gt;=</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e2)</td></tr>
<tr class="separator:a642d11dbe47e027614a5a3bcfe12d34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66d112b9b6d693ee82d08c7a01f7a14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac66d112b9b6d693ee82d08c7a01f7a14">isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ac66d112b9b6d693ee82d08c7a01f7a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> for the predicate isnan(e) to the given expression.  <a href="#ac66d112b9b6d693ee82d08c7a01f7a14">More...</a><br /></td></tr>
<tr class="separator:ac66d112b9b6d693ee82d08c7a01f7a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac460ea048a6b4cddcaf88672a6abcf46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac460ea048a6b4cddcaf88672a6abcf46">isinf</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:ac460ea048a6b4cddcaf88672a6abcf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> determining if the given expression <code>e</code> is a positive or negative infinity.  <a href="#ac460ea048a6b4cddcaf88672a6abcf46">More...</a><br /></td></tr>
<tr class="separator:ac460ea048a6b4cddcaf88672a6abcf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fbe2690e2170be14656811a9d860d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa9fbe2690e2170be14656811a9d860d5">isfinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;e)</td></tr>
<tr class="memdesc:aa9fbe2690e2170be14656811a9d860d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> determining if the given expression <code>e</code> has a finite value.  <a href="#aa9fbe2690e2170be14656811a9d860d5">More...</a><br /></td></tr>
<tr class="separator:aa9fbe2690e2170be14656811a9d860d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648f540fa40e1e281133b972e394574a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a648f540fa40e1e281133b972e394574a">positive_semidefinite</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;m)</td></tr>
<tr class="memdesc:a648f540fa40e1e281133b972e394574a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula constraining <code>m</code> to be a positive-semidefinite matrix.  <a href="#a648f540fa40e1e281133b972e394574a">More...</a><br /></td></tr>
<tr class="separator:a648f540fa40e1e281133b972e394574a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514b594b37dbb603af40803e175b5f6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a514b594b37dbb603af40803e175b5f6a">positive_semidefinite</a> (const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;m, Eigen::UpLoType mode)</td></tr>
<tr class="memdesc:a514b594b37dbb603af40803e175b5f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a symbolic positive-semidefinite formula from <code>m</code>.  <a href="#a514b594b37dbb603af40803e175b5f6a">More...</a><br /></td></tr>
<tr class="separator:a514b594b37dbb603af40803e175b5f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589bce42bdf814187045157a262e8953"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a589bce42bdf814187045157a262e8953"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::MatrixXpr &gt;::value &amp;&amp;std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a589bce42bdf814187045157a262e8953">positive_semidefinite</a> (const Eigen::TriangularView&lt; Derived, Eigen::Lower &gt; &amp;l)</td></tr>
<tr class="memdesc:a589bce42bdf814187045157a262e8953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a symbolic positive-semidefinite formula from a lower triangular-view <code>l</code>.  <a href="#a589bce42bdf814187045157a262e8953">More...</a><br /></td></tr>
<tr class="separator:a589bce42bdf814187045157a262e8953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8fb394a3d4252968bd22740945fed2"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a5f8fb394a3d4252968bd22740945fed2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::MatrixXpr &gt;::value &amp;&amp;std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5f8fb394a3d4252968bd22740945fed2">positive_semidefinite</a> (const Eigen::TriangularView&lt; Derived, Eigen::Upper &gt; &amp;u)</td></tr>
<tr class="memdesc:a5f8fb394a3d4252968bd22740945fed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a symbolic positive-semidefinite formula from an upper triangular-view <code>u</code>.  <a href="#a5f8fb394a3d4252968bd22740945fed2">More...</a><br /></td></tr>
<tr class="separator:a5f8fb394a3d4252968bd22740945fed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c794bfc916c077b16d9c7d47031f68c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3c794bfc916c077b16d9c7d47031f68c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="separator:a3c794bfc916c077b16d9c7d47031f68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3821701f71cdfe8c9fbb277e017b384d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3821701f71cdfe8c9fbb277e017b384d">is_false</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a3821701f71cdfe8c9fbb277e017b384d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is structurally equal to False formula.  <a href="#a3821701f71cdfe8c9fbb277e017b384d">More...</a><br /></td></tr>
<tr class="separator:a3821701f71cdfe8c9fbb277e017b384d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a71b252df5a615ff80f712e2983ab53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1a71b252df5a615ff80f712e2983ab53">is_true</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a1a71b252df5a615ff80f712e2983ab53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is structurally equal to True formula.  <a href="#a1a71b252df5a615ff80f712e2983ab53">More...</a><br /></td></tr>
<tr class="separator:a1a71b252df5a615ff80f712e2983ab53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571adc7bcdc056eec761a657f9354cd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a571adc7bcdc056eec761a657f9354cd7">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a571adc7bcdc056eec761a657f9354cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a variable formula.  <a href="#a571adc7bcdc056eec761a657f9354cd7">More...</a><br /></td></tr>
<tr class="separator:a571adc7bcdc056eec761a657f9354cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff01b0d18262c1673124bd659870a3a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aff01b0d18262c1673124bd659870a3a4">is_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aff01b0d18262c1673124bd659870a3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing equality (==).  <a href="#aff01b0d18262c1673124bd659870a3a4">More...</a><br /></td></tr>
<tr class="separator:aff01b0d18262c1673124bd659870a3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf5f88e2f5295758117375a30de6386"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1cf5f88e2f5295758117375a30de6386">is_not_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a1cf5f88e2f5295758117375a30de6386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing disequality (!=).  <a href="#a1cf5f88e2f5295758117375a30de6386">More...</a><br /></td></tr>
<tr class="separator:a1cf5f88e2f5295758117375a30de6386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c7242773fe5a8413bf3505e34e8477"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af6c7242773fe5a8413bf3505e34e8477">is_greater_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:af6c7242773fe5a8413bf3505e34e8477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing greater-than (&gt;).  <a href="#af6c7242773fe5a8413bf3505e34e8477">More...</a><br /></td></tr>
<tr class="separator:af6c7242773fe5a8413bf3505e34e8477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71ff98005aa4a5b0d0639c055fb295f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa71ff98005aa4a5b0d0639c055fb295f">is_greater_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aa71ff98005aa4a5b0d0639c055fb295f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing greater-than-or-equal-to (&gt;=).  <a href="#aa71ff98005aa4a5b0d0639c055fb295f">More...</a><br /></td></tr>
<tr class="separator:aa71ff98005aa4a5b0d0639c055fb295f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50548d8092f6c0fa9796daf743a91d56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a50548d8092f6c0fa9796daf743a91d56">is_less_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a50548d8092f6c0fa9796daf743a91d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing less-than (&lt;).  <a href="#a50548d8092f6c0fa9796daf743a91d56">More...</a><br /></td></tr>
<tr class="separator:a50548d8092f6c0fa9796daf743a91d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bd0f6e944bac326e6e943f26d3d043"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad4bd0f6e944bac326e6e943f26d3d043">is_less_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ad4bd0f6e944bac326e6e943f26d3d043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing less-than-or-equal-to (&lt;=).  <a href="#ad4bd0f6e944bac326e6e943f26d3d043">More...</a><br /></td></tr>
<tr class="separator:ad4bd0f6e944bac326e6e943f26d3d043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0abfc50fd5ff7cda1e5709688b4569"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aac0abfc50fd5ff7cda1e5709688b4569">is_relational</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aac0abfc50fd5ff7cda1e5709688b4569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}).  <a href="#aac0abfc50fd5ff7cda1e5709688b4569">More...</a><br /></td></tr>
<tr class="separator:aac0abfc50fd5ff7cda1e5709688b4569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52208f3bf9cb2720f5d99223c20382f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a52208f3bf9cb2720f5d99223c20382f9">is_conjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a52208f3bf9cb2720f5d99223c20382f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a conjunction (∧).  <a href="#a52208f3bf9cb2720f5d99223c20382f9">More...</a><br /></td></tr>
<tr class="separator:a52208f3bf9cb2720f5d99223c20382f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f5414ecb9fa8f70d2303a3408aa95b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a96f5414ecb9fa8f70d2303a3408aa95b">is_disjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a96f5414ecb9fa8f70d2303a3408aa95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a disjunction (∨).  <a href="#a96f5414ecb9fa8f70d2303a3408aa95b">More...</a><br /></td></tr>
<tr class="separator:a96f5414ecb9fa8f70d2303a3408aa95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce383d57808e711c1517e9bd461cde2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abce383d57808e711c1517e9bd461cde2">is_nary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:abce383d57808e711c1517e9bd461cde2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a n-ary formula ({∧, ∨}).  <a href="#abce383d57808e711c1517e9bd461cde2">More...</a><br /></td></tr>
<tr class="separator:abce383d57808e711c1517e9bd461cde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcebff63e5d9aa57da4a45df326a2acf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abcebff63e5d9aa57da4a45df326a2acf">is_negation</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:abcebff63e5d9aa57da4a45df326a2acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a negation (¬).  <a href="#abcebff63e5d9aa57da4a45df326a2acf">More...</a><br /></td></tr>
<tr class="separator:abcebff63e5d9aa57da4a45df326a2acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2266fd8f32067b29eed7e0345658af9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae2266fd8f32067b29eed7e0345658af9">is_forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ae2266fd8f32067b29eed7e0345658af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a Forall formula (∀).  <a href="#ae2266fd8f32067b29eed7e0345658af9">More...</a><br /></td></tr>
<tr class="separator:ae2266fd8f32067b29eed7e0345658af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819538a0900f5b91b88a5a5b25f756d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a819538a0900f5b91b88a5a5b25f756d1">is_isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a819538a0900f5b91b88a5a5b25f756d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is an isnan formula.  <a href="#a819538a0900f5b91b88a5a5b25f756d1">More...</a><br /></td></tr>
<tr class="separator:a819538a0900f5b91b88a5a5b25f756d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8a8cf51365e956ea445cf6b77d2577"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9a8a8cf51365e956ea445cf6b77d2577">is_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a9a8a8cf51365e956ea445cf6b77d2577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a positive-semidefinite formula.  <a href="#a9a8a8cf51365e956ea445cf6b77d2577">More...</a><br /></td></tr>
<tr class="separator:a9a8a8cf51365e956ea445cf6b77d2577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486a9821c4235aeda4e39ff0652f72e7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a486a9821c4235aeda4e39ff0652f72e7">get_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a486a9821c4235aeda4e39ff0652f72e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the embedded variable in the variable formula <code>f</code>.  <a href="#a486a9821c4235aeda4e39ff0652f72e7">More...</a><br /></td></tr>
<tr class="separator:a486a9821c4235aeda4e39ff0652f72e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef2e4ae842f5cec22644a1627929c20"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#afef2e4ae842f5cec22644a1627929c20">get_lhs_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:afef2e4ae842f5cec22644a1627929c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lhs-argument of a relational formula <code>f</code>.  <a href="#afef2e4ae842f5cec22644a1627929c20">More...</a><br /></td></tr>
<tr class="separator:afef2e4ae842f5cec22644a1627929c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952d7f91d0e9e67110274daf0d17f132"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a952d7f91d0e9e67110274daf0d17f132">get_rhs_expression</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a952d7f91d0e9e67110274daf0d17f132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rhs-argument of a relational formula <code>f</code>.  <a href="#a952d7f91d0e9e67110274daf0d17f132">More...</a><br /></td></tr>
<tr class="separator:a952d7f91d0e9e67110274daf0d17f132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2362f52cf6b8c750209340520e7bc9b4"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2362f52cf6b8c750209340520e7bc9b4">get_operands</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a2362f52cf6b8c750209340520e7bc9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of formulas in a n-ary formula <code>f</code>.  <a href="#a2362f52cf6b8c750209340520e7bc9b4">More...</a><br /></td></tr>
<tr class="separator:a2362f52cf6b8c750209340520e7bc9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7303caa2be22b055163dc4e7134834"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2c7303caa2be22b055163dc4e7134834">get_operand</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a2c7303caa2be22b055163dc4e7134834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the formula in a negation formula <code>f</code>.  <a href="#a2c7303caa2be22b055163dc4e7134834">More...</a><br /></td></tr>
<tr class="separator:a2c7303caa2be22b055163dc4e7134834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5db567077a794c0bb1653699c84a95"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3f5db567077a794c0bb1653699c84a95">get_quantified_variables</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a3f5db567077a794c0bb1653699c84a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quantified variables in a forall formula <code>f</code>.  <a href="#a3f5db567077a794c0bb1653699c84a95">More...</a><br /></td></tr>
<tr class="separator:a3f5db567077a794c0bb1653699c84a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfcc66d64e8756ae983891059050205"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acbfcc66d64e8756ae983891059050205">get_quantified_formula</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:acbfcc66d64e8756ae983891059050205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quantified formula in a forall formula <code>f</code>.  <a href="#acbfcc66d64e8756ae983891059050205">More...</a><br /></td></tr>
<tr class="separator:acbfcc66d64e8756ae983891059050205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19aa57dcc28c59559eef51f7cbba8cba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a19aa57dcc28c59559eef51f7cbba8cba">get_matrix_in_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a19aa57dcc28c59559eef51f7cbba8cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matrix in a positive-semidefinite formula <code>f</code>.  <a href="#a19aa57dcc28c59559eef51f7cbba8cba">More...</a><br /></td></tr>
<tr class="separator:a19aa57dcc28c59559eef51f7cbba8cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee5f21259ce481fb8967a457dc80362"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a4ee5f21259ce481fb8967a457dc80362"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar()==typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4ee5f21259ce481fb8967a457dc80362">operator==</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a4ee5f21259ce481fb8967a457dc80362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise symbolic-equality of two arrays <code>m1</code> and <code>m2</code>.  <a href="#a4ee5f21259ce481fb8967a457dc80362">More...</a><br /></td></tr>
<tr class="separator:a4ee5f21259ce481fb8967a457dc80362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebadda4ff0c83bc56fbe0d1a1394c42"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:a7ebadda4ff0c83bc56fbe0d1a1394c42"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename Derived::Scalar()==ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7ebadda4ff0c83bc56fbe0d1a1394c42">operator==</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a7ebadda4ff0c83bc56fbe0d1a1394c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using equal-to operator (==).  <a href="#a7ebadda4ff0c83bc56fbe0d1a1394c42">More...</a><br /></td></tr>
<tr class="separator:a7ebadda4ff0c83bc56fbe0d1a1394c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a608496012273ef3a3588c98177334d"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:a4a608496012273ef3a3588c98177334d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(ScalarType()==typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4a608496012273ef3a3588c98177334d">operator==</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a4a608496012273ef3a3588c98177334d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> equal-to operator (==).  <a href="#a4a608496012273ef3a3588c98177334d">More...</a><br /></td></tr>
<tr class="separator:a4a608496012273ef3a3588c98177334d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9128f57eda95a717917a28f5c510968"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ae9128f57eda95a717917a28f5c510968"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar()&lt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae9128f57eda95a717917a28f5c510968">operator&lt;=</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:ae9128f57eda95a717917a28f5c510968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using less-than-or-equal operator (&lt;=).  <a href="#ae9128f57eda95a717917a28f5c510968">More...</a><br /></td></tr>
<tr class="separator:ae9128f57eda95a717917a28f5c510968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68198826f1753cb1e463c57c42da9dc7"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:a68198826f1753cb1e463c57c42da9dc7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename Derived::Scalar()&lt;=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a68198826f1753cb1e463c57c42da9dc7">operator&lt;=</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a68198826f1753cb1e463c57c42da9dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using less-than-or-equal operator (&lt;=).  <a href="#a68198826f1753cb1e463c57c42da9dc7">More...</a><br /></td></tr>
<tr class="separator:a68198826f1753cb1e463c57c42da9dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b7debe6add1a90d995b7fe32077e15"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:a84b7debe6add1a90d995b7fe32077e15"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(ScalarType()&lt;=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a84b7debe6add1a90d995b7fe32077e15">operator&lt;=</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a84b7debe6add1a90d995b7fe32077e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than-or-equal operator (&lt;=).  <a href="#a84b7debe6add1a90d995b7fe32077e15">More...</a><br /></td></tr>
<tr class="separator:a84b7debe6add1a90d995b7fe32077e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f14d72dc6d1dacae1f23f666ed42595"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a0f14d72dc6d1dacae1f23f666ed42595"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar()&lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0f14d72dc6d1dacae1f23f666ed42595">operator&lt;</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a0f14d72dc6d1dacae1f23f666ed42595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using less-than operator (&lt;).  <a href="#a0f14d72dc6d1dacae1f23f666ed42595">More...</a><br /></td></tr>
<tr class="separator:a0f14d72dc6d1dacae1f23f666ed42595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986b3544a84c715fba5ba1633845a206"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:a986b3544a84c715fba5ba1633845a206"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename Derived::Scalar()&lt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a986b3544a84c715fba5ba1633845a206">operator&lt;</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a986b3544a84c715fba5ba1633845a206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using less-than operator (&lt;).  <a href="#a986b3544a84c715fba5ba1633845a206">More...</a><br /></td></tr>
<tr class="separator:a986b3544a84c715fba5ba1633845a206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c9b1d47ba70ed1290375ef56166d13"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:ae3c9b1d47ba70ed1290375ef56166d13"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(ScalarType()&lt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae3c9b1d47ba70ed1290375ef56166d13">operator&lt;</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:ae3c9b1d47ba70ed1290375ef56166d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than operator (&lt;).  <a href="#ae3c9b1d47ba70ed1290375ef56166d13">More...</a><br /></td></tr>
<tr class="separator:ae3c9b1d47ba70ed1290375ef56166d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f925205cdf85170720d4cc61ec10991"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a0f925205cdf85170720d4cc61ec10991"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar() &gt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0f925205cdf85170720d4cc61ec10991">operator&gt;=</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a0f925205cdf85170720d4cc61ec10991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using greater-than-or-equal operator (&gt;=).  <a href="#a0f925205cdf85170720d4cc61ec10991">More...</a><br /></td></tr>
<tr class="separator:a0f925205cdf85170720d4cc61ec10991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b826253c8e91199f4b45732ba4bf2b"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:a04b826253c8e91199f4b45732ba4bf2b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename Derived::Scalar() &gt;=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a04b826253c8e91199f4b45732ba4bf2b">operator&gt;=</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a04b826253c8e91199f4b45732ba4bf2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using greater-than-or-equal operator (&gt;=).  <a href="#a04b826253c8e91199f4b45732ba4bf2b">More...</a><br /></td></tr>
<tr class="separator:a04b826253c8e91199f4b45732ba4bf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405bf4ecc90c0dc8aa47223422d4ed52"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:a405bf4ecc90c0dc8aa47223422d4ed52"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(ScalarType() &gt;=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a405bf4ecc90c0dc8aa47223422d4ed52">operator&gt;=</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a405bf4ecc90c0dc8aa47223422d4ed52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than-or-equal operator (&lt;=) instead of greater-than-or-equal operator (&gt;=).  <a href="#a405bf4ecc90c0dc8aa47223422d4ed52">More...</a><br /></td></tr>
<tr class="separator:a405bf4ecc90c0dc8aa47223422d4ed52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22804124c97e376fad6bb10d00113f6"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ad22804124c97e376fad6bb10d00113f6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad22804124c97e376fad6bb10d00113f6">operator&gt;</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:ad22804124c97e376fad6bb10d00113f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using greater-than operator (&gt;).  <a href="#ad22804124c97e376fad6bb10d00113f6">More...</a><br /></td></tr>
<tr class="separator:ad22804124c97e376fad6bb10d00113f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a0bb42e093d46cbd74a0c263c0d61a"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:ac3a0bb42e093d46cbd74a0c263c0d61a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename Derived::Scalar() &gt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac3a0bb42e093d46cbd74a0c263c0d61a">operator&gt;</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:ac3a0bb42e093d46cbd74a0c263c0d61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using greater-than operator (&gt;).  <a href="#ac3a0bb42e093d46cbd74a0c263c0d61a">More...</a><br /></td></tr>
<tr class="separator:ac3a0bb42e093d46cbd74a0c263c0d61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e63a21e3a4861f1a6fccbc7667cd298"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:a0e63a21e3a4861f1a6fccbc7667cd298"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(ScalarType() &gt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0e63a21e3a4861f1a6fccbc7667cd298">operator&gt;</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a0e63a21e3a4861f1a6fccbc7667cd298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than operator (&lt;) instead of greater-than operator (&gt;).  <a href="#a0e63a21e3a4861f1a6fccbc7667cd298">More...</a><br /></td></tr>
<tr class="separator:a0e63a21e3a4861f1a6fccbc7667cd298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ab0d3036f7e2f93354a35e4dad6ae2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a54ab0d3036f7e2f93354a35e4dad6ae2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar() !=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, typename internal::RelationalOpTraits&lt; DerivedA, DerivedB &gt;::ReturnType &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a54ab0d3036f7e2f93354a35e4dad6ae2">operator!=</a> (const DerivedA &amp;a1, const DerivedB &amp;a2)</td></tr>
<tr class="memdesc:a54ab0d3036f7e2f93354a35e4dad6ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using not-equal operator (!=).  <a href="#a54ab0d3036f7e2f93354a35e4dad6ae2">More...</a><br /></td></tr>
<tr class="separator:a54ab0d3036f7e2f93354a35e4dad6ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29162801f264334d6292daf5830f9f78"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ScalarType &gt; </td></tr>
<tr class="memitem:a29162801f264334d6292daf5830f9f78"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename Derived::Scalar() !=ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a29162801f264334d6292daf5830f9f78">operator!=</a> (const Derived &amp;a, const ScalarType &amp;v)</td></tr>
<tr class="memdesc:a29162801f264334d6292daf5830f9f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using not-equal operator (!=).  <a href="#a29162801f264334d6292daf5830f9f78">More...</a><br /></td></tr>
<tr class="separator:a29162801f264334d6292daf5830f9f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4d5abce6202d5c1e711750cf6d4fb6"><td class="memTemplParams" colspan="2">template&lt;typename ScalarType , typename Derived &gt; </td></tr>
<tr class="memitem:a1d4d5abce6202d5c1e711750cf6d4fb6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; Derived &gt;::XprKind, Eigen::ArrayXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(ScalarType() !=typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, Eigen::Array&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1d4d5abce6202d5c1e711750cf6d4fb6">operator!=</a> (const ScalarType &amp;v, const Derived &amp;a)</td></tr>
<tr class="memdesc:a1d4d5abce6202d5c1e711750cf6d4fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> not-equal operator (!=).  <a href="#a1d4d5abce6202d5c1e711750cf6d4fb6">More...</a><br /></td></tr>
<tr class="separator:a1d4d5abce6202d5c1e711750cf6d4fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2f78812963ed2e8e95b5807249efbc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a2f2f78812963ed2e8e95b5807249efbc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt;::value &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar()==typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2f2f78812963ed2e8e95b5807249efbc">operator==</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a2f2f78812963ed2e8e95b5807249efbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula checking if two matrices <code>m1</code> and <code>m2</code> are equal.  <a href="#a2f2f78812963ed2e8e95b5807249efbc">More...</a><br /></td></tr>
<tr class="separator:a2f2f78812963ed2e8e95b5807249efbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72b431bb035e5035d4a5ca5c1aedb02"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ac72b431bb035e5035d4a5ca5c1aedb02"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt;::value &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar() !=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac72b431bb035e5035d4a5ca5c1aedb02">operator!=</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:ac72b431bb035e5035d4a5ca5c1aedb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing the condition whether <code>m1</code> and <code>m2</code> are not the same.  <a href="#ac72b431bb035e5035d4a5ca5c1aedb02">More...</a><br /></td></tr>
<tr class="separator:ac72b431bb035e5035d4a5ca5c1aedb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fb24103c168ad624e3416b15f206ae"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a41fb24103c168ad624e3416b15f206ae"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt;::value &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar()&lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a41fb24103c168ad624e3416b15f206ae">operator&lt;</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a41fb24103c168ad624e3416b15f206ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using less-than (&lt;) operator.  <a href="#a41fb24103c168ad624e3416b15f206ae">More...</a><br /></td></tr>
<tr class="separator:a41fb24103c168ad624e3416b15f206ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382f5863e12e1c5357b9e40a42a1787d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a382f5863e12e1c5357b9e40a42a1787d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt;::value &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar()&lt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a382f5863e12e1c5357b9e40a42a1787d">operator&lt;=</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a382f5863e12e1c5357b9e40a42a1787d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using less-than-or-equal operator (&lt;=).  <a href="#a382f5863e12e1c5357b9e40a42a1787d">More...</a><br /></td></tr>
<tr class="separator:a382f5863e12e1c5357b9e40a42a1787d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6112c67bd713407a1da5a46df61f0ba"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ad6112c67bd713407a1da5a46df61f0ba"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt;::value &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad6112c67bd713407a1da5a46df61f0ba">operator&gt;</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:ad6112c67bd713407a1da5a46df61f0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using greater-than operator (&gt;).  <a href="#ad6112c67bd713407a1da5a46df61f0ba">More...</a><br /></td></tr>
<tr class="separator:ad6112c67bd713407a1da5a46df61f0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56de2d077a42329f2c508a71e7e52ca9"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a56de2d077a42329f2c508a71e7e52ca9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename Eigen::internal::traits&lt; DerivedA &gt;::XprKind, Eigen::MatrixXpr &gt;::value &amp;&amp;std::is_same&lt; typename Eigen::internal::traits&lt; DerivedB &gt;::XprKind, Eigen::MatrixXpr &gt;::value &amp;&amp;std::is_same&lt; decltype(typename DerivedA::Scalar() &gt;=typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a56de2d077a42329f2c508a71e7e52ca9">operator&gt;=</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a56de2d077a42329f2c508a71e7e52ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using greater-than-or-equal operator (&gt;=).  <a href="#a56de2d077a42329f2c508a71e7e52ca9">More...</a><br /></td></tr>
<tr class="separator:a56de2d077a42329f2c508a71e7e52ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe1f207a7dfa971bf80a1d44041368b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9fe1f207a7dfa971bf80a1d44041368b">is_false</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a9fe1f207a7dfa971bf80a1d44041368b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is structurally equal to False formula.  <a href="#a9fe1f207a7dfa971bf80a1d44041368b">More...</a><br /></td></tr>
<tr class="separator:a9fe1f207a7dfa971bf80a1d44041368b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3654df643f4d7840fd8548eb81f4a9ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3654df643f4d7840fd8548eb81f4a9ae">is_true</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a3654df643f4d7840fd8548eb81f4a9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is structurally equal to True formula.  <a href="#a3654df643f4d7840fd8548eb81f4a9ae">More...</a><br /></td></tr>
<tr class="separator:a3654df643f4d7840fd8548eb81f4a9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac014e89da18637b81f9c1fbe6306e689"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac014e89da18637b81f9c1fbe6306e689">is_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:ac014e89da18637b81f9c1fbe6306e689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a variable formula.  <a href="#ac014e89da18637b81f9c1fbe6306e689">More...</a><br /></td></tr>
<tr class="separator:ac014e89da18637b81f9c1fbe6306e689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ce3ca5629e2672f177ff3c0cc088ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a09ce3ca5629e2672f177ff3c0cc088ae">is_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a09ce3ca5629e2672f177ff3c0cc088ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing equality (==).  <a href="#a09ce3ca5629e2672f177ff3c0cc088ae">More...</a><br /></td></tr>
<tr class="separator:a09ce3ca5629e2672f177ff3c0cc088ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5cfac124e8ae1c7450c4e0c91c2bc07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac5cfac124e8ae1c7450c4e0c91c2bc07">is_not_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:ac5cfac124e8ae1c7450c4e0c91c2bc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing disequality (!=).  <a href="#ac5cfac124e8ae1c7450c4e0c91c2bc07">More...</a><br /></td></tr>
<tr class="separator:ac5cfac124e8ae1c7450c4e0c91c2bc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aab22ba7b7baeb20a13b0aa90172fc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0aab22ba7b7baeb20a13b0aa90172fc1">is_greater_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a0aab22ba7b7baeb20a13b0aa90172fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing greater-than (&gt;).  <a href="#a0aab22ba7b7baeb20a13b0aa90172fc1">More...</a><br /></td></tr>
<tr class="separator:a0aab22ba7b7baeb20a13b0aa90172fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788e2bbb344403337e7b77edf2bd92fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a788e2bbb344403337e7b77edf2bd92fa">is_greater_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a788e2bbb344403337e7b77edf2bd92fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing greater-than-or-equal-to (&gt;=).  <a href="#a788e2bbb344403337e7b77edf2bd92fa">More...</a><br /></td></tr>
<tr class="separator:a788e2bbb344403337e7b77edf2bd92fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed4c523512b2ee45d906c0f9d0b1d13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aaed4c523512b2ee45d906c0f9d0b1d13">is_less_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:aaed4c523512b2ee45d906c0f9d0b1d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing less-than (&lt;).  <a href="#aaed4c523512b2ee45d906c0f9d0b1d13">More...</a><br /></td></tr>
<tr class="separator:aaed4c523512b2ee45d906c0f9d0b1d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfca6086d970d576d51fa5364416a297"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#adfca6086d970d576d51fa5364416a297">is_less_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:adfca6086d970d576d51fa5364416a297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a formula representing less-than-or-equal-to (&lt;=).  <a href="#adfca6086d970d576d51fa5364416a297">More...</a><br /></td></tr>
<tr class="separator:adfca6086d970d576d51fa5364416a297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500b46690e6bd8926394ccf7c8482a70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a500b46690e6bd8926394ccf7c8482a70">is_relational</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a500b46690e6bd8926394ccf7c8482a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}).  <a href="#a500b46690e6bd8926394ccf7c8482a70">More...</a><br /></td></tr>
<tr class="separator:a500b46690e6bd8926394ccf7c8482a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60a650ffd29c64c25be2dc84bfefccc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad60a650ffd29c64c25be2dc84bfefccc">is_conjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:ad60a650ffd29c64c25be2dc84bfefccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a conjunction (∧).  <a href="#ad60a650ffd29c64c25be2dc84bfefccc">More...</a><br /></td></tr>
<tr class="separator:ad60a650ffd29c64c25be2dc84bfefccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb95d50cf0c445f6be7d3d1e5a356a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9fb95d50cf0c445f6be7d3d1e5a356a9">is_disjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a9fb95d50cf0c445f6be7d3d1e5a356a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a disjunction (∨).  <a href="#a9fb95d50cf0c445f6be7d3d1e5a356a9">More...</a><br /></td></tr>
<tr class="separator:a9fb95d50cf0c445f6be7d3d1e5a356a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a463fed830ca5aa9b3ff7bdef8f67a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a18a463fed830ca5aa9b3ff7bdef8f67a">is_negation</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a18a463fed830ca5aa9b3ff7bdef8f67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a negation (¬).  <a href="#a18a463fed830ca5aa9b3ff7bdef8f67a">More...</a><br /></td></tr>
<tr class="separator:a18a463fed830ca5aa9b3ff7bdef8f67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aeb30cdaf6f0d8f4d324afee241ae89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1aeb30cdaf6f0d8f4d324afee241ae89">is_forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a1aeb30cdaf6f0d8f4d324afee241ae89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a Forall formula (∀).  <a href="#a1aeb30cdaf6f0d8f4d324afee241ae89">More...</a><br /></td></tr>
<tr class="separator:a1aeb30cdaf6f0d8f4d324afee241ae89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726023da52d6033c2565368b6def1e16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a726023da52d6033c2565368b6def1e16">is_isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a726023da52d6033c2565368b6def1e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is an isnan formula.  <a href="#a726023da52d6033c2565368b6def1e16">More...</a><br /></td></tr>
<tr class="separator:a726023da52d6033c2565368b6def1e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a59dcaebd746af03b1996daf8d8901"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a42a59dcaebd746af03b1996daf8d8901">is_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;f)</td></tr>
<tr class="memdesc:a42a59dcaebd746af03b1996daf8d8901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>f</code> is a positive semidefinite formula.  <a href="#a42a59dcaebd746af03b1996daf8d8901">More...</a><br /></td></tr>
<tr class="separator:a42a59dcaebd746af03b1996daf8d8901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba2673fe37620dcc2a3b06ab7b72bec"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1ba2673fe37620dcc2a3b06ab7b72bec">to_false</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a1ba2673fe37620dcc2a3b06ab7b72bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaFalse&gt;</code>.  <a href="#a1ba2673fe37620dcc2a3b06ab7b72bec">More...</a><br /></td></tr>
<tr class="separator:a1ba2673fe37620dcc2a3b06ab7b72bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa798e0006353eec207f3d8949b9dac6e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa798e0006353eec207f3d8949b9dac6e">to_false</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:aa798e0006353eec207f3d8949b9dac6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaFalse&gt;</code>.  <a href="#aa798e0006353eec207f3d8949b9dac6e">More...</a><br /></td></tr>
<tr class="separator:aa798e0006353eec207f3d8949b9dac6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85772f75f073405ed82017151b4cb279"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a85772f75f073405ed82017151b4cb279">to_true</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a85772f75f073405ed82017151b4cb279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaTrue&gt;</code>.  <a href="#a85772f75f073405ed82017151b4cb279">More...</a><br /></td></tr>
<tr class="separator:a85772f75f073405ed82017151b4cb279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f183c5bf0f406767e56af9241233ba5"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7f183c5bf0f406767e56af9241233ba5">to_true</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a7f183c5bf0f406767e56af9241233ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaTrue&gt;</code>.  <a href="#a7f183c5bf0f406767e56af9241233ba5">More...</a><br /></td></tr>
<tr class="separator:a7f183c5bf0f406767e56af9241233ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b78dde9ca32fe1ee12cc232a9a4e85c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3b78dde9ca32fe1ee12cc232a9a4e85c">to_variable</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a3b78dde9ca32fe1ee12cc232a9a4e85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaVar&gt;</code>.  <a href="#a3b78dde9ca32fe1ee12cc232a9a4e85c">More...</a><br /></td></tr>
<tr class="separator:a3b78dde9ca32fe1ee12cc232a9a4e85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cc1d5ad9af2df4592a5e536d1f8191"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a88cc1d5ad9af2df4592a5e536d1f8191">to_variable</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a88cc1d5ad9af2df4592a5e536d1f8191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaVar&gt;</code>.  <a href="#a88cc1d5ad9af2df4592a5e536d1f8191">More...</a><br /></td></tr>
<tr class="separator:a88cc1d5ad9af2df4592a5e536d1f8191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259612bbd9405f24d4ac3b60d54575e6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a259612bbd9405f24d4ac3b60d54575e6">to_relational</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a259612bbd9405f24d4ac3b60d54575e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const RelationalFormulaCell&gt;</code>.  <a href="#a259612bbd9405f24d4ac3b60d54575e6">More...</a><br /></td></tr>
<tr class="separator:a259612bbd9405f24d4ac3b60d54575e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d435fa1f878d87ebaea81f9c30c1c0c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5d435fa1f878d87ebaea81f9c30c1c0c">to_relational</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a5d435fa1f878d87ebaea81f9c30c1c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const RelationalFormulaCell&gt;</code>.  <a href="#a5d435fa1f878d87ebaea81f9c30c1c0c">More...</a><br /></td></tr>
<tr class="separator:a5d435fa1f878d87ebaea81f9c30c1c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a6204418091c1fbf26c9d2ad03389f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a10a6204418091c1fbf26c9d2ad03389f">to_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a10a6204418091c1fbf26c9d2ad03389f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaEq&gt;</code>.  <a href="#a10a6204418091c1fbf26c9d2ad03389f">More...</a><br /></td></tr>
<tr class="separator:a10a6204418091c1fbf26c9d2ad03389f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd0c45d93c60c6d378d73e4041f6323"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0fd0c45d93c60c6d378d73e4041f6323">to_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a0fd0c45d93c60c6d378d73e4041f6323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaEq&gt;</code>.  <a href="#a0fd0c45d93c60c6d378d73e4041f6323">More...</a><br /></td></tr>
<tr class="separator:a0fd0c45d93c60c6d378d73e4041f6323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e880ce60c41c7e65085dbf911edded"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a70e880ce60c41c7e65085dbf911edded">to_not_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a70e880ce60c41c7e65085dbf911edded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaNeq&gt;</code>.  <a href="#a70e880ce60c41c7e65085dbf911edded">More...</a><br /></td></tr>
<tr class="separator:a70e880ce60c41c7e65085dbf911edded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489de7c0c27a31969904b3f9a10792f3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a489de7c0c27a31969904b3f9a10792f3">to_not_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a489de7c0c27a31969904b3f9a10792f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaNeq&gt;</code>.  <a href="#a489de7c0c27a31969904b3f9a10792f3">More...</a><br /></td></tr>
<tr class="separator:a489de7c0c27a31969904b3f9a10792f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352fe19778d77b7095580950d8e298b4"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a352fe19778d77b7095580950d8e298b4">to_greater_than</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a352fe19778d77b7095580950d8e298b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaGt&gt;</code>.  <a href="#a352fe19778d77b7095580950d8e298b4">More...</a><br /></td></tr>
<tr class="separator:a352fe19778d77b7095580950d8e298b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8319545722755f981d6c314f7994c469"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8319545722755f981d6c314f7994c469">to_greater_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a8319545722755f981d6c314f7994c469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaGt&gt;</code>.  <a href="#a8319545722755f981d6c314f7994c469">More...</a><br /></td></tr>
<tr class="separator:a8319545722755f981d6c314f7994c469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8cbb802de92188843f8531d6b05827"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7f8cbb802de92188843f8531d6b05827">to_greater_than_or_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a7f8cbb802de92188843f8531d6b05827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaGeq&gt;</code>.  <a href="#a7f8cbb802de92188843f8531d6b05827">More...</a><br /></td></tr>
<tr class="separator:a7f8cbb802de92188843f8531d6b05827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159568e84904a2b16547ca120d8cb879"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a159568e84904a2b16547ca120d8cb879">to_greater_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a159568e84904a2b16547ca120d8cb879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaGeq&gt;</code>.  <a href="#a159568e84904a2b16547ca120d8cb879">More...</a><br /></td></tr>
<tr class="separator:a159568e84904a2b16547ca120d8cb879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7488de67ca4d6bc69cec3bb0f67ae4c3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7488de67ca4d6bc69cec3bb0f67ae4c3">to_less_than</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a7488de67ca4d6bc69cec3bb0f67ae4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaLt&gt;</code>.  <a href="#a7488de67ca4d6bc69cec3bb0f67ae4c3">More...</a><br /></td></tr>
<tr class="separator:a7488de67ca4d6bc69cec3bb0f67ae4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67a9b87898cca1805eb751adce904e3"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac67a9b87898cca1805eb751adce904e3">to_less_than</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:ac67a9b87898cca1805eb751adce904e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaLt&gt;</code>.  <a href="#ac67a9b87898cca1805eb751adce904e3">More...</a><br /></td></tr>
<tr class="separator:ac67a9b87898cca1805eb751adce904e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb39c33945b763922fe0fcacc6c369b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acfb39c33945b763922fe0fcacc6c369b">to_less_than_or_equal_to</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:acfb39c33945b763922fe0fcacc6c369b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaLeq&gt;</code>.  <a href="#acfb39c33945b763922fe0fcacc6c369b">More...</a><br /></td></tr>
<tr class="separator:acfb39c33945b763922fe0fcacc6c369b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7885122152600db68a8c6219de6a941f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7885122152600db68a8c6219de6a941f">to_less_than_or_equal_to</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a7885122152600db68a8c6219de6a941f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaLeq&gt;</code>.  <a href="#a7885122152600db68a8c6219de6a941f">More...</a><br /></td></tr>
<tr class="separator:a7885122152600db68a8c6219de6a941f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180aa6c7637801b158099a87a59a4185"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a180aa6c7637801b158099a87a59a4185">to_conjunction</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a180aa6c7637801b158099a87a59a4185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaAnd&gt;</code>.  <a href="#a180aa6c7637801b158099a87a59a4185">More...</a><br /></td></tr>
<tr class="separator:a180aa6c7637801b158099a87a59a4185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7b85f4c856cc5e59afd911c80a1e2a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6c7b85f4c856cc5e59afd911c80a1e2a">to_conjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a6c7b85f4c856cc5e59afd911c80a1e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaAnd&gt;</code>.  <a href="#a6c7b85f4c856cc5e59afd911c80a1e2a">More...</a><br /></td></tr>
<tr class="separator:a6c7b85f4c856cc5e59afd911c80a1e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0758b788047cb3d6b4737c6d54cee2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0b0758b788047cb3d6b4737c6d54cee2">to_disjunction</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a0b0758b788047cb3d6b4737c6d54cee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaOr&gt;</code>.  <a href="#a0b0758b788047cb3d6b4737c6d54cee2">More...</a><br /></td></tr>
<tr class="separator:a0b0758b788047cb3d6b4737c6d54cee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3089338cbed9420262519689dbe55e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4b3089338cbed9420262519689dbe55e">to_disjunction</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a4b3089338cbed9420262519689dbe55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaOr&gt;</code>.  <a href="#a4b3089338cbed9420262519689dbe55e">More...</a><br /></td></tr>
<tr class="separator:a4b3089338cbed9420262519689dbe55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f9249b5c150485c3c7cff61d5c0416"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad0f9249b5c150485c3c7cff61d5c0416">to_nary</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:ad0f9249b5c150485c3c7cff61d5c0416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const NaryFormulaCell&gt;</code>.  <a href="#ad0f9249b5c150485c3c7cff61d5c0416">More...</a><br /></td></tr>
<tr class="separator:ad0f9249b5c150485c3c7cff61d5c0416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4592d5998754e71a2983829aa1cc18c0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4592d5998754e71a2983829aa1cc18c0">to_nary</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a4592d5998754e71a2983829aa1cc18c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const NaryFormulaCell&gt;</code>.  <a href="#a4592d5998754e71a2983829aa1cc18c0">More...</a><br /></td></tr>
<tr class="separator:a4592d5998754e71a2983829aa1cc18c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceef2c41a1ce6c5f7eed83c1d2df9381"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aceef2c41a1ce6c5f7eed83c1d2df9381">to_negation</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:aceef2c41a1ce6c5f7eed83c1d2df9381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaNot&gt;</code>.  <a href="#aceef2c41a1ce6c5f7eed83c1d2df9381">More...</a><br /></td></tr>
<tr class="separator:aceef2c41a1ce6c5f7eed83c1d2df9381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe394b8aff884d326802f14991f2c35"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#acfe394b8aff884d326802f14991f2c35">to_negation</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:acfe394b8aff884d326802f14991f2c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaNot&gt;</code>.  <a href="#acfe394b8aff884d326802f14991f2c35">More...</a><br /></td></tr>
<tr class="separator:acfe394b8aff884d326802f14991f2c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c587017789ff28f462e87ba0a44872d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7c587017789ff28f462e87ba0a44872d">to_forall</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a7c587017789ff28f462e87ba0a44872d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaForall&gt;</code>.  <a href="#a7c587017789ff28f462e87ba0a44872d">More...</a><br /></td></tr>
<tr class="separator:a7c587017789ff28f462e87ba0a44872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07372c92a7d28a29ffaa9535b083eea6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a07372c92a7d28a29ffaa9535b083eea6">to_forall</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a07372c92a7d28a29ffaa9535b083eea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaForall&gt;</code>.  <a href="#a07372c92a7d28a29ffaa9535b083eea6">More...</a><br /></td></tr>
<tr class="separator:a07372c92a7d28a29ffaa9535b083eea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f46f5ae1e9130eb9214a2ae0611f52"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad4f46f5ae1e9130eb9214a2ae0611f52">to_isnan</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:ad4f46f5ae1e9130eb9214a2ae0611f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaIsnan&gt;</code>.  <a href="#ad4f46f5ae1e9130eb9214a2ae0611f52">More...</a><br /></td></tr>
<tr class="separator:ad4f46f5ae1e9130eb9214a2ae0611f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dbe606b9ecf35f89933db21e9c4f68"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a52dbe606b9ecf35f89933db21e9c4f68">to_isnan</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a52dbe606b9ecf35f89933db21e9c4f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaIsnan&gt;</code>.  <a href="#a52dbe606b9ecf35f89933db21e9c4f68">More...</a><br /></td></tr>
<tr class="separator:a52dbe606b9ecf35f89933db21e9c4f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6854fa16fb68d99c3cbe16d2c9afc584"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6854fa16fb68d99c3cbe16d2c9afc584">to_positive_semidefinite</a> (const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;f_ptr)</td></tr>
<tr class="memdesc:a6854fa16fb68d99c3cbe16d2c9afc584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaPositiveSemidefinite&gt;</code>.  <a href="#a6854fa16fb68d99c3cbe16d2c9afc584">More...</a><br /></td></tr>
<tr class="separator:a6854fa16fb68d99c3cbe16d2c9afc584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f05196882dfccfb74c47092c2900322"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6f05196882dfccfb74c47092c2900322">to_positive_semidefinite</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f)</td></tr>
<tr class="memdesc:a6f05196882dfccfb74c47092c2900322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts <code>f</code> to <code>shared_ptr&lt;const FormulaPositiveSemidefinite&gt;</code>.  <a href="#a6f05196882dfccfb74c47092c2900322">More...</a><br /></td></tr>
<tr class="separator:a6f05196882dfccfb74c47092c2900322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2748b5dc34bc17a6c6e98ac1d0cc1ad"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Visitor , typename... Args&gt; </td></tr>
<tr class="memitem:aa2748b5dc34bc17a6c6e98ac1d0cc1ad"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa2748b5dc34bc17a6c6e98ac1d0cc1ad">VisitFormula</a> (Visitor *v, const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa2748b5dc34bc17a6c6e98ac1d0cc1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls visitor object <code>v</code> with a symbolic formula <code>f</code>, and arguments <code>args</code>.  <a href="#aa2748b5dc34bc17a6c6e98ac1d0cc1ad">More...</a><br /></td></tr>
<tr class="separator:aa2748b5dc34bc17a6c6e98ac1d0cc1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8505db5f6e70df16a3cecda394bdcb24"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8505db5f6e70df16a3cecda394bdcb24">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a8505db5f6e70df16a3cecda394bdcb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791475e9d37a8e5fd5f1314045428997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a791475e9d37a8e5fd5f1314045428997">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> m1, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m2)</td></tr>
<tr class="memdesc:a791475e9d37a8e5fd5f1314045428997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a multiplication of two monomials, <code>m1</code> and <code>m2</code>.  <a href="#a791475e9d37a8e5fd5f1314045428997">More...</a><br /></td></tr>
<tr class="separator:a791475e9d37a8e5fd5f1314045428997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3d409cea5e6c6495394208c8c8c6ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8b3d409cea5e6c6495394208c8c8c6ee">pow</a> (<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> m, <a class="el" href="classint.html">int</a> p)</td></tr>
<tr class="memdesc:a8b3d409cea5e6c6495394208c8c8c6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>m1</code> raised to <code>p</code>.  <a href="#a8b3d409cea5e6c6495394208c8c8c6ee">More...</a><br /></td></tr>
<tr class="separator:a8b3d409cea5e6c6495394208c8c8c6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71ffcec2b8e06d52b7c6e8f53106160"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af71ffcec2b8e06d52b7c6e8f53106160">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;m)</td></tr>
<tr class="separator:af71ffcec2b8e06d52b7c6e8f53106160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5885669a7b9958dc209c13778d48e6ef"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a>, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5885669a7b9958dc209c13778d48e6ef">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;m1, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;m2)</td></tr>
<tr class="memdesc:a5885669a7b9958dc209c13778d48e6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a multiplication of two monomials, <code>m1</code> and <code>m2</code>.  <a href="#a5885669a7b9958dc209c13778d48e6ef">More...</a><br /></td></tr>
<tr class="separator:a5885669a7b9958dc209c13778d48e6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1d54669ca8ae5ea474b5904c50e85e"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a>, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aec1d54669ca8ae5ea474b5904c50e85e">pow</a> (<a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> m, <a class="el" href="classint.html">int</a> p)</td></tr>
<tr class="memdesc:aec1d54669ca8ae5ea474b5904c50e85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>m</code> raised to <code>p</code>.  <a href="#aec1d54669ca8ae5ea474b5904c50e85e">More...</a><br /></td></tr>
<tr class="separator:aec1d54669ca8ae5ea474b5904c50e85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c0029b04f957181b0cb2bdae701514"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a04c0029b04f957181b0cb2bdae701514">MonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="memdesc:a04c0029b04f957181b0cb2bdae701514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all monomials up to a given degree under the graded reverse lexicographic order.  <a href="#a04c0029b04f957181b0cb2bdae701514">More...</a><br /></td></tr>
<tr class="separator:a04c0029b04f957181b0cb2bdae701514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40528027cce753aacb377913342f536"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa40528027cce753aacb377913342f536">NChooseK</a> (<a class="el" href="classint.html">int</a> n, <a class="el" href="classint.html">int</a> k)</td></tr>
<tr class="separator:aa40528027cce753aacb377913342f536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af297794f22c0458592aeea637cce060a"><td class="memTemplParams" colspan="2">template&lt;int n, int degree&gt; </td></tr>
<tr class="memitem:af297794f22c0458592aeea637cce060a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, <a class="el" href="namespacedrake_1_1symbolic.html#aa40528027cce753aacb377913342f536">NChooseK</a>(n+degree, degree), 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af297794f22c0458592aeea637cce060a">MonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars)</td></tr>
<tr class="memdesc:af297794f22c0458592aeea637cce060a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all monomials up to a given degree under the graded reverse lexicographic order.  <a href="#af297794f22c0458592aeea637cce060a">More...</a><br /></td></tr>
<tr class="separator:af297794f22c0458592aeea637cce060a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff00cd9261b602f7ce7708286d2dae05"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aff00cd9261b602f7ce7708286d2dae05">EvenDegreeMonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="memdesc:aff00cd9261b602f7ce7708286d2dae05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all even degree monomials up to a given degree under the graded reverse lexicographic order.  <a href="#aff00cd9261b602f7ce7708286d2dae05">More...</a><br /></td></tr>
<tr class="separator:aff00cd9261b602f7ce7708286d2dae05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6ac4e26dcd9023a9f8146aa75454c7"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ade6ac4e26dcd9023a9f8146aa75454c7">OddDegreeMonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="memdesc:ade6ac4e26dcd9023a9f8146aa75454c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all odd degree monomials up to a given degree under the graded reverse lexicographic order.  <a href="#ade6ac4e26dcd9023a9f8146aa75454c7">More...</a><br /></td></tr>
<tr class="separator:ade6ac4e26dcd9023a9f8146aa75454c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade37df718218bcbdbc1edd9a0b6a596a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ade37df718218bcbdbc1edd9a0b6a596a">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="memdesc:ade37df718218bcbdbc1edd9a0b6a596a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operation for polynomial.  <a href="#ade37df718218bcbdbc1edd9a0b6a596a">More...</a><br /></td></tr>
<tr class="separator:ade37df718218bcbdbc1edd9a0b6a596a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb3773f2d585ffce0253cb15c8c00a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#affb3773f2d585ffce0253cb15c8c00a0">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p1, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p2)</td></tr>
<tr class="separator:affb3773f2d585ffce0253cb15c8c00a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a4be02d87d5a6d31efbbcb5d3ba934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a52a4be02d87d5a6d31efbbcb5d3ba934">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a52a4be02d87d5a6d31efbbcb5d3ba934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b091bab8bb06edd276c6b4a420903c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a96b091bab8bb06edd276c6b4a420903c">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, double c)</td></tr>
<tr class="separator:a96b091bab8bb06edd276c6b4a420903c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04dff9a90e39ac9985d520d3e66f5c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af04dff9a90e39ac9985d520d3e66f5c3">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:af04dff9a90e39ac9985d520d3e66f5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e02326d779ba8c55ad9d9f6eb54f3d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4e02326d779ba8c55ad9d9f6eb54f3d8">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m1, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m2)</td></tr>
<tr class="separator:a4e02326d779ba8c55ad9d9f6eb54f3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd958cf7990638bdd2576c2ab62ad43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8dd958cf7990638bdd2576c2ab62ad43">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, double c)</td></tr>
<tr class="separator:a8dd958cf7990638bdd2576c2ab62ad43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289b47480364e01b67e3c86aa33a0fe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a289b47480364e01b67e3c86aa33a0fe4">operator+</a> (double c, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:a289b47480364e01b67e3c86aa33a0fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee4b0876c4a92c7bd3030b193ce0dbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5ee4b0876c4a92c7bd3030b193ce0dbd">operator+</a> (double c, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a5ee4b0876c4a92c7bd3030b193ce0dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42522d07a4a9c32a89e8b4eea9a00a60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a42522d07a4a9c32a89e8b4eea9a00a60">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:a42522d07a4a9c32a89e8b4eea9a00a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab876f48eb96e82b718df0050b9d57d8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab876f48eb96e82b718df0050b9d57d8b">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:ab876f48eb96e82b718df0050b9d57d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa3f21ab39b7fb01be90ed9255df5f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1aa3f21ab39b7fb01be90ed9255df5f9">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p1, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p2)</td></tr>
<tr class="separator:a1aa3f21ab39b7fb01be90ed9255df5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc89061cd63bf0e4d0d79c57d3b72e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aacc89061cd63bf0e4d0d79c57d3b72e4">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:aacc89061cd63bf0e4d0d79c57d3b72e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f8b6bfe08648f4a0dac518e1abb0bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a48f8b6bfe08648f4a0dac518e1abb0bd">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, double c)</td></tr>
<tr class="separator:a48f8b6bfe08648f4a0dac518e1abb0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada023ba3d82bbf8137d74409bf596457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ada023ba3d82bbf8137d74409bf596457">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:ada023ba3d82bbf8137d74409bf596457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4fa4bbef7ce58efc247dd1717a2ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0e4fa4bbef7ce58efc247dd1717a2ded">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m1, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m2)</td></tr>
<tr class="separator:a0e4fa4bbef7ce58efc247dd1717a2ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369ea32ea396cc86951892020d5c4a4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a369ea32ea396cc86951892020d5c4a4b">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, double c)</td></tr>
<tr class="separator:a369ea32ea396cc86951892020d5c4a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6ad1d11dea0eafbfed0db238957d64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abe6ad1d11dea0eafbfed0db238957d64">operator-</a> (double c, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:abe6ad1d11dea0eafbfed0db238957d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448e985024e32143f3ca12d8596211d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a448e985024e32143f3ca12d8596211d4">operator-</a> (double c, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a448e985024e32143f3ca12d8596211d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03731fe9a001a20e071a7a9e106061bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a03731fe9a001a20e071a7a9e106061bd">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:a03731fe9a001a20e071a7a9e106061bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f8eee8c5c646b5f3fc43baf3ce5854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a30f8eee8c5c646b5f3fc43baf3ce5854">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:a30f8eee8c5c646b5f3fc43baf3ce5854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b6eea79253234902bbcf4643e34d81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae3b6eea79253234902bbcf4643e34d81">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p1, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p2)</td></tr>
<tr class="separator:ae3b6eea79253234902bbcf4643e34d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e804fc81cb6d40414b816f559f81a7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a9e804fc81cb6d40414b816f559f81a7d">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:a9e804fc81cb6d40414b816f559f81a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38134e3394d8c40a7a91490154de2b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af38134e3394d8c40a7a91490154de2b3">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, double c)</td></tr>
<tr class="separator:af38134e3394d8c40a7a91490154de2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04739aabb37142340b869a126cc54a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab04739aabb37142340b869a126cc54a1">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:ab04739aabb37142340b869a126cc54a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812892dbfc6443dc1eed055e1915f5e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a812892dbfc6443dc1eed055e1915f5e4">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m, double c)</td></tr>
<tr class="separator:a812892dbfc6443dc1eed055e1915f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fe276a728b54ce277fcc972fd28d78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a46fe276a728b54ce277fcc972fd28d78">operator *</a> (double c, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:a46fe276a728b54ce277fcc972fd28d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78d0e5127e0fa0fab9f26c075c6ad9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa78d0e5127e0fa0fab9f26c075c6ad9d">operator *</a> (double c, const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;m)</td></tr>
<tr class="separator:aa78d0e5127e0fa0fab9f26c075c6ad9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0eab276a88883d8e2607630cb93bc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1a0eab276a88883d8e2607630cb93bc5">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v)</td></tr>
<tr class="separator:a1a0eab276a88883d8e2607630cb93bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66975f1892907d118eb8cb98d6465c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab66975f1892907d118eb8cb98d6465c7">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;v, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p)</td></tr>
<tr class="separator:ab66975f1892907d118eb8cb98d6465c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9423440606bd13d4767c72dd97ec6a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ae9423440606bd13d4767c72dd97ec6a2">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> p, double v)</td></tr>
<tr class="memdesc:ae9423440606bd13d4767c72dd97ec6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>p / v</code>.  <a href="#ae9423440606bd13d4767c72dd97ec6a2">More...</a><br /></td></tr>
<tr class="separator:ae9423440606bd13d4767c72dd97ec6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa3b0259a14e44faf2d959f540e9446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8fa3b0259a14e44faf2d959f540e9446">pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, <a class="el" href="classint.html">int</a> n)</td></tr>
<tr class="memdesc:a8fa3b0259a14e44faf2d959f540e9446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns polynomial <code>rasied</code> to <code>n</code>.  <a href="#a8fa3b0259a14e44faf2d959f540e9446">More...</a><br /></td></tr>
<tr class="separator:a8fa3b0259a14e44faf2d959f540e9446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9eb2f0937be3e670ccdca9c4d30c63d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad9eb2f0937be3e670ccdca9c4d30c63d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:ad9eb2f0937be3e670ccdca9c4d30c63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece6b8e4e48de49ed447c6d62b81ce88"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:aece6b8e4e48de49ed447c6d62b81ce88"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aece6b8e4e48de49ed447c6d62b81ce88">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:aece6b8e4e48de49ed447c6d62b81ce88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following seven operations:  <a href="#aece6b8e4e48de49ed447c6d62b81ce88">More...</a><br /></td></tr>
<tr class="separator:aece6b8e4e48de49ed447c6d62b81ce88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1596c40ec725591479b2b4290a6e347b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1596c40ec725591479b2b4290a6e347b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &gt;::value, Eigen::Matrix&lt; double, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1596c40ec725591479b2b4290a6e347b">Evaluate</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;m, const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;env)</td></tr>
<tr class="memdesc:a1596c40ec725591479b2b4290a6e347b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a matrix <code>m</code> of symbolic polynomials using <code>env</code>.  <a href="#a1596c40ec725591479b2b4290a6e347b">More...</a><br /></td></tr>
<tr class="separator:a1596c40ec725591479b2b4290a6e347b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e355d7c9eb6bff11199a94c16ed5c8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a5e355d7c9eb6bff11199a94c16ed5c8a">Jacobian</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &gt;&gt; &amp;f, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;vars)</td></tr>
<tr class="memdesc:a5e355d7c9eb6bff11199a94c16ed5c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>.  <a href="#a5e355d7c9eb6bff11199a94c16ed5c8a">More...</a><br /></td></tr>
<tr class="separator:a5e355d7c9eb6bff11199a94c16ed5c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4242b6a1ad5bddbba0242c96d4a36c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad4242b6a1ad5bddbba0242c96d4a36c2">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="memdesc:ad4242b6a1ad5bddbba0242c96d4a36c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus operation for rational function.  <a href="#ad4242b6a1ad5bddbba0242c96d4a36c2">More...</a><br /></td></tr>
<tr class="separator:ad4242b6a1ad5bddbba0242c96d4a36c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8327415ae13cae1b0d450c384079a49e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8327415ae13cae1b0d450c384079a49e">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="separator:a8327415ae13cae1b0d450c384079a49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6364a2e4727b0af4071b15da0cad509"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ac6364a2e4727b0af4071b15da0cad509">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:ac6364a2e4727b0af4071b15da0cad509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185c9ab6bca14a042a837aadf2064546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a185c9ab6bca14a042a837aadf2064546">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a185c9ab6bca14a042a837aadf2064546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167d0d14d66effceeb5834371626452b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a167d0d14d66effceeb5834371626452b">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, double c)</td></tr>
<tr class="separator:a167d0d14d66effceeb5834371626452b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc08ea95543252bcf2b31fdfe723d26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0dc08ea95543252bcf2b31fdfe723d26">operator+</a> (double c, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a0dc08ea95543252bcf2b31fdfe723d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ea1fd857bdf8fa5c18f570118640ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#af9ea1fd857bdf8fa5c18f570118640ff">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="separator:af9ea1fd857bdf8fa5c18f570118640ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec6e83953a4663403fcb08592e16b01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0ec6e83953a4663403fcb08592e16b01">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:a0ec6e83953a4663403fcb08592e16b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d7c5f60ed6d69385cebc84f1154a2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a47d7c5f60ed6d69385cebc84f1154a2e">operator-</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a47d7c5f60ed6d69385cebc84f1154a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad564d8bc7c97743e2ca0654c2c417c8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad564d8bc7c97743e2ca0654c2c417c8d">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, double c)</td></tr>
<tr class="separator:ad564d8bc7c97743e2ca0654c2c417c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f74050260696325581c3087d07fab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a22f74050260696325581c3087d07fab7">operator-</a> (double c, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a22f74050260696325581c3087d07fab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97671d479c281451e703b58530b17082"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a97671d479c281451e703b58530b17082">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="separator:a97671d479c281451e703b58530b17082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71ee73fb966e97f0de864fa7cdb3692"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad71ee73fb966e97f0de864fa7cdb3692">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:ad71ee73fb966e97f0de864fa7cdb3692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5c62b680b89f6fe992e5bc6b01e6c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1c5c62b680b89f6fe992e5bc6b01e6c7">operator *</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a1c5c62b680b89f6fe992e5bc6b01e6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1611c62700b00b9861c339879899a121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1611c62700b00b9861c339879899a121">operator *</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, double c)</td></tr>
<tr class="separator:a1611c62700b00b9861c339879899a121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347249d56768661c610bf3bafb5ff167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a347249d56768661c610bf3bafb5ff167">operator *</a> (double c, <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f)</td></tr>
<tr class="separator:a347249d56768661c610bf3bafb5ff167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8b6db1763f8f7a5d98de636b9cd7c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3c8b6db1763f8f7a5d98de636b9cd7c9">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f1, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f2)</td></tr>
<tr class="separator:a3c8b6db1763f8f7a5d98de636b9cd7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8d6fb5671a17bf0c89c1c5aef9efaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4a8d6fb5671a17bf0c89c1c5aef9efaf">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p)</td></tr>
<tr class="separator:a4a8d6fb5671a17bf0c89c1c5aef9efaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ad135e8775cf9d721b1223218fff2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a27ad135e8775cf9d721b1223218fff2d">operator/</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;p, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f)</td></tr>
<tr class="separator:a27ad135e8775cf9d721b1223218fff2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687c99f46e854d9237083b2f34e6665c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a687c99f46e854d9237083b2f34e6665c">operator/</a> (<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> f, double c)</td></tr>
<tr class="separator:a687c99f46e854d9237083b2f34e6665c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb47877c3cad48fe6a8e25edb0620495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#abb47877c3cad48fe6a8e25edb0620495">operator/</a> (double c, const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f)</td></tr>
<tr class="separator:abb47877c3cad48fe6a8e25edb0620495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d86ae3f21714ef199febddf60550fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a43d86ae3f21714ef199febddf60550fe">pow</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;f, <a class="el" href="classint.html">int</a> n)</td></tr>
<tr class="memdesc:a43d86ae3f21714ef199febddf60550fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rational function <code>f</code> raised to <code>n</code>.  <a href="#a43d86ae3f21714ef199febddf60550fe">More...</a><br /></td></tr>
<tr class="separator:a43d86ae3f21714ef199febddf60550fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267c5d854d55ce16b1e58490ff426661"><td class="memTemplParams" colspan="2">template&lt;typename MatrixL , typename MatrixR &gt; </td></tr>
<tr class="memitem:a267c5d854d55ce16b1e58490ff426661"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a267c5d854d55ce16b1e58490ff426661">operator *</a> (const MatrixL &amp;lhs, const MatrixR &amp;rhs)</td></tr>
<tr class="memdesc:a267c5d854d55ce16b1e58490ff426661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the following operations:  <a href="#a267c5d854d55ce16b1e58490ff426661">More...</a><br /></td></tr>
<tr class="separator:a267c5d854d55ce16b1e58490ff426661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697784ea0eafd05039e3a0c97b7c1415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1symbolic.html#a134e54042165751a5e5369b4631c90eb">Rewriter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a697784ea0eafd05039e3a0c97b7c1415">MakeRuleRewriter</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html">RewritingRule</a> &amp;r)</td></tr>
<tr class="memdesc:a697784ea0eafd05039e3a0c97b7c1415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rewriter based on a rewriting rule <code>r</code>.  <a href="#a697784ea0eafd05039e3a0c97b7c1415">More...</a><br /></td></tr>
<tr class="separator:a697784ea0eafd05039e3a0c97b7c1415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e0055c99275292d22eb59c103fb0ae"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab6e0055c99275292d22eb59c103fb0ae">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a> type)</td></tr>
<tr class="separator:ab6e0055c99275292d22eb59c103fb0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8261e92becc1714b40d5eb5cc370da8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa8261e92becc1714b40d5eb5cc370da8">MakeMatrixVariable</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;name, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a> type)</td></tr>
<tr class="memdesc:aa8261e92becc1714b40d5eb5cc370da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen matrix of symbolic variables.  <a href="#aa8261e92becc1714b40d5eb5cc370da8">More...</a><br /></td></tr>
<tr class="separator:aa8261e92becc1714b40d5eb5cc370da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8fedc6cdc53869462f7aebaafa32c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4a8fedc6cdc53869462f7aebaafa32c0">MakeMatrixBooleanVariable</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;name)</td></tr>
<tr class="memdesc:a4a8fedc6cdc53869462f7aebaafa32c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen matrix of symbolic Boolean variables.  <a href="#a4a8fedc6cdc53869462f7aebaafa32c0">More...</a><br /></td></tr>
<tr class="separator:a4a8fedc6cdc53869462f7aebaafa32c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61ece2fbaa79f8aad11313fa4b36150"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab61ece2fbaa79f8aad11313fa4b36150">MakeMatrixBinaryVariable</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;name)</td></tr>
<tr class="memdesc:ab61ece2fbaa79f8aad11313fa4b36150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen matrix of symbolic binary variables.  <a href="#ab61ece2fbaa79f8aad11313fa4b36150">More...</a><br /></td></tr>
<tr class="separator:ab61ece2fbaa79f8aad11313fa4b36150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29875ac163c78c1d1e75106b5890c949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a29875ac163c78c1d1e75106b5890c949">MakeMatrixContinuousVariable</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;name)</td></tr>
<tr class="memdesc:a29875ac163c78c1d1e75106b5890c949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen matrix of symbolic continuous variables.  <a href="#a29875ac163c78c1d1e75106b5890c949">More...</a><br /></td></tr>
<tr class="separator:a29875ac163c78c1d1e75106b5890c949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6779284f55bfadabde9c015ad694d093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6779284f55bfadabde9c015ad694d093">MakeMatrixIntegerVariable</a> (<a class="el" href="classint.html">int</a> rows, <a class="el" href="classint.html">int</a> cols, const std::string &amp;name)</td></tr>
<tr class="memdesc:a6779284f55bfadabde9c015ad694d093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen matrix of symbolic integer variables.  <a href="#a6779284f55bfadabde9c015ad694d093">More...</a><br /></td></tr>
<tr class="separator:a6779284f55bfadabde9c015ad694d093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77055238eec353c7b077cd2fafd83aa7"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a77055238eec353c7b077cd2fafd83aa7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a77055238eec353c7b077cd2fafd83aa7">MakeMatrixVariable</a> (const std::string &amp;name, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a> type)</td></tr>
<tr class="memdesc:a77055238eec353c7b077cd2fafd83aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen matrix of symbolic variables.  <a href="#a77055238eec353c7b077cd2fafd83aa7">More...</a><br /></td></tr>
<tr class="separator:a77055238eec353c7b077cd2fafd83aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab43ed8981b8575f24e83fdf4b26295"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a2ab43ed8981b8575f24e83fdf4b26295"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2ab43ed8981b8575f24e83fdf4b26295">MakeMatrixBooleanVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2ab43ed8981b8575f24e83fdf4b26295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen matrix of symbolic Boolean variables.  <a href="#a2ab43ed8981b8575f24e83fdf4b26295">More...</a><br /></td></tr>
<tr class="separator:a2ab43ed8981b8575f24e83fdf4b26295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803dbab92e520549b625dde70f05fe47"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a803dbab92e520549b625dde70f05fe47"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a803dbab92e520549b625dde70f05fe47">MakeMatrixBinaryVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a803dbab92e520549b625dde70f05fe47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen matrix of symbolic binary variables.  <a href="#a803dbab92e520549b625dde70f05fe47">More...</a><br /></td></tr>
<tr class="separator:a803dbab92e520549b625dde70f05fe47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93b9abfad06da819d5460018eb49b5c"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:ad93b9abfad06da819d5460018eb49b5c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad93b9abfad06da819d5460018eb49b5c">MakeMatrixContinuousVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad93b9abfad06da819d5460018eb49b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen matrix of symbolic continuous variables.  <a href="#ad93b9abfad06da819d5460018eb49b5c">More...</a><br /></td></tr>
<tr class="separator:ad93b9abfad06da819d5460018eb49b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b71b38080ba3cd1d36172c4577ed445"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a6b71b38080ba3cd1d36172c4577ed445"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6b71b38080ba3cd1d36172c4577ed445">MakeMatrixIntegerVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a6b71b38080ba3cd1d36172c4577ed445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen matrix of symbolic integer variables.  <a href="#a6b71b38080ba3cd1d36172c4577ed445">More...</a><br /></td></tr>
<tr class="separator:a6b71b38080ba3cd1d36172c4577ed445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94f411b6759f6c243c684e37595f1e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ab94f411b6759f6c243c684e37595f1e5">MakeVectorVariable</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;name, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a> type)</td></tr>
<tr class="memdesc:ab94f411b6759f6c243c684e37595f1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen vector of symbolic variables.  <a href="#ab94f411b6759f6c243c684e37595f1e5">More...</a><br /></td></tr>
<tr class="separator:ab94f411b6759f6c243c684e37595f1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db73b37d01f12010d12cd426f7f5054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a0db73b37d01f12010d12cd426f7f5054">MakeVectorBooleanVariable</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;name)</td></tr>
<tr class="memdesc:a0db73b37d01f12010d12cd426f7f5054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen vector of symbolic Boolean variables.  <a href="#a0db73b37d01f12010d12cd426f7f5054">More...</a><br /></td></tr>
<tr class="separator:a0db73b37d01f12010d12cd426f7f5054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486a6cf03a93f8f8693c94e57d29e0ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a486a6cf03a93f8f8693c94e57d29e0ea">MakeVectorBinaryVariable</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;name)</td></tr>
<tr class="memdesc:a486a6cf03a93f8f8693c94e57d29e0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen vector of symbolic binary variables.  <a href="#a486a6cf03a93f8f8693c94e57d29e0ea">More...</a><br /></td></tr>
<tr class="separator:a486a6cf03a93f8f8693c94e57d29e0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abc75a1263e517c17a4fcb5944ba474"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3abc75a1263e517c17a4fcb5944ba474">MakeVectorContinuousVariable</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;name)</td></tr>
<tr class="memdesc:a3abc75a1263e517c17a4fcb5944ba474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen vector of symbolic continuous variables.  <a href="#a3abc75a1263e517c17a4fcb5944ba474">More...</a><br /></td></tr>
<tr class="separator:a3abc75a1263e517c17a4fcb5944ba474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7493090d0f80fbec7343113df05f6b90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a7493090d0f80fbec7343113df05f6b90">MakeVectorIntegerVariable</a> (<a class="el" href="classint.html">int</a> rows, const std::string &amp;name)</td></tr>
<tr class="memdesc:a7493090d0f80fbec7343113df05f6b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dynamically-sized Eigen vector of symbolic integer variables.  <a href="#a7493090d0f80fbec7343113df05f6b90">More...</a><br /></td></tr>
<tr class="separator:a7493090d0f80fbec7343113df05f6b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09c18b98a36a770ab68c048bd70b09c"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:ad09c18b98a36a770ab68c048bd70b09c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#ad09c18b98a36a770ab68c048bd70b09c">MakeVectorVariable</a> (const std::string &amp;name, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a> type)</td></tr>
<tr class="memdesc:ad09c18b98a36a770ab68c048bd70b09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen vector of symbolic variables.  <a href="#ad09c18b98a36a770ab68c048bd70b09c">More...</a><br /></td></tr>
<tr class="separator:ad09c18b98a36a770ab68c048bd70b09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2f37fa21183f09e3544a4c6891494b"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a4d2f37fa21183f09e3544a4c6891494b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a4d2f37fa21183f09e3544a4c6891494b">MakeVectorBooleanVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a4d2f37fa21183f09e3544a4c6891494b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen vector of symbolic Boolean variables.  <a href="#a4d2f37fa21183f09e3544a4c6891494b">More...</a><br /></td></tr>
<tr class="separator:a4d2f37fa21183f09e3544a4c6891494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698dcb5dd4fea36841d305e89f52dd97"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a698dcb5dd4fea36841d305e89f52dd97"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a698dcb5dd4fea36841d305e89f52dd97">MakeVectorBinaryVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a698dcb5dd4fea36841d305e89f52dd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen vector of symbolic binary variables.  <a href="#a698dcb5dd4fea36841d305e89f52dd97">More...</a><br /></td></tr>
<tr class="separator:a698dcb5dd4fea36841d305e89f52dd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a6b5840c741f1869738945cef3d8c5"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a86a6b5840c741f1869738945cef3d8c5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a86a6b5840c741f1869738945cef3d8c5">MakeVectorContinuousVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a86a6b5840c741f1869738945cef3d8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen vector of symbolic continuous variables.  <a href="#a86a6b5840c741f1869738945cef3d8c5">More...</a><br /></td></tr>
<tr class="separator:a86a6b5840c741f1869738945cef3d8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a22da2ebae3f3ca478d07976adfca85"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:a2a22da2ebae3f3ca478d07976adfca85"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a2a22da2ebae3f3ca478d07976adfca85">MakeVectorIntegerVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a2a22da2ebae3f3ca478d07976adfca85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a static-sized Eigen vector of symbolic integer variables.  <a href="#a2a22da2ebae3f3ca478d07976adfca85">More...</a><br /></td></tr>
<tr class="separator:a2a22da2ebae3f3ca478d07976adfca85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4a660f10cf9c46c5b8321db227e2e5"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a1d4a660f10cf9c46c5b8321db227e2e5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt; DerivedA, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::value &amp;&amp;<a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt; DerivedB, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a1d4a660f10cf9c46c5b8321db227e2e5">CheckStructuralEquality</a> (const DerivedA &amp;m1, const DerivedB &amp;m2)</td></tr>
<tr class="memdesc:a1d4a660f10cf9c46c5b8321db227e2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two Eigen::Matrix&lt;Variable&gt; <code>m1</code> and <code>m2</code> are structurally equal.  <a href="#a1d4a660f10cf9c46c5b8321db227e2e5">More...</a><br /></td></tr>
<tr class="separator:a1d4a660f10cf9c46c5b8321db227e2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24e959c9dc95dbb3702f878e78a4963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aa24e959c9dc95dbb3702f878e78a4963">operator+=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:aa24e959c9dc95dbb3702f878e78a4963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>var1</code> with the result of set-union(<code>var1</code>, <code>var2</code>).  <a href="#aa24e959c9dc95dbb3702f878e78a4963">More...</a><br /></td></tr>
<tr class="separator:aa24e959c9dc95dbb3702f878e78a4963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474ff58b198baf20986ebf6ff810f3cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a474ff58b198baf20986ebf6ff810f3cb">operator+=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a474ff58b198baf20986ebf6ff810f3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>vars</code> with the result of set-union(<code>vars</code>, { <code>var</code> }).  <a href="#a474ff58b198baf20986ebf6ff810f3cb">More...</a><br /></td></tr>
<tr class="separator:a474ff58b198baf20986ebf6ff810f3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2399f6ee5b4c18bc26dc3fd5b6c07a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aba2399f6ee5b4c18bc26dc3fd5b6c07a">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:aba2399f6ee5b4c18bc26dc3fd5b6c07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-union of <code>var1</code> and <code>var2</code>.  <a href="#aba2399f6ee5b4c18bc26dc3fd5b6c07a">More...</a><br /></td></tr>
<tr class="separator:aba2399f6ee5b4c18bc26dc3fd5b6c07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497331a32f5911a18cef34b07df6c04a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a497331a32f5911a18cef34b07df6c04a">operator+</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a497331a32f5911a18cef34b07df6c04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-union of <code>vars</code> and {<code>var}</code>.  <a href="#a497331a32f5911a18cef34b07df6c04a">More...</a><br /></td></tr>
<tr class="separator:a497331a32f5911a18cef34b07df6c04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae117a884f72a1a73cc2863ec026c011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#aae117a884f72a1a73cc2863ec026c011">operator+</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var, <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars)</td></tr>
<tr class="memdesc:aae117a884f72a1a73cc2863ec026c011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-union of {<code>var}</code> and <code>vars</code>.  <a href="#aae117a884f72a1a73cc2863ec026c011">More...</a><br /></td></tr>
<tr class="separator:aae117a884f72a1a73cc2863ec026c011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b30a6b5de749f06ec5c918f6b4b27f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a6b30a6b5de749f06ec5c918f6b4b27f8">operator-=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:a6b30a6b5de749f06ec5c918f6b4b27f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>var1</code> with the result of set-minus(<code>var1</code>, <code>var2</code>).  <a href="#a6b30a6b5de749f06ec5c918f6b4b27f8">More...</a><br /></td></tr>
<tr class="separator:a6b30a6b5de749f06ec5c918f6b4b27f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f3692fb5f1d16586b897e369979028"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a35f3692fb5f1d16586b897e369979028">operator-=</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a35f3692fb5f1d16586b897e369979028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>vars</code> with the result of set-minus(<code>vars</code>, {<code>var}</code>).  <a href="#a35f3692fb5f1d16586b897e369979028">More...</a><br /></td></tr>
<tr class="separator:a35f3692fb5f1d16586b897e369979028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d93012a42e93f92eb3b7fab8bd60733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a3d93012a42e93f92eb3b7fab8bd60733">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:a3d93012a42e93f92eb3b7fab8bd60733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-minus(<code>var1</code>, <code>vars2</code>).  <a href="#a3d93012a42e93f92eb3b7fab8bd60733">More...</a><br /></td></tr>
<tr class="separator:a3d93012a42e93f92eb3b7fab8bd60733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062f8182804bd14f76a6f2ac17718a80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a062f8182804bd14f76a6f2ac17718a80">operator-</a> (<a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> vars, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;var)</td></tr>
<tr class="memdesc:a062f8182804bd14f76a6f2ac17718a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns set-minus(<code>vars</code>, { <code>var</code> }).  <a href="#a062f8182804bd14f76a6f2ac17718a80">More...</a><br /></td></tr>
<tr class="separator:a062f8182804bd14f76a6f2ac17718a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc4e8320720218ee84dc1fdc7439d17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1symbolic.html#a8dc4e8320720218ee84dc1fdc7439d17">intersect</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars1, const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;vars2)</td></tr>
<tr class="memdesc:a8dc4e8320720218ee84dc1fdc7439d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intersection of <code>vars1</code> and <code>vars2</code>.  <a href="#a8dc4e8320720218ee84dc1fdc7439d17">More...</a><br /></td></tr>
<tr class="separator:a8dc4e8320720218ee84dc1fdc7439d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aeb27ddf30420e620beb8e6725d83208f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb27ddf30420e620beb8e6725d83208f">&#9670;&nbsp;</a></span>Pattern</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1symbolic.html#aeb27ddf30420e620beb8e6725d83208f">Pattern</a> =  <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pattern is an expression which possibly includes variables which represent placeholders. </p>
<p>It is used to construct a <code><a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html" title="A RewritingRule, lhs =&gt; rhs, consists of two Patterns lhs and rhs.">RewritingRule</a></code>. </p>

</div>
</div>
<a id="a134e54042165751a5e5369b4631c90eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134e54042165751a5e5369b4631c90eb">&#9670;&nbsp;</a></span>Rewriter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1symbolic.html#a134e54042165751a5e5369b4631c90eb">Rewriter</a> =  std::function&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>(const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <code>Rewriter</code> is a function from an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">Expression</a> to an <a class="el" href="classdrake_1_1symbolic_1_1_expression.html" title="Represents a symbolic form of an expression.">Expression</a>. </p>

</div>
</div>
<a id="acbfe43d34e6c71c503d4de11da53bbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfe43d34e6c71c503d4de11da53bbb7">&#9670;&nbsp;</a></span>Substitution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1symbolic.html#acbfe43d34e6c71c503d4de11da53bbb7">Substitution</a> =  std::unordered_map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aebde9bdda9a428ef1bab6175954d30fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebde9bdda9a428ef1bab6175954d30fa">&#9670;&nbsp;</a></span>ExpressionKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30fa">ExpressionKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kinds of symbolic expressions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faacb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc"><p>constant (double) </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa5a92344ee95acf10c31901b36418be77"></a>Var&#160;</td><td class="fielddoc"><p>variable </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faaec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"><p>addition (+) </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa62b6d55816cf737bfc6f42e60df1a3f2"></a>Mul&#160;</td><td class="fielddoc"><p>multiplication (*) </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa43d11850893d2fe84a1e618121c1cc0a"></a>Div&#160;</td><td class="fielddoc"><p>division (/) </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faace0be71e33226e4c1db2bcea5959f16b"></a>Log&#160;</td><td class="fielddoc"><p>logarithms </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa1e34af023adeb7d5f484f8eb4b9826b6"></a>Abs&#160;</td><td class="fielddoc"><p>absolute value function </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faacad39a154bffb61175f674d6eefaf6d0"></a>Exp&#160;</td><td class="fielddoc"><p>exponentiation </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faaae77f3ad25595e35b327334d89410054"></a>Sqrt&#160;</td><td class="fielddoc"><p>square root </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa8be6d3e955290ee50c00a4bc92aa7749"></a>Pow&#160;</td><td class="fielddoc"><p>power function </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa0986d137604183312e6d3599578bc6cd"></a>Sin&#160;</td><td class="fielddoc"><p>sine </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faaffca562be079b9e4e41ea9d6a86c582b"></a>Cos&#160;</td><td class="fielddoc"><p>cosine </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa1266b4e6f81e60733ec6c717e0181f60"></a>Tan&#160;</td><td class="fielddoc"><p>tangent </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa76cfc54de4e2b9cde17334c821217d11"></a>Asin&#160;</td><td class="fielddoc"><p>arcsine </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faaed4629033ecb516ed7d1536e162030bb"></a>Acos&#160;</td><td class="fielddoc"><p>arccosine </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faac9968ab1fa8103acbb3a4f22265f2def"></a>Atan&#160;</td><td class="fielddoc"><p>arctangent </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa5816dfcaf3b6dbb486ef9c8c006ff613"></a>Atan2&#160;</td><td class="fielddoc"><p>arctangent2 (atan2(y,x) = atan(y/x)) </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa98ed804abf4edd1f3be3fa894fa8cc3d"></a>Sinh&#160;</td><td class="fielddoc"><p>hyperbolic sine </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa4371c3565b771b40c187487cc0190392"></a>Cosh&#160;</td><td class="fielddoc"><p>hyperbolic cosine </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faacc132a41cab5676334f353a22a0aa5c5"></a>Tanh&#160;</td><td class="fielddoc"><p>hyperbolic tangent </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa78d811e98514cd165dda532286610fd2"></a>Min&#160;</td><td class="fielddoc"><p>min </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa6a061313d22e51e0f25b7cd4dc065233"></a>Max&#160;</td><td class="fielddoc"><p>max </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faab95a01ffffa8fcdd2a9af961937c097c"></a>Ceil&#160;</td><td class="fielddoc"><p>ceil </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faaf3f6d0343d56ce88ce7958170ed05cb3"></a>Floor&#160;</td><td class="fielddoc"><p>floor </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faaaff6933d8331eca27edc911467980c9c"></a>IfThenElse&#160;</td><td class="fielddoc"><p>if then else </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa7ecfb3bf076a6a9635f975fe96ac97fd"></a>NaN&#160;</td><td class="fielddoc"><p>NaN. </p>
</td></tr>
<tr><td class="fieldname"><a id="aebde9bdda9a428ef1bab6175954d30faa2e59a51ac43bc3415c1b8ce7b3f98579"></a>UninterpretedFunction&#160;</td><td class="fielddoc"><p>Uninterpreted function. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6869e7044dd90be5d972ee7dd4e821b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6869e7044dd90be5d972ee7dd4e821b6">&#9670;&nbsp;</a></span>FormulaKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kinds of symbolic formulas. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6af8320b26d30ab433c5a54546d21f414c"></a>False&#160;</td><td class="fielddoc"><p>⊥ </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6af827cf462f62848df37c5e1e94a4da74"></a>True&#160;</td><td class="fielddoc"><p>⊤ </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a5a92344ee95acf10c31901b36418be77"></a>Var&#160;</td><td class="fielddoc"><p>Boolean <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">Variable</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a3718b5ecf60aa0dba49e150e96cb1fc3"></a>Eq&#160;</td><td class="fielddoc"><p>= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6ae4ecc5da3c6dbb4448f25990dc609727"></a>Neq&#160;</td><td class="fielddoc"><p>!= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a086cb8308e5a36e7c4ed1f8873ad801f"></a>Gt&#160;</td><td class="fielddoc"><p>&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a5dabfebb89e6e45a8cf8573d92746ed3"></a>Geq&#160;</td><td class="fielddoc"><p>&gt;= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a50033c15af7795cd6617f117b29d6922"></a>Lt&#160;</td><td class="fielddoc"><p>&lt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6abe5721bf93d718a79358217ec9b88176"></a>Leq&#160;</td><td class="fielddoc"><p>&lt;= </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6ac33315685a0cba3ce53be378b3c7874b"></a>And&#160;</td><td class="fielddoc"><p>Conjunction (∧) </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a3a2d5fe857d8f9541136a124c2edec6c"></a>Or&#160;</td><td class="fielddoc"><p>Disjunction (∨) </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6aa74c05d080620f087c4e523977230666"></a>Not&#160;</td><td class="fielddoc"><p>Negation (¬) </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a43cfe3c750a08acb91df1e3384548078"></a>Forall&#160;</td><td class="fielddoc"><p>Universal quantification (∀) </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6afd116e3418522ffc34d7423bc601510d"></a>Isnan&#160;</td><td class="fielddoc"><p>NaN check predicate. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6869e7044dd90be5d972ee7dd4e821b6a1fbc164d3e50b7fd20690a21f1b7b2f2"></a>PositiveSemidefinite&#160;</td><td class="fielddoc"><p>Positive semidefinite matrix. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a24ba050d5b6f088d5fe578396b3ad646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ba050d5b6f088d5fe578396b3ad646">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6244fef922874b743a272fe683cf068b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6244fef922874b743a272fe683cf068b">&#9670;&nbsp;</a></span>acos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa12acbb0b86d35d1de9280e699d3999d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12acbb0b86d35d1de9280e699d3999d">&#9670;&nbsp;</a></span>asin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5beb575f1104a060ab02a89544fef1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5beb575f1104a060ab02a89544fef1d">&#9670;&nbsp;</a></span>atan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03d536a13db7de62414f5279c60148aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d536a13db7de62414f5279c60148aa">&#9670;&nbsp;</a></span>atan2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d4ba82d6dffb1c0c6f40a768f86eae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4ba82d6dffb1c0c6f40a768f86eae7">&#9670;&nbsp;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d4a660f10cf9c46c5b8321db227e2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4a660f10cf9c46c5b8321db227e2e5">&#9670;&nbsp;</a></span>CheckStructuralEquality() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt;DerivedA, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;::value &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__scalar__same.html">is_eigen_scalar_same</a>&lt;DerivedB, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;::value, bool&gt;::type drake::symbolic::CheckStructuralEquality </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two Eigen::Matrix&lt;Variable&gt; <code>m1</code> and <code>m2</code> are structurally equal. </p>
<p>That is, it returns true if and only if <code>m1(i, j)</code> is structurally equal to <code>m2(i, j)</code> for all <code>i</code>, <code>j</code>. </p>

</div>
</div>
<a id="ac3d55ec6a55f554174d9bc45d7ed7f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d55ec6a55f554174d9bc45d7ed7f5c">&#9670;&nbsp;</a></span>CheckStructuralEquality() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt;Eigen::MatrixBase&lt;DerivedA&gt;, DerivedA&gt;::value &amp;&amp; std::is_base_of&lt;Eigen::MatrixBase&lt;DerivedB&gt;, DerivedB&gt;::value &amp;&amp; std::is_same&lt;typename DerivedA::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::value &amp;&amp; std::is_same&lt;typename DerivedB::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::value, bool&gt;::type drake::symbolic::CheckStructuralEquality </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two Eigen::Matrix&lt;Expression&gt; <code>m1</code> and <code>m2</code> are structurally equal. </p>
<p>That is, it returns true if and only if <code>m1(i, j)</code> is structurally equal to <code>m2(i, j)</code> for all <code>i</code>, <code>j</code>. </p>

</div>
</div>
<a id="a6b4d1b24311f37c799ef18498b95020c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4d1b24311f37c799ef18498b95020c">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79d98cdd1dd5802fe6c341ecfe9c6cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d98cdd1dd5802fe6c341ecfe9c6cce">&#9670;&nbsp;</a></span>cosh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c152941a4e06624bac5926fac2d4e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c152941a4e06624bac5926fac2d4e32">&#9670;&nbsp;</a></span>DecomposeAffineExpressions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::DecomposeAffineExpressions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::VectorXd &gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes <code>expressions</code> into <code>M</code> * <code>vars</code> + <code>v</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>expressions</code> is not affine in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>M.rows() == expressions.rows() &amp;&amp; M.cols() == vars.rows(). </dd>
<dd>
v.rows() == expressions.rows(). </dd></dl>

</div>
</div>
<a id="aa6c01361f464b3eae396f7d1a0e92c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c01361f464b3eae396f7d1a0e92c85">&#9670;&nbsp;</a></span>DecomposeLinearExpressions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::DecomposeLinearExpressions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes <code>expressions</code> into <code>M</code> * <code>vars</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>expressions</code> is not linear in <code>vars</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>M.rows() == expressions.rows() &amp;&amp; M.cols() == vars.rows(). </dd></dl>

</div>
</div>
<a id="a1596c40ec725591479b2b4290a6e347b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1596c40ec725591479b2b4290a6e347b">&#9670;&nbsp;</a></span>Evaluate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&gt;::value, Eigen::Matrix&lt;double, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime&gt; &gt; drake::symbolic::Evaluate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>env</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a matrix <code>m</code> of symbolic polynomials using <code>env</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a matrix of double whose size is the size of <code>m</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if NaN is detected during evaluation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac085a32409b678f96a69f5e50fc00ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac085a32409b678f96a69f5e50fc00ed7">&#9670;&nbsp;</a></span>Evaluate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::value, Eigen::Matrix&lt;double, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime&gt; &gt; drake::symbolic::Evaluate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *&#160;</td>
          <td class="paramname"><em>random_generator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a symbolic matrix <code>m</code> using <code>env</code> and <code>random_generator</code>. </p>
<p>If there is a random variable in <code>m</code> which is unassigned in <code>env</code>, this function uses <code>random_generator</code> to sample a value and use the value to substitute all occurrences of the random variable in <code>m</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>a matrix of double whose size is the size of <code>m</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if NaN is detected during evaluation. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>m</code> includes unassigned random variables but <code>random_generator</code> is <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f0355c03127b4d0312e5f761a0f530a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0355c03127b4d0312e5f761a0f530a">&#9670;&nbsp;</a></span>Evaluate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::SparseMatrix&lt;double&gt; drake::symbolic::Evaluate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::SparseMatrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>env</em> = <code><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates <code>m</code> using a given environment (by default, an empty environment). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there exists a variable in <code>m</code> whose value is not provided by <code>env</code>. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if NaN is detected during evaluation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87b9a5af49a6b9d6140189a132c4c2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b9a5af49a6b9d6140189a132c4c2d7">&#9670;&nbsp;</a></span>EvaluateChebyshevPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double drake::symbolic::EvaluateChebyshevPolynomial </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>variable_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates a Chebyshev polynomial at a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable_val</td><td>The value of the variable. </td></tr>
    <tr><td class="paramname">degree</td><td>The degree of the Chebyshev polynomial. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff00cd9261b602f7ce7708286d2dae05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff00cd9261b602f7ce7708286d2dae05">&#9670;&nbsp;</a></span>EvenDegreeMonomialBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1&gt; drake::symbolic::EvenDegreeMonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all even degree monomials up to a given degree under the graded reverse lexicographic order. </p>
<p>A monomial has an even degree if its total degree is even. So xy is an even degree monomial (degree 2) while x²y is not (degree 3). Note that graded reverse lexicographic order uses the total order among <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">Variable</a> which is based on a variable's unique ID. For example, for a given variable ordering x &gt; y &gt; z, <code>EvenDegreeMonomialBasis({x, y, z}, 2)</code> returns a column vector <code>[x², xy, y², xz, yz, z², 1]</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>vars</code> is a non-empty set. </dd>
<dd>
<code>degree</code> is a non-negative integer. </dd></dl>

</div>
</div>
<a id="a683b7c0db1ce737fc0e3af3323a4fed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683b7c0db1ce737fc0e3af3323a4fed1">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56b28c66fdf5d2b582a677660936abca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b28c66fdf5d2b582a677660936abca">&#9670;&nbsp;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c6d2ea09c3aa020cf408bc9472ec9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6d2ea09c3aa020cf408bc9472ec9eb">&#9670;&nbsp;</a></span>forall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::forall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a formula <code>f</code>, universally quantified by variables <code>vars</code>. </p>

</div>
</div>
<a id="af785f16951e394debcd11a9225ef469c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af785f16951e394debcd11a9225ef469c">&#9670;&nbsp;</a></span>get_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::get_argument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the argument in the unary expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a unary expression.} </dd></dl>

</div>
</div>
<a id="acffaee70b54f60b4d1b9f1771f78ddf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffaee70b54f60b4d1b9f1771f78ddf7">&#9670;&nbsp;</a></span>get_base_to_exponent_map_in_multiplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;&amp; drake::symbolic::get_base_to_exponent_map_in_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map from a base expression to its exponent expression in the multiplication expression <code>e</code>. </p>
<p>For instance, given 7 * x^2 * y^3 * z^x, the return value maps 'x' to 2, 'y' to 3, and 'z' to 'x'. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a multiplication expression.} </dd></dl>

</div>
</div>
<a id="a251f0e1c8ae1894d0a09ccaeb5e79a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251f0e1c8ae1894d0a09ccaeb5e79a41">&#9670;&nbsp;</a></span>get_conditional_formula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&amp; drake::symbolic::get_conditional_formula </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the conditional formula in the if-then-else expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is an if-then-else expression. </dd></dl>

</div>
</div>
<a id="afe3d5ca2b76943558837ffa2a47162e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3d5ca2b76943558837ffa2a47162e1">&#9670;&nbsp;</a></span>get_constant_in_addition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double drake::symbolic::get_constant_in_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant part of the addition expression <code>e</code>. </p>
<p>For instance, given 7 + 2 * x + 3 * y, it returns 7. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is an addition expression.} </dd></dl>

</div>
</div>
<a id="af56c1d979ba67b0eceaac7f0ba54235c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56c1d979ba67b0eceaac7f0ba54235c">&#9670;&nbsp;</a></span>get_constant_in_multiplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double drake::symbolic::get_constant_in_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant part of the multiplication expression <code>e</code>. </p>
<p>For instance, given 7 * x^2 * y^3, it returns 7. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a multiplication expression.} </dd></dl>

</div>
</div>
<a id="a1b317498b02b74b0937f7cdb31b0ef52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b317498b02b74b0937f7cdb31b0ef52">&#9670;&nbsp;</a></span>get_constant_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double drake::symbolic::get_constant_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant value of the constant expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a constant expression.} </dd></dl>

</div>
</div>
<a id="ae1a1c7093f3e8d89930f0aa748ee188c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a1c7093f3e8d89930f0aa748ee188c">&#9670;&nbsp;</a></span>get_else_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::get_else_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 'else' expression in the if-then-else expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is an if-then-else expression. </dd></dl>

</div>
</div>
<a id="a20be18c2d4942e2e64987a30c7e37c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20be18c2d4942e2e64987a30c7e37c1d">&#9670;&nbsp;</a></span>get_expr_to_coeff_map_in_addition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, double&gt;&amp; drake::symbolic::get_expr_to_coeff_map_in_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map from an expression to its coefficient in the addition expression <code>e</code>. </p>
<p>For instance, given 7 + 2 * x + 3 * y, the return value maps 'x' to 2 and 'y' to 3. </p><dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is an addition expression.} </dd></dl>

</div>
</div>
<a id="a38f904009d1e4f9ad6f5ed22a4e4c41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f904009d1e4f9ad6f5ed22a4e4c41b">&#9670;&nbsp;</a></span>get_first_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::get_first_argument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first argument of the binary expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a binary expression.} </dd></dl>

</div>
</div>
<a id="afef2e4ae842f5cec22644a1627929c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef2e4ae842f5cec22644a1627929c20">&#9670;&nbsp;</a></span>get_lhs_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::get_lhs_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the lhs-argument of a relational formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a relational formula.} </dd></dl>

</div>
</div>
<a id="a19aa57dcc28c59559eef51f7cbba8cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19aa57dcc28c59559eef51f7cbba8cba">&#9670;&nbsp;</a></span>get_matrix_in_positive_semidefinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;&amp; drake::symbolic::get_matrix_in_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the matrix in a positive-semidefinite formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a positive-semidefinite formula.} </dd></dl>

</div>
</div>
<a id="a2c7303caa2be22b055163dc4e7134834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7303caa2be22b055163dc4e7134834">&#9670;&nbsp;</a></span>get_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&amp; drake::symbolic::get_operand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the formula in a negation formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a negation formula.} </dd></dl>

</div>
</div>
<a id="a2362f52cf6b8c750209340520e7bc9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2362f52cf6b8c750209340520e7bc9b4">&#9670;&nbsp;</a></span>get_operands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;&amp; drake::symbolic::get_operands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of formulas in a n-ary formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a n-ary formula.} </dd></dl>

</div>
</div>
<a id="acbfcc66d64e8756ae983891059050205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfcc66d64e8756ae983891059050205">&#9670;&nbsp;</a></span>get_quantified_formula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&amp; drake::symbolic::get_quantified_formula </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the quantified formula in a forall formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a forall formula.} </dd></dl>

</div>
</div>
<a id="a3f5db567077a794c0bb1653699c84a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5db567077a794c0bb1653699c84a95">&#9670;&nbsp;</a></span>get_quantified_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&amp; drake::symbolic::get_quantified_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the quantified variables in a forall formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a forall formula.} </dd></dl>

</div>
</div>
<a id="a952d7f91d0e9e67110274daf0d17f132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952d7f91d0e9e67110274daf0d17f132">&#9670;&nbsp;</a></span>get_rhs_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::get_rhs_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rhs-argument of a relational formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>f</code> is a relational formula.} </dd></dl>

</div>
</div>
<a id="a8da800513f72f528dffddd89f9263b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da800513f72f528dffddd89f9263b3a">&#9670;&nbsp;</a></span>get_second_argument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::get_second_argument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the second argument of the binary expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a binary expression.} </dd></dl>

</div>
</div>
<a id="abd312bc518c0dd20a656021aef3e3c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd312bc518c0dd20a656021aef3e3c37">&#9670;&nbsp;</a></span>get_then_expression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::get_then_expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 'then' expression in the if-then-else expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is an if-then-else expression. </dd></dl>

</div>
</div>
<a id="a374ac54710c8173da5ca4b2d7eeec520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374ac54710c8173da5ca4b2d7eeec520">&#9670;&nbsp;</a></span>get_uninterpreted_function_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;&amp; drake::symbolic::get_uninterpreted_function_arguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the arguments of an uninterpreted-function expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is an uninterpreted-function expression. </dd></dl>

</div>
</div>
<a id="a901d5aa27994e415a1eb4145968dc25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901d5aa27994e415a1eb4145968dc25c">&#9670;&nbsp;</a></span>get_uninterpreted_function_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; drake::symbolic::get_uninterpreted_function_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of an uninterpreted-function expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is an uninterpreted-function expression. </dd></dl>

</div>
</div>
<a id="a486a9821c4235aeda4e39ff0652f72e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486a9821c4235aeda4e39ff0652f72e7">&#9670;&nbsp;</a></span>get_variable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&amp; drake::symbolic::get_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the embedded variable in the variable formula <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>f</code> is a variable formula. </dd></dl>

</div>
</div>
<a id="aebd6758ef1c73c0ab835a7e8c6aad187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd6758ef1c73c0ab835a7e8c6aad187">&#9670;&nbsp;</a></span>get_variable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&amp; drake::symbolic::get_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the embedded variable in the variable expression <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>e</code> is a variable expression.} </dd></dl>

</div>
</div>
<a id="ab1ebc87f878cdb6a3f0339711d591a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ebc87f878cdb6a3f0339711d591a26">&#9670;&nbsp;</a></span>GetDistinctVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::GetDistinctVariables </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the distinct variables in the matrix of expressions. </p>

</div>
</div>
<a id="a7eb71f55634f4f2430d1abb2df5b92d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb71f55634f4f2430d1abb2df5b92d8">&#9670;&nbsp;</a></span>GetVariableVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::GetVariableVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>evec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a vector of variables from the vector of variable expressions. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is an expression in <code>vec</code> which is not a variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dfe436e1c70779badecad19c8a039fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dfe436e1c70779badecad19c8a039fe">&#9670;&nbsp;</a></span>if_then_else()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::if_then_else </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e_then</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e_else</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">  if_then_else(cond, expr_then, expr_else)
</pre><p>The value returned by the above if-then-else expression is <code>expr_then</code> if <code>cond</code> is evaluated to true. Otherwise, it returns <code>expr_else</code>.</p>
<p>The semantics is similar to the C++'s conditional expression constructed by its ternary operator, <code></code>?:. However, there is a key difference between the C++'s conditional expression and our <code>if_then_else</code> expression in a way the arguments are evaluated during the construction.</p>
<ul>
<li>In case of the C++'s conditional expression, <code> cond ? expr_then : expr_else</code>, the then expression <code>expr_then</code> (respectively, the else expression <code>expr_else</code>) is <b>only</b> evaluated when the conditional expression <code>cond</code> is evaluated to <b>true</b> (respectively, when <code>cond</code> is evaluated to <b>false</b>).</li>
<li>In case of the symbolic expression, <code>if_then_else(cond, expr_then, expr_else)</code>, however, <b>both</b> arguments <code>expr_then</code> and <code>expr_else</code> are evaluated first and then passed to the <code>if_then_else</code> function.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function returns an <b>expression</b> and it is different from the C++'s if-then-else <b>statement</b>.</dd>
<dd>
While it is still possible to define <code> min, max, abs</code> math functions using <code>if_then_else</code> expression, it is highly <b>recommended</b> to use the provided native definitions for them because it allows solvers to detect specific math functions and to have a room for special optimizations.</dd>
<dd>
More information about the C++'s conditional expression and ternary operator is available at <a href="http://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator">http://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator</a>. </dd></dl>

</div>
</div>
<a id="a8dc4e8320720218ee84dc1fdc7439d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc4e8320720218ee84dc1fdc7439d17">&#9670;&nbsp;</a></span>intersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the intersection of <code>vars1</code> and <code>vars2</code>. </p>
<p>This function has a time complexity of <code>O(N₁ + N₂)</code> where <code>N₁</code> and <code>N₂</code> are the size of <code>vars1</code> and <code>vars2</code> respectively. </p>

</div>
</div>
<a id="a942b47a07cae421b3152f11536e6579c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942b47a07cae421b3152f11536e6579c">&#9670;&nbsp;</a></span>is_abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an abs expression. </p>

</div>
</div>
<a id="a8e6c5829257cf5c28c162ffad2bd3f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6c5829257cf5c28c162ffad2bd3f58">&#9670;&nbsp;</a></span>is_abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an absolute-value-function expression. </p>

</div>
</div>
<a id="ac2fcf1da78e47a4afb20e0a4e85ac7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fcf1da78e47a4afb20e0a4e85ac7dd">&#9670;&nbsp;</a></span>is_acos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an arccosine expression. </p>

</div>
</div>
<a id="aa70b034dae56512552b00315c20edaf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70b034dae56512552b00315c20edaf4">&#9670;&nbsp;</a></span>is_acos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an arccosine expression. </p>

</div>
</div>
<a id="acdaf0abb22b9280fc9622bd2d488a3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdaf0abb22b9280fc9622bd2d488a3e1">&#9670;&nbsp;</a></span>is_addition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an addition expression. </p>

</div>
</div>
<a id="ae9dfc929a3e771ece5e5d20312e96abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9dfc929a3e771ece5e5d20312e96abd">&#9670;&nbsp;</a></span>is_addition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an addition expression. </p>

</div>
</div>
<a id="acfa5bc007d1b065d2afc30e2f6ced7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa5bc007d1b065d2afc30e2f6ced7a9">&#9670;&nbsp;</a></span>is_asin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an arcsine expression. </p>

</div>
</div>
<a id="ab3f6cc91aa5d1f9133526887cec35cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f6cc91aa5d1f9133526887cec35cd4">&#9670;&nbsp;</a></span>is_asin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an arcsine expression. </p>

</div>
</div>
<a id="af5a94b6eea9d24d8415703bfc07a1c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a94b6eea9d24d8415703bfc07a1c05">&#9670;&nbsp;</a></span>is_atan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an arctangent expression. </p>

</div>
</div>
<a id="ae4927daffb66b9bd137c174d41d94444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4927daffb66b9bd137c174d41d94444">&#9670;&nbsp;</a></span>is_atan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an arctangent expression. </p>

</div>
</div>
<a id="a4ac54d0c8fa80bf084505f90528c9f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac54d0c8fa80bf084505f90528c9f5e">&#9670;&nbsp;</a></span>is_atan2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an arctangent2 expression. </p>

</div>
</div>
<a id="acb998316cfc15506d72b2f2843b4fa62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb998316cfc15506d72b2f2843b4fa62">&#9670;&nbsp;</a></span>is_atan2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a arctangent2 expression. </p>

</div>
</div>
<a id="a1525a5e26f678130b369bc1414d9891a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1525a5e26f678130b369bc1414d9891a">&#9670;&nbsp;</a></span>is_ceil() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a ceil expression. </p>

</div>
</div>
<a id="a358f01574b969ec8e0b75498929b9d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358f01574b969ec8e0b75498929b9d95">&#9670;&nbsp;</a></span>is_ceil() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a ceil expression. </p>

</div>
</div>
<a id="a52208f3bf9cb2720f5d99223c20382f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52208f3bf9cb2720f5d99223c20382f9">&#9670;&nbsp;</a></span>is_conjunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_conjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a conjunction (∧). </p>

</div>
</div>
<a id="ad60a650ffd29c64c25be2dc84bfefccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60a650ffd29c64c25be2dc84bfefccc">&#9670;&nbsp;</a></span>is_conjunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_conjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a conjunction (∧). </p>

</div>
</div>
<a id="ae0f809da2a5c679df2b90aadedde5350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f809da2a5c679df2b90aadedde5350">&#9670;&nbsp;</a></span>is_constant() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a constant expression. </p>

</div>
</div>
<a id="a993384c5125c55ca3f5a11586a9bb675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993384c5125c55ca3f5a11586a9bb675">&#9670;&nbsp;</a></span>is_constant() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a constant expression representing <code>v</code>. </p>

</div>
</div>
<a id="a2b0cfbc77e62d7ffd76914817afcfbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0cfbc77e62d7ffd76914817afcfbb8">&#9670;&nbsp;</a></span>is_constant() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a constant expression. </p>

</div>
</div>
<a id="a208a1c5a02e5bff9ba66d7b7db588ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208a1c5a02e5bff9ba66d7b7db588ba0">&#9670;&nbsp;</a></span>is_cos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a cosine expression. </p>

</div>
</div>
<a id="a78259c13b2add79a1ad23e2cc8f5b314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78259c13b2add79a1ad23e2cc8f5b314">&#9670;&nbsp;</a></span>is_cos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a cosine expression. </p>

</div>
</div>
<a id="a93e09e7b40ee56f60a121014f02603fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e09e7b40ee56f60a121014f02603fb">&#9670;&nbsp;</a></span>is_cosh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a hyperbolic-cosine expression. </p>

</div>
</div>
<a id="a9729350280d57ceaa1fd4c01c46ab48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9729350280d57ceaa1fd4c01c46ab48c">&#9670;&nbsp;</a></span>is_cosh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a hyperbolic-cosine expression. </p>

</div>
</div>
<a id="a96f5414ecb9fa8f70d2303a3408aa95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f5414ecb9fa8f70d2303a3408aa95b">&#9670;&nbsp;</a></span>is_disjunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_disjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a disjunction (∨). </p>

</div>
</div>
<a id="a9fb95d50cf0c445f6be7d3d1e5a356a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb95d50cf0c445f6be7d3d1e5a356a9">&#9670;&nbsp;</a></span>is_disjunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_disjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a disjunction (∨). </p>

</div>
</div>
<a id="a60ddcd6effc0d16b4ab5e71008a84fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ddcd6effc0d16b4ab5e71008a84fd5">&#9670;&nbsp;</a></span>is_division() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_division </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a division expression. </p>

</div>
</div>
<a id="ac1eddc430d6a33fc13db8d53a51bdfd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1eddc430d6a33fc13db8d53a51bdfd3">&#9670;&nbsp;</a></span>is_division() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_division </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a division expression. </p>

</div>
</div>
<a id="aff01b0d18262c1673124bd659870a3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff01b0d18262c1673124bd659870a3a4">&#9670;&nbsp;</a></span>is_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing equality (==). </p>

</div>
</div>
<a id="a09ce3ca5629e2672f177ff3c0cc088ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ce3ca5629e2672f177ff3c0cc088ae">&#9670;&nbsp;</a></span>is_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing equality (==). </p>

</div>
</div>
<a id="aa8f471231c119fee48c6dba7a2d5ab18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f471231c119fee48c6dba7a2d5ab18">&#9670;&nbsp;</a></span>is_exp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an exp expression. </p>

</div>
</div>
<a id="a1633315c1c26cbd8411a7ea0d860a9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1633315c1c26cbd8411a7ea0d860a9c2">&#9670;&nbsp;</a></span>is_exp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an exp expression. </p>

</div>
</div>
<a id="a3821701f71cdfe8c9fbb277e017b384d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3821701f71cdfe8c9fbb277e017b384d">&#9670;&nbsp;</a></span>is_false() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_false </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is structurally equal to False formula. </p>

</div>
</div>
<a id="a9fe1f207a7dfa971bf80a1d44041368b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe1f207a7dfa971bf80a1d44041368b">&#9670;&nbsp;</a></span>is_false() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_false </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is structurally equal to False formula. </p>

</div>
</div>
<a id="abc7a6656f58842adedcc8024b14bc06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7a6656f58842adedcc8024b14bc06c">&#9670;&nbsp;</a></span>is_floor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a floor expression. </p>

</div>
</div>
<a id="a568d4712bfb6ef78d4908efce797ebd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568d4712bfb6ef78d4908efce797ebd2">&#9670;&nbsp;</a></span>is_floor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a floor expression. </p>

</div>
</div>
<a id="ae2266fd8f32067b29eed7e0345658af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2266fd8f32067b29eed7e0345658af9">&#9670;&nbsp;</a></span>is_forall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_forall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a Forall formula (∀). </p>

</div>
</div>
<a id="a1aeb30cdaf6f0d8f4d324afee241ae89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aeb30cdaf6f0d8f4d324afee241ae89">&#9670;&nbsp;</a></span>is_forall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_forall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a Forall formula (∀). </p>

</div>
</div>
<a id="af6c7242773fe5a8413bf3505e34e8477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c7242773fe5a8413bf3505e34e8477">&#9670;&nbsp;</a></span>is_greater_than() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_greater_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing greater-than (&gt;). </p>

</div>
</div>
<a id="a0aab22ba7b7baeb20a13b0aa90172fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aab22ba7b7baeb20a13b0aa90172fc1">&#9670;&nbsp;</a></span>is_greater_than() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_greater_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing greater-than (&gt;). </p>

</div>
</div>
<a id="aa71ff98005aa4a5b0d0639c055fb295f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71ff98005aa4a5b0d0639c055fb295f">&#9670;&nbsp;</a></span>is_greater_than_or_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing greater-than-or-equal-to (&gt;=). </p>

</div>
</div>
<a id="a788e2bbb344403337e7b77edf2bd92fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788e2bbb344403337e7b77edf2bd92fa">&#9670;&nbsp;</a></span>is_greater_than_or_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing greater-than-or-equal-to (&gt;=). </p>

</div>
</div>
<a id="aa12b990bcc72a788e6d8176894d0d8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12b990bcc72a788e6d8176894d0d8a2">&#9670;&nbsp;</a></span>is_if_then_else() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_if_then_else </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an if-then-else expression. </p>

</div>
</div>
<a id="af9473fec0f5aba36ac7c89281bf4d524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9473fec0f5aba36ac7c89281bf4d524">&#9670;&nbsp;</a></span>is_if_then_else() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_if_then_else </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an if-then-else expression. </p>

</div>
</div>
<a id="ad0aaf128d1ed75cbab9c4ca238e0ae6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0aaf128d1ed75cbab9c4ca238e0ae6c">&#9670;&nbsp;</a></span>is_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_integer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a819538a0900f5b91b88a5a5b25f756d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819538a0900f5b91b88a5a5b25f756d1">&#9670;&nbsp;</a></span>is_isnan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is an isnan formula. </p>

</div>
</div>
<a id="a726023da52d6033c2565368b6def1e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726023da52d6033c2565368b6def1e16">&#9670;&nbsp;</a></span>is_isnan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is an isnan formula. </p>

</div>
</div>
<a id="a50548d8092f6c0fa9796daf743a91d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50548d8092f6c0fa9796daf743a91d56">&#9670;&nbsp;</a></span>is_less_than() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_less_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing less-than (&lt;). </p>

</div>
</div>
<a id="aaed4c523512b2ee45d906c0f9d0b1d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed4c523512b2ee45d906c0f9d0b1d13">&#9670;&nbsp;</a></span>is_less_than() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_less_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing less-than (&lt;). </p>

</div>
</div>
<a id="ad4bd0f6e944bac326e6e943f26d3d043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bd0f6e944bac326e6e943f26d3d043">&#9670;&nbsp;</a></span>is_less_than_or_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing less-than-or-equal-to (&lt;=). </p>

</div>
</div>
<a id="adfca6086d970d576d51fa5364416a297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfca6086d970d576d51fa5364416a297">&#9670;&nbsp;</a></span>is_less_than_or_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing less-than-or-equal-to (&lt;=). </p>

</div>
</div>
<a id="a8f5dcbc71dc0b20b3debbeafdd5f1614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5dcbc71dc0b20b3debbeafdd5f1614">&#9670;&nbsp;</a></span>is_log() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a log expression. </p>

</div>
</div>
<a id="aee17d0564b198d4c784811945707ddbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee17d0564b198d4c784811945707ddbf">&#9670;&nbsp;</a></span>is_log() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a log expression. </p>

</div>
</div>
<a id="a0a84ca31e769b94d1adcc69789826934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a84ca31e769b94d1adcc69789826934">&#9670;&nbsp;</a></span>is_max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a max expression. </p>

</div>
</div>
<a id="a409d972b3926adbbb031a5c3aef3d153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409d972b3926adbbb031a5c3aef3d153">&#9670;&nbsp;</a></span>is_max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a max expression. </p>

</div>
</div>
<a id="a911dd37b6ac155198d923500bbc97135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911dd37b6ac155198d923500bbc97135">&#9670;&nbsp;</a></span>is_min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a min expression. </p>

</div>
</div>
<a id="a429537da181b9861e8e1b51648691059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429537da181b9861e8e1b51648691059">&#9670;&nbsp;</a></span>is_min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a min expression. </p>

</div>
</div>
<a id="aee7c3de3be1c5f350b439dcdc7e8b24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7c3de3be1c5f350b439dcdc7e8b24d">&#9670;&nbsp;</a></span>is_multiplication() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a multiplication expression. </p>

</div>
</div>
<a id="a19a56ae8b296df9d9285c93e00b82dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a56ae8b296df9d9285c93e00b82dc7">&#9670;&nbsp;</a></span>is_multiplication() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an multiplication expression. </p>

</div>
</div>
<a id="a92b9f0534ca861f03dbaa96ec1712f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b9f0534ca861f03dbaa96ec1712f7f">&#9670;&nbsp;</a></span>is_nan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_nan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is NaN. </p>

</div>
</div>
<a id="abce383d57808e711c1517e9bd461cde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce383d57808e711c1517e9bd461cde2">&#9670;&nbsp;</a></span>is_nary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_nary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a n-ary formula ({∧, ∨}). </p>

</div>
</div>
<a id="aef684b8834080c14e7dc13d497db9c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef684b8834080c14e7dc13d497db9c22">&#9670;&nbsp;</a></span>is_neg_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_neg_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is -1.0. </p>

</div>
</div>
<a id="abcebff63e5d9aa57da4a45df326a2acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcebff63e5d9aa57da4a45df326a2acf">&#9670;&nbsp;</a></span>is_negation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_negation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a negation (¬). </p>

</div>
</div>
<a id="a18a463fed830ca5aa9b3ff7bdef8f67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a463fed830ca5aa9b3ff7bdef8f67a">&#9670;&nbsp;</a></span>is_negation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_negation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a negation (¬). </p>

</div>
</div>
<a id="a0169dcd3572d7e3c626f154d1db8b7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0169dcd3572d7e3c626f154d1db8b7a3">&#9670;&nbsp;</a></span>is_non_negative_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_non_negative_integer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cf5f88e2f5295758117375a30de6386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf5f88e2f5295758117375a30de6386">&#9670;&nbsp;</a></span>is_not_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_not_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing disequality (!=). </p>

</div>
</div>
<a id="ac5cfac124e8ae1c7450c4e0c91c2bc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5cfac124e8ae1c7450c4e0c91c2bc07">&#9670;&nbsp;</a></span>is_not_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_not_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a formula representing disequality (!=). </p>

</div>
</div>
<a id="a45f342ca12fff0fb252625b2f62afe97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f342ca12fff0fb252625b2f62afe97">&#9670;&nbsp;</a></span>is_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is 1.0. </p>

</div>
</div>
<a id="a859d0e7196b00ffd99a347ff8a7d4d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859d0e7196b00ffd99a347ff8a7d4d76">&#9670;&nbsp;</a></span>is_positive_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_positive_integer </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a8a8cf51365e956ea445cf6b77d2577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8a8cf51365e956ea445cf6b77d2577">&#9670;&nbsp;</a></span>is_positive_semidefinite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a positive-semidefinite formula. </p>

</div>
</div>
<a id="a42a59dcaebd746af03b1996daf8d8901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a59dcaebd746af03b1996daf8d8901">&#9670;&nbsp;</a></span>is_positive_semidefinite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a positive semidefinite formula. </p>

</div>
</div>
<a id="aceba5fef90cbd2790037fa685e3ffdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceba5fef90cbd2790037fa685e3ffdce">&#9670;&nbsp;</a></span>is_pow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a power-function expression. </p>

</div>
</div>
<a id="a1ae3c8118eef15cc3a9dafe14c6d48c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae3c8118eef15cc3a9dafe14c6d48c2">&#9670;&nbsp;</a></span>is_pow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a power-function expression. </p>

</div>
</div>
<a id="aac0abfc50fd5ff7cda1e5709688b4569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0abfc50fd5ff7cda1e5709688b4569">&#9670;&nbsp;</a></span>is_relational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_relational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}). </p>

</div>
</div>
<a id="a500b46690e6bd8926394ccf7c8482a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500b46690e6bd8926394ccf7c8482a70">&#9670;&nbsp;</a></span>is_relational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_relational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a relational formula ({==, !=, &gt;, &gt;=, &lt;, &lt;=}). </p>

</div>
</div>
<a id="a23b9105cdfbe657bfe90eaf47d9e8f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b9105cdfbe657bfe90eaf47d9e8f11">&#9670;&nbsp;</a></span>is_sin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a sine expression. </p>

</div>
</div>
<a id="a790f1dea22ffa64d7c75849403aae060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790f1dea22ffa64d7c75849403aae060">&#9670;&nbsp;</a></span>is_sin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a sine expression. </p>

</div>
</div>
<a id="aa66cbc3a6c390d0d04bf3839e4377850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66cbc3a6c390d0d04bf3839e4377850">&#9670;&nbsp;</a></span>is_sinh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a hyperbolic-sine expression. </p>

</div>
</div>
<a id="a0373300d4207624b99351d0f7c347b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0373300d4207624b99351d0f7c347b85">&#9670;&nbsp;</a></span>is_sinh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a hyperbolic-sine expression. </p>

</div>
</div>
<a id="acfe3f1787c60c08adf6af1e1f29ff6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe3f1787c60c08adf6af1e1f29ff6cf">&#9670;&nbsp;</a></span>is_sqrt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a square-root expression. </p>

</div>
</div>
<a id="a6a645e5342fb66cd3fc7de8c38eac6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a645e5342fb66cd3fc7de8c38eac6b4">&#9670;&nbsp;</a></span>is_sqrt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a square-root expression. </p>

</div>
</div>
<a id="a8dd352ee762ef421653cd8941fa5ce22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd352ee762ef421653cd8941fa5ce22">&#9670;&nbsp;</a></span>is_tan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a tangent expression. </p>

</div>
</div>
<a id="a7eaf3f36c1f3fdf51121f77083894794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eaf3f36c1f3fdf51121f77083894794">&#9670;&nbsp;</a></span>is_tan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a tangent expression. </p>

</div>
</div>
<a id="a9da61282d0c5ccefeaa2068d84a19273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da61282d0c5ccefeaa2068d84a19273">&#9670;&nbsp;</a></span>is_tanh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a hyperbolic-tangent expression. </p>

</div>
</div>
<a id="ac06c87629b60cbdc34b8e2a9f715cd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06c87629b60cbdc34b8e2a9f715cd41">&#9670;&nbsp;</a></span>is_tanh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a hyperbolic-tangent expression. </p>

</div>
</div>
<a id="a1a71b252df5a615ff80f712e2983ab53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a71b252df5a615ff80f712e2983ab53">&#9670;&nbsp;</a></span>is_true() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_true </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is structurally equal to True formula. </p>

</div>
</div>
<a id="a3654df643f4d7840fd8548eb81f4a9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3654df643f4d7840fd8548eb81f4a9ae">&#9670;&nbsp;</a></span>is_true() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_true </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is structurally equal to True formula. </p>

</div>
</div>
<a id="a71c7e1bd2b1367487d36a6cd6871af0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c7e1bd2b1367487d36a6cd6871af0c">&#9670;&nbsp;</a></span>is_two()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_two </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is 2.0. </p>

</div>
</div>
<a id="ab6c97ad4e8b82b5c045695eb76fc1256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c97ad4e8b82b5c045695eb76fc1256">&#9670;&nbsp;</a></span>is_uninterpreted_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is an uninterpreted-function expression. </p>

</div>
</div>
<a id="aa47a95b03c275d9687461839c5612472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47a95b03c275d9687461839c5612472">&#9670;&nbsp;</a></span>is_uninterpreted_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is an uninterpreted-function expression. </p>

</div>
</div>
<a id="a571adc7bcdc056eec761a657f9354cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571adc7bcdc056eec761a657f9354cd7">&#9670;&nbsp;</a></span>is_variable() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a variable formula. </p>

</div>
</div>
<a id="ac014e89da18637b81f9c1fbe6306e689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac014e89da18637b81f9c1fbe6306e689">&#9670;&nbsp;</a></span>is_variable() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>f</code> is a variable formula. </p>

</div>
</div>
<a id="a184038d04f0ab628e12fb53a6f7cb5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184038d04f0ab628e12fb53a6f7cb5d9">&#9670;&nbsp;</a></span>is_variable() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is a variable expression. </p>

</div>
</div>
<a id="a2196a9e544a94c2e7c277b18c7b7716b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2196a9e544a94c2e7c277b18c7b7716b">&#9670;&nbsp;</a></span>is_variable() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>c</code> is a variable expression. </p>

</div>
</div>
<a id="a717f1ae4a1d038bc7870416276167f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717f1ae4a1d038bc7870416276167f19">&#9670;&nbsp;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::is_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <code>e</code> is 0.0. </p>

</div>
</div>
<a id="a13c0db41d89c9257d2fbfc4928fa5bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c0db41d89c9257d2fbfc4928fa5bd7">&#9670;&nbsp;</a></span>IsAffine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::IsAffine </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if every element in <code>m</code> is affine in <code>vars</code>. </p>
<dl class="section note"><dt>Note</dt><dd>If <code>m</code> is an empty matrix, it returns true. </dd></dl>

</div>
</div>
<a id="a9d8e94c7598bd59e6a5314ffbc3c7f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8e94c7598bd59e6a5314ffbc3c7f59">&#9670;&nbsp;</a></span>IsAffine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::IsAffine </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if every element in <code>m</code> is affine. </p>
<dl class="section note"><dt>Note</dt><dd>If <code>m</code> is an empty matrix, it returns true. </dd></dl>

</div>
</div>
<a id="aa9fbe2690e2170be14656811a9d860d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fbe2690e2170be14656811a9d860d5">&#9670;&nbsp;</a></span>isfinite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::isfinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> determining if the given expression <code>e</code> has a finite value. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if NaN is detected during evaluation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac460ea048a6b4cddcaf88672a6abcf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac460ea048a6b4cddcaf88672a6abcf46">&#9670;&nbsp;</a></span>isinf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::isinf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> determining if the given expression <code>e</code> is a positive or negative infinity. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if NaN is detected during evaluation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac66d112b9b6d693ee82d08c7a01f7a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66d112b9b6d693ee82d08c7a01f7a14">&#9670;&nbsp;</a></span>isnan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a> for the predicate isnan(e) to the given expression. </p>
<p>This serves as the argument-dependent lookup related to std::isnan(double).</p>
<p>When this formula is evaluated, there are two possible outcomes:</p><ul>
<li>Returns false if the <a class="el" href="namespacedrake_1_1symbolic.html#ac085a32409b678f96a69f5e50fc00ed7" title="Evaluates a symbolic matrix m using env and random_generator.">e.Evaluate()</a> is not NaN.</li>
<li>Throws std::runtime_error if NaN is detected during evaluation. Note that the evaluation of <code>isnan(e)</code> never returns true. </li>
</ul>

</div>
</div>
<a id="a5e355d7c9eb6bff11199a94c16ed5c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e355d7c9eb6bff11199a94c16ed5c8a">&#9670;&nbsp;</a></span>Jacobian() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&gt; drake::symbolic::Jacobian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>. </p>
<p>J(i,j) contains ∂f(i)/∂vars(j).</p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>vars</code> is non-empty}. </dd></dl>

</div>
</div>
<a id="ad0f56048cec3e53d98346a36df54a006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f56048cec3e53d98346a36df54a006">&#9670;&nbsp;</a></span>Jacobian() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt; drake::symbolic::Jacobian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>. </p>
<p>J(i,j) contains ∂f(i)/∂vars(j).</p>
<p>For example, Jacobian([x * cos(y), x * sin(y), x^2], {x, y}) returns the following 3x2 matrix: </p><pre>
 = |cos(y)   -x * sin(y)|
   |sin(y)    x * cos(y)|
   | 2 * x             0|
 </pre><dl class="section pre"><dt>Precondition</dt><dd>{<code>vars</code> is non-empty}. </dd></dl>

</div>
</div>
<a id="a71a3b8e65cfeb6d57deb7fe9d70f1d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a3b8e65cfeb6d57deb7fe9d70f1d4d">&#9670;&nbsp;</a></span>Jacobian() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt; drake::symbolic::Jacobian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Jacobian matrix J of the vector function <code>f</code> with respect to <code>vars</code>. </p>
<p>J(i,j) contains ∂f(i)/∂vars(j).</p>
<dl class="section pre"><dt>Precondition</dt><dd>{<code>vars</code> is non-empty}. </dd></dl>

</div>
</div>
<a id="ab6702577f951bca3006ab02f3313484e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6702577f951bca3006ab02f3313484e">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5aaadf953e1753ea5c2ff78a3bb030ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aaadf953e1753ea5c2ff78a3bb030ec">&#9670;&nbsp;</a></span>make_conjunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::make_conjunction </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>formulas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a conjunction of <code>formulas</code>. </p>
<p>It performs the following simplification:</p>
<ul>
<li>make_conjunction({}) returns True.</li>
<li>make_conjunction({f₁}) returns f₁.</li>
<li>If False ∈ <code>formulas</code>, it returns False.</li>
<li>If True ∈ <code>formulas</code>, it will not appear in the return value.</li>
<li>Nested conjunctions will be flattened. For example, make_conjunction({f₁, f₂ ∧ f₃}) returns f₁ ∧ f₂ ∧ f₃. </li>
</ul>

</div>
</div>
<a id="afc6dff8519d02993c6699ddb3ebb28cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6dff8519d02993c6699ddb3ebb28cf">&#9670;&nbsp;</a></span>make_disjunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::make_disjunction </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>formulas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a disjunction of <code>formulas</code>. </p>
<p>It performs the following simplification:</p>
<ul>
<li>make_disjunction({}) returns False.</li>
<li>make_disjunction({f₁}) returns f₁.</li>
<li>If True ∈ <code>formulas</code>, it returns True.</li>
<li>If False ∈ <code>formulas</code>, it will not appear in the return value.</li>
<li>Nested disjunctions will be flattened. For example, make_disjunction({f₁, f₂ ∨ f₃}) returns f₁ ∨ f₂ ∨ f₃. </li>
</ul>

</div>
</div>
<a id="ab61ece2fbaa79f8aad11313fa4b36150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61ece2fbaa79f8aad11313fa4b36150">&#9670;&nbsp;</a></span>MakeMatrixBinaryVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeMatrixBinaryVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen matrix of symbolic binary variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a803dbab92e520549b625dde70f05fe47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803dbab92e520549b625dde70f05fe47">&#9670;&nbsp;</a></span>MakeMatrixBinaryVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols&gt; drake::symbolic::MakeMatrixBinaryVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen matrix of symbolic binary variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a8fedc6cdc53869462f7aebaafa32c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8fedc6cdc53869462f7aebaafa32c0">&#9670;&nbsp;</a></span>MakeMatrixBooleanVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeMatrixBooleanVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen matrix of symbolic Boolean variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ab43ed8981b8575f24e83fdf4b26295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab43ed8981b8575f24e83fdf4b26295">&#9670;&nbsp;</a></span>MakeMatrixBooleanVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols&gt; drake::symbolic::MakeMatrixBooleanVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen matrix of symbolic Boolean variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29875ac163c78c1d1e75106b5890c949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29875ac163c78c1d1e75106b5890c949">&#9670;&nbsp;</a></span>MakeMatrixContinuousVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeMatrixContinuousVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen matrix of symbolic continuous variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad93b9abfad06da819d5460018eb49b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93b9abfad06da819d5460018eb49b5c">&#9670;&nbsp;</a></span>MakeMatrixContinuousVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols&gt; drake::symbolic::MakeMatrixContinuousVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen matrix of symbolic continuous variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6779284f55bfadabde9c015ad694d093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6779284f55bfadabde9c015ad694d093">&#9670;&nbsp;</a></span>MakeMatrixIntegerVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeMatrixIntegerVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen matrix of symbolic integer variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b71b38080ba3cd1d36172c4577ed445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b71b38080ba3cd1d36172c4577ed445">&#9670;&nbsp;</a></span>MakeMatrixIntegerVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols&gt; drake::symbolic::MakeMatrixIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen matrix of symbolic integer variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8261e92becc1714b40d5eb5cc370da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8261e92becc1714b40d5eb5cc370da8">&#9670;&nbsp;</a></span>MakeMatrixVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeMatrixVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen matrix of symbolic variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77055238eec353c7b077cd2fafd83aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77055238eec353c7b077cd2fafd83aa7">&#9670;&nbsp;</a></span>MakeMatrixVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, cols&gt; drake::symbolic::MakeMatrixVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen matrix of symbolic variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of cols in the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The (i, j)-th element will be named as <code>name(i, j)</code>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a697784ea0eafd05039e3a0c97b7c1415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a697784ea0eafd05039e3a0c97b7c1415">&#9670;&nbsp;</a></span>MakeRuleRewriter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1symbolic.html#a134e54042165751a5e5369b4631c90eb">Rewriter</a> drake::symbolic::MakeRuleRewriter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rewriting_rule.html">RewritingRule</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a rewriter based on a rewriting rule <code>r</code>. </p>

</div>
</div>
<a id="a486a6cf03a93f8f8693c94e57d29e0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486a6cf03a93f8f8693c94e57d29e0ea">&#9670;&nbsp;</a></span>MakeVectorBinaryVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeVectorBinaryVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen vector of symbolic binary variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a698dcb5dd4fea36841d305e89f52dd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698dcb5dd4fea36841d305e89f52dd97">&#9670;&nbsp;</a></span>MakeVectorBinaryVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1&gt; drake::symbolic::MakeVectorBinaryVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen vector of symbolic binary variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0db73b37d01f12010d12cd426f7f5054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db73b37d01f12010d12cd426f7f5054">&#9670;&nbsp;</a></span>MakeVectorBooleanVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeVectorBooleanVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen vector of symbolic Boolean variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d2f37fa21183f09e3544a4c6891494b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2f37fa21183f09e3544a4c6891494b">&#9670;&nbsp;</a></span>MakeVectorBooleanVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1&gt; drake::symbolic::MakeVectorBooleanVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen vector of symbolic Boolean variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3abc75a1263e517c17a4fcb5944ba474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3abc75a1263e517c17a4fcb5944ba474">&#9670;&nbsp;</a></span>MakeVectorContinuousVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeVectorContinuousVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen vector of symbolic continuous variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86a6b5840c741f1869738945cef3d8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a6b5840c741f1869738945cef3d8c5">&#9670;&nbsp;</a></span>MakeVectorContinuousVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1&gt; drake::symbolic::MakeVectorContinuousVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen vector of symbolic continuous variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7493090d0f80fbec7343113df05f6b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7493090d0f80fbec7343113df05f6b90">&#9670;&nbsp;</a></span>MakeVectorIntegerVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeVectorIntegerVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen vector of symbolic integer variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a22da2ebae3f3ca478d07976adfca85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a22da2ebae3f3ca478d07976adfca85">&#9670;&nbsp;</a></span>MakeVectorIntegerVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1&gt; drake::symbolic::MakeVectorIntegerVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen vector of symbolic integer variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab94f411b6759f6c243c684e37595f1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94f411b6759f6c243c684e37595f1e5">&#9670;&nbsp;</a></span>MakeVectorVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt; drake::symbolic::MakeVectorVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a dynamically-sized Eigen vector of symbolic variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad09c18b98a36a770ab68c048bd70b09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09c18b98a36a770ab68c048bd70b09c">&#9670;&nbsp;</a></span>MakeVectorVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>, rows, 1&gt; drake::symbolic::MakeVectorVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a static-sized Eigen vector of symbolic variables. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The size of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The common prefix for variables. The i-th element will be named as <code>name(i)</code>. </td></tr>
    <tr><td class="paramname">type</td><td>The type of variables in the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f6413d336e52ed76599cc96a8c87eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6413d336e52ed76599cc96a8c87eee">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a368c7616ccd2ce8d1587aa7343575d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368c7616ccd2ce8d1587aa7343575d52">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04c0029b04f957181b0cb2bdae701514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c0029b04f957181b0cb2bdae701514">&#9670;&nbsp;</a></span>MonomialBasis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1&gt; drake::symbolic::MonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all monomials up to a given degree under the graded reverse lexicographic order. </p>
<p>Note that graded reverse lexicographic order uses the total order among <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">Variable</a> which is based on a variable's unique ID. For example, for a given variable ordering x &gt; y &gt; z, <code>MonomialBasis({x, y, z}, 2)</code> returns a column vector <code>[x^2, xy, y^2, xz, yz, z^2, x, y, z, 1]</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>vars</code> is a non-empty set. </dd>
<dd>
<code>degree</code> is a non-negative integer. </dd></dl>

</div>
</div>
<a id="af297794f22c0458592aeea637cce060a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af297794f22c0458592aeea637cce060a">&#9670;&nbsp;</a></span>MonomialBasis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, <a class="el" href="namespacedrake_1_1symbolic.html#aa40528027cce753aacb377913342f536">NChooseK</a>(n + degree, degree), 1&gt; drake::symbolic::MonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all monomials up to a given degree under the graded reverse lexicographic order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>number of variables. </td></tr>
    <tr><td class="paramname">degree</td><td>maximum total degree of monomials to compute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>vars</code> is a non-empty set. </dd>
<dd>
vars.size() == <code>n</code>. </dd></dl>

</div>
</div>
<a id="aa40528027cce753aacb377913342f536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40528027cce753aacb377913342f536">&#9670;&nbsp;</a></span>NChooseK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> drake::symbolic::NChooseK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade6ac4e26dcd9023a9f8146aa75454c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6ac4e26dcd9023a9f8146aa75454c7">&#9670;&nbsp;</a></span>OddDegreeMonomialBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>, Eigen::Dynamic, 1&gt; drake::symbolic::OddDegreeMonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all odd degree monomials up to a given degree under the graded reverse lexicographic order. </p>
<p>A monomial has an odd degree if its total degree is odd. So x²y is an odd degree monomial (degree 3) while xy is not (degree 2). Note that graded reverse lexicographic order uses the total order among <a class="el" href="classdrake_1_1symbolic_1_1_variable.html" title="Represents a symbolic variable.">Variable</a> which is based on a variable's unique ID. For example, for a given variable ordering x &gt; y &gt; z, <code>OddDegreeMonomialBasis({x, y, z}, 3)</code> returns a column vector <code>[x³, x²y, xy², y³, x²z, xyz, y²z, xz², yz², z³, x, y, z]</code></p>
<dl class="section pre"><dt>Precondition</dt><dd><code>vars</code> is a non-empty set. </dd>
<dd>
<code>degree</code> is a non-negative integer. </dd></dl>

</div>
</div>
<a id="a71e40924c21a4f08a5cc274eaf7ddebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e40924c21a4f08a5cc274eaf7ddebd">&#9670;&nbsp;</a></span>operator &amp;&amp;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator &amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a39da4f4e5f916079f201f92852399f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39da4f4e5f916079f201f92852399f45">&#9670;&nbsp;</a></span>operator &amp;&amp;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator &amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaea3ce465525b0c357d1c5115e49a626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea3ce465525b0c357d1c5115e49a626">&#9670;&nbsp;</a></span>operator &amp;&amp;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator &amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4758fb8f36a1a85b9fa932003216fe2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4758fb8f36a1a85b9fa932003216fe2e">&#9670;&nbsp;</a></span>operator &amp;&amp;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator &amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a76deccd3cd3f64d9b875dd5116792c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76deccd3cd3f64d9b875dd5116792c07">&#9670;&nbsp;</a></span>operator *() <span class="overload">[1/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a>, double&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the product of two Chebyshev basis elements. </p>
<p>Since Tₘ(x) * Tₙ(x) = 0.5 (Tₘ₊ₙ(x) + Tₘ₋ₙ(x)) if m &gt;= n, the product of Chebyshev basis elements is the weighted sum of several Chebyshev basis elements. For example T₁(x)T₂(y) * T₃(x)T₁(y) = 0.25*(T₄(x)T₃(y) + T₂(x)T₃(y)</p><ul>
<li>T₄(x)T₁(y) + T₂(x)T₁(y)) <dl class="section return"><dt>Returns</dt><dd>the result of the product, from each <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> to its coefficient. In the example above, it returns (T₄(x)T₃(y) -&gt; 0.25), (T₂(x)T₃(y) -&gt; 0.25), (T₄(x)T₁(y) -&gt; 0.25) and (T₂(x)T₁(y) -&gt; 0.25) </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a97671d479c281451e703b58530b17082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97671d479c281451e703b58530b17082">&#9670;&nbsp;</a></span>operator *() <span class="overload">[2/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad71ee73fb966e97f0de864fa7cdb3692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71ee73fb966e97f0de864fa7cdb3692">&#9670;&nbsp;</a></span>operator *() <span class="overload">[3/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c5c62b680b89f6fe992e5bc6b01e6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5c62b680b89f6fe992e5bc6b01e6c7">&#9670;&nbsp;</a></span>operator *() <span class="overload">[4/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1611c62700b00b9861c339879899a121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1611c62700b00b9861c339879899a121">&#9670;&nbsp;</a></span>operator *() <span class="overload">[5/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a347249d56768661c610bf3bafb5ff167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347249d56768661c610bf3bafb5ff167">&#9670;&nbsp;</a></span>operator *() <span class="overload">[6/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a791475e9d37a8e5fd5f1314045428997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791475e9d37a8e5fd5f1314045428997">&#9670;&nbsp;</a></span>operator *() <span class="overload">[7/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a multiplication of two monomials, <code>m1</code> and <code>m2</code>. </p>

</div>
</div>
<a id="a5885669a7b9958dc209c13778d48e6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5885669a7b9958dc209c13778d48e6ef">&#9670;&nbsp;</a></span>operator *() <span class="overload">[8/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a>, double&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a multiplication of two monomials, <code>m1</code> and <code>m2</code>. </p>
<dl class="section note"><dt>Note</dt><dd>that we return a map from the monomial product to its coefficient. This map has size 1, and the coefficient is also 1. We return a map instead of the <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html" title="MonomialBasisElement represents a monomial, a product of powers of variables with non-negative intege...">MonomialBasisElement</a> directly, because we want operator* to have the same return signature as other <a class="el" href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html" title="Each polynomial p(x) can be written as a linear combination of its basis elements p(x) = ∑ᵢ cᵢ * ϕᵢ(x...">PolynomialBasisElement</a>. For example, the product between two <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> objects is a weighted sum of <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> objects. </dd>
<dd>
we do not provide operator*= function for this class, since operator*= would return <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html" title="MonomialBasisElement represents a monomial, a product of powers of variables with non-negative intege...">MonomialBasisElement</a>, which is different from operator*. </dd></dl>

</div>
</div>
<a id="a267c5d854d55ce16b1e58490ff426661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267c5d854d55ce16b1e58490ff426661">&#9670;&nbsp;</a></span>operator *() <span class="overload">[9/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following operations: </p>
<ul>
<li>Matrix&lt;RF&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;RF&gt;</li>
<li>Matrix&lt;RF&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;RF&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;RF&gt; =&gt; Matrix&lt;RF&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;RF&gt; =&gt; Matrix&lt;RF&gt;</li>
</ul>
<p>where RF is a shorthand for <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html" title="Represents symbolic rational function.">RationalFunction</a>.</p>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information</dd></dl>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="ae3b6eea79253234902bbcf4643e34d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b6eea79253234902bbcf4643e34d81">&#9670;&nbsp;</a></span>operator *() <span class="overload">[10/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e804fc81cb6d40414b816f559f81a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e804fc81cb6d40414b816f559f81a7d">&#9670;&nbsp;</a></span>operator *() <span class="overload">[11/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af38134e3394d8c40a7a91490154de2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38134e3394d8c40a7a91490154de2b3">&#9670;&nbsp;</a></span>operator *() <span class="overload">[12/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab04739aabb37142340b869a126cc54a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04739aabb37142340b869a126cc54a1">&#9670;&nbsp;</a></span>operator *() <span class="overload">[13/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a812892dbfc6443dc1eed055e1915f5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812892dbfc6443dc1eed055e1915f5e4">&#9670;&nbsp;</a></span>operator *() <span class="overload">[14/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a46fe276a728b54ce277fcc972fd28d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46fe276a728b54ce277fcc972fd28d78">&#9670;&nbsp;</a></span>operator *() <span class="overload">[15/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa78d0e5127e0fa0fab9f26c075c6ad9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78d0e5127e0fa0fab9f26c075c6ad9d">&#9670;&nbsp;</a></span>operator *() <span class="overload">[16/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a0eab276a88883d8e2607630cb93bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0eab276a88883d8e2607630cb93bc5">&#9670;&nbsp;</a></span>operator *() <span class="overload">[17/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab66975f1892907d118eb8cb98d6465c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66975f1892907d118eb8cb98d6465c7">&#9670;&nbsp;</a></span>operator *() <span class="overload">[18/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aece6b8e4e48de49ed447c6d62b81ce88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece6b8e4e48de49ed447c6d62b81ce88">&#9670;&nbsp;</a></span>operator *() <span class="overload">[19/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following seven operations: </p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="a1dbec6a09664cb563d86071a7be38913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbec6a09664cb563d86071a7be38913">&#9670;&nbsp;</a></span>operator *() <span class="overload">[20/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9672ecf8933b210eeedda1d56e670c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9672ecf8933b210eeedda1d56e670c8">&#9670;&nbsp;</a></span>operator *() <span class="overload">[21/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt;::value &amp;&amp; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt;::value &amp;&amp; std::is_same&lt;typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::value &amp;&amp; std::is_same&lt;typename MatrixR::Scalar, double&gt;::value, Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following seven operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="a106c3f1e5e8ffaf1d667a7c1858753ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106c3f1e5e8ffaf1d667a7c1858753ad">&#9670;&nbsp;</a></span>operator *() <span class="overload">[22/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt;::value &amp;&amp; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt;::value &amp;&amp; std::is_same&lt;typename MatrixL::Scalar, double&gt;::value &amp;&amp; std::is_same&lt;typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::value, Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following seven operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="a9128a895c3456d01b9c3c5b76bedf68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9128a895c3456d01b9c3c5b76bedf68b">&#9670;&nbsp;</a></span>operator *() <span class="overload">[23/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt;::value &amp;&amp; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt;::value &amp;&amp; std::is_same&lt;typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::value &amp;&amp; std::is_same&lt;typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;::value, Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following seven operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="a9bd1b0e780b38b3c3538e516ba979f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd1b0e780b38b3c3538e516ba979f89">&#9670;&nbsp;</a></span>operator *() <span class="overload">[24/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt;::value &amp;&amp; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt;::value &amp;&amp; std::is_same&lt;typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;::value &amp;&amp; std::is_same&lt;typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::value, Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following seven operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="aa379ca3565b4c97f5124bc78599febf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa379ca3565b4c97f5124bc78599febf4">&#9670;&nbsp;</a></span>operator *() <span class="overload">[25/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt;::value &amp;&amp; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt;::value &amp;&amp; std::is_same&lt;typename MatrixL::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;::value &amp;&amp; std::is_same&lt;typename MatrixR::Scalar, double&gt;::value, Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following seven operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="a4c03c6df6e36906365f51623fd53bdb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c03c6df6e36906365f51623fd53bdb6">&#9670;&nbsp;</a></span>operator *() <span class="overload">[26/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixL&gt;, MatrixL&gt;::value &amp;&amp; std::is_base_of&lt;Eigen::MatrixBase&lt;MatrixR&gt;, MatrixR&gt;::value &amp;&amp; std::is_same&lt;typename MatrixL::Scalar, double&gt;::value &amp;&amp; std::is_same&lt;typename MatrixR::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a>&gt;::value, Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, MatrixL::RowsAtCompileTime, MatrixR::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const MatrixL &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixR &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the following seven operations: </p>
<p>Provides the following operations:</p>
<ul>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Polynomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;Monomial&gt; * Matrix&lt;double&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Polynomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
<li>Matrix&lt;double&gt; * Matrix&lt;Monomial&gt; =&gt; Matrix&lt;Polynomial&gt;</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>that these operator overloadings are necessary even after providing Eigen::ScalarBinaryOpTraits. See <a href="https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen">https://stackoverflow.com/questions/41494288/mixing-scalar-types-in-eigen</a> for more information. </dd></dl>

</div>
</div>
<a id="adac78e96efaa07849f158591192b2dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac78e96efaa07849f158591192b2dca">&#9670;&nbsp;</a></span>operator *() <span class="overload">[27/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, LhsMode, LhsOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; double, Dim, RhsMode, RhsOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform&lt;double&gt; * Transform&lt;Expression&gt; =&gt; Transform&lt;Expression&gt; </p>

</div>
</div>
<a id="aac410f7e82c9d06e796d7fcb4508f5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac410f7e82c9d06e796d7fcb4508f5e4">&#9670;&nbsp;</a></span>operator *() <span class="overload">[28/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto drake::symbolic::operator * </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Transform&lt; double, Dim, LhsMode, LhsOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Transform&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Dim, RhsMode, RhsOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform&lt;Expression&gt; * Transform&lt;double&gt; =&gt; Transform&lt;Expression&gt; </p>

</div>
</div>
<a id="a6ee2268a69d74bce563c043848528741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee2268a69d74bce563c043848528741">&#9670;&nbsp;</a></span>operator *=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::operator *= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a489c472556030b17c10028a04ba70aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489c472556030b17c10028a04ba70aad">&#9670;&nbsp;</a></span>operator!() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9f34a1136227779b18433cd0a2f4dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f34a1136227779b18433cd0a2f4dde">&#9670;&nbsp;</a></span>operator!() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5c1c4bfd4434de52e240126b78853c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c1c4bfd4434de52e240126b78853c0">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> <a class="el" href="namespacedrake_1_1symbolic.html#a489c472556030b17c10028a04ba70aad">drake::symbolic::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54ab0d3036f7e2f93354a35e4dad6ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ab0d3036f7e2f93354a35e4dad6ae2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() != typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, typename internal::RelationalOpTraits&lt;DerivedA, DerivedB&gt;::ReturnType&gt;::type <a class="el" href="namespacedrake_1_1symbolic.html#a489c472556030b17c10028a04ba70aad">drake::symbolic::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using not-equal operator (!=). </p>

</div>
</div>
<a id="a29162801f264334d6292daf5830f9f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29162801f264334d6292daf5830f9f78">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename Derived::Scalar() != ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::type <a class="el" href="namespacedrake_1_1symbolic.html#a489c472556030b17c10028a04ba70aad">drake::symbolic::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using not-equal operator (!=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a != v)</code> has a symbolic formula <code>a(i, j) != v</code>. </p>

</div>
</div>
<a id="a1d4d5abce6202d5c1e711750cf6d4fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4d5abce6202d5c1e711750cf6d4fb6">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(ScalarType() != typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::type <a class="el" href="namespacedrake_1_1symbolic.html#a489c472556030b17c10028a04ba70aad">drake::symbolic::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> not-equal operator (!=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v != a)</code> has a symbolic formula <code>v != a(i, j)</code>. </p>

</div>
</div>
<a id="ac72b431bb035e5035d4a5ca5c1aedb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72b431bb035e5035d4a5ca5c1aedb02">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt;::value &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() != typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::type <a class="el" href="namespacedrake_1_1symbolic.html#a489c472556030b17c10028a04ba70aad">drake::symbolic::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing the condition whether <code>m1</code> and <code>m2</code> are not the same. </p>
<p>The following table describes the return type of <code>m1</code> != <code>m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">bool   </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>.</p>
<p>Note that this function does <em>not</em> provide operator overloading for the following case. It returns <code>bool</code> and is provided by Eigen.</p>
<ul>
<li>Eigen::Matrix&lt;double&gt; != Eigen::Matrix&lt;double&gt; </li>
</ul>

</div>
</div>
<a id="a8327415ae13cae1b0d450c384079a49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8327415ae13cae1b0d450c384079a49e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6364a2e4727b0af4071b15da0cad509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6364a2e4727b0af4071b15da0cad509">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a185c9ab6bca14a042a837aadf2064546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185c9ab6bca14a042a837aadf2064546">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a167d0d14d66effceeb5834371626452b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167d0d14d66effceeb5834371626452b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0dc08ea95543252bcf2b31fdfe723d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc08ea95543252bcf2b31fdfe723d26">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba2399f6ee5b4c18bc26dc3fd5b6c07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2399f6ee5b4c18bc26dc3fd5b6c07a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-union of <code>var1</code> and <code>var2</code>. </p>

</div>
</div>
<a id="a497331a32f5911a18cef34b07df6c04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497331a32f5911a18cef34b07df6c04a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-union of <code>vars</code> and {<code>var}</code>. </p>

</div>
</div>
<a id="aae117a884f72a1a73cc2863ec026c011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae117a884f72a1a73cc2863ec026c011">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-union of {<code>var}</code> and <code>vars</code>. </p>

</div>
</div>
<a id="affb3773f2d585ffce0253cb15c8c00a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb3773f2d585ffce0253cb15c8c00a0">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52a4be02d87d5a6d31efbbcb5d3ba934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a4be02d87d5a6d31efbbcb5d3ba934">&#9670;&nbsp;</a></span>operator+() <span class="overload">[10/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96b091bab8bb06edd276c6b4a420903c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b091bab8bb06edd276c6b4a420903c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[11/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af04dff9a90e39ac9985d520d3e66f5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04dff9a90e39ac9985d520d3e66f5c3">&#9670;&nbsp;</a></span>operator+() <span class="overload">[12/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e02326d779ba8c55ad9d9f6eb54f3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e02326d779ba8c55ad9d9f6eb54f3d8">&#9670;&nbsp;</a></span>operator+() <span class="overload">[13/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dd958cf7990638bdd2576c2ab62ad43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd958cf7990638bdd2576c2ab62ad43">&#9670;&nbsp;</a></span>operator+() <span class="overload">[14/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a289b47480364e01b67e3c86aa33a0fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289b47480364e01b67e3c86aa33a0fe4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[15/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ee4b0876c4a92c7bd3030b193ce0dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee4b0876c4a92c7bd3030b193ce0dbd">&#9670;&nbsp;</a></span>operator+() <span class="overload">[16/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42522d07a4a9c32a89e8b4eea9a00a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42522d07a4a9c32a89e8b4eea9a00a60">&#9670;&nbsp;</a></span>operator+() <span class="overload">[17/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab876f48eb96e82b718df0050b9d57d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab876f48eb96e82b718df0050b9d57d8b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[18/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3293ffe3812fbfa2dbd63263fcf6c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3293ffe3812fbfa2dbd63263fcf6c4c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[19/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a105ae15b8e85984cf3ae81a7b67de38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105ae15b8e85984cf3ae81a7b67de38c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[20/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9084a43cdfa02b10cb216c7bfff0dcb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9084a43cdfa02b10cb216c7bfff0dcb3">&#9670;&nbsp;</a></span>operator+() <span class="overload">[21/21]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa24e959c9dc95dbb3702f878e78a4963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24e959c9dc95dbb3702f878e78a4963">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code>var1</code> with the result of set-union(<code>var1</code>, <code>var2</code>). </p>

</div>
</div>
<a id="a474ff58b198baf20986ebf6ff810f3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474ff58b198baf20986ebf6ff810f3cb">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code>vars</code> with the result of set-union(<code>vars</code>, { <code>var</code> }). </p>

</div>
</div>
<a id="a1519bc7275ec68c904b395067f8ff775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1519bc7275ec68c904b395067f8ff775">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4242b6a1ad5bddbba0242c96d4a36c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4242b6a1ad5bddbba0242c96d4a36c2">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unary minus operation for rational function. </p>
<p>if f(x) = p(x) / q(x), then -f(x) = (-p(x)) / q(x) </p>

</div>
</div>
<a id="af9ea1fd857bdf8fa5c18f570118640ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ea1fd857bdf8fa5c18f570118640ff">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ec6e83953a4663403fcb08592e16b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec6e83953a4663403fcb08592e16b01">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47d7c5f60ed6d69385cebc84f1154a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d7c5f60ed6d69385cebc84f1154a2e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad564d8bc7c97743e2ca0654c2c417c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad564d8bc7c97743e2ca0654c2c417c8d">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22f74050260696325581c3087d07fab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f74050260696325581c3087d07fab7">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d93012a42e93f92eb3b7fab8bd60733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d93012a42e93f92eb3b7fab8bd60733">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-minus(<code>var1</code>, <code>vars2</code>). </p>

</div>
</div>
<a id="a062f8182804bd14f76a6f2ac17718a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062f8182804bd14f76a6f2ac17718a80">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a>&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns set-minus(<code>vars</code>, { <code>var</code> }). </p>

</div>
</div>
<a id="ade37df718218bcbdbc1edd9a0b6a596a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade37df718218bcbdbc1edd9a0b6a596a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unary minus operation for polynomial. </p>

</div>
</div>
<a id="a1aa3f21ab39b7fb01be90ed9255df5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa3f21ab39b7fb01be90ed9255df5f9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[10/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacc89061cd63bf0e4d0d79c57d3b72e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc89061cd63bf0e4d0d79c57d3b72e4">&#9670;&nbsp;</a></span>operator-() <span class="overload">[11/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48f8b6bfe08648f4a0dac518e1abb0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f8b6bfe08648f4a0dac518e1abb0bd">&#9670;&nbsp;</a></span>operator-() <span class="overload">[12/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada023ba3d82bbf8137d74409bf596457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada023ba3d82bbf8137d74409bf596457">&#9670;&nbsp;</a></span>operator-() <span class="overload">[13/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e4fa4bbef7ce58efc247dd1717a2ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4fa4bbef7ce58efc247dd1717a2ded">&#9670;&nbsp;</a></span>operator-() <span class="overload">[14/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a369ea32ea396cc86951892020d5c4a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369ea32ea396cc86951892020d5c4a4b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[15/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe6ad1d11dea0eafbfed0db238957d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6ad1d11dea0eafbfed0db238957d64">&#9670;&nbsp;</a></span>operator-() <span class="overload">[16/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a448e985024e32143f3ca12d8596211d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448e985024e32143f3ca12d8596211d4">&#9670;&nbsp;</a></span>operator-() <span class="overload">[17/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03731fe9a001a20e071a7a9e106061bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03731fe9a001a20e071a7a9e106061bd">&#9670;&nbsp;</a></span>operator-() <span class="overload">[18/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30f8eee8c5c646b5f3fc43baf3ce5854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f8eee8c5c646b5f3fc43baf3ce5854">&#9670;&nbsp;</a></span>operator-() <span class="overload">[19/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8d3a7da7b3275333a0f2d67d649ead8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d3a7da7b3275333a0f2d67d649ead8">&#9670;&nbsp;</a></span>operator-() <span class="overload">[20/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a554e434566b78163855f96829c244e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554e434566b78163855f96829c244e37">&#9670;&nbsp;</a></span>operator-() <span class="overload">[21/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac306b9a9b7ace256330ae3ab8deaafef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac306b9a9b7ace256330ae3ab8deaafef">&#9670;&nbsp;</a></span>operator-() <span class="overload">[22/22]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b30a6b5de749f06ec5c918f6b4b27f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b30a6b5de749f06ec5c918f6b4b27f8">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code>var1</code> with the result of set-minus(<code>var1</code>, <code>var2</code>). </p>

</div>
</div>
<a id="a35f3692fb5f1d16586b897e369979028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f3692fb5f1d16586b897e369979028">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> drake::symbolic::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code>vars</code> with the result of set-minus(<code>vars</code>, {<code>var}</code>). </p>

</div>
</div>
<a id="a380b68d6baf2cb5ab4212e435d1104ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380b68d6baf2cb5ab4212e435d1104ee">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c8b6db1763f8f7a5d98de636b9cd7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8b6db1763f8f7a5d98de636b9cd7c9">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a8d6fb5671a17bf0c89c1c5aef9efaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8d6fb5671a17bf0c89c1c5aef9efaf">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27ad135e8775cf9d721b1223218fff2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ad135e8775cf9d721b1223218fff2d">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a687c99f46e854d9237083b2f34e6665c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687c99f46e854d9237083b2f34e6665c">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb47877c3cad48fe6a8e25edb0620495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb47877c3cad48fe6a8e25edb0620495">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9423440606bd13d4767c72dd97ec6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9423440606bd13d4767c72dd97ec6a2">&#9670;&nbsp;</a></span>operator/() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>p / v</code>. </p>

</div>
</div>
<a id="a43e7c74e8b9ea1c9c5843c590e388009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e7c74e8b9ea1c9c5843c590e388009">&#9670;&nbsp;</a></span>operator/() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c5d6073354479ca8e507536cd36f844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5d6073354479ca8e507536cd36f844">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&amp; drake::symbolic::operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1245bbf1795b4f97ec4c04cd79dcde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1245bbf1795b4f97ec4c04cd79dcde3">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a>&#160;</td>
          <td class="paramname"><em>k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1symbolic.html#a6869e7044dd90be5d972ee7dd4e821b6">FormulaKind</a>&#160;</td>
          <td class="paramname"><em>k2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70b5e99a86a85837124c6a006f7ec60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b5e99a86a85837124c6a006f7ec60a">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30fa">ExpressionKind</a>&#160;</td>
          <td class="paramname"><em>k1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1symbolic.html#aebde9bdda9a428ef1bab6175954d30fa">ExpressionKind</a>&#160;</td>
          <td class="paramname"><em>k2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total ordering between ExpressionKinds. </p>

</div>
</div>
<a id="a0ad84d6691fb2bf9627d894d56b8ef6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad84d6691fb2bf9627d894d56b8ef6f">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f14d72dc6d1dacae1f23f666ed42595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f14d72dc6d1dacae1f23f666ed42595">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, typename internal::RelationalOpTraits&lt;DerivedA, DerivedB&gt;::ReturnType&gt;::type drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using less-than operator (&lt;). </p>

</div>
</div>
<a id="a986b3544a84c715fba5ba1633845a206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986b3544a84c715fba5ba1633845a206">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename Derived::Scalar() &lt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using less-than operator (&lt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a &lt; v)</code> has a symbolic formula <code>a(i, j) &lt; v</code>. </p>

</div>
</div>
<a id="ae3c9b1d47ba70ed1290375ef56166d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c9b1d47ba70ed1290375ef56166d13">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(ScalarType() &lt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than operator (&lt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v &lt; a)</code> has a symbolic formula <code>v &lt; a(i, j)</code>. </p>

</div>
</div>
<a id="a41fb24103c168ad624e3416b15f206ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fb24103c168ad624e3416b15f206ae">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt;::value &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &lt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::type drake::symbolic::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using less-than (&lt;) operator. </p>
<p>The following table describes the return type of <code>m1</code> &lt; <code>m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">N/A   </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>. </p>

</div>
</div>
<a id="ab6e0055c99275292d22eb59c103fb0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e0055c99275292d22eb59c103fb0ae">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7">Variable::Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31d454a069abf89b2a0b6c71222ec221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d454a069abf89b2a0b6c71222ec221">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_polynomial.html">ChebyshevPolynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af975c2571c59b1d8b03b213a15096336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af975c2571c59b1d8b03b213a15096336">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html">ChebyshevBasisElement</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8505db5f6e70df16a3cecda394bdcb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8505db5f6e70df16a3cecda394bdcb24">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af71ffcec2b8e06d52b7c6e8f53106160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71ffcec2b8e06d52b7c6e8f53106160">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9eb2f0937be3e670ccdca9c4d30c63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9eb2f0937be3e670ccdca9c4d30c63d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c794bfc916c077b16d9c7d47031f68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c794bfc916c077b16d9c7d47031f68c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30a0c468c43eb087bc5e98af3c3ad278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a0c468c43eb087bc5e98af3c3ad278">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::symbolic::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaba9db65867379d7603eeaeb9be56451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba9db65867379d7603eeaeb9be56451">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9128f57eda95a717917a28f5c510968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9128f57eda95a717917a28f5c510968">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &lt;= typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, typename internal::RelationalOpTraits&lt;DerivedA, DerivedB&gt;::ReturnType&gt;::type drake::symbolic::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using less-than-or-equal operator (&lt;=). </p>

</div>
</div>
<a id="a68198826f1753cb1e463c57c42da9dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68198826f1753cb1e463c57c42da9dc7">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename Derived::Scalar() &lt;= ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using less-than-or-equal operator (&lt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a &lt;= v)</code> has a symbolic formula <code>a(i, j) &lt;= v</code>. </p>

</div>
</div>
<a id="a84b7debe6add1a90d995b7fe32077e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b7debe6add1a90d995b7fe32077e15">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(ScalarType() &lt;= typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than-or-equal operator (&lt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v &lt;= a)</code> has a symbolic formula <code>v &lt;= a(i, j)</code>. </p>

</div>
</div>
<a id="a382f5863e12e1c5357b9e40a42a1787d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382f5863e12e1c5357b9e40a42a1787d">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt;::value &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &lt;= typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::type drake::symbolic::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using less-than-or-equal operator (&lt;=). </p>
<p>The following table describes the return type of <code>m1</code> &lt;= <code>m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">N/A   </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>. </p>

</div>
</div>
<a id="a463b86323b82db42856d70b2537759e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463b86323b82db42856d70b2537759e3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ee5f21259ce481fb8967a457dc80362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee5f21259ce481fb8967a457dc80362">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() == typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, typename internal::RelationalOpTraits&lt;DerivedA, DerivedB&gt;::ReturnType&gt;::type drake::symbolic::operator== </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise symbolic-equality of two arrays <code>m1</code> and <code>m2</code>. </p>
<p>The following table describes the return type of <code>m1</code> == <code>m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EA&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EA&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EA&lt;double&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EA&lt;Expression&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EA&lt;Variable&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EA&lt;double&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;Formula&gt;  </td><td class="markdownTableBodyNone">EA&lt;bool&gt;   </td></tr>
</table>
<p>In the table, <code>EA</code> is a short-hand of <code>Eigen::Array</code>.</p>
<p>Note that this function does <em>not</em> provide operator overloading for the following case. It returns <code>Eigen::Array&lt;bool&gt;</code> and is provided by Eigen.</p>
<ul>
<li>Eigen::Array&lt;double&gt; == Eigen::Array&lt;double&gt; </li>
</ul>

</div>
</div>
<a id="a7ebadda4ff0c83bc56fbe0d1a1394c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebadda4ff0c83bc56fbe0d1a1394c42">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename Derived::Scalar() == ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator== </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using equal-to operator (==). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a == v)</code> has a symbolic formula <code>a(i, j) == v</code>.</p>
<p>Here is an example using this operator overloading. </p><div class="fragment"><div class="line">Eigen::Array&lt;Variable, 2, 2&gt; a;</div><div class="line">a &lt;&lt; Variable{<span class="stringliteral">&quot;x&quot;</span>}, Variable{<span class="stringliteral">&quot;y&quot;</span>},</div><div class="line">     Variable{<span class="stringliteral">&quot;z&quot;</span>}, Variable{<span class="stringliteral">&quot;w&quot;</span>};</div><div class="line">Eigen::Array&lt;Formula, 2, 2&gt; f = (a == 3.5);</div><div class="line"><span class="comment">// Here f = |(x == 3.5)  (y == 3.5)|</span></div><div class="line"><span class="comment">//          |(z == 3.5)  (w == 3.5)|.</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a4a608496012273ef3a3588c98177334d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a608496012273ef3a3588c98177334d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(ScalarType() == typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator== </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> equal-to operator (==). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v == a)</code> has a symbolic formula <code>v == a(i, j)</code>.</p>
<p>Here is an example using this operator overloading. </p><div class="fragment"><div class="line">Eigen::Array&lt;Variable, 2, 2&gt; a;</div><div class="line">a &lt;&lt; Variable{<span class="stringliteral">&quot;x&quot;</span>}, Variable{<span class="stringliteral">&quot;y&quot;</span>},</div><div class="line">     Variable{<span class="stringliteral">&quot;z&quot;</span>}, Variable{<span class="stringliteral">&quot;w&quot;</span>};</div><div class="line">Eigen::Array&lt;Formula, 2, 2&gt; f = (3.5 == a);</div><div class="line"><span class="comment">// Here f = |(3.5 == x)  (3.5 == y)|</span></div><div class="line"><span class="comment">//          |(3.5 == z)  (3.5 == w)|.</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a2f2f78812963ed2e8e95b5807249efbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2f78812963ed2e8e95b5807249efbc">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt;::value &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() == typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::type drake::symbolic::operator== </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula checking if two matrices <code>m1</code> and <code>m2</code> are equal. </p>
<p>The following table describes the return type of <code>m1</code> == <code>m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">bool   </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>.</p>
<p>Note that this function does <em>not</em> provide operator overloading for the following case. It returns <code>bool</code> and is provided by Eigen.</p>
<ul>
<li>Eigen::Matrix&lt;double&gt; == Eigen::Matrix&lt;double&gt;</li>
</ul>
<p>Note that this method returns a conjunctive formula which keeps its conjuncts as <code>std::set&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>&gt;</code> internally. This set is ordered by <code><a class="el" href="classdrake_1_1symbolic_1_1_formula.html#abd2677c76ddb28c10321b8178cfc6292" title="Checks lexicographical ordering between this and e.">Formula::Less</a></code> and this ordering can be <em>different</em> from the one in inputs. Also, any duplicated formulas are removed in construction. Please check the following example.</p>
<div class="fragment"><div class="line"><span class="comment">// set up v1 = [y x y] and v2 = [1 2 1]</span></div><div class="line">VectorX&lt;Expression&gt; v1{3};</div><div class="line">VectorX&lt;Expression&gt; v2{3};</div><div class="line"><span class="keyword">const</span> Variable x{<span class="stringliteral">&quot;x&quot;</span>};</div><div class="line"><span class="keyword">const</span> Variable y{<span class="stringliteral">&quot;y&quot;</span>};</div><div class="line">v1 &lt;&lt; y, x, y;</div><div class="line">v2 &lt;&lt; 1, 2, 1;</div><div class="line"><span class="comment">// Here v1_eq_v2 = ((x = 2) ∧ (y = 1))</span></div><div class="line"><span class="keyword">const</span> Formula v1_eq_v2{v1 == v2};</div><div class="line"><span class="keyword">const</span> std::set&lt;Formula&gt; conjuncts{<a class="code" href="namespacedrake_1_1symbolic.html#a2362f52cf6b8c750209340520e7bc9b4">get_operands</a>(v1_eq_v2)};</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> Formula&amp; f : conjuncts) {</div><div class="line">  std::cerr &lt;&lt; f &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"><span class="comment">// The outcome of the above loop is:</span></div><div class="line">(x = 2)</div><div class="line">(y = 1)</div></div><!-- fragment --> 
</div>
</div>
<a id="a5a12a5db3a9b2e8520e002e437354717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a12a5db3a9b2e8520e002e437354717">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad22804124c97e376fad6bb10d00113f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad22804124c97e376fad6bb10d00113f6">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, typename internal::RelationalOpTraits&lt;DerivedA, DerivedB&gt;::ReturnType&gt;::type drake::symbolic::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using greater-than operator (&gt;). </p>

</div>
</div>
<a id="ac3a0bb42e093d46cbd74a0c263c0d61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a0bb42e093d46cbd74a0c263c0d61a">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename Derived::Scalar() &gt; ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using greater-than operator (&gt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a &gt; v)</code> has a symbolic formula <code>a(i, j) &gt; v</code>. </p>

</div>
</div>
<a id="a0e63a21e3a4861f1a6fccbc7667cd298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e63a21e3a4861f1a6fccbc7667cd298">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(ScalarType() &gt; typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than operator (&lt;) instead of greater-than operator (&gt;). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v &gt; a)</code> has a symbolic formula <code>a(i, j) &lt; v</code>.</p>
<p>Note that given <code>v &gt; a</code>, this methods returns the result of <code>a &lt; v</code>. First of all, this formulation is mathematically equivalent to the original formulation. We implement this method in this way to be consistent with Eigen's semantics. See the definition of <code>EIGEN_MAKE_CWISE_COMP_R_OP</code> in ArrayCwiseBinaryOps.h file in Eigen. </p>

</div>
</div>
<a id="ad6112c67bd713407a1da5a46df61f0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6112c67bd713407a1da5a46df61f0ba">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt;::value &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &gt; typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::type drake::symbolic::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using greater-than operator (&gt;). </p>
<p>The following table describes the return type of <code>m1</code> &gt; <code>m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">N/A   </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>. </p>

</div>
</div>
<a id="a642d11dbe47e027614a5a3bcfe12d34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642d11dbe47e027614a5a3bcfe12d34e">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f925205cdf85170720d4cc61ec10991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f925205cdf85170720d4cc61ec10991">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &gt;= typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, typename internal::RelationalOpTraits&lt;DerivedA, DerivedB&gt;::ReturnType&gt;::type drake::symbolic::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison of two arrays <code>a1</code> and <code>a2</code> using greater-than-or-equal operator (&gt;=). </p>

</div>
</div>
<a id="a04b826253c8e91199f4b45732ba4bf2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b826253c8e91199f4b45732ba4bf2b">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename Derived::Scalar() &gt;= ScalarType()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between an array <code>a</code> and a scalar <code>v</code> using greater-than-or-equal operator (&gt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(a &gt;= v)</code> has a symbolic formula <code>a(i, j) &gt;= v</code>. </p>

</div>
</div>
<a id="a405bf4ecc90c0dc8aa47223422d4ed52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405bf4ecc90c0dc8aa47223422d4ed52">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::ArrayXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(ScalarType() &gt;= typename Derived::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, Eigen::Array&lt;<a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt;::type drake::symbolic::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an Eigen array of symbolic formulas where each element includes element-wise comparison between a scalar <code>v</code> and an array <code>using</code> less-than-or-equal operator (&lt;=) instead of greater-than-or-equal operator (&gt;=). </p>
<p>That is, for all i and j, the (i, j)-th entry of <code>(v &gt;= a)</code> has a symbolic formula <code>a(i, j) &lt;= v</code>.</p>
<p>Note that given <code>v &gt;= a</code>, this methods returns the result of <code>a &lt;= v</code>. First of all, this formulation is mathematically equivalent to the original formulation. We implement this method in this way to be consistent with Eigen's semantics. See the definition of <code>EIGEN_MAKE_CWISE_COMP_R_OP</code> in ArrayCwiseBinaryOps.h file in Eigen. </p>

</div>
</div>
<a id="a56de2d077a42329f2c508a71e7e52ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56de2d077a42329f2c508a71e7e52ca9">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedA&gt;::XprKind, Eigen::MatrixXpr&gt;::value &amp;&amp; std::is_same&lt;typename Eigen::internal::traits&lt;DerivedB&gt;::XprKind, Eigen::MatrixXpr&gt;::value &amp;&amp; std::is_same&lt;decltype(typename DerivedA::Scalar() &gt;= typename DerivedB::Scalar()), <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::type drake::symbolic::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const DerivedA &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedB &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula representing element-wise comparison between two matrices <code>m1</code> and <code>m2</code> using greater-than-or-equal operator (&gt;=). </p>
<p>The following table describes the return type of <code>m1</code> &gt;= <code>m2</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">LHS \ RHS  </th><th class="markdownTableHeadNone">EM&lt;Expression&gt;  </th><th class="markdownTableHeadNone">EM&lt;Variable&gt;  </th><th class="markdownTableHeadNone">EM&lt;double&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;Expression&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EM&lt;Variable&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">EM&lt;double&gt;  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html" title="Represents a symbolic form of a first-order logic formula.">Formula</a>  </td><td class="markdownTableBodyNone">N/A   </td></tr>
</table>
<p>In the table, <code>EM</code> is a short-hand of <code>Eigen::Matrix</code>. </p>

</div>
</div>
<a id="a600c585cf975dd9a8dd94b118f0bd161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600c585cf975dd9a8dd94b118f0bd161">&#9670;&nbsp;</a></span>operator||() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac41223d30845a91ba757f6277ad8f8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41223d30845a91ba757f6277ad8f8a1">&#9670;&nbsp;</a></span>operator||() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aafc2f3979d06df08b80d2b280b9728c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc2f3979d06df08b80d2b280b9728c7">&#9670;&nbsp;</a></span>operator||() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a237ee4f068e65a6a4614af59482889eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237ee4f068e65a6a4614af59482889eb">&#9670;&nbsp;</a></span>operator||() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af50e3bc4e34ea64ae4d7065ad1fc72ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50e3bc4e34ea64ae4d7065ad1fc72ac">&#9670;&nbsp;</a></span>PopulateRandomVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> drake::symbolic::PopulateRandomVariables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a>&#160;</td>
          <td class="paramname"><em>env</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variables.html">Variables</a> &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *&#160;</td>
          <td class="paramname"><em>random_generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates the environment <code>env</code> by sampling values for the unassigned random variables in <code>variables</code> using <code>random_generator</code>. </p>

</div>
</div>
<a id="a648f540fa40e1e281133b972e394574a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648f540fa40e1e281133b972e394574a">&#9670;&nbsp;</a></span>positive_semidefinite() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a symbolic formula constraining <code>m</code> to be a positive-semidefinite matrix. </p>
<p>By definition, a symmetric matrix <code>m</code> is positive-semidefinte if xᵀ m x ≥ 0 for all vector x ∈ ℝⁿ.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>m</code> is not symmetric.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method checks if <code>m</code> is symmetric, which can be costly. If you want to avoid it, please consider using <code>positive_semidefinite(m.triangularView&lt;Eigen::Lower&gt;())</code> or <code>positive_semidefinite(m.triangularView&lt;Eigen::Upper&gt;())</code> instead of <code>positive_semidefinite(m)</code>. </dd></dl>

</div>
</div>
<a id="a514b594b37dbb603af40803e175b5f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514b594b37dbb603af40803e175b5f6a">&#9670;&nbsp;</a></span>positive_semidefinite() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> drake::symbolic::positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::UpLoType&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a symbolic positive-semidefinite formula from <code>m</code>. </p>
<p>If <code>mode</code> is Eigen::Lower, it's using the lower-triangular part of <code>m</code> to construct a positive-semidefinite formula. If <code>mode</code> is Eigen::Upper, the upper-triangular part of <code>m</code> is used. It throws std::runtime_error if <code>has</code> other values. See the following code snippet.</p>
<div class="fragment"><div class="line">Eigen::Matrix&lt;Expression, 2, 2&gt; m;</div><div class="line">m &lt;&lt; 1.0, 2.0,</div><div class="line">     3.0, 4.0;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Formula psd_l{<a class="code" href="namespacedrake_1_1symbolic.html#a648f540fa40e1e281133b972e394574a">positive_semidefinite</a>(m, Eigen::Lower)};</div><div class="line"><span class="comment">// psd_l includes [1.0 3.0]</span></div><div class="line"><span class="comment">//                [3.0 4.0].</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> Formula psd_u{<a class="code" href="namespacedrake_1_1symbolic.html#a648f540fa40e1e281133b972e394574a">positive_semidefinite</a>(m, Eigen::Upper)};</div><div class="line"><span class="comment">// psd_u includes [1.0 2.0]</span></div><div class="line"><span class="comment">//                [2.0 4.0].</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a589bce42bdf814187045157a262e8953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589bce42bdf814187045157a262e8953">&#9670;&nbsp;</a></span>positive_semidefinite() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::MatrixXpr&gt;::value &amp;&amp; std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::type drake::symbolic::positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::TriangularView&lt; Derived, Eigen::Lower &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a symbolic positive-semidefinite formula from a lower triangular-view <code>l</code>. </p>
<p>See the following code snippet.</p>
<div class="fragment"><div class="line">Eigen::Matrix&lt;Expression, 2, 2&gt; m;</div><div class="line">m &lt;&lt; 1.0, 2.0,</div><div class="line">     3.0, 4.0;</div><div class="line"></div><div class="line">Formula psd{<a class="code" href="namespacedrake_1_1symbolic.html#a648f540fa40e1e281133b972e394574a">positive_semidefinite</a>(m.triangularView&lt;Eigen::Lower&gt;())};</div><div class="line"><span class="comment">// psd includes [1.0 3.0]</span></div><div class="line"><span class="comment">//              [3.0 4.0].</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a5f8fb394a3d4252968bd22740945fed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8fb394a3d4252968bd22740945fed2">&#9670;&nbsp;</a></span>positive_semidefinite() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;typename Eigen::internal::traits&lt;Derived&gt;::XprKind, Eigen::MatrixXpr&gt;::value &amp;&amp; std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>&gt;::value, <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a>&gt;::type drake::symbolic::positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const Eigen::TriangularView&lt; Derived, Eigen::Upper &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs and returns a symbolic positive-semidefinite formula from an upper triangular-view <code>u</code>. </p>
<p>See the following code snippet.</p>
<div class="fragment"><div class="line">Eigen::Matrix&lt;Expression, 2, 2&gt; m;</div><div class="line">m &lt;&lt; 1.0, 2.0,</div><div class="line">     3.0, 4.0;</div><div class="line"></div><div class="line">Formula psd{<a class="code" href="namespacedrake_1_1symbolic.html#a648f540fa40e1e281133b972e394574a">positive_semidefinite</a>(m.triangularView&lt;Eigen::Upper&gt;())};</div><div class="line"><span class="comment">// psd includes [1.0 2.0]</span></div><div class="line"><span class="comment">//              [2.0 4.0].</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a8b3d409cea5e6c6495394208c8c8c6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3d409cea5e6c6495394208c8c8c6ee">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a> drake::symbolic::pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">Monomial</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>m1</code> raised to <code>p</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>p</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43d86ae3f21714ef199febddf60550fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d86ae3f21714ef199febddf60550fe">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> drake::symbolic::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_rational_function.html">RationalFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rational function <code>f</code> raised to <code>n</code>. </p>
<p>If n is positive, (f/g)ⁿ = fⁿ / gⁿ; If n is negative, (f/g)ⁿ = g⁻ⁿ / f⁻ⁿ; (f/g)⁰ = 1 / 1. </p>

</div>
</div>
<a id="aec1d54669ca8ae5ea474b5904c50e85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1d54669ca8ae5ea474b5904c50e85e">&#9670;&nbsp;</a></span>pow() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a>, double&gt; drake::symbolic::pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html">MonomialBasisElement</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>m</code> raised to <code>p</code>. </p>
<dl class="section note"><dt>Note</dt><dd>that we return a map from the monomial power to its coefficient. This map has size 1, and the coefficient is also 1. We return a map instead of the <a class="el" href="classdrake_1_1symbolic_1_1_monomial_basis_element.html" title="MonomialBasisElement represents a monomial, a product of powers of variables with non-negative intege...">MonomialBasisElement</a> directly, because we want <a class="el" href="namespacedrake_1_1symbolic.html#a3abe49c1083796a8b370bab55535aa72">pow()</a> to have the same return signature as other <a class="el" href="classdrake_1_1symbolic_1_1_polynomial_basis_element.html" title="Each polynomial p(x) can be written as a linear combination of its basis elements p(x) = ∑ᵢ cᵢ * ϕᵢ(x...">PolynomialBasisElement</a>. For example, the power of a <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> object is a weighted sum of <a class="el" href="classdrake_1_1symbolic_1_1_chebyshev_basis_element.html" title="ChebyshevBasisElement represents an element of Chebyshev polynomial basis, written as the product of ...">ChebyshevBasisElement</a> objects. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>p</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fa3b0259a14e44faf2d959f540e9446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa3b0259a14e44faf2d959f540e9446">&#9670;&nbsp;</a></span>pow() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> drake::symbolic::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns polynomial <code>rasied</code> to <code>n</code>. </p>

</div>
</div>
<a id="a3abe49c1083796a8b370bab55535aa72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3abe49c1083796a8b370bab55535aa72">&#9670;&nbsp;</a></span>pow() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90efdc7cf4be8bddc1fa365fb78b8e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90efdc7cf4be8bddc1fa365fb78b8e4a">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96d1119f8ec23bd6d918a984ce5820b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d1119f8ec23bd6d918a984ce5820b9">&#9670;&nbsp;</a></span>sinh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a65a5c97c514e6a5cb74438c6c2f5e760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a5c97c514e6a5cb74438c6c2f5e760">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d9d2f72a70233db108561adf734ecdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9d2f72a70233db108561adf734ecdd">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime&gt; drake::symbolic::Substitute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1symbolic.html#acbfe43d34e6c71c503d4de11da53bbb7">Substitution</a> &amp;&#160;</td>
          <td class="paramname"><em>subst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes a symbolic matrix <code>m</code> using a given substitution <code>subst</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a matrix of symbolic expressions whose size is the size of <code>m</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if NaN is detected during substitution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d45b86ae4b7872576bb3fac8b22ca94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d45b86ae4b7872576bb3fac8b22ca94">&#9670;&nbsp;</a></span>Substitute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a>, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime, 0, Derived::MaxRowsAtCompileTime, Derived::MaxColsAtCompileTime&gt; drake::symbolic::Substitute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitutes <code>var</code> with <code>e</code> in a symbolic matrix <code>m</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a matrix of symbolic expressions whose size is the size of <code>m</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if NaN is detected during substitution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78354ef5dda9c52bbc103d57712c303e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78354ef5dda9c52bbc103d57712c303e">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::symbolic::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9900f71e1c1ceb9d59553adfa2db2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9900f71e1c1ceb9d59553adfa2db2b5">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbb3ea44b1cf2fd877d782b8486d5aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb3ea44b1cf2fd877d782b8486d5aeb">&#9670;&nbsp;</a></span>tanh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed2857d827b306fc80cf6c23e14f211c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2857d827b306fc80cf6c23e14f211c">&#9670;&nbsp;</a></span>TaylorExpand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::TaylorExpand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_environment.html">Environment</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Taylor series expansion of <code>f</code> around <code>a</code> of order <code>order</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Symbolic expression to approximate using Taylor series expansion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Symbolic environment which specifies the point of approximation. If a partial environment is provided, the unspecified variables are treated as symbolic variables (e.g. decision variable). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Positive integer which specifies the maximum order of the resulting polynomial approximating <code>f</code> around <code>a</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1daeae1984840b825c4a2a00bad31ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1daeae1984840b825c4a2a00bad31ac">&#9670;&nbsp;</a></span>to_abs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a>&gt; drake::symbolic::to_abs </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionAbs&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html" title="Symbolic expression representing absolute value function.">ExpressionAbs</a></code>. </dd></dl>

</div>
</div>
<a id="a6681bd6eee8a596b9d010a4374a18026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6681bd6eee8a596b9d010a4374a18026">&#9670;&nbsp;</a></span>to_abs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a>&gt; drake::symbolic::to_abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAbs&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html" title="Symbolic expression representing absolute value function.">ExpressionAbs</a></code>. </dd></dl>

</div>
</div>
<a id="a39b359eaa31c38d5b94b47e2befd7d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b359eaa31c38d5b94b47e2befd7d72">&#9670;&nbsp;</a></span>to_abs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html">ExpressionAbs</a>&gt; drake::symbolic::to_abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionAbs&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_abs.html" title="Symbolic expression representing absolute value function.">ExpressionAbs</a></code>. </dd></dl>

</div>
</div>
<a id="a0ecd824b675e48cb348b880f5023673e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecd824b675e48cb348b880f5023673e">&#9670;&nbsp;</a></span>to_acos() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a>&gt; drake::symbolic::to_acos </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionAcos&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html" title="Symbolic expression representing arccosine function.">ExpressionAcos</a></code>. </dd></dl>

</div>
</div>
<a id="aa12a22a9717c9a2a50245cab09adceec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12a22a9717c9a2a50245cab09adceec">&#9670;&nbsp;</a></span>to_acos() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a>&gt; drake::symbolic::to_acos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAcos&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html" title="Symbolic expression representing arccosine function.">ExpressionAcos</a></code>. </dd></dl>

</div>
</div>
<a id="a8f6734fb6733ffdcb5b084c7b0f19114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6734fb6733ffdcb5b084c7b0f19114">&#9670;&nbsp;</a></span>to_acos() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html">ExpressionAcos</a>&gt; drake::symbolic::to_acos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionAcos&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_acos.html" title="Symbolic expression representing arccosine function.">ExpressionAcos</a></code>. </dd></dl>

</div>
</div>
<a id="a6aee978a40d6518b2821b2c1a91f43b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aee978a40d6518b2821b2c1a91f43b6">&#9670;&nbsp;</a></span>to_addition() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a>&gt; drake::symbolic::to_addition </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionAdd&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html" title="Symbolic expression representing an addition which is a sum of products.">ExpressionAdd</a></code>. </dd></dl>

</div>
</div>
<a id="a0f5cbe2fa0a4c27ba7da0be48683a728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5cbe2fa0a4c27ba7da0be48683a728">&#9670;&nbsp;</a></span>to_addition() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a>&gt; drake::symbolic::to_addition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAdd&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html" title="Symbolic expression representing an addition which is a sum of products.">ExpressionAdd</a></code>. </dd></dl>

</div>
</div>
<a id="aca2448e8f4c4ffb7c764c9b8bdddfbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2448e8f4c4ffb7c764c9b8bdddfbd3">&#9670;&nbsp;</a></span>to_addition() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html">ExpressionAdd</a>&gt; drake::symbolic::to_addition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionAdd&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_add.html" title="Symbolic expression representing an addition which is a sum of products.">ExpressionAdd</a></code>. </dd></dl>

</div>
</div>
<a id="aec94d5786975e5d7a7e1b7946e4fcb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec94d5786975e5d7a7e1b7946e4fcb3f">&#9670;&nbsp;</a></span>to_asin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a>&gt; drake::symbolic::to_asin </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionAsin&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html" title="Symbolic expression representing arcsine function.">ExpressionAsin</a></code>. </dd></dl>

</div>
</div>
<a id="ad623f73697227858e57831d5271f2361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad623f73697227858e57831d5271f2361">&#9670;&nbsp;</a></span>to_asin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a>&gt; drake::symbolic::to_asin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAsin&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html" title="Symbolic expression representing arcsine function.">ExpressionAsin</a></code>. </dd></dl>

</div>
</div>
<a id="a303f958f845f5a16daeea10a72007098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303f958f845f5a16daeea10a72007098">&#9670;&nbsp;</a></span>to_asin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html">ExpressionAsin</a>&gt; drake::symbolic::to_asin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionAsin&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_asin.html" title="Symbolic expression representing arcsine function.">ExpressionAsin</a></code>. </dd></dl>

</div>
</div>
<a id="a4abe6ed64006a6caf5b8ffd016d9d564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4abe6ed64006a6caf5b8ffd016d9d564">&#9670;&nbsp;</a></span>to_atan() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a>&gt; drake::symbolic::to_atan </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionAtan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html" title="Symbolic expression representing arctangent function.">ExpressionAtan</a></code>. </dd></dl>

</div>
</div>
<a id="afd4790cb5947f9d886463912b44dc53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4790cb5947f9d886463912b44dc53f">&#9670;&nbsp;</a></span>to_atan() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a>&gt; drake::symbolic::to_atan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAtan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html" title="Symbolic expression representing arctangent function.">ExpressionAtan</a></code>. </dd></dl>

</div>
</div>
<a id="a5c636513383a9a3ab3f8fd92064932c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c636513383a9a3ab3f8fd92064932c6">&#9670;&nbsp;</a></span>to_atan() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html">ExpressionAtan</a>&gt; drake::symbolic::to_atan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionAtan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan.html" title="Symbolic expression representing arctangent function.">ExpressionAtan</a></code>. </dd></dl>

</div>
</div>
<a id="a7be1d5cbdfe80024dcbf36264504f720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be1d5cbdfe80024dcbf36264504f720">&#9670;&nbsp;</a></span>to_atan2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a>&gt; drake::symbolic::to_atan2 </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionAtan2&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html" title="Symbolic expression representing atan2 function (arctangent function with two arguments).">ExpressionAtan2</a></code>. </dd></dl>

</div>
</div>
<a id="abe7e04a20dd742f4b319659a7bcca24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7e04a20dd742f4b319659a7bcca24f">&#9670;&nbsp;</a></span>to_atan2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a>&gt; drake::symbolic::to_atan2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionAtan2&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html" title="Symbolic expression representing atan2 function (arctangent function with two arguments).">ExpressionAtan2</a></code>. </dd></dl>

</div>
</div>
<a id="a8910f7e2d4fece2b78bb57c45e62b125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8910f7e2d4fece2b78bb57c45e62b125">&#9670;&nbsp;</a></span>to_atan2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html">ExpressionAtan2</a>&gt; drake::symbolic::to_atan2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionAtan2&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_atan2.html" title="Symbolic expression representing atan2 function (arctangent function with two arguments).">ExpressionAtan2</a></code>. </dd></dl>

</div>
</div>
<a id="aee9e480e796a36c2988ef23e83f24a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9e480e796a36c2988ef23e83f24a08">&#9670;&nbsp;</a></span>to_binary() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a>&gt; drake::symbolic::to_binary </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;BinaryExpressionCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html" title="Represents the base class for binary expressions.">BinaryExpressionCell</a></code>. </dd></dl>

</div>
</div>
<a id="a844f455ce08d059f1bd69f2765e22d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844f455ce08d059f1bd69f2765e22d6a">&#9670;&nbsp;</a></span>to_binary() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a>&gt; drake::symbolic::to_binary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const BinaryExpressionCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html" title="Represents the base class for binary expressions.">BinaryExpressionCell</a></code>. </dd></dl>

</div>
</div>
<a id="a5a9a716129fbcdd8a274085e04ca26c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9a716129fbcdd8a274085e04ca26c1">&#9670;&nbsp;</a></span>to_binary() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html">BinaryExpressionCell</a>&gt; drake::symbolic::to_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;BinaryExpressionCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e-&gt;ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_binary_expression_cell.html" title="Represents the base class for binary expressions.">BinaryExpressionCell</a></code>. </dd></dl>

</div>
</div>
<a id="a67b27dc7be5ef0b7ed9d9da76141fd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b27dc7be5ef0b7ed9d9da76141fd06">&#9670;&nbsp;</a></span>to_ceil() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a>&gt; drake::symbolic::to_ceil </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionCeiling&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html" title="Symbolic expression representing ceil function.">ExpressionCeiling</a></code>. </dd></dl>

</div>
</div>
<a id="aa34e2eb22a1480475985c1c893762a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34e2eb22a1480475985c1c893762a4e">&#9670;&nbsp;</a></span>to_ceil() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a>&gt; drake::symbolic::to_ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionCeiling&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html" title="Symbolic expression representing ceil function.">ExpressionCeiling</a></code>. </dd></dl>

</div>
</div>
<a id="a0301c6eb6243d84b5f3a55a65d067e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0301c6eb6243d84b5f3a55a65d067e98">&#9670;&nbsp;</a></span>to_ceil() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html">ExpressionCeiling</a>&gt; drake::symbolic::to_ceil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionCeiling&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_ceiling.html" title="Symbolic expression representing ceil function.">ExpressionCeiling</a></code>. </dd></dl>

</div>
</div>
<a id="a180aa6c7637801b158099a87a59a4185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180aa6c7637801b158099a87a59a4185">&#9670;&nbsp;</a></span>to_conjunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a>&gt; drake::symbolic::to_conjunction </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaAnd&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_conjunction(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a6c7b85f4c856cc5e59afd911c80a1e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7b85f4c856cc5e59afd911c80a1e2a">&#9670;&nbsp;</a></span>to_conjunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_and.html">FormulaAnd</a>&gt; drake::symbolic::to_conjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaAnd&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_conjunction(f)</code> is true. </dd></dl>

</div>
</div>
<a id="af2708aa3cdfbd35a6c8dfdf846102093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2708aa3cdfbd35a6c8dfdf846102093">&#9670;&nbsp;</a></span>to_constant() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html">ExpressionConstant</a>&gt; drake::symbolic::to_constant </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionConstant&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html" title="Symbolic expression representing a constant.">ExpressionConstant</a></code>. </dd></dl>

</div>
</div>
<a id="a61a80e99d12d93faa0ac6d5d7e322f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a80e99d12d93faa0ac6d5d7e322f3b">&#9670;&nbsp;</a></span>to_constant() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html">ExpressionConstant</a>&gt; drake::symbolic::to_constant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionConstant&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html" title="Symbolic expression representing a constant.">ExpressionConstant</a></code>. </dd></dl>

</div>
</div>
<a id="aefe2b1e3ee3c9df2e69bb00df0dee547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe2b1e3ee3c9df2e69bb00df0dee547">&#9670;&nbsp;</a></span>to_constant() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html">ExpressionConstant</a>&gt; drake::symbolic::to_constant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionConstant&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e-&gt;ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_constant.html" title="Symbolic expression representing a constant.">ExpressionConstant</a></code>. </dd></dl>

</div>
</div>
<a id="abacb0e6cb526379b60fd156af4b527cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacb0e6cb526379b60fd156af4b527cf">&#9670;&nbsp;</a></span>to_cos() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a>&gt; drake::symbolic::to_cos </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionCos&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html" title="Symbolic expression representing cosine function.">ExpressionCos</a></code>. </dd></dl>

</div>
</div>
<a id="afdf44cbe131d42d4cca59fd098e62dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf44cbe131d42d4cca59fd098e62dbe">&#9670;&nbsp;</a></span>to_cos() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a>&gt; drake::symbolic::to_cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionCos&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html" title="Symbolic expression representing cosine function.">ExpressionCos</a></code>. </dd></dl>

</div>
</div>
<a id="a7abdc81f10cc7d9c2dad5f809d6d1905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abdc81f10cc7d9c2dad5f809d6d1905">&#9670;&nbsp;</a></span>to_cos() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html">ExpressionCos</a>&gt; drake::symbolic::to_cos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionCos&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_cos.html" title="Symbolic expression representing cosine function.">ExpressionCos</a></code>. </dd></dl>

</div>
</div>
<a id="ae9e124af49dfeefbaecdb2b062413e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e124af49dfeefbaecdb2b062413e40">&#9670;&nbsp;</a></span>to_cosh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a>&gt; drake::symbolic::to_cosh </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionCosh&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html" title="Symbolic expression representing hyperbolic cosine function.">ExpressionCosh</a></code>. </dd></dl>

</div>
</div>
<a id="ab651038b9eb8bfe5e9eee3a972d5e3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab651038b9eb8bfe5e9eee3a972d5e3db">&#9670;&nbsp;</a></span>to_cosh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a>&gt; drake::symbolic::to_cosh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionCosh&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html" title="Symbolic expression representing hyperbolic cosine function.">ExpressionCosh</a></code>. </dd></dl>

</div>
</div>
<a id="a819f238f0c2b84e91a214a85e89920de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819f238f0c2b84e91a214a85e89920de">&#9670;&nbsp;</a></span>to_cosh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html">ExpressionCosh</a>&gt; drake::symbolic::to_cosh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionCosh&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_cosh.html" title="Symbolic expression representing hyperbolic cosine function.">ExpressionCosh</a></code>. </dd></dl>

</div>
</div>
<a id="a0b0758b788047cb3d6b4737c6d54cee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0758b788047cb3d6b4737c6d54cee2">&#9670;&nbsp;</a></span>to_disjunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a>&gt; drake::symbolic::to_disjunction </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaOr&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_disjunction(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a4b3089338cbed9420262519689dbe55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3089338cbed9420262519689dbe55e">&#9670;&nbsp;</a></span>to_disjunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_or.html">FormulaOr</a>&gt; drake::symbolic::to_disjunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaOr&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_disjunction(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a66792167f2936394301f9322b77104f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66792167f2936394301f9322b77104f8">&#9670;&nbsp;</a></span>to_division() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a>&gt; drake::symbolic::to_division </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionDiv&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html" title="Symbolic expression representing division.">ExpressionDiv</a></code>. </dd></dl>

</div>
</div>
<a id="ad26a3824f44065547e3416df989e4d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26a3824f44065547e3416df989e4d3e">&#9670;&nbsp;</a></span>to_division() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a>&gt; drake::symbolic::to_division </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionDiv&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html" title="Symbolic expression representing division.">ExpressionDiv</a></code>. </dd></dl>

</div>
</div>
<a id="ac72af3ed882189fd2f5a48214214fdf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72af3ed882189fd2f5a48214214fdf9">&#9670;&nbsp;</a></span>to_division() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html">ExpressionDiv</a>&gt; drake::symbolic::to_division </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionDiv&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_div.html" title="Symbolic expression representing division.">ExpressionDiv</a></code>. </dd></dl>

</div>
</div>
<a id="a10a6204418091c1fbf26c9d2ad03389f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a6204418091c1fbf26c9d2ad03389f">&#9670;&nbsp;</a></span>to_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a>&gt; drake::symbolic::to_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaEq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a0fd0c45d93c60c6d378d73e4041f6323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd0c45d93c60c6d378d73e4041f6323">&#9670;&nbsp;</a></span>to_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_eq.html">FormulaEq</a>&gt; drake::symbolic::to_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaEq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_equal_to(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a4518fb7cc38ea2cd3efc4a3bead3e82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4518fb7cc38ea2cd3efc4a3bead3e82e">&#9670;&nbsp;</a></span>to_exp() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a> &gt; to_exp </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionExp&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html" title="Symbolic expression representing exponentiation using the base of natural logarithms.">ExpressionExp</a></code>. </dd></dl>

</div>
</div>
<a id="a918dcfa4e1c6bf30473602e582553fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918dcfa4e1c6bf30473602e582553fb7">&#9670;&nbsp;</a></span>to_exp() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a> &gt; to_exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionExp&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html" title="Symbolic expression representing exponentiation using the base of natural logarithms.">ExpressionExp</a></code>. </dd></dl>

</div>
</div>
<a id="a19c2b13ce0db5f3f1bcf93baec1b862d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19c2b13ce0db5f3f1bcf93baec1b862d">&#9670;&nbsp;</a></span>to_exp() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html">ExpressionExp</a> &gt; to_exp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionExp&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_exp.html" title="Symbolic expression representing exponentiation using the base of natural logarithms.">ExpressionExp</a></code>. </dd></dl>

</div>
</div>
<a id="a1ba2673fe37620dcc2a3b06ab7b72bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba2673fe37620dcc2a3b06ab7b72bec">&#9670;&nbsp;</a></span>to_false() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a>&gt; drake::symbolic::to_false </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaFalse&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_false(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="aa798e0006353eec207f3d8949b9dac6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa798e0006353eec207f3d8949b9dac6e">&#9670;&nbsp;</a></span>to_false() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_false.html">FormulaFalse</a>&gt; drake::symbolic::to_false </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaFalse&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_false(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a1ca6d0b50c8894d1c59c94f738a86d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca6d0b50c8894d1c59c94f738a86d8e">&#9670;&nbsp;</a></span>to_floor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a>&gt; drake::symbolic::to_floor </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionFloor&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html" title="Symbolic expression representing floor function.">ExpressionFloor</a></code>. </dd></dl>

</div>
</div>
<a id="ad1c41c2b040c7e7c734456761fa0a34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c41c2b040c7e7c734456761fa0a34f">&#9670;&nbsp;</a></span>to_floor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a>&gt; drake::symbolic::to_floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionFloor&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html" title="Symbolic expression representing floor function.">ExpressionFloor</a></code>. </dd></dl>

</div>
</div>
<a id="adb90175340b5282809d4a3710145e758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb90175340b5282809d4a3710145e758">&#9670;&nbsp;</a></span>to_floor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html">ExpressionFloor</a>&gt; drake::symbolic::to_floor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionFloor&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_floor.html" title="Symbolic expression representing floor function.">ExpressionFloor</a></code>. </dd></dl>

</div>
</div>
<a id="a7c587017789ff28f462e87ba0a44872d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c587017789ff28f462e87ba0a44872d">&#9670;&nbsp;</a></span>to_forall() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a>&gt; drake::symbolic::to_forall </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaForall&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_forall(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a07372c92a7d28a29ffaa9535b083eea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07372c92a7d28a29ffaa9535b083eea6">&#9670;&nbsp;</a></span>to_forall() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_forall.html">FormulaForall</a>&gt; drake::symbolic::to_forall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaForall&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_forall(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a352fe19778d77b7095580950d8e298b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352fe19778d77b7095580950d8e298b4">&#9670;&nbsp;</a></span>to_greater_than() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a>&gt; drake::symbolic::to_greater_than </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaGt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_greater_than(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a8319545722755f981d6c314f7994c469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8319545722755f981d6c314f7994c469">&#9670;&nbsp;</a></span>to_greater_than() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_gt.html">FormulaGt</a>&gt; drake::symbolic::to_greater_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaGt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_greater_than(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a7f8cbb802de92188843f8531d6b05827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8cbb802de92188843f8531d6b05827">&#9670;&nbsp;</a></span>to_greater_than_or_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a>&gt; drake::symbolic::to_greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaGeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_greater_than_or_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a159568e84904a2b16547ca120d8cb879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159568e84904a2b16547ca120d8cb879">&#9670;&nbsp;</a></span>to_greater_than_or_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_geq.html">FormulaGeq</a>&gt; drake::symbolic::to_greater_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaGeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_greater_than_or_equal_to(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a6913fad5224e9e1eab2396bdd20db92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6913fad5224e9e1eab2396bdd20db92b">&#9670;&nbsp;</a></span>to_if_then_else() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a>&gt; drake::symbolic::to_if_then_else </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionIfThenElse&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html" title="Symbolic expression representing if-then-else expression.">ExpressionIfThenElse</a></code>. </dd></dl>

</div>
</div>
<a id="a331dd3f183e945974f4cb1bfee8eb54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331dd3f183e945974f4cb1bfee8eb54f">&#9670;&nbsp;</a></span>to_if_then_else() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a>&gt; drake::symbolic::to_if_then_else </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionIfThenElse&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html" title="Symbolic expression representing if-then-else expression.">ExpressionIfThenElse</a></code>. </dd></dl>

</div>
</div>
<a id="ae8e7c6adb035b5360d0065cd5b1a6e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e7c6adb035b5360d0065cd5b1a6e7b">&#9670;&nbsp;</a></span>to_if_then_else() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html">ExpressionIfThenElse</a>&gt; drake::symbolic::to_if_then_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionIfThenElse&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_if_then_else.html" title="Symbolic expression representing if-then-else expression.">ExpressionIfThenElse</a></code>. </dd></dl>

</div>
</div>
<a id="ad4f46f5ae1e9130eb9214a2ae0611f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f46f5ae1e9130eb9214a2ae0611f52">&#9670;&nbsp;</a></span>to_isnan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a>&gt; drake::symbolic::to_isnan </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaIsnan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_isnan(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a52dbe606b9ecf35f89933db21e9c4f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52dbe606b9ecf35f89933db21e9c4f68">&#9670;&nbsp;</a></span>to_isnan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_isnan.html">FormulaIsnan</a>&gt; drake::symbolic::to_isnan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaIsnan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_isnan(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a7488de67ca4d6bc69cec3bb0f67ae4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7488de67ca4d6bc69cec3bb0f67ae4c3">&#9670;&nbsp;</a></span>to_less_than() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a>&gt; drake::symbolic::to_less_than </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaLt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_less_than(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="ac67a9b87898cca1805eb751adce904e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67a9b87898cca1805eb751adce904e3">&#9670;&nbsp;</a></span>to_less_than() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_lt.html">FormulaLt</a>&gt; drake::symbolic::to_less_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaLt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_less_than(f)</code> is true. </dd></dl>

</div>
</div>
<a id="acfb39c33945b763922fe0fcacc6c369b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb39c33945b763922fe0fcacc6c369b">&#9670;&nbsp;</a></span>to_less_than_or_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a>&gt; drake::symbolic::to_less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaLeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_less_than_or_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a7885122152600db68a8c6219de6a941f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7885122152600db68a8c6219de6a941f">&#9670;&nbsp;</a></span>to_less_than_or_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_leq.html">FormulaLeq</a>&gt; drake::symbolic::to_less_than_or_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaLeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_less_than_or_equal_to(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a42be92856b50af12f40ccffe4a8634da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42be92856b50af12f40ccffe4a8634da">&#9670;&nbsp;</a></span>to_log() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a>&gt; drake::symbolic::to_log </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionLog&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html" title="Symbolic expression representing logarithms.">ExpressionLog</a></code>. </dd></dl>

</div>
</div>
<a id="a47e9c0798e8cd0fb86b8ea9bf0ee1594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e9c0798e8cd0fb86b8ea9bf0ee1594">&#9670;&nbsp;</a></span>to_log() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a>&gt; drake::symbolic::to_log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionLog&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html" title="Symbolic expression representing logarithms.">ExpressionLog</a></code>. </dd></dl>

</div>
</div>
<a id="aab44805086e06cfec55cf7554202eb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab44805086e06cfec55cf7554202eb2e">&#9670;&nbsp;</a></span>to_log() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html">ExpressionLog</a>&gt; drake::symbolic::to_log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionLog&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_log.html" title="Symbolic expression representing logarithms.">ExpressionLog</a></code>. </dd></dl>

</div>
</div>
<a id="ad3ef10c460bfd3356304cfc4ddd45871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ef10c460bfd3356304cfc4ddd45871">&#9670;&nbsp;</a></span>to_max() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a>&gt; drake::symbolic::to_max </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionMax&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html" title="Symbolic expression representing max function.">ExpressionMax</a></code>. </dd></dl>

</div>
</div>
<a id="aca3ef858fc84394fa03779f31117cfc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3ef858fc84394fa03779f31117cfc3">&#9670;&nbsp;</a></span>to_max() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a>&gt; drake::symbolic::to_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionMax&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html" title="Symbolic expression representing max function.">ExpressionMax</a></code>. </dd></dl>

</div>
</div>
<a id="ab2b19c2ecb35334ffe962c6f81928a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b19c2ecb35334ffe962c6f81928a59">&#9670;&nbsp;</a></span>to_max() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html">ExpressionMax</a>&gt; drake::symbolic::to_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionMax&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_max.html" title="Symbolic expression representing max function.">ExpressionMax</a></code>. </dd></dl>

</div>
</div>
<a id="afe59d85af6a0957d2ffedf731cd2c518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe59d85af6a0957d2ffedf731cd2c518">&#9670;&nbsp;</a></span>to_min() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a>&gt; drake::symbolic::to_min </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionMin&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html" title="Symbolic expression representing min function.">ExpressionMin</a></code>. </dd></dl>

</div>
</div>
<a id="a777fe08a1a50861c1dc53b14be414de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777fe08a1a50861c1dc53b14be414de8">&#9670;&nbsp;</a></span>to_min() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a>&gt; drake::symbolic::to_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionMin&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html" title="Symbolic expression representing min function.">ExpressionMin</a></code>. </dd></dl>

</div>
</div>
<a id="a40abc776ecff931414b48d3070d27a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40abc776ecff931414b48d3070d27a6b">&#9670;&nbsp;</a></span>to_min() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html">ExpressionMin</a>&gt; drake::symbolic::to_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionMin&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_min.html" title="Symbolic expression representing min function.">ExpressionMin</a></code>. </dd></dl>

</div>
</div>
<a id="a7cf591075325809961d0975a0bad30a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf591075325809961d0975a0bad30a0">&#9670;&nbsp;</a></span>to_multiplication() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a>&gt; drake::symbolic::to_multiplication </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionMul&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html" title="Symbolic expression representing a multiplication of powers.">ExpressionMul</a></code>. </dd></dl>

</div>
</div>
<a id="a91059e637eb041b04786808c970c0ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91059e637eb041b04786808c970c0ed7">&#9670;&nbsp;</a></span>to_multiplication() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a>&gt; drake::symbolic::to_multiplication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionMul&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html" title="Symbolic expression representing a multiplication of powers.">ExpressionMul</a></code>. </dd></dl>

</div>
</div>
<a id="a572832161aa30d231e6ad34194feb033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572832161aa30d231e6ad34194feb033">&#9670;&nbsp;</a></span>to_multiplication() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html">ExpressionMul</a>&gt; drake::symbolic::to_multiplication </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionMul&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_mul.html" title="Symbolic expression representing a multiplication of powers.">ExpressionMul</a></code>. </dd></dl>

</div>
</div>
<a id="ad0f9249b5c150485c3c7cff61d5c0416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f9249b5c150485c3c7cff61d5c0416">&#9670;&nbsp;</a></span>to_nary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a>&gt; drake::symbolic::to_nary </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const NaryFormulaCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_nary(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a4592d5998754e71a2983829aa1cc18c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4592d5998754e71a2983829aa1cc18c0">&#9670;&nbsp;</a></span>to_nary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_nary_formula_cell.html">NaryFormulaCell</a>&gt; drake::symbolic::to_nary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const NaryFormulaCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_nary(f)</code> is true. </dd></dl>

</div>
</div>
<a id="aceef2c41a1ce6c5f7eed83c1d2df9381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceef2c41a1ce6c5f7eed83c1d2df9381">&#9670;&nbsp;</a></span>to_negation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a>&gt; drake::symbolic::to_negation </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaNot&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_negation(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="acfe394b8aff884d326802f14991f2c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe394b8aff884d326802f14991f2c35">&#9670;&nbsp;</a></span>to_negation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_not.html">FormulaNot</a>&gt; drake::symbolic::to_negation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaNot&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_negation(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a70e880ce60c41c7e65085dbf911edded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e880ce60c41c7e65085dbf911edded">&#9670;&nbsp;</a></span>to_not_equal_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a>&gt; drake::symbolic::to_not_equal_to </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaNeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_not_equal_to(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a489de7c0c27a31969904b3f9a10792f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489de7c0c27a31969904b3f9a10792f3">&#9670;&nbsp;</a></span>to_not_equal_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_neq.html">FormulaNeq</a>&gt; drake::symbolic::to_not_equal_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaNeq&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_not_equal_to(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a6854fa16fb68d99c3cbe16d2c9afc584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6854fa16fb68d99c3cbe16d2c9afc584">&#9670;&nbsp;</a></span>to_positive_semidefinite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a>&gt; drake::symbolic::to_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaPositiveSemidefinite&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_positive_semidefinite(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a6f05196882dfccfb74c47092c2900322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f05196882dfccfb74c47092c2900322">&#9670;&nbsp;</a></span>to_positive_semidefinite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_positive_semidefinite.html">FormulaPositiveSemidefinite</a>&gt; drake::symbolic::to_positive_semidefinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaPositiveSemidefinite&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_positive_semidefinite(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a0bd9338e5ca18182888de1ea5f5da1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd9338e5ca18182888de1ea5f5da1b9">&#9670;&nbsp;</a></span>to_pow() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a>&gt; drake::symbolic::to_pow </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionPow&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html" title="Symbolic expression representing power function.">ExpressionPow</a></code>. </dd></dl>

</div>
</div>
<a id="a2370032c0c398a96e44d7f00008cd566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2370032c0c398a96e44d7f00008cd566">&#9670;&nbsp;</a></span>to_pow() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a>&gt; drake::symbolic::to_pow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionPow&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html" title="Symbolic expression representing power function.">ExpressionPow</a></code>. </dd></dl>

</div>
</div>
<a id="a37ec5117d285c57a7232dc2507c09456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ec5117d285c57a7232dc2507c09456">&#9670;&nbsp;</a></span>to_pow() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html">ExpressionPow</a>&gt; drake::symbolic::to_pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionPow&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_pow.html" title="Symbolic expression representing power function.">ExpressionPow</a></code>. </dd></dl>

</div>
</div>
<a id="a259612bbd9405f24d4ac3b60d54575e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259612bbd9405f24d4ac3b60d54575e6">&#9670;&nbsp;</a></span>to_relational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a>&gt; drake::symbolic::to_relational </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const RelationalFormulaCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_relational(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a5d435fa1f878d87ebaea81f9c30c1c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d435fa1f878d87ebaea81f9c30c1c0c">&#9670;&nbsp;</a></span>to_relational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_relational_formula_cell.html">RelationalFormulaCell</a>&gt; drake::symbolic::to_relational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const RelationalFormulaCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_relational(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a63f0ee9736a5612de981fc34c959b83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f0ee9736a5612de981fc34c959b83a">&#9670;&nbsp;</a></span>to_sin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a>&gt; drake::symbolic::to_sin </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionSin&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html" title="Symbolic expression representing sine function.">ExpressionSin</a></code>. </dd></dl>

</div>
</div>
<a id="a3598b5d3b102aaf9f2bcfd267096c3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3598b5d3b102aaf9f2bcfd267096c3d4">&#9670;&nbsp;</a></span>to_sin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a>&gt; drake::symbolic::to_sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionSin&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html" title="Symbolic expression representing sine function.">ExpressionSin</a></code>. </dd></dl>

</div>
</div>
<a id="a82193c006ad9f4d178f9eca0c3eff288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82193c006ad9f4d178f9eca0c3eff288">&#9670;&nbsp;</a></span>to_sin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html">ExpressionSin</a>&gt; drake::symbolic::to_sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionSin&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_sin.html" title="Symbolic expression representing sine function.">ExpressionSin</a></code>. </dd></dl>

</div>
</div>
<a id="ae97fb68eaad141cc6177a44b2e77135f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97fb68eaad141cc6177a44b2e77135f">&#9670;&nbsp;</a></span>to_sinh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a>&gt; drake::symbolic::to_sinh </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionSinh&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html" title="Symbolic expression representing hyperbolic sine function.">ExpressionSinh</a></code>. </dd></dl>

</div>
</div>
<a id="a10890b71ebe07e3e230460dfaaeaf877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10890b71ebe07e3e230460dfaaeaf877">&#9670;&nbsp;</a></span>to_sinh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a>&gt; drake::symbolic::to_sinh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionSinh&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html" title="Symbolic expression representing hyperbolic sine function.">ExpressionSinh</a></code>. </dd></dl>

</div>
</div>
<a id="a10d369e2ad6befa385e41b0eb350bdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d369e2ad6befa385e41b0eb350bdd3">&#9670;&nbsp;</a></span>to_sinh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html">ExpressionSinh</a>&gt; drake::symbolic::to_sinh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionSinh&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_sinh.html" title="Symbolic expression representing hyperbolic sine function.">ExpressionSinh</a></code>. </dd></dl>

</div>
</div>
<a id="a6ce18aa6183f7c0c9109f6217fed8e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce18aa6183f7c0c9109f6217fed8e69">&#9670;&nbsp;</a></span>to_sqrt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a>&gt; drake::symbolic::to_sqrt </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionSqrt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html" title="Symbolic expression representing square-root.">ExpressionSqrt</a></code>. </dd></dl>

</div>
</div>
<a id="a7d693b2bf5346dc1f4092a1bbc77d790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d693b2bf5346dc1f4092a1bbc77d790">&#9670;&nbsp;</a></span>to_sqrt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a>&gt; drake::symbolic::to_sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionSqrt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html" title="Symbolic expression representing square-root.">ExpressionSqrt</a></code>. </dd></dl>

</div>
</div>
<a id="a9fcfc6237d1d5d86e8d9a36b4bd3a5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fcfc6237d1d5d86e8d9a36b4bd3a5c7">&#9670;&nbsp;</a></span>to_sqrt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html">ExpressionSqrt</a>&gt; drake::symbolic::to_sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionSqrt&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_sqrt.html" title="Symbolic expression representing square-root.">ExpressionSqrt</a></code>. </dd></dl>

</div>
</div>
<a id="af04f9840044b92df4e44eca238c8cd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04f9840044b92df4e44eca238c8cd62">&#9670;&nbsp;</a></span>to_tan() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a>&gt; drake::symbolic::to_tan </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionTan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html" title="Symbolic expression representing tangent function.">ExpressionTan</a></code>. </dd></dl>

</div>
</div>
<a id="ac4f4ed90783040b2bf23b79c781a7594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f4ed90783040b2bf23b79c781a7594">&#9670;&nbsp;</a></span>to_tan() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a>&gt; drake::symbolic::to_tan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionTan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html" title="Symbolic expression representing tangent function.">ExpressionTan</a></code>. </dd></dl>

</div>
</div>
<a id="aff629d72d92c6f5ec6add9800c41267f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff629d72d92c6f5ec6add9800c41267f">&#9670;&nbsp;</a></span>to_tan() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html">ExpressionTan</a>&gt; drake::symbolic::to_tan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionTan&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_tan.html" title="Symbolic expression representing tangent function.">ExpressionTan</a></code>. </dd></dl>

</div>
</div>
<a id="a9539581f8f57306f69ae74a4e2b50a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9539581f8f57306f69ae74a4e2b50a0b">&#9670;&nbsp;</a></span>to_tanh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a>&gt; drake::symbolic::to_tanh </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionTanh&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html" title="Symbolic expression representing hyperbolic tangent function.">ExpressionTanh</a></code>. </dd></dl>

</div>
</div>
<a id="a6d60ce5e8e142a1919eedfd4fbfac7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d60ce5e8e142a1919eedfd4fbfac7b7">&#9670;&nbsp;</a></span>to_tanh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a>&gt; drake::symbolic::to_tanh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionTanh&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html" title="Symbolic expression representing hyperbolic tangent function.">ExpressionTanh</a></code>. </dd></dl>

</div>
</div>
<a id="ae08efb29f84b54b9a3a642e45a147baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08efb29f84b54b9a3a642e45a147baa">&#9670;&nbsp;</a></span>to_tanh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html">ExpressionTanh</a>&gt; drake::symbolic::to_tanh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionTanh&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_tanh.html" title="Symbolic expression representing hyperbolic tangent function.">ExpressionTanh</a></code>. </dd></dl>

</div>
</div>
<a id="a85772f75f073405ed82017151b4cb279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85772f75f073405ed82017151b4cb279">&#9670;&nbsp;</a></span>to_true() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a>&gt; drake::symbolic::to_true </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaTrue&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_true(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a7f183c5bf0f406767e56af9241233ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f183c5bf0f406767e56af9241233ba5">&#9670;&nbsp;</a></span>to_true() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_true.html">FormulaTrue</a>&gt; drake::symbolic::to_true </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaTrue&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_true(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a765d0812ec1409b35dd5a483d6d8e145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765d0812ec1409b35dd5a483d6d8e145">&#9670;&nbsp;</a></span>to_unary() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a>&gt; drake::symbolic::to_unary </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;UnaryExpressionCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html" title="Represents the base class for unary expressions.">UnaryExpressionCell</a></code>. </dd></dl>

</div>
</div>
<a id="ad1501b8c956fb9e788ec6a3b69db7051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1501b8c956fb9e788ec6a3b69db7051">&#9670;&nbsp;</a></span>to_unary() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a>&gt; drake::symbolic::to_unary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const UnaryExpressionCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html" title="Represents the base class for unary expressions.">UnaryExpressionCell</a></code>. </dd></dl>

</div>
</div>
<a id="a2783fd40888e09c46ab6641902488156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2783fd40888e09c46ab6641902488156">&#9670;&nbsp;</a></span>to_unary() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html">UnaryExpressionCell</a>&gt; drake::symbolic::to_unary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;UnaryExpressionCell&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e-&gt;ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_unary_expression_cell.html" title="Represents the base class for unary expressions.">UnaryExpressionCell</a></code>. </dd></dl>

</div>
</div>
<a id="a4de0c0fabeedb18688b94ce9d85a21d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de0c0fabeedb18688b94ce9d85a21d1">&#9670;&nbsp;</a></span>to_uninterpreted_function() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a>&gt; drake::symbolic::to_uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionUninterpretedFunction&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html" title="Symbolic expression representing an uninterpreted function.">ExpressionUninterpretedFunction</a></code>. </dd></dl>

</div>
</div>
<a id="a4faed8e01e77e2e45b88050b550b934e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4faed8e01e77e2e45b88050b550b934e">&#9670;&nbsp;</a></span>to_uninterpreted_function() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a>&gt; drake::symbolic::to_uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionUninterpretedFunction&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html" title="Symbolic expression representing an uninterpreted function.">ExpressionUninterpretedFunction</a></code>. </dd></dl>

</div>
</div>
<a id="ac6363c5c8a48f4960af65936434237c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6363c5c8a48f4960af65936434237c7">&#9670;&nbsp;</a></span>to_uninterpreted_function() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html">ExpressionUninterpretedFunction</a>&gt; drake::symbolic::to_uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionUninterpretedFunction&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_uninterpreted_function.html" title="Symbolic expression representing an uninterpreted function.">ExpressionUninterpretedFunction</a></code>. </dd></dl>

</div>
</div>
<a id="a3b78dde9ca32fe1ee12cc232a9a4e85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b78dde9ca32fe1ee12cc232a9a4e85c">&#9670;&nbsp;</a></span>to_variable() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a>&gt; drake::symbolic::to_variable </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classdrake_1_1symbolic_1_1_formula_cell.html">FormulaCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f_ptr</code> to <code>shared_ptr&lt;const FormulaVar&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_variable(*f_ptr)</code> is true. </dd></dl>

</div>
</div>
<a id="a88cc1d5ad9af2df4592a5e536d1f8191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cc1d5ad9af2df4592a5e536d1f8191">&#9670;&nbsp;</a></span>to_variable() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_formula_var.html">FormulaVar</a>&gt; drake::symbolic::to_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>f</code> to <code>shared_ptr&lt;const FormulaVar&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>is_variable(f)</code> is true. </dd></dl>

</div>
</div>
<a id="a0fb2ff65bada4e39d74027f409d240e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb2ff65bada4e39d74027f409d240e6">&#9670;&nbsp;</a></span>to_variable() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a>&gt; drake::symbolic::to_variable </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression_cell.html">ExpressionCell</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>expr_ptr</code> to <code>shared_ptr&lt;ExpressionVar&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*expr_ptr</code> is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html" title="Symbolic expression representing a variable.">ExpressionVar</a></code>. </dd></dl>

</div>
</div>
<a id="aee3298ef04e0d64a1e1780f4213f626e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3298ef04e0d64a1e1780f4213f626e">&#9670;&nbsp;</a></span>to_variable() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a>&gt; drake::symbolic::to_variable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;const ExpressionVar&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e.ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html" title="Symbolic expression representing a variable.">ExpressionVar</a></code>. </dd></dl>

</div>
</div>
<a id="ac955d0c955ceefc130d72ba1445b77cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac955d0c955ceefc130d72ba1445b77cd">&#9670;&nbsp;</a></span>to_variable() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html">ExpressionVar</a>&gt; drake::symbolic::to_variable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts <code>e</code> to <code>shared_ptr&lt;ExpressionVar&gt;</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*</code>(e-&gt;ptr_) is of <code><a class="el" href="classdrake_1_1symbolic_1_1_expression_var.html" title="Symbolic expression representing a variable.">ExpressionVar</a></code>. </dd></dl>

</div>
</div>
<a id="a986094e62cf81f5b0c1d4f33df8f8e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986094e62cf81f5b0c1d4f33df8f8e3f">&#9670;&nbsp;</a></span>uninterpreted_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> drake::symbolic::uninterpreted_function </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &gt;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an uninterpreted-function expression with <code>name</code> and <code>arguments</code>. </p>
<p>An uninterpreted function is an opaque function that has no other property than its name and a list of its arguments. This is useful to applications where it is good enough to provide abstract information of a function without exposing full details. Declaring sparsity of a system is a typical example. </p>

</div>
</div>
<a id="ab58092344918003fc7e186b1c57bbc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58092344918003fc7e186b1c57bbc7f">&#9670;&nbsp;</a></span>VisitExpression()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result drake::symbolic::VisitExpression </td>
          <td>(</td>
          <td class="paramtype">Visitor *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls visitor object <code>v</code> with a symbolic-expression <code>e</code>, and arguments <code>args</code>. </p>
<p>Visitor object is expected to implement the following methods which take <code>f</code> and <code>args:</code> <code>VisitConstant</code>, <code>VisitVariable</code>, <code>VisitAddition</code>, <code>VisitMultiplication</code>, <code>VisitDivision</code>, <code>VisitLog</code>, <code>VisitAbs</code>, <code>VisitExp</code>, <code>VisitSqrt</code>, <code>VisitPow</code>, <code>VisitSin</code>, <code>VisitCos</code>, <code>VisitTan</code>, <code>VisitAsin</code>, <code>VisitAtan</code>, <code>VisitAtan2</code>, <code>VisitSinh</code>, <code>VisitCosh</code>, <code>VisitTanh</code>, <code>VisitMin</code>, <code>VisitMax</code>, <code>VisitCeil</code>, <code>VisitFloor</code>, <code>VisitIfThenElse</code>, `VisitUninterpretedFunction.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if NaN is detected during a visit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2748b5dc34bc17a6c6e98ac1d0cc1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2748b5dc34bc17a6c6e98ac1d0cc1ad">&#9670;&nbsp;</a></span>VisitFormula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result drake::symbolic::VisitFormula </td>
          <td>(</td>
          <td class="paramtype">Visitor *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_formula.html">Formula</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls visitor object <code>v</code> with a symbolic formula <code>f</code>, and arguments <code>args</code>. </p>
<p>Visitor object is expected to implement the following methods which take <code>f</code> and <code>args:</code> <code>VisitFalse</code>, <code>VisitTrue</code>, <code>VisitVariable</code>, <code>VisitEqualTo</code>, VisitNotEqualTo, VisitGreaterThan, <code>VisitGreaterThanOrEqualTo</code>, <code>VisitLessThan</code>, <code>VisitLessThanOrEqualTo</code>, <code>VisitConjunction</code>, <code>VisitDisjunction</code>, <code>VisitNegation</code>, <code>VisitForall</code>, <code>VisitIsnan</code>, <code>VisitPositiveSemidefinite</code>.</p>
<p>Check the implementation of <code>NegationNormalFormConverter</code> class in drake/common/test/symbolic_formula_visitor_test.cc file to find an example. </p>

</div>
</div>
<a id="a0a61c45c20176e91159639186b26e35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a61c45c20176e91159639186b26e35e">&#9670;&nbsp;</a></span>VisitPolynomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result drake::symbolic::VisitPolynomial </td>
          <td>(</td>
          <td class="paramtype">Visitor *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls visitor object <code>v</code> with a polynomial symbolic-expression <code>e</code>, and arguments <code>args</code>. </p>
<p>Visitor object is expected to implement the following methods which take <code>f</code> and <code>args:</code> <code>VisitConstant</code>, <code>VisitVariable</code>, <code>VisitAddition</code>, <code>VisitMultiplication</code>, <code>VisitDivision</code>, <code>VisitPow</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if NaN is detected during a visit.</td></tr>
  </table>
  </dd>
</dl>
<p>See the implementation of <code>DegreeVisitor</code> class and <code>Degree</code> function in drake/common/symbolic_monomial.cc as an example usage.</p>
<dl class="section pre"><dt>Precondition</dt><dd>e.is_polynomial() is true. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1symbolic.html">symbolic</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
