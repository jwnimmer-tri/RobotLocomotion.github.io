<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Frame&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_frame.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classdrake_1_1multibody_1_1_frame-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Frame&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::multibody::Frame&lt; T &gt;</h3>

<p>Frame is an abstract class representing a <em>material frame</em> (also called a <em>physical frame</em>), meaning that it is associated with a material point of a <a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a>. </p>
<p>A material frame can be used to apply forces and torques to a multibody system, and can be used as an attachment point for force-producing elements like joints, actuators, and constraints. Despite its name, Frame is not the most general frame representation in Drake; see <a class="el" href="classdrake_1_1multibody_1_1_frame_base.html" title="FrameBase is an abstract representation of the concept of a frame in multibody dynamics.">FrameBase</a> for a more-general discussion.</p>
<p>The pose and motion of a Frame object is always calculated relative to the <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html" title="A BodyFrame is a material Frame that serves as the unique reference frame for a Body.">BodyFrame</a> of the body with which it is associated, and every Frame object can report which <a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a> object that is. Concrete classes derived from Frame differ only in how those kinematic properties are calculated. For soft bodies that calculation may depend on the body's deformation state variables. A Frame on a rigid body will usually have a fixed offset from its <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html" title="A BodyFrame is a material Frame that serves as the unique reference frame for a Body.">BodyFrame</a>, but that is not required &ndash; a frame that moves with respect to its <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html" title="A BodyFrame is a material Frame that serves as the unique reference frame for a Body.">BodyFrame</a> can still be a material frame on that rigid body.</p>
<p>As always in Drake, runtime numerical quantities are stored in a Context. A Frame object does not store runtime values, but provides methods for extracting frame-associated values (such as the Frame object's kinematics) from a given Context.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/multibody/tree/multibody_tree.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeb41e2fea35bd8efcbcd67c896bc5766"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#aeb41e2fea35bd8efcbcd67c896bc5766">body</a> () const</td></tr>
<tr class="memdesc:aeb41e2fea35bd8efcbcd67c896bc5766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the body associated to this Frame.  <a href="#aeb41e2fea35bd8efcbcd67c896bc5766">More...</a><br /></td></tr>
<tr class="separator:aeb41e2fea35bd8efcbcd67c896bc5766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d83126860c9766c12c88786177cf22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a64d83126860c9766c12c88786177cf22">is_world_frame</a> () const</td></tr>
<tr class="memdesc:a64d83126860c9766c12c88786177cf22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>this</code> is the world frame.  <a href="#a64d83126860c9766c12c88786177cf22">More...</a><br /></td></tr>
<tr class="separator:a64d83126860c9766c12c88786177cf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6681a8def9431af1311063721c46fe14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a6681a8def9431af1311063721c46fe14">is_body_frame</a> () const</td></tr>
<tr class="memdesc:a6681a8def9431af1311063721c46fe14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>this</code> is the body frame.  <a href="#a6681a8def9431af1311063721c46fe14">More...</a><br /></td></tr>
<tr class="separator:a6681a8def9431af1311063721c46fe14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8227ba86a01f26e4f173cd5e219d5d1"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#ad8227ba86a01f26e4f173cd5e219d5d1">name</a> () const</td></tr>
<tr class="memdesc:ad8227ba86a01f26e4f173cd5e219d5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this frame. It may be empty if unnamed.  <a href="#ad8227ba86a01f26e4f173cd5e219d5d1">More...</a><br /></td></tr>
<tr class="separator:ad8227ba86a01f26e4f173cd5e219d5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823f61b343f8646b35b8035a6a1ee4a9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a823f61b343f8646b35b8035a6a1ee4a9">CalcPoseInBodyFrame</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const =0</td></tr>
<tr class="memdesc:a823f61b343f8646b35b8035a6a1ee4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pose <code>X_BF</code> of <code>this</code> frame F in the body frame B associated with this frame.  <a href="#a823f61b343f8646b35b8035a6a1ee4a9">More...</a><br /></td></tr>
<tr class="separator:a823f61b343f8646b35b8035a6a1ee4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306cd244c02c230ad6642efcdc5ba312"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a306cd244c02c230ad6642efcdc5ba312">CalcRotationMatrixInBodyFrame</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const =0</td></tr>
<tr class="memdesc:a306cd244c02c230ad6642efcdc5ba312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rotation matrix <code>R_BF</code> that relates body frame B to <code>this</code> frame F (B is the body frame to which <code>this</code> frame F is attached).  <a href="#a306cd244c02c230ad6642efcdc5ba312">More...</a><br /></td></tr>
<tr class="separator:a306cd244c02c230ad6642efcdc5ba312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f41fe43f53ca7807f256f0d5daa0734"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a9f41fe43f53ca7807f256f0d5daa0734">GetFixedPoseInBodyFrame</a> () const</td></tr>
<tr class="memdesc:a9f41fe43f53ca7807f256f0d5daa0734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <a class="el" href="classdrake_1_1multibody_1_1_frame.html#a823f61b343f8646b35b8035a6a1ee4a9" title="Returns the pose X_BF of this frame F in the body frame B associated with this frame.">CalcPoseInBodyFrame()</a> that returns the fixed pose <code>X_BF</code> of <code>this</code> frame F in the body frame B associated with this frame.  <a href="#a9f41fe43f53ca7807f256f0d5daa0734">More...</a><br /></td></tr>
<tr class="separator:a9f41fe43f53ca7807f256f0d5daa0734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab645c93960ef7dc30603102c64015644"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#ab645c93960ef7dc30603102c64015644">GetFixedRotationMatrixInBodyFrame</a> () const</td></tr>
<tr class="memdesc:ab645c93960ef7dc30603102c64015644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rotation matrix <code>R_BF</code> that relates body frame B to <code>this</code> frame F (B is the body frame to which <code>this</code> frame F is attached).  <a href="#ab645c93960ef7dc30603102c64015644">More...</a><br /></td></tr>
<tr class="separator:ab645c93960ef7dc30603102c64015644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d48b5a6c31b367eb3fff952fcefe648"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a5d48b5a6c31b367eb3fff952fcefe648">CalcOffsetPoseInBody</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_FQ) const</td></tr>
<tr class="memdesc:a5d48b5a6c31b367eb3fff952fcefe648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the offset pose <code>X_FQ</code> of a frame Q in <code>this</code> frame F, this method computes the pose <code>X_BQ</code> of frame Q in the body frame B to which this frame is attached.  <a href="#a5d48b5a6c31b367eb3fff952fcefe648">More...</a><br /></td></tr>
<tr class="separator:a5d48b5a6c31b367eb3fff952fcefe648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693cd211e3eb5fc7d2ffdaa5af8b3e4a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a693cd211e3eb5fc7d2ffdaa5af8b3e4a">CalcOffsetRotationMatrixInBody</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_FQ) const</td></tr>
<tr class="memdesc:a693cd211e3eb5fc7d2ffdaa5af8b3e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the rotation matrix <code>R_BQ</code> that relates body frame B to frame Q via <code>this</code> intermediate frame F, i.e., <code>R_BQ = R_BF * R_FQ</code> (B is the body frame to which <code>this</code> frame F is attached).  <a href="#a693cd211e3eb5fc7d2ffdaa5af8b3e4a">More...</a><br /></td></tr>
<tr class="separator:a693cd211e3eb5fc7d2ffdaa5af8b3e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a070ee83deb89bd6cca65946a5f8f37"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a4a070ee83deb89bd6cca65946a5f8f37">GetFixedOffsetPoseInBody</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_FQ) const</td></tr>
<tr class="memdesc:a4a070ee83deb89bd6cca65946a5f8f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <a class="el" href="classdrake_1_1multibody_1_1_frame.html#a5d48b5a6c31b367eb3fff952fcefe648" title="Given the offset pose X_FQ of a frame Q in this frame F, this method computes the pose X_BQ of frame ...">CalcOffsetPoseInBody()</a> that given the offset pose <code>X_FQ</code> of a frame Q in <code>this</code> frame F, returns the pose <code>X_BQ</code> of frame Q in the body frame B to which this frame is attached.  <a href="#a4a070ee83deb89bd6cca65946a5f8f37">More...</a><br /></td></tr>
<tr class="separator:a4a070ee83deb89bd6cca65946a5f8f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff50422b2283b8cc9b6560092b80803"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#aaff50422b2283b8cc9b6560092b80803">GetFixedRotationMatrixInBody</a> (const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;R_FQ) const</td></tr>
<tr class="memdesc:aaff50422b2283b8cc9b6560092b80803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the rotation matrix <code>R_BQ</code> that relates body frame B to frame Q via <code>this</code> intermediate frame F, i.e., <code>R_BQ = R_BF * R_FQ</code> (B is the body frame to which <code>this</code> frame F is attached).  <a href="#aaff50422b2283b8cc9b6560092b80803">More...</a><br /></td></tr>
<tr class="separator:aaff50422b2283b8cc9b6560092b80803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83e4f95896da52a0cd6b46dd40853af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#aa83e4f95896da52a0cd6b46dd40853af">CalcPoseInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aa83e4f95896da52a0cd6b46dd40853af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the pose <code>X_WF</code> of <code>this</code> frame F in the world frame W as a function of the state of the model stored in <code>context</code>.  <a href="#aa83e4f95896da52a0cd6b46dd40853af">More...</a><br /></td></tr>
<tr class="separator:aa83e4f95896da52a0cd6b46dd40853af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e6bc147aee91d64b153cbd7cdb5d01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a09e6bc147aee91d64b153cbd7cdb5d01">CalcPose</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_M) const</td></tr>
<tr class="memdesc:a09e6bc147aee91d64b153cbd7cdb5d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the pose <code>X_MF</code> of <code>this</code> frame F in measured in <code>frame_M</code> as a function of the state of the model stored in <code>context</code>.  <a href="#a09e6bc147aee91d64b153cbd7cdb5d01">More...</a><br /></td></tr>
<tr class="separator:a09e6bc147aee91d64b153cbd7cdb5d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19115a9160df4a7936a333684cc26f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#aa19115a9160df4a7936a333684cc26f4">CalcRotationMatrix</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_M) const</td></tr>
<tr class="memdesc:aa19115a9160df4a7936a333684cc26f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the rotation matrix <code>R_MF</code> that relates <code>frame_M</code> and <code>this</code> frame F as a function of the state stored in <code>context</code>.  <a href="#aa19115a9160df4a7936a333684cc26f4">More...</a><br /></td></tr>
<tr class="separator:aa19115a9160df4a7936a333684cc26f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6b793a9b933ba18d670f763ca90eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a8d6b793a9b933ba18d670f763ca90eb4">CalcRotationMatrixInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a8d6b793a9b933ba18d670f763ca90eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns the rotation matrix <code>R_WF</code> that relates the world frame W and <code>this</code> frame F as a function of the state stored in <code>context</code>.  <a href="#a8d6b793a9b933ba18d670f763ca90eb4">More...</a><br /></td></tr>
<tr class="separator:a8d6b793a9b933ba18d670f763ca90eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e26d78710628e036f86e991d3434d4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a2e26d78710628e036f86e991d3434d4b">CalcSpatialVelocityInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a2e26d78710628e036f86e991d3434d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the spatial velocity <code>V_WF</code> of <code>this</code> frame F in the world frame W as a function of the state of the model stored in <code>context</code>.  <a href="#a2e26d78710628e036f86e991d3434d4b">More...</a><br /></td></tr>
<tr class="separator:a2e26d78710628e036f86e991d3434d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebfd42eb5a5a2b1ff8c5d5686359f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#afebfd42eb5a5a2b1ff8c5d5686359f77">CalcSpatialVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_M, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E) const</td></tr>
<tr class="memdesc:afebfd42eb5a5a2b1ff8c5d5686359f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the spatial velocity <code>V_MF_E</code> of <code>this</code> frame F measured in <code>frame_M</code> and expressed in <code>frame_E</code> as a function of the state of the model stored in <code>context</code>.  <a href="#afebfd42eb5a5a2b1ff8c5d5686359f77">More...</a><br /></td></tr>
<tr class="separator:afebfd42eb5a5a2b1ff8c5d5686359f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c96f5b61a2a9047007f24f74b2ad63f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a2c96f5b61a2a9047007f24f74b2ad63f">CalcSpatialAccelerationInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a2c96f5b61a2a9047007f24f74b2ad63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the spatial acceleration A_WF_W of <code>this</code> frame F in world frame W expressed in W as a function of the state stored in context.  <a href="#a2c96f5b61a2a9047007f24f74b2ad63f">More...</a><br /></td></tr>
<tr class="separator:a2c96f5b61a2a9047007f24f74b2ad63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72750ba8b4de6270d8625462a7453e85"><td class="memTemplParams" colspan="2">template&lt;typename ToScalar &gt; </td></tr>
<tr class="memitem:a72750ba8b4de6270d8625462a7453e85"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; ToScalar &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a72750ba8b4de6270d8625462a7453e85">CloneToScalar</a> (const internal::MultibodyTree&lt; ToScalar &gt; &amp;tree_clone) const</td></tr>
<tr class="memdesc:a72750ba8b4de6270d8625462a7453e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) NVI to <a class="el" href="classdrake_1_1multibody_1_1_frame.html#a0162ba098d0c07be12d3a7244914de38" title="Clones this Frame (templated on T) to a frame templated on double.">DoCloneToScalar()</a> templated on the scalar type of the new clone to be created.  <a href="#a72750ba8b4de6270d8625462a7453e85">More...</a><br /></td></tr>
<tr class="separator:a72750ba8b4de6270d8625462a7453e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a921f7998dbc51e8b4298b1fbb2369686"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a921f7998dbc51e8b4298b1fbb2369686">Frame</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a> &amp;)=delete</td></tr>
<tr class="separator:a921f7998dbc51e8b4298b1fbb2369686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e197bedf7aa897596ace36baca53361"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a8e197bedf7aa897596ace36baca53361">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a> &amp;)=delete</td></tr>
<tr class="separator:a8e197bedf7aa897596ace36baca53361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced939d5919bf90594d6821ab9bf0fb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#aced939d5919bf90594d6821ab9bf0fb8">Frame</a> (<a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aced939d5919bf90594d6821ab9bf0fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486765b5bb3145d29946d6dae95a9332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a486765b5bb3145d29946d6dae95a9332">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a486765b5bb3145d29946d6dae95a9332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdrake_1_1multibody_1_1_multibody_element')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html">MultibodyElement&lt; FrameBase, T, FrameIndex &gt;</a></td></tr>
<tr class="memitem:a1703fe23765583a9ceb91bfba1adc896 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a1703fe23765583a9ceb91bfba1adc896">~MultibodyElement</a> ()</td></tr>
<tr class="separator:a1703fe23765583a9ceb91bfba1adc896 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab10b1c612e1455976fc9e71c4ba7df6 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#aab10b1c612e1455976fc9e71c4ba7df6">index</a> () const</td></tr>
<tr class="memdesc:aab10b1c612e1455976fc9e71c4ba7df6 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this element's unique index.  <a href="classdrake_1_1multibody_1_1_multibody_element.html#aab10b1c612e1455976fc9e71c4ba7df6">More...</a><br /></td></tr>
<tr class="separator:aab10b1c612e1455976fc9e71c4ba7df6 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2192bbd60e8c8d2c14763041d66d50 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#acd2192bbd60e8c8d2c14763041d66d50">model_instance</a> () const</td></tr>
<tr class="memdesc:acd2192bbd60e8c8d2c14763041d66d50 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ModelInstanceIndex of the model instance to which this element belongs.  <a href="classdrake_1_1multibody_1_1_multibody_element.html#acd2192bbd60e8c8d2c14763041d66d50">More...</a><br /></td></tr>
<tr class="separator:acd2192bbd60e8c8d2c14763041d66d50 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310da1a776ff08627f2f658ff2a6da11 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memItemLeft" align="right" valign="top">const MultibodyPlantDeferred &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a310da1a776ff08627f2f658ff2a6da11">GetParentPlant</a> () const</td></tr>
<tr class="memdesc:a310da1a776ff08627f2f658ff2a6da11 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MultibodyPlant that owns this MultibodyElement.  <a href="classdrake_1_1multibody_1_1_multibody_element.html#a310da1a776ff08627f2f658ff2a6da11">More...</a><br /></td></tr>
<tr class="separator:a310da1a776ff08627f2f658ff2a6da11 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d506f577f85b2c7c49a678007ef2f8b inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a2d506f577f85b2c7c49a678007ef2f8b">MultibodyElement</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html">MultibodyElement</a> &amp;)=delete</td></tr>
<tr class="separator:a2d506f577f85b2c7c49a678007ef2f8b inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8659b2212916d36167001616643398f1 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a8659b2212916d36167001616643398f1">MultibodyElement</a> (<a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html">MultibodyElement</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a8659b2212916d36167001616643398f1 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e4f9cb97baf94b1cdc26585e2e1e3c inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html">MultibodyElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a47e4f9cb97baf94b1cdc26585e2e1e3c">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html">MultibodyElement</a> &amp;)=delete</td></tr>
<tr class="separator:a47e4f9cb97baf94b1cdc26585e2e1e3c inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d3ff54398a47f3c1e9ce9b4fb2e120 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html">MultibodyElement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#ac7d3ff54398a47f3c1e9ce9b4fb2e120">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html">MultibodyElement</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ac7d3ff54398a47f3c1e9ce9b4fb2e120 inherit pub_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8a0a86b14a720059603e2529def64353"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a8a0a86b14a720059603e2529def64353">Frame</a> (const std::string &amp;<a class="el" href="classdrake_1_1multibody_1_1_frame.html#ad8227ba86a01f26e4f173cd5e219d5d1">name</a>, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;<a class="el" href="classdrake_1_1multibody_1_1_frame.html#aeb41e2fea35bd8efcbcd67c896bc5766">body</a>, std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#acd2192bbd60e8c8d2c14763041d66d50">model_instance</a>={})</td></tr>
<tr class="memdesc:a8a0a86b14a720059603e2529def64353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only derived classes can use this constructor.  <a href="#a8a0a86b14a720059603e2529def64353">More...</a><br /></td></tr>
<tr class="separator:a8a0a86b14a720059603e2529def64353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930d3e9d3ee5044dde9f4aaaec16b78a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a930d3e9d3ee5044dde9f4aaaec16b78a">Frame</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;<a class="el" href="classdrake_1_1multibody_1_1_frame.html#aeb41e2fea35bd8efcbcd67c896bc5766">body</a>)</td></tr>
<tr class="memdesc:a930d3e9d3ee5044dde9f4aaaec16b78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload to permit constructing an unnamed frame.  <a href="#a930d3e9d3ee5044dde9f4aaaec16b78a">More...</a><br /></td></tr>
<tr class="separator:a930d3e9d3ee5044dde9f4aaaec16b78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods to make a clone templated on different scalar types.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are meant to be called by MultibodyTree::CloneToScalar() when making a clone of the entire tree or a new instance templated on a different scalar type.</p>
<p>The only const argument to these methods is the new MultibodyTree clone under construction. Specific Frame subclasses might specify a number of prerequisites on the cloned tree and therefore require it to be at a given state of cloning. See MultibodyTree::CloneToScalar() for a list of prerequisites that are guaranteed to be satisfied during the cloning process. </p>
</div></td></tr>
<tr class="memitem:a0162ba098d0c07be12d3a7244914de38"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a0162ba098d0c07be12d3a7244914de38">DoCloneToScalar</a> (const internal::MultibodyTree&lt; double &gt; &amp;tree_clone) const =0</td></tr>
<tr class="memdesc:a0162ba098d0c07be12d3a7244914de38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this Frame (templated on T) to a frame templated on <code>double</code>.  <a href="#a0162ba098d0c07be12d3a7244914de38">More...</a><br /></td></tr>
<tr class="separator:a0162ba098d0c07be12d3a7244914de38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652a1d7c4d9d502fffcec5b9d27dd3ec"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a652a1d7c4d9d502fffcec5b9d27dd3ec">DoCloneToScalar</a> (const internal::MultibodyTree&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &amp;tree_clone) const =0</td></tr>
<tr class="memdesc:a652a1d7c4d9d502fffcec5b9d27dd3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this Frame (templated on T) to a frame templated on AutoDiffXd.  <a href="#a652a1d7c4d9d502fffcec5b9d27dd3ec">More...</a><br /></td></tr>
<tr class="separator:a652a1d7c4d9d502fffcec5b9d27dd3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a1267a3cceabc6d0bec7768cd6f2c7"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a21a1267a3cceabc6d0bec7768cd6f2c7">DoCloneToScalar</a> (const internal::MultibodyTree&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;) const =0</td></tr>
<tr class="separator:a21a1267a3cceabc6d0bec7768cd6f2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1multibody_1_1_frame_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classdrake_1_1multibody_1_1_frame_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classdrake_1_1multibody_1_1_frame_base.html">FrameBase&lt; T &gt;</a></td></tr>
<tr class="memitem:a5230206d73958e479e1f2d7ce463557b inherit pro_methods_classdrake_1_1multibody_1_1_frame_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_frame_base.html#a5230206d73958e479e1f2d7ce463557b">FrameBase</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#acd2192bbd60e8c8d2c14763041d66d50">model_instance</a>)</td></tr>
<tr class="separator:a5230206d73958e479e1f2d7ce463557b inherit pro_methods_classdrake_1_1multibody_1_1_frame_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classdrake_1_1multibody_1_1_multibody_element')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html">MultibodyElement&lt; FrameBase, T, FrameIndex &gt;</a></td></tr>
<tr class="memitem:a7b561934ea4adacae196c9f85cfa6f13 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a7b561934ea4adacae196c9f85cfa6f13">MultibodyElement</a> ()</td></tr>
<tr class="memdesc:a7b561934ea4adacae196c9f85cfa6f13 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor made protected so that sub-classes can still declare their default constructors if they need to.  <a href="classdrake_1_1multibody_1_1_multibody_element.html#a7b561934ea4adacae196c9f85cfa6f13">More...</a><br /></td></tr>
<tr class="separator:a7b561934ea4adacae196c9f85cfa6f13 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a912f1fd024549f45d6197eadc30e48 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a5a912f1fd024549f45d6197eadc30e48">MultibodyElement</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#acd2192bbd60e8c8d2c14763041d66d50">model_instance</a>)</td></tr>
<tr class="memdesc:a5a912f1fd024549f45d6197eadc30e48 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which allows specifying a model instance.  <a href="classdrake_1_1multibody_1_1_multibody_element.html#a5a912f1fd024549f45d6197eadc30e48">More...</a><br /></td></tr>
<tr class="separator:a5a912f1fd024549f45d6197eadc30e48 inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf452ebe0b6b98c3ee73e04b6963feba inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memItemLeft" align="right" valign="top">const internal::MultibodyTree&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#acf452ebe0b6b98c3ee73e04b6963feba">get_parent_tree</a> () const</td></tr>
<tr class="memdesc:acf452ebe0b6b98c3ee73e04b6963feba inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the parent MultibodyTree that owns this element.  <a href="classdrake_1_1multibody_1_1_multibody_element.html#acf452ebe0b6b98c3ee73e04b6963feba">More...</a><br /></td></tr>
<tr class="separator:acf452ebe0b6b98c3ee73e04b6963feba inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e3e034aa4ff8fbfc3ae70b96923ccb inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#a68e3e034aa4ff8fbfc3ae70b96923ccb">SetTopology</a> (const internal::MultibodyTreeTopology &amp;tree)</td></tr>
<tr class="memdesc:a68e3e034aa4ff8fbfc3ae70b96923ccb inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives MultibodyElement-derived objects the opportunity to retrieve their topology after MultibodyTree::Finalize() is invoked.  <a href="classdrake_1_1multibody_1_1_multibody_element.html#a68e3e034aa4ff8fbfc3ae70b96923ccb">More...</a><br /></td></tr>
<tr class="separator:a68e3e034aa4ff8fbfc3ae70b96923ccb inherit pro_methods_classdrake_1_1multibody_1_1_multibody_element"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a921f7998dbc51e8b4298b1fbb2369686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921f7998dbc51e8b4298b1fbb2369686">&#9670;&nbsp;</a></span>Frame() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aced939d5919bf90594d6821ab9bf0fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced939d5919bf90594d6821ab9bf0fb8">&#9670;&nbsp;</a></span>Frame() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a0a86b14a720059603e2529def64353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0a86b14a720059603e2529def64353">&#9670;&nbsp;</a></span>Frame() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt;&#160;</td>
          <td class="paramname"><em>model_instance</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only derived classes can use this constructor. </p>
<p>It creates a Frame object attached to <code>body</code> and puts the frame in the body's model instance. </p>

</div>
</div>
<a id="a930d3e9d3ee5044dde9f4aaaec16b78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930d3e9d3ee5044dde9f4aaaec16b78a">&#9670;&nbsp;</a></span>Frame() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload to permit constructing an unnamed frame. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeb41e2fea35bd8efcbcd67c896bc5766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb41e2fea35bd8efcbcd67c896bc5766">&#9670;&nbsp;</a></span>body()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;&amp; body </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reference to the body associated to this Frame. </p>

</div>
</div>
<a id="a5d48b5a6c31b367eb3fff952fcefe648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d48b5a6c31b367eb3fff952fcefe648">&#9670;&nbsp;</a></span>CalcOffsetPoseInBody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;T&gt; CalcOffsetPoseInBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_FQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the offset pose <code>X_FQ</code> of a frame Q in <code>this</code> frame F, this method computes the pose <code>X_BQ</code> of frame Q in the body frame B to which this frame is attached. </p>
<p>In other words, if the pose of <code>this</code> frame F in the body frame B is <code>X_BF</code>, this method computes the pose <code>X_BQ</code> of frame Q in the body frame B as <code>X_BQ = X_BF * X_FQ</code>. In particular, if <code>this</code> <b>is</b><code>the body frame B, i.e.</code>X_BF<code>is the identity transformation, this method directly returns</code>X_FQ`. Specific frame subclasses can override this method to provide faster implementations if needed. </p>

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#a359a32149ff74ea25f4f381533bf67de">BodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#a359a32149ff74ea25f4f381533bf67de">BodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a693cd211e3eb5fc7d2ffdaa5af8b3e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693cd211e3eb5fc7d2ffdaa5af8b3e4a">&#9670;&nbsp;</a></span>CalcOffsetRotationMatrixInBody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt;T&gt; CalcOffsetRotationMatrixInBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the rotation matrix <code>R_BQ</code> that relates body frame B to frame Q via <code>this</code> intermediate frame F, i.e., <code>R_BQ = R_BF * R_FQ</code> (B is the body frame to which <code>this</code> frame F is attached). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_FQ</td><td>rotation matrix that relates frame F to frame Q. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#a435e455a5023bdbaef4f38d4c6ed1c76">BodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#a435e455a5023bdbaef4f38d4c6ed1c76">BodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a09e6bc147aee91d64b153cbd7cdb5d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e6bc147aee91d64b153cbd7cdb5d01">&#9670;&nbsp;</a></span>CalcPose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;T&gt; CalcPose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the pose <code>X_MF</code> of <code>this</code> frame F in measured in <code>frame_M</code> as a function of the state of the model stored in <code>context</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_frame.html#aa83e4f95896da52a0cd6b46dd40853af" title="Computes and returns the pose X_WF of this frame F in the world frame W as a function of the state of...">CalcPoseInWorld()</a>. </dd></dl>

</div>
</div>
<a id="a823f61b343f8646b35b8035a6a1ee4a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823f61b343f8646b35b8035a6a1ee4a9">&#9670;&nbsp;</a></span>CalcPoseInBodyFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;T&gt; CalcPoseInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pose <code>X_BF</code> of <code>this</code> frame F in the body frame B associated with this frame. </p>
<p>In particular, if <code>this</code> <b>is</b> the body frame B, this method directly returns the identity transformation. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#a9f65e5386fde2dfee6fd8e3991143dd0">FixedOffsetFrame&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#af545520bafbd67a7e6c8b3c0bf4aae6f">BodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#af545520bafbd67a7e6c8b3c0bf4aae6f">BodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="aa83e4f95896da52a0cd6b46dd40853af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83e4f95896da52a0cd6b46dd40853af">&#9670;&nbsp;</a></span>CalcPoseInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;T&gt; CalcPoseInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the pose <code>X_WF</code> of <code>this</code> frame F in the world frame W as a function of the state of the model stored in <code>context</code>. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_body.html#adb15f7a08a083af61068735632ada406" title="Returns the pose X_WB of this body B in the world frame W as a function of the state of the model sto...">Body::EvalPoseInWorld()</a> provides a more efficient way to obtain the pose for a body frame. </dd></dl>

</div>
</div>
<a id="aa19115a9160df4a7936a333684cc26f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19115a9160df4a7936a333684cc26f4">&#9670;&nbsp;</a></span>CalcRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt;T&gt; CalcRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates and returns the rotation matrix <code>R_MF</code> that relates <code>frame_M</code> and <code>this</code> frame F as a function of the state stored in <code>context</code>. </p>

</div>
</div>
<a id="a306cd244c02c230ad6642efcdc5ba312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306cd244c02c230ad6642efcdc5ba312">&#9670;&nbsp;</a></span>CalcRotationMatrixInBodyFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt;T&gt; CalcRotationMatrixInBodyFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rotation matrix <code>R_BF</code> that relates body frame B to <code>this</code> frame F (B is the body frame to which <code>this</code> frame F is attached). </p>
<dl class="section note"><dt>Note</dt><dd>If <code>this</code> is B, this method returns the identity RotationMatrix. </dd></dl>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#ad8032074837c5573af1b34f7bef6efc7">FixedOffsetFrame&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#a5f1f8d35fd236710bc6fde286f4c7946">BodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#a5f1f8d35fd236710bc6fde286f4c7946">BodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a8d6b793a9b933ba18d670f763ca90eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6b793a9b933ba18d670f763ca90eb4">&#9670;&nbsp;</a></span>CalcRotationMatrixInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt;T&gt; CalcRotationMatrixInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates and returns the rotation matrix <code>R_WF</code> that relates the world frame W and <code>this</code> frame F as a function of the state stored in <code>context</code>. </p>

</div>
</div>
<a id="a2c96f5b61a2a9047007f24f74b2ad63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c96f5b61a2a9047007f24f74b2ad63f">&#9670;&nbsp;</a></span>CalcSpatialAccelerationInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt;T&gt; CalcSpatialAccelerationInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the spatial acceleration A_WF_W of <code>this</code> frame F in world frame W expressed in W as a function of the state stored in context. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_body.html#a87451694c9fdf67303c1550f11bdf3c2" title="Returns A_WB_W, the spatial acceleration of this body B in the world frame W expressed in frame W as ...">Body::EvalSpatialAccelerationInWorld()</a> provides a more efficient way to obtain the spatial acceleration for a body frame. </dd>
<dd>
When cached values are out of sync with the state stored in context, this method performs an expensive forward dynamics computation, whereas once evaluated, successive calls to this method are inexpensive. </dd></dl>

</div>
</div>
<a id="afebfd42eb5a5a2b1ff8c5d5686359f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afebfd42eb5a5a2b1ff8c5d5686359f77">&#9670;&nbsp;</a></span>CalcSpatialVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt;T&gt; CalcSpatialVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the spatial velocity <code>V_MF_E</code> of <code>this</code> frame F measured in <code>frame_M</code> and expressed in <code>frame_E</code> as a function of the state of the model stored in <code>context</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_frame.html#a2e26d78710628e036f86e991d3434d4b" title="Computes and returns the spatial velocity V_WF of this frame F in the world frame W as a function of ...">CalcSpatialVelocityInWorld()</a>. </dd></dl>

</div>
</div>
<a id="a2e26d78710628e036f86e991d3434d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e26d78710628e036f86e991d3434d4b">&#9670;&nbsp;</a></span>CalcSpatialVelocityInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt;T&gt; CalcSpatialVelocityInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the spatial velocity <code>V_WF</code> of <code>this</code> frame F in the world frame W as a function of the state of the model stored in <code>context</code>. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_body.html#a9c07832f25dde3f8403e98c73dd24d1b" title="Returns the spatial velocity V_WB of this body B in the world frame W as a function of the state of t...">Body::EvalSpatialVelocityInWorld()</a> provides a more efficient way to obtain the spatial velocity for a body frame. </dd></dl>

</div>
</div>
<a id="a72750ba8b4de6270d8625462a7453e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72750ba8b4de6270d8625462a7453e85">&#9670;&nbsp;</a></span>CloneToScalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;ToScalar&gt; &gt; CloneToScalar </td>
          <td>(</td>
          <td class="paramtype">const internal::MultibodyTree&lt; ToScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree_clone</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) NVI to <a class="el" href="classdrake_1_1multibody_1_1_frame.html#a0162ba098d0c07be12d3a7244914de38" title="Clones this Frame (templated on T) to a frame templated on double.">DoCloneToScalar()</a> templated on the scalar type of the new clone to be created. </p>
<p>This method is mostly intended to be called by MultibodyTree::CloneToScalar(). Most users should not call this clone method directly but rather clone the entire parent MultibodyTree if needed. </p><dl class="section see"><dt>See also</dt><dd>MultibodyTree::CloneToScalar() </dd></dl>

</div>
</div>
<a id="a0162ba098d0c07be12d3a7244914de38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0162ba098d0c07be12d3a7244914de38">&#9670;&nbsp;</a></span>DoCloneToScalar() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;double&gt; &gt; DoCloneToScalar </td>
          <td>(</td>
          <td class="paramtype">const internal::MultibodyTree&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree_clone</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones this Frame (templated on T) to a frame templated on <code>double</code>. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#a5bbfff93bcd19af35f85733af71224f7">FixedOffsetFrame&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#a5bbfff93bcd19af35f85733af71224f7">BodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#a5bbfff93bcd19af35f85733af71224f7">BodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a652a1d7c4d9d502fffcec5b9d27dd3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652a1d7c4d9d502fffcec5b9d27dd3ec">&#9670;&nbsp;</a></span>DoCloneToScalar() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;<a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a>&gt; &gt; DoCloneToScalar </td>
          <td>(</td>
          <td class="paramtype">const internal::MultibodyTree&lt; <a class="el" href="namespacedrake.html#a35725b277b02aeb79f24fd7f724e6dbc">AutoDiffXd</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree_clone</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones this Frame (templated on T) to a frame templated on AutoDiffXd. </p>

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#acd3092c461ef2339ba51209fcf41bdbe">FixedOffsetFrame&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#acd3092c461ef2339ba51209fcf41bdbe">BodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#acd3092c461ef2339ba51209fcf41bdbe">BodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a21a1267a3cceabc6d0bec7768cd6f2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a1267a3cceabc6d0bec7768cd6f2c7">&#9670;&nbsp;</a></span>DoCloneToScalar() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt; &gt; DoCloneToScalar </td>
          <td>(</td>
          <td class="paramtype">const internal::MultibodyTree&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#aed0eeb663f377076dab1ae0ab44be5aa">FixedOffsetFrame&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#aed0eeb663f377076dab1ae0ab44be5aa">BodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#aed0eeb663f377076dab1ae0ab44be5aa">BodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a4a070ee83deb89bd6cca65946a5f8f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a070ee83deb89bd6cca65946a5f8f37">&#9670;&nbsp;</a></span>GetFixedOffsetPoseInBody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;T&gt; GetFixedOffsetPoseInBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_FQ</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variant of <a class="el" href="classdrake_1_1multibody_1_1_frame.html#a5d48b5a6c31b367eb3fff952fcefe648" title="Given the offset pose X_FQ of a frame Q in this frame F, this method computes the pose X_BQ of frame ...">CalcOffsetPoseInBody()</a> that given the offset pose <code>X_FQ</code> of a frame Q in <code>this</code> frame F, returns the pose <code>X_BQ</code> of frame Q in the body frame B to which this frame is attached. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if called on a Frame that does not have a fixed offset in the body frame. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#a210c46de44edae60f004ed525d2d018f">BodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#a210c46de44edae60f004ed525d2d018f">BodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a9f41fe43f53ca7807f256f0d5daa0734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f41fe43f53ca7807f256f0d5daa0734">&#9670;&nbsp;</a></span>GetFixedPoseInBodyFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;T&gt; GetFixedPoseInBodyFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Variant of <a class="el" href="classdrake_1_1multibody_1_1_frame.html#a823f61b343f8646b35b8035a6a1ee4a9" title="Returns the pose X_BF of this frame F in the body frame B associated with this frame.">CalcPoseInBodyFrame()</a> that returns the fixed pose <code>X_BF</code> of <code>this</code> frame F in the body frame B associated with this frame. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if called on a Frame that does not have a fixed offset in the body frame. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#a85ed93e3f60b6b39558dfcc087442495">FixedOffsetFrame&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#a85ed93e3f60b6b39558dfcc087442495">BodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#a85ed93e3f60b6b39558dfcc087442495">BodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="aaff50422b2283b8cc9b6560092b80803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff50422b2283b8cc9b6560092b80803">&#9670;&nbsp;</a></span>GetFixedRotationMatrixInBody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt;T&gt; GetFixedRotationMatrixInBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R_FQ</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and returns the rotation matrix <code>R_BQ</code> that relates body frame B to frame Q via <code>this</code> intermediate frame F, i.e., <code>R_BQ = R_BF * R_FQ</code> (B is the body frame to which <code>this</code> frame F is attached). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R_FQ</td><td>rotation matrix that relates frame F to frame Q. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>this</code> frame F is a Frame that does not have a fixed offset in the body frame B (i.e., <code>R_BF</code> is not constant). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#abb66ebf40df1ef9fb2d4347e84a9ab2f">BodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#abb66ebf40df1ef9fb2d4347e84a9ab2f">BodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="ab645c93960ef7dc30603102c64015644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab645c93960ef7dc30603102c64015644">&#9670;&nbsp;</a></span>GetFixedRotationMatrixInBodyFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt;T&gt; GetFixedRotationMatrixInBodyFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rotation matrix <code>R_BF</code> that relates body frame B to <code>this</code> frame F (B is the body frame to which <code>this</code> frame F is attached). </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if <code>this</code> frame F is a Frame that does not have a fixed offset in the body frame B (i.e., <code>R_BF</code> is not constant). Frame sub-classes that have a constant <code>R_BF</code> must override this method. An example of a frame sub-class not implementing this method would be that of a frame on a soft body, for which its pose in the body frame depends on the state of deformation of the body. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classdrake_1_1multibody_1_1_fixed_offset_frame.html#aab37c950311b422d44019ea551ae5b1e">FixedOffsetFrame&lt; T &gt;</a>, <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#aab37c950311b422d44019ea551ae5b1e">BodyFrame&lt; T &gt;</a>, and <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html#aab37c950311b422d44019ea551ae5b1e">BodyFrame&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a6681a8def9431af1311063721c46fe14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6681a8def9431af1311063721c46fe14">&#9670;&nbsp;</a></span>is_body_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_body_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>this</code> is the body frame. </p>

</div>
</div>
<a id="a64d83126860c9766c12c88786177cf22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d83126860c9766c12c88786177cf22">&#9670;&nbsp;</a></span>is_world_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_world_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>this</code> is the world frame. </p>

</div>
</div>
<a id="ad8227ba86a01f26e4f173cd5e219d5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8227ba86a01f26e4f173cd5e219d5d1">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of this frame. It may be empty if unnamed. </p>

</div>
</div>
<a id="a486765b5bb3145d29946d6dae95a9332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486765b5bb3145d29946d6dae95a9332">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e197bedf7aa897596ace36baca53361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e197bedf7aa897596ace36baca53361">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/tree/<a class="el" href="frame_8h.html">frame.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
