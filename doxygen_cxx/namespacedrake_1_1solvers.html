<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: drake::solvers Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacedrake_1_1solvers.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">drake::solvers Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedrake_1_1solvers_1_1fbstab"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers_1_1fbstab.html">fbstab</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedrake_1_1solvers_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_add_rotation_matrix_box_sphere_intersection_return.html">AddRotationMatrixBoxSphereIntersectionReturn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some of the newly added variables in function AddRotationMatrixBoxSphereIntersectionMilpConstraints.  <a href="structdrake_1_1solvers_1_1_add_rotation_matrix_box_sphere_intersection_return.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binding on constraint type C is a mapping of the decision variables onto the inputs of C.  <a href="classdrake_1_1solvers_1_1_binding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_bounding_box_constraint.html">BoundingBoxConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a constraint of the form \( lb &lt;= x &lt;= ub \).  <a href="classdrake_1_1solvers_1_1_bounding_box_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_constraint.html">Constraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint is a function + lower and upper bounds.  <a href="classdrake_1_1solvers_1_1_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an abstract base for all costs.  <a href="classdrake_1_1solvers_1_1_cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_csdp_solver.html">CsdpSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_csdp_solver_details.html">CsdpSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CSDP solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_csdp_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_dreal_solver.html">DrealSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_equality_constrained_q_p_solver.html">EqualityConstrainedQPSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a quadratic program with equality constraint.  <a href="classdrake_1_1solvers_1_1_equality_constrained_q_p_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_evaluator_base.html">EvaluatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an abstract interface to represent an expression, mapping a fixed or dynamic number of inputs to a fixed number of outputs, that may be evaluated on a scalar type of double or AutoDiffXd.  <a href="classdrake_1_1solvers_1_1_evaluator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_evaluator_constraint.html">EvaluatorConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint that may be specified using another (potentially nonlinear) evaluator.  <a href="classdrake_1_1solvers_1_1_evaluator_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_evaluator_cost.html">EvaluatorCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cost that may be specified using another (potentially nonlinear) evaluator.  <a href="classdrake_1_1solvers_1_1_evaluator_cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html">ExponentialConeConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exponential cone constraint is a special type of convex cone constraint.  <a href="classdrake_1_1solvers_1_1_exponential_cone_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_expression_constraint.html">ExpressionConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose a generic (potentially nonlinear) constraint represented as a vector of symbolic Expression.  <a href="classdrake_1_1solvers_1_1_expression_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_function_evaluator.html">FunctionEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An evaluator that may be specified using a callable object.  <a href="classdrake_1_1solvers_1_1_function_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_gurobi_solver.html">GurobiSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_gurobi_solver_details.html">GurobiSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Gurobi solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_gurobi_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_ipopt_solver.html">IpoptSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_ipopt_solver_details.html">IpoptSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Ipopt solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_ipopt_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html">LinearComplementarityConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a constraint of the form:  <a href="classdrake_1_1solvers_1_1_linear_complementarity_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a constraint of the form \( lb &lt;= Ax &lt;= ub \).  <a href="classdrake_1_1solvers_1_1_linear_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_cost.html">LinearCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a cost of the form </p><p class="formulaDsp">
\[ a&#39;x + b \]
</p>
<p>.  <a href="classdrake_1_1solvers_1_1_linear_cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_equality_constraint.html">LinearEqualityConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a constraint of the form \( Ax = b \).  <a href="classdrake_1_1solvers_1_1_linear_equality_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html">LinearMatrixInequalityConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose the matrix inequality constraint on variable x<p class="formulaDsp">
\[ F_0 + x_1 F_1 + ... + x_n F_n \text{ is p.s.d} \]
</p>
<p> where p.s.d stands for positive semidefinite.  <a href="classdrake_1_1solvers_1_1_linear_matrix_inequality_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_linear_system_solver.html">LinearSystemSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the least-square solution to the linear system A * x = b.  <a href="classdrake_1_1solvers_1_1_linear_system_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_logarithmic_sos2_new_binary_variables.html">LogarithmicSos2NewBinaryVariables</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the new binary variables in the compile time, for Special Ordered Set of type 2 (SOS2) constraint.  <a href="structdrake_1_1solvers_1_1_logarithmic_sos2_new_binary_variables.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>LogarithmicSos2NewBinaryVariables&lt; Eigen::Dynamic &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html">LorentzConeConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraining the linear expression \( z=Ax+b \) lies within the Lorentz cone.  <a href="classdrake_1_1solvers_1_1_lorentz_cone_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> stores the decision variables, the constraints and costs of an optimization problem.  <a href="classdrake_1_1solvers_1_1_mathematical_program.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result returned by <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">MathematicalProgram::Solve()</a>.  <a href="classdrake_1_1solvers_1_1_mathematical_program_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_minimum_value_constraint.html">MinimumValueConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrain all elements of the vector returned by the user-provided function to be no smaller than a specified minimum value.  <a href="classdrake_1_1solvers_1_1_minimum_value_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_branch_and_bound.html">MixedIntegerBranchAndBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mixed-integer optimization problem (MIP) (or more accurately, mixed binary problem), solve this problem through branch-and-bound process.  <a href="classdrake_1_1solvers_1_1_mixed_integer_branch_and_bound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_branch_and_bound_node.html">MixedIntegerBranchAndBoundNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node in the branch-and-bound (bnb) tree.  <a href="classdrake_1_1solvers_1_1_mixed_integer_branch_and_bound_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html">MixedIntegerRotationConstraintGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We relax the non-convex SO(3) constraint on rotation matrix R to mixed-integer linear constraints.  <a href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html">MobyLCPSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for solving Linear Complementarity Problems (LCPs).  <a href="classdrake_1_1solvers_1_1_moby_l_c_p_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_moby_lcp_solver_id.html">MobyLcpSolverId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-template class for MobyLcpSolver&lt;T&gt; constants.  <a href="classdrake_1_1solvers_1_1_moby_lcp_solver_id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_mosek_solver.html">MosekSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_mosek_solver_details.html">MosekSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Mosek solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_mosek_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_new_symmetric_variable_names.html">NewSymmetricVariableNames</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_new_variable_names.html">NewVariableNames</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>NewVariableNames&lt; Eigen::Dynamic &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_new_variable_names_3_01_rows_00_01_cols_01_4.html">NewVariableNames&lt; Rows, Cols &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_new_variable_names_3_01_size_01_4.html">NewVariableNames&lt; Size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the names for the newly added variables.  <a href="structdrake_1_1solvers_1_1_new_variable_names_3_01_size_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_nlopt_solver.html">NloptSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_nlopt_solver_details.html">NloptSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The NLopt solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_nlopt_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_osqp_solver.html">OsqpSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_osqp_solver_details.html">OsqpSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OSQP solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_osqp_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_polynomial_constraint.html">PolynomialConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint on the values of multivariate polynomials.  <a href="classdrake_1_1solvers_1_1_polynomial_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_polynomial_cost.html">PolynomialCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a cost of the form P(x, y...) where P is a multivariate polynomial in x, y, ...  <a href="classdrake_1_1solvers_1_1_polynomial_cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_polynomial_evaluator.html">PolynomialEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an evaluator of the form P(x, y...) where P is a multivariate polynomial in x, y, ...  <a href="classdrake_1_1solvers_1_1_polynomial_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html">PositiveSemidefiniteConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a positive semidefinite constraint on a symmetric matrix S </p><p class="formulaDsp">
\[\text{ S is p.s.d }\]
</p>
<p> namely, all eigen values of S are non-negative.  <a href="classdrake_1_1solvers_1_1_positive_semidefinite_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_quadratic_constraint.html">QuadraticConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">lb ≤ .5 xᵀQx + bᵀx ≤ ub Without loss of generality, the class stores a symmetric matrix Q.  <a href="classdrake_1_1solvers_1_1_quadratic_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a cost of the form </p><p class="formulaDsp">
\[ .5 x&#39;Qx + b&#39;x + c \]
</p>
<p>.  <a href="classdrake_1_1solvers_1_1_quadratic_cost.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraining that the linear expression \( z=Ax+b \) lies within rotated Lorentz cone.  <a href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_scs_solver.html">ScsSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_scs_solver_details.html">ScsSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SCS solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_scs_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_snopt_solver.html">SnoptSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdrake_1_1solvers_1_1_snopt_solver_details.html">SnoptSolverDetails</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SNOPT solver details after calling <a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92" title="Solves an optimization program, with optional initial guess and solver options.">Solve()</a> function.  <a href="structdrake_1_1solvers_1_1_snopt_solver_details.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_base.html">SolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class used by implementations of individual solvers.  <a href="classdrake_1_1solvers_1_1_solver_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html" title="Interface used by implementations of individual solvers.">SolverInterface</a> implementation.  <a href="classdrake_1_1solvers_1_1_solver_id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface used by implementations of individual solvers.  <a href="classdrake_1_1solvers_1_1_solver_interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores options for multiple solvers.  <a href="classdrake_1_1solvers_1_1_solver_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_solver_type_converter.html">SolverTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts between SolverType and <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html" title="Identifies a SolverInterface implementation.">SolverId</a>.  <a href="classdrake_1_1solvers_1_1_solver_type_converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_system_identification.html">SystemIdentification</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions for system identification.  <a href="classdrake_1_1solvers_1_1_system_identification.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_unrevised_lemke_solver.html">UnrevisedLemkeSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the Unrevised Implementation of Lemke Algorithm's for solving Linear Complementarity Problems (LCPs).  <a href="classdrake_1_1solvers_1_1_unrevised_lemke_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_unrevised_lemke_solver_id.html">UnrevisedLemkeSolverId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-template class for UnrevisedLemkeSolver&lt;T&gt; constants.  <a href="classdrake_1_1solvers_1_1_unrevised_lemke_solver_id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1solvers_1_1_visualization_callback.html">VisualizationCallback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a simple evaluator with no outputs that takes a callback function pointer.  <a href="classdrake_1_1solvers_1_1_visualization_callback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa708f80d971209e3d46c1e41f05c1393"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aa708f80d971209e3d46c1e41f05c1393">DecisionVariable</a> = <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a></td></tr>
<tr class="separator:aa708f80d971209e3d46c1e41f05c1393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf84184cb10b49233b007295d1880e17"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:acf84184cb10b49233b007295d1880e17"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a> = Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, rows, cols &gt;</td></tr>
<tr class="separator:acf84184cb10b49233b007295d1880e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20d09ae94d1e722c2961fbaca37f967"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:aa20d09ae94d1e722c2961fbaca37f967"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a> = <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; rows, 1 &gt;</td></tr>
<tr class="separator:aa20d09ae94d1e722c2961fbaca37f967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04cfbe6b8d63ecb463fc087385ce061"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> = <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:ac04cfbe6b8d63ecb463fc087385ce061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca924499b3b011a50d3bd9d051295efa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> = <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt; Eigen::Dynamic &gt;</td></tr>
<tr class="separator:aca924499b3b011a50d3bd9d051295efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062b182db5c52f5a71221a4c5958ea0b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> = std::list&lt; Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &gt;</td></tr>
<tr class="separator:a062b182db5c52f5a71221a4c5958ea0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f19da4730aeebddf6a1d14f51f0b7ec"><td class="memTemplParams" colspan="2">template&lt;int rows, int cols&gt; </td></tr>
<tr class="memitem:a0f19da4730aeebddf6a1d14f51f0b7ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a> = Eigen::Matrix&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, rows, cols &gt;</td></tr>
<tr class="memdesc:a0f19da4730aeebddf6a1d14f51f0b7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable, int, int&gt;.  <a href="#a0f19da4730aeebddf6a1d14f51f0b7ec">More...</a><br /></td></tr>
<tr class="separator:a0f19da4730aeebddf6a1d14f51f0b7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0943cc7cf2cc9bf7db6facfe53a8568"><td class="memTemplParams" colspan="2">template&lt;int rows&gt; </td></tr>
<tr class="memitem:ac0943cc7cf2cc9bf7db6facfe53a8568"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a> = <a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt; rows, 1 &gt;</td></tr>
<tr class="memdesc:ac0943cc7cf2cc9bf7db6facfe53a8568"><td class="mdescLeft">&#160;</td><td class="mdescRight">VectorIndeterminate&lt;int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable, int, 1&gt;.  <a href="#ac0943cc7cf2cc9bf7db6facfe53a8568">More...</a><br /></td></tr>
<tr class="separator:ac0943cc7cf2cc9bf7db6facfe53a8568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e13290a9b854b4fee070764f978d22"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a60e13290a9b854b4fee070764f978d22">MatrixXIndeterminate</a> = <a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt; Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a60e13290a9b854b4fee070764f978d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">MatrixXIndeterminate is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic, Eigen::Dynamic&gt;.  <a href="#a60e13290a9b854b4fee070764f978d22">More...</a><br /></td></tr>
<tr class="separator:a60e13290a9b854b4fee070764f978d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ed74a4ca04549f64c547dfba0724d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> = <a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt; Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a91ed74a4ca04549f64c547dfba0724d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">VectorXIndeterminate is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic, 1&gt;.  <a href="#a91ed74a4ca04549f64c547dfba0724d5">More...</a><br /></td></tr>
<tr class="separator:a91ed74a4ca04549f64c547dfba0724d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27bca68509bbb001ab8073089b48031"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ac27bca68509bbb001ab8073089b48031">IndeterminatesRefList</a> = std::list&lt; Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> &gt; &gt;</td></tr>
<tr class="separator:ac27bca68509bbb001ab8073089b48031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2a57e87ae4e4088e12967a25a7c229"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#adc2a57e87ae4e4088e12967a25a7c229">MinimumValuePenaltyFunction</a> = std::function&lt; void(double x, double *penalty, double *dpenalty_dx)&gt;</td></tr>
<tr class="memdesc:adc2a57e87ae4e4088e12967a25a7c229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the penalty function φ(x) and its derivatives dφ(x)/dx.  <a href="#adc2a57e87ae4e4088e12967a25a7c229">More...</a><br /></td></tr>
<tr class="separator:adc2a57e87ae4e4088e12967a25a7c229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5617ec1dc3b70cd1683d8850fe69585d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> = std::unordered_set&lt; <a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a>, <a class="el" href="namespacedrake.html#a323dc8b0cc629c61d4da8feeaa8cd4f5">DefaultHash</a> &gt;</td></tr>
<tr class="separator:a5617ec1dc3b70cd1683d8850fe69585d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b1b3c88fe94fd28d7564b90f50a00f"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a55b1b3c88fe94fd28d7564b90f50a00f">RollPitchYawLimits</a></td></tr>
<tr class="separator:a55b1b3c88fe94fd28d7564b90f50a00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae07229124cd16e9d8b62fe359c7d0b40"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ae07229124cd16e9d8b62fe359c7d0b40">CommonSolverOption</a> { <a class="el" href="namespacedrake_1_1solvers.html#ae07229124cd16e9d8b62fe359c7d0b40a222307df6fb67d2a524cade7227ca4f8">kPrintFileName</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#ae07229124cd16e9d8b62fe359c7d0b40aca5719f05d0aceacc42e256644394100">kPrintToConsole</a>
 }</td></tr>
<tr class="memdesc:ae07229124cd16e9d8b62fe359c7d0b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some options can be applied to not one solver, but many solvers (for example, many solvers support printing out the progress in each iteration).  <a href="namespacedrake_1_1solvers.html#ae07229124cd16e9d8b62fe359c7d0b40">More...</a><br /></td></tr>
<tr class="separator:ae07229124cd16e9d8b62fe359c7d0b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6297509967536d29159910e5c51fd285"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a> { <a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285a5bff8e60dc42878e194fb2d87460ed29">kLogarithmic</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285aac97f0008bcf7c7fe4f2ff94160e1385">kLinear</a>
 }</td></tr>
<tr class="memdesc:a6297509967536d29159910e5c51fd285"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a continuous variable whose range is cut into small intervals, we will use binary variables to represent which interval the continuous variable is in.  <a href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">More...</a><br /></td></tr>
<tr class="separator:a6297509967536d29159910e5c51fd285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115b732b5de5502e59437ee38babe95f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a> { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa597a3cf4953daab8ab5e6ffebeff44d0">kGenericCost</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fad7bf05f9b17385b6e8aa383fc67fc83f">kGenericConstraint</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa29122b5334de24190e886ea289d14a2a">kQuadraticCost</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fae8503f9b8b6fbe23f14ac068f665c9c0">kQuadraticConstraint</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa302b09f3d249d023c8aaad1097b50edb">kLinearCost</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa42f1335762da576901b57e5b118858e9">kLinearConstraint</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa48d237e8d01c95129ecc34be15f4b789">kLinearEqualityConstraint</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa8c8fa060b46a40b2fd97509493514f33">kLinearComplementarityConstraint</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95faa19344b8110a4be1b5581a25f612713f">kLorentzConeConstraint</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa9e8364decaab78121a0ceaabb57c72cc">kRotatedLorentzConeConstraint</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa59e241294144c7cdf7ea7c8e64b361aa">kPositiveSemidefiniteConstraint</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa6186f6ad8f4222b61ec29ea48a046299">kExponentialConeConstraint</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa12a1034a77cf500ebcff46f8e493bb10">kBinaryVariable</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95fa288767e402655671f06cd5313e8bada9">kCallback</a>
<br />
 }</td></tr>
<tr class="separator:a115b732b5de5502e59437ee38babe95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1949f5edc628077e2d780c150de88d74"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74">RollPitchYawLimitOptions</a> { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74a34bbac4b028a742de1b931cc2694dcea">kNoLimits</a> = 0, 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74af029ec457c6dc0bdc5bee0edc2baf12d">kRPYError</a> = 1 &lt;&lt; 0, 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74af69f0d7bda8d330fcf89df333412794d">kRoll_NegPI_2_to_PI_2</a> = 1 &lt;&lt; 1, 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74a6973c9c90ce92aa52ce62a6e0fc4664d">kRoll_0_to_PI</a> = 1 &lt;&lt; 2, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74adb2b51a6cdf2edf29dc2bfdcefef6ce0">kPitch_NegPI_2_to_PI_2</a> = 1 &lt;&lt; 3, 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74a56192ce118646021d72474e9520a804a">kPitch_0_to_PI</a> = 1 &lt;&lt; 4, 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74aa059fc525d6d174e5e070c7261ff8e43">kYaw_NegPI_2_to_PI_2</a> = 1 &lt;&lt; 5, 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74aca450e45c136c14aabb606a09e0775a8">kYaw_0_to_PI</a> = 1 &lt;&lt; 6, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74a27402335e74462e03adf2c79e903705e">kRoll_0_to_PI_2</a> = (1 &lt;&lt; 1) | (1 &lt;&lt; 2), 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74af031fdd95c7b0bd771a160bf2905eaae">kPitch_0_to_PI_2</a> = (1 &lt;&lt; 3) | (1 &lt;&lt; 4), 
<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74aae2b1591bba5a77450b0df77a207be8f">kYaw_0_to_PI_2</a> = (1 &lt;&lt; 5) | (1 &lt;&lt; 6)
<br />
 }</td></tr>
<tr class="separator:a1949f5edc628077e2d780c150de88d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121673ddbdadd10b2e3ceab52a93f5d3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a> { <a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3a268e3bfe4e48f70785a46a8d3552e552">kTwoSlackVariables</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690">kNullspace</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3a2992c87df2428b480924bf6c6509edec">kLorentzConeSlack</a>
 }</td></tr>
<tr class="memdesc:a121673ddbdadd10b2e3ceab52a93f5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDPA format doesn't accept free variables, namely the problem it solves is in this form P1.  <a href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3">More...</a><br /></td></tr>
<tr class="separator:a121673ddbdadd10b2e3ceab52a93f5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331f41a3139a87d16e1422bc818c136f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a> { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fa15e1c4845b9467d880999c78de6afe45">kSolutionFound</a> = 0, 
<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fa78cb430cc349315a2ba0f3602ef64b6d">kInvalidInput</a> = -1, 
<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fa4f17cb26e989bf3f8c2990cd51fcede9">kInfeasibleConstraints</a> = -2, 
<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fa4b9de95ee3087851acd98262e09f0be8">kUnbounded</a> = -3, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fabca339897d605430456c35a1a10a4a9f">kUnknownError</a> = -4, 
<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fa49c70e81a2c58028009dbd993fd85dd3">kInfeasible_Or_Unbounded</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fa97600ae7efdb5c8fecf91e99463ef4ef">kIterationLimit</a> = -6, 
<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136fae1f645d6b81b09a506f807a18d5e1d4b">kDualInfeasible</a> = -7
<br />
 }</td></tr>
<tr class="separator:a331f41a3139a87d16e1422bc818c136f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b06041d7c1fb05f379714f4312306ec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ec">SolverType</a> { <br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ecae654b0ad8f79045aff33844a0c3cdf81">kCsdp</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306eca65fbd0baf8ecc955767af55707dbd36d">kDReal</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306eca71cedba88b736e372f499099329d5173">kEqualityConstrainedQP</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ecabc8ddfb8a00bb405e68545ce187ac238">kGurobi</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ecaa1f0780f88b19c3a73710b47fc57d795">kIpopt</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ecaebb0e280cb0e7da8a3868247749a4d9d">kLinearSystem</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ecabd0a61a2cf9acec23fccd41c7402ef56">kMobyLCP</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306eca18bc9cbd9bb764958e636263b1b53a9d">kMosek</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306eca64e0ff0ce277a08ed59a9fe9140a8fd7">kNlopt</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306eca6e645ae8d30d672d9800a422f4be4c9d">kOsqp</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306eca6619293bd01e7ea8efb3682f16bf55c4">kSnopt</a>, 
<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ecad1ddb13aaaf649f197e0f6549596571c">kScs</a>, 
<br />
&#160;&#160;<a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306eca045139748552611db2ba18934b6f89f6">kUnrevisedLemke</a>
<br />
 }</td></tr>
<tr class="separator:a8b06041d7c1fb05f379714f4312306ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab9867f403bc6e247a2b55c9022f6fa3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ab9867f403bc6e247a2b55c9022f6fa3a">ReplaceBilinearTerms</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;e, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;x, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;y, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;W)</td></tr>
<tr class="memdesc:ab9867f403bc6e247a2b55c9022f6fa3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all the bilinear product terms in the expression <code>e</code>, with the corresponding terms in <code>W</code>, where <code>W</code> represents the matrix x * yᵀ, such that after replacement, <code>e</code> does not have bilinear terms involving <code>x</code> and <code>y</code>.  <a href="#ab9867f403bc6e247a2b55c9022f6fa3a">More...</a><br /></td></tr>
<tr class="separator:ab9867f403bc6e247a2b55c9022f6fa3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab097e2ddc8c73cd83a8ae0e801b9071"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:aab097e2ddc8c73cd83a8ae0e801b9071"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aab097e2ddc8c73cd83a8ae0e801b9071">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;binding)</td></tr>
<tr class="memdesc:aab097e2ddc8c73cd83a8ae0e801b9071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding</a>.  <a href="#aab097e2ddc8c73cd83a8ae0e801b9071">More...</a><br /></td></tr>
<tr class="separator:aab097e2ddc8c73cd83a8ae0e801b9071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e1d0462e0e3506873f993879d48898"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#af2e1d0462e0e3506873f993879d48898">ChooseBestSolver</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog)</td></tr>
<tr class="memdesc:af2e1d0462e0e3506873f993879d48898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the best solver given the formulation in the optimization program and the availability of the solvers.  <a href="#af2e1d0462e0e3506873f993879d48898">More...</a><br /></td></tr>
<tr class="separator:af2e1d0462e0e3506873f993879d48898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b69ef16f17a627abcbe62dde1d4807"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a55b69ef16f17a627abcbe62dde1d4807">GetKnownSolvers</a> ()</td></tr>
<tr class="memdesc:a55b69ef16f17a627abcbe62dde1d4807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of solvers known to ChooseBestSolver.  <a href="#a55b69ef16f17a627abcbe62dde1d4807">More...</a><br /></td></tr>
<tr class="separator:a55b69ef16f17a627abcbe62dde1d4807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a32aadfdc1241e4e39f206479b6000"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ac0a32aadfdc1241e4e39f206479b6000">MakeSolver</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;id)</td></tr>
<tr class="memdesc:ac0a32aadfdc1241e4e39f206479b6000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the solver ID, create the solver with the matching ID.  <a href="#ac0a32aadfdc1241e4e39f206479b6000">More...</a><br /></td></tr>
<tr class="separator:ac0a32aadfdc1241e4e39f206479b6000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed794af38e7da9270528fd2185861862"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aed794af38e7da9270528fd2185861862">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacedrake_1_1solvers.html#ae07229124cd16e9d8b62fe359c7d0b40">CommonSolverOption</a> common_solver_option)</td></tr>
<tr class="separator:aed794af38e7da9270528fd2185861862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f972e77c40a9afab91907620c621e11"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a5f972e77c40a9afab91907620c621e11">MakeQuadraticErrorCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;x_desired)</td></tr>
<tr class="memdesc:a5f972e77c40a9afab91907620c621e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired).  <a href="#a5f972e77c40a9afab91907620c621e11">More...</a><br /></td></tr>
<tr class="separator:a5f972e77c40a9afab91907620c621e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bad4d69748b5e84448a51d04f672f76"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a4bad4d69748b5e84448a51d04f672f76">MakeL2NormCost</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b)</td></tr>
<tr class="memdesc:a4bad4d69748b5e84448a51d04f672f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a cost term of the form | Ax - b |^2.  <a href="#a4bad4d69748b5e84448a51d04f672f76">More...</a><br /></td></tr>
<tr class="separator:a4bad4d69748b5e84448a51d04f672f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d268ea8150fb094f1499a958c50defb"><td class="memTemplParams" colspan="2">template&lt;typename FF &gt; </td></tr>
<tr class="memitem:a9d268ea8150fb094f1499a958c50defb"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a9d268ea8150fb094f1499a958c50defb">MakeFunctionCost</a> (FF &amp;&amp;f)</td></tr>
<tr class="memdesc:a9d268ea8150fb094f1499a958c50defb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an input of type <code>F</code> to a nonlinear cost.  <a href="#a9d268ea8150fb094f1499a958c50defb">More...</a><br /></td></tr>
<tr class="separator:a9d268ea8150fb094f1499a958c50defb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f304c33d467b0bf0ad02e25a2ced143"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a8f304c33d467b0bf0ad02e25a2ced143">ConcatenateVariableRefList</a> (const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;var_list)</td></tr>
<tr class="memdesc:a8f304c33d467b0bf0ad02e25a2ced143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates each element in <code>var_list</code> into a single Eigen vector of decision variables, returns this concatenated vector.  <a href="#a8f304c33d467b0bf0ad02e25a2ced143">More...</a><br /></td></tr>
<tr class="separator:a8f304c33d467b0bf0ad02e25a2ced143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dddde3ce550bdc321a2240ab12cec0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a82dddde3ce550bdc321a2240ab12cec0">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1solvers_1_1_evaluator_base.html">EvaluatorBase</a> &amp;e)</td></tr>
<tr class="memdesc:a82dddde3ce550bdc321a2240ab12cec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the evaluator.  <a href="#a82dddde3ce550bdc321a2240ab12cec0">More...</a><br /></td></tr>
<tr class="separator:a82dddde3ce550bdc321a2240ab12cec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca547471b139de0956139286cbfe5f10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aca547471b139de0956139286cbfe5f10">ConcatenateIndeterminatesRefList</a> (const <a class="el" href="namespacedrake_1_1solvers.html#ac27bca68509bbb001ab8073089b48031">IndeterminatesRefList</a> &amp;var_list)</td></tr>
<tr class="memdesc:aca547471b139de0956139286cbfe5f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates each element in <code>var_list</code> into a single Eigen vector of indeterminates, returns this concatenated vector.  <a href="#aca547471b139de0956139286cbfe5f10">More...</a><br /></td></tr>
<tr class="separator:aca547471b139de0956139286cbfe5f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897158ddd3d5fd975edd151850ecc639"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="classint.html">int</a>, -1, -1, Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a897158ddd3d5fd975edd151850ecc639">EnumerateIntegerSolutions</a> (const Eigen::Ref&lt; const Eigen::MatrixXi &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;b, const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;lower_bound, const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;upper_bound)</td></tr>
<tr class="memdesc:a897158ddd3d5fd975edd151850ecc639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all integer solutions x to the linear inequalities.  <a href="#a897158ddd3d5fd975edd151850ecc639">More...</a><br /></td></tr>
<tr class="separator:a897158ddd3d5fd975edd151850ecc639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ba521ece6e61a25713f11610b01d97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ab3ba521ece6e61a25713f11610b01d97">CreateLogicalAndConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b2, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1_and_b2)</td></tr>
<tr class="memdesc:ab3ba521ece6e61a25713f11610b01d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints, such that when b1, b2, b1_and_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_and_b2 = b1 ∧ b2 (b1 and b2).  <a href="#ab3ba521ece6e61a25713f11610b01d97">More...</a><br /></td></tr>
<tr class="separator:ab3ba521ece6e61a25713f11610b01d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3cfbf9597820039fe2d6c3f175731b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ada3cfbf9597820039fe2d6c3f175731b">CreateLogicalOrConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b2, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1_or_b2)</td></tr>
<tr class="memdesc:ada3cfbf9597820039fe2d6c3f175731b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds linear constraints, such that when b1, b2, b1_or_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_or_b2 = b1 ∨ b2 (b1 or b2).  <a href="#ada3cfbf9597820039fe2d6c3f175731b">More...</a><br /></td></tr>
<tr class="separator:ada3cfbf9597820039fe2d6c3f175731b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a863c255da14a1441e3ac58d082472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aa7a863c255da14a1441e3ac58d082472">CreateLogicalXorConstraint</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b2, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;b1_xor_b2)</td></tr>
<tr class="memdesc:aa7a863c255da14a1441e3ac58d082472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add linear constraints, such that when b1, b2, b1_xor_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_xor_b2 = b1 ⊕ b2 (b1 exclusive xor b2).  <a href="#aa7a863c255da14a1441e3ac58d082472">More...</a><br /></td></tr>
<tr class="separator:aa7a863c255da14a1441e3ac58d082472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1460b4c245321e57b234a724d774fc50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a1460b4c245321e57b234a724d774fc50">CreateBinaryCodeMatchConstraint</a> (const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;code, const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;expected, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;match)</td></tr>
<tr class="memdesc:a1460b4c245321e57b234a724d774fc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create linear constraints such that, when these constraints are satisfied, match = 1 if and only if code == expected, otherwise match = 0.  <a href="#a1460b4c245321e57b234a724d774fc50">More...</a><br /></td></tr>
<tr class="separator:a1460b4c245321e57b234a724d774fc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014d2838aa5fae12520da4ebf46005ca"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a014d2838aa5fae12520da4ebf46005ca">GetVariableValue</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;var, const std::optional&lt; std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt;&gt; &amp;variable_index, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;variable_values)</td></tr>
<tr class="memdesc:a014d2838aa5fae12520da4ebf46005ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the value of a single variable <code>var</code> from <code>variable_values</code>.  <a href="#a014d2838aa5fae12520da4ebf46005ca">More...</a><br /></td></tr>
<tr class="separator:a014d2838aa5fae12520da4ebf46005ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea397eafcfb30a40737ceb69dcea0e4"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a7ea397eafcfb30a40737ceb69dcea0e4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same&lt; typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;::value, Eigen::Matrix&lt; double, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a7ea397eafcfb30a40737ceb69dcea0e4">GetVariableValue</a> (const Eigen::MatrixBase&lt; Derived &gt; &amp;var, const std::optional&lt; std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt;&gt; &amp;variable_index, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;variable_values)</td></tr>
<tr class="memdesc:a7ea397eafcfb30a40737ceb69dcea0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload <a class="el" href="namespacedrake_1_1solvers.html#a014d2838aa5fae12520da4ebf46005ca" title="Retrieve the value of a single variable var from variable_values.">GetVariableValue()</a> function, but for an Eigen matrix of decision variables.  <a href="#a7ea397eafcfb30a40737ceb69dcea0e4">More...</a><br /></td></tr>
<tr class="separator:a7ea397eafcfb30a40737ceb69dcea0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d06c693e90f6849f70d4b549f015e1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a0d06c693e90f6849f70d4b549f015e1e">ExponentiallySmoothedHingeLoss</a> (double x, double *penalty, double *dpenalty_dx)</td></tr>
<tr class="memdesc:a0d06c693e90f6849f70d4b549f015e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hinge loss function smoothed by exponential function.  <a href="#a0d06c693e90f6849f70d4b549f015e1e">More...</a><br /></td></tr>
<tr class="separator:a0d06c693e90f6849f70d4b549f015e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c445985c8e0f84a2f88f2e70c8f9983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a5c445985c8e0f84a2f88f2e70c8f9983">QuadraticallySmoothedHingeLoss</a> (double x, double *penalty, double *dpenalty_dx)</td></tr>
<tr class="memdesc:a5c445985c8e0f84a2f88f2e70c8f9983"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear hinge loss, smoothed with a quadratic loss near the origin.  <a href="#a5c445985c8e0f84a2f88f2e70c8f9983">More...</a><br /></td></tr>
<tr class="separator:a5c445985c8e0f84a2f88f2e70c8f9983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7d6f23d494612f72e8efc99b87143c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a2f7d6f23d494612f72e8efc99b87143c">CeilLog2</a> (<a class="el" href="classint.html">int</a> n)</td></tr>
<tr class="memdesc:a2f7d6f23d494612f72e8efc99b87143c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return ⌈log₂(n)⌉, namely the minimal integer no smaller than log₂(n), with base 2.  <a href="#a2f7d6f23d494612f72e8efc99b87143c">More...</a><br /></td></tr>
<tr class="separator:a2f7d6f23d494612f72e8efc99b87143c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b9149430052d822e7716abae61ff30"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac5b9149430052d822e7716abae61ff30"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">drake::is_eigen_vector_of</a>&lt; Derived, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;::value, typename <a class="el" href="structdrake_1_1solvers_1_1_logarithmic_sos2_new_binary_variables.html">LogarithmicSos2NewBinaryVariables</a>&lt; Derived::RowsAtCompileTime &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ac5b9149430052d822e7716abae61ff30">AddLogarithmicSos2Constraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::MatrixBase&lt; Derived &gt; &amp;lambda, const std::string &amp;binary_variable_name=&quot;y&quot;)</td></tr>
<tr class="memdesc:ac5b9149430052d822e7716abae61ff30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the special ordered set 2 (SOS2) constraint,.  <a href="#ac5b9149430052d822e7716abae61ff30">More...</a><br /></td></tr>
<tr class="separator:ac5b9149430052d822e7716abae61ff30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49d99f80f15d8e6bdd6a6c2d2fdcc23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#af49d99f80f15d8e6bdd6a6c2d2fdcc23">AddLogarithmicSos2Constraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;lambda, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;y)</td></tr>
<tr class="memdesc:af49d99f80f15d8e6bdd6a6c2d2fdcc23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the special ordered set 2 (SOS2) constraint,.  <a href="#af49d99f80f15d8e6bdd6a6c2d2fdcc23">More...</a><br /></td></tr>
<tr class="separator:af49d99f80f15d8e6bdd6a6c2d2fdcc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46c83406ebd077e9c93b5ea05946ee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ab46c83406ebd077e9c93b5ea05946ee2">AddSos2Constraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;lambda, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;y)</td></tr>
<tr class="memdesc:ab46c83406ebd077e9c93b5ea05946ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the special ordered set 2 (SOS2) constraint.  <a href="#ab46c83406ebd077e9c93b5ea05946ee2">More...</a><br /></td></tr>
<tr class="separator:ab46c83406ebd077e9c93b5ea05946ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3dd262dc400586c539cd57b1bb311ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ab3dd262dc400586c539cd57b1bb311ed">AddLogarithmicSos1Constraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;lambda, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;y, const Eigen::Ref&lt; const Eigen::MatrixXi &gt; &amp;binary_encoding)</td></tr>
<tr class="memdesc:ab3dd262dc400586c539cd57b1bb311ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the special ordered set of type 1 (SOS1) constraint.  <a href="#ab3dd262dc400586c539cd57b1bb311ed">More...</a><br /></td></tr>
<tr class="separator:ab3dd262dc400586c539cd57b1bb311ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8dc4e6bf90d7180583c31a7c06381b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a6a8dc4e6bf90d7180583c31a7c06381b">AddLogarithmicSos1Constraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, <a class="el" href="classint.html">int</a> num_lambda)</td></tr>
<tr class="memdesc:a6a8dc4e6bf90d7180583c31a7c06381b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the special ordered set of type 1 (SOS1) constraint.  <a href="#a6a8dc4e6bf90d7180583c31a7c06381b">More...</a><br /></td></tr>
<tr class="separator:a6a8dc4e6bf90d7180583c31a7c06381b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc62e1bcb70d02de2cb87f7bea20bc77"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#afc62e1bcb70d02de2cb87f7bea20bc77">to_string</a> (<a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a> interval_binning)</td></tr>
<tr class="separator:afc62e1bcb70d02de2cb87f7bea20bc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c59daf7e576403f76128d2063303e9b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a6c59daf7e576403f76128d2063303e9b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a> &amp;binning)</td></tr>
<tr class="separator:a6c59daf7e576403f76128d2063303e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f1dadcfa983a3f1b2068a3fc882dfc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedPhiX , typename DerivedPhiY , typename DerivedBx , typename DerivedBy &gt; </td></tr>
<tr class="memitem:af9f1dadcfa983a3f1b2068a3fc882dfc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; DerivedPhiX, double &gt;::value &amp;&amp;<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; DerivedPhiY, double &gt;::value &amp;&amp;<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; DerivedBx, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;::value &amp;&amp;<a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt; DerivedBy, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;::value, <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; DerivedPhiX::RowsAtCompileTime, DerivedPhiY::RowsAtCompileTime &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#af9f1dadcfa983a3f1b2068a3fc882dfc">AddBilinearProductMcCormickEnvelopeSos2</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;x, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;y, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;w, const DerivedPhiX &amp;phi_x, const DerivedPhiY &amp;phi_y, const DerivedBx &amp;Bx, const DerivedBy &amp;By, <a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a> binning)</td></tr>
<tr class="memdesc:af9f1dadcfa983a3f1b2068a3fc882dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add constraints to the optimization program, such that the bilinear product x * y is approximated by w, using Special Ordered Set of Type 2 (sos2) constraint.  <a href="#af9f1dadcfa983a3f1b2068a3fc882dfc">More...</a><br /></td></tr>
<tr class="separator:af9f1dadcfa983a3f1b2068a3fc882dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f7d44186352e1090de1343d468cad2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a81f7d44186352e1090de1343d468cad2">AddBilinearProductMcCormickEnvelopeMultipleChoice</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;x, const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;y, const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;w, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;phi_x, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;phi_y, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;Bx, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;By)</td></tr>
<tr class="memdesc:a81f7d44186352e1090de1343d468cad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add constraints to the optimization program, such that the bilinear product x * y is approximated by w, using Mixed Integer constraint with "Multiple
Choice" model.  <a href="#a81f7d44186352e1090de1343d468cad2">More...</a><br /></td></tr>
<tr class="separator:a81f7d44186352e1090de1343d468cad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1311acfcf14624ea4089d19783d824"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#abd1311acfcf14624ea4089d19783d824">to_string</a> (<a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html#a50cc1069474becb0998889b417d7b4ff">MixedIntegerRotationConstraintGenerator::Approach</a> type)</td></tr>
<tr class="separator:abd1311acfcf14624ea4089d19783d824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bfa8de91e5e18137f387121fb80933"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ac9bfa8de91e5e18137f387121fb80933">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html#a50cc1069474becb0998889b417d7b4ff">MixedIntegerRotationConstraintGenerator::Approach</a> &amp;type)</td></tr>
<tr class="separator:ac9bfa8de91e5e18137f387121fb80933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86dd14a5111afdacac8ccbbd0fafc9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1solvers_1_1_add_rotation_matrix_box_sphere_intersection_return.html">AddRotationMatrixBoxSphereIntersectionReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#af86dd14a5111afdacac8ccbbd0fafc9a">AddRotationMatrixBoxSphereIntersectionMilpConstraints</a> (const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;R, <a class="el" href="classint.html">int</a> num_intervals_per_half_axis, <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog)</td></tr>
<tr class="memdesc:af86dd14a5111afdacac8ccbbd0fafc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds binary variables that constrain the value of the column <em>and</em> row vectors of R, in order to add the following (in some cases non-convex) constraints as an MILP.  <a href="#af86dd14a5111afdacac8ccbbd0fafc9a">More...</a><br /></td></tr>
<tr class="separator:af86dd14a5111afdacac8ccbbd0fafc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b2d302506a6a2fe144c79bd2598131"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::MatrixXd, Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#af6b2d302506a6a2fe144c79bd2598131">DecomposeNonConvexQuadraticForm</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q)</td></tr>
<tr class="memdesc:af6b2d302506a6a2fe144c79bd2598131"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a non-convex homogeneous quadratic form xᵀQx, where Q is not necessarily a positive semidefinite matrix, we decompose it as a difference between two convex homogeneous quadratic forms xᵀQx = xᵀQ₁x - xᵀQ₂x, Q₁, Q₂ are positive semidefinite.  <a href="#af6b2d302506a6a2fe144c79bd2598131">More...</a><br /></td></tr>
<tr class="separator:af6b2d302506a6a2fe144c79bd2598131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea88a3c59172c77e8537633348a057a9"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a> &gt;, std::vector&lt; <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; <a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a> &gt; &gt;, <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aea88a3c59172c77e8537633348a057a9">AddRelaxNonConvexQuadraticConstraintInTrustRegion</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;x, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q1, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;Q2, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;y, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;p, double lower_bound, double upper_bound, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;linearization_point, double trust_region_gap)</td></tr>
<tr class="memdesc:aea88a3c59172c77e8537633348a057a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a non-convex quadratic constraint lb ≤ xᵀQ₁x - xᵀQ₂x + pᵀy ≤ ub where Q₁, Q₂ are both positive semidefinite matrices.  <a href="#aea88a3c59172c77e8537633348a057a9">More...</a><br /></td></tr>
<tr class="separator:aea88a3c59172c77e8537633348a057a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186a9635874aed6b476d60870d57da01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a186a9635874aed6b476d60870d57da01">AreRequiredAttributesSupported</a> (const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;required, const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;supported)</td></tr>
<tr class="memdesc:a186a9635874aed6b476d60870d57da01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>required</code> is a subset of <code>supported</code>.  <a href="#a186a9635874aed6b476d60870d57da01">More...</a><br /></td></tr>
<tr class="separator:a186a9635874aed6b476d60870d57da01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb26b995d486732f1b2867751dbbee7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#adfb26b995d486732f1b2867751dbbee7">to_string</a> (const <a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a> &amp;)</td></tr>
<tr class="separator:adfb26b995d486732f1b2867751dbbee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa3414cee7c7ef46d8549673b42e344"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a5fa3414cee7c7ef46d8549673b42e344">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a> &amp;)</td></tr>
<tr class="separator:a5fa3414cee7c7ef46d8549673b42e344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3eb74236fcb577dba315f884034169"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aab3eb74236fcb577dba315f884034169">to_string</a> (const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;)</td></tr>
<tr class="separator:aab3eb74236fcb577dba315f884034169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9c2c72528e25a82932f03228d9c867"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a3d9c2c72528e25a82932f03228d9c867">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;)</td></tr>
<tr class="separator:a3d9c2c72528e25a82932f03228d9c867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfb56c6154dc071912945d08ee6833b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a8cfb56c6154dc071912945d08ee6833b">NewRotationMatrixVars</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const std::string &amp;name=&quot;R&quot;)</td></tr>
<tr class="memdesc:a8cfb56c6154dc071912945d08ee6833b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a 3x3 matrix of decision variables with the trivial bounding box constraint ensuring all elements are [-1,1], and the linear constraint imposing -1 &lt;= trace(R) &lt;= 3.  <a href="#a8cfb56c6154dc071912945d08ee6833b">More...</a><br /></td></tr>
<tr class="separator:a8cfb56c6154dc071912945d08ee6833b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7466e7ce1b8db6de94ad0524f8106d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a0c7466e7ce1b8db6de94ad0524f8106d">AddBoundingBoxConstraintsImpliedByRollPitchYawLimits</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;R, <a class="el" href="namespacedrake_1_1solvers.html#a55b1b3c88fe94fd28d7564b90f50a00f">RollPitchYawLimits</a> limits=<a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74a34bbac4b028a742de1b931cc2694dcea">kNoLimits</a>)</td></tr>
<tr class="memdesc:a0c7466e7ce1b8db6de94ad0524f8106d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies <em>very conservative</em> limits on the entries of R for the cases when rotations can be limited (for instance, if you want to search over rotations, but there is an obvious symmetry in the problem so that e.g.  <a href="#a0c7466e7ce1b8db6de94ad0524f8106d">More...</a><br /></td></tr>
<tr class="separator:a0c7466e7ce1b8db6de94ad0524f8106d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9202a27d1c86559e9496ec01fde853e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a9202a27d1c86559e9496ec01fde853e9">AddRotationMatrixSpectrahedralSdpConstraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;R)</td></tr>
<tr class="memdesc:a9202a27d1c86559e9496ec01fde853e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraint (10) from <a href="https://arxiv.org/pdf/1403.4914.pdf">https://arxiv.org/pdf/1403.4914.pdf</a> , which exactly represents the convex hull of all rotation matrices in 3D.  <a href="#a9202a27d1c86559e9496ec01fde853e9">More...</a><br /></td></tr>
<tr class="separator:a9202a27d1c86559e9496ec01fde853e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6304aed086cdd57240ad1f57b66a7986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a6304aed086cdd57240ad1f57b66a7986">AddRotationMatrixOrthonormalSocpConstraint</a> (<a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *prog, const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;R)</td></tr>
<tr class="memdesc:a6304aed086cdd57240ad1f57b66a7986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a set of convex constraints which approximate the set of orthogonal matrices, O(3).  <a href="#a6304aed086cdd57240ad1f57b66a7986">More...</a><br /></td></tr>
<tr class="separator:a6304aed086cdd57240ad1f57b66a7986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2470f8cacd8e5f5a473b10d0acf6cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#aeb2470f8cacd8e5f5a473b10d0acf6cc">GenerateSDPA</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, const std::string &amp;file_name, <a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a> method=<a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690">RemoveFreeVariableMethod::kNullspace</a>)</td></tr>
<tr class="memdesc:aeb2470f8cacd8e5f5a473b10d0acf6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDPA is a format to record an SDP problem.  <a href="#aeb2470f8cacd8e5f5a473b10d0acf6cc">More...</a><br /></td></tr>
<tr class="separator:aeb2470f8cacd8e5f5a473b10d0acf6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1201a087105dc635e2bd748486171c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#acb1201a087105dc635e2bd748486171c">to_string</a> (<a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a> solution_result)</td></tr>
<tr class="separator:acb1201a087105dc635e2bd748486171c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269b7066a168f80390ed6c496829ffcd"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a269b7066a168f80390ed6c496829ffcd">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a> solution_result)</td></tr>
<tr class="separator:a269b7066a168f80390ed6c496829ffcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bf1722e3e347d7878ae44be98b4b92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a07bf1722e3e347d7878ae44be98b4b92">Solve</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, const std::optional&lt; Eigen::VectorXd &gt; &amp;initial_guess, const std::optional&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;solver_options)</td></tr>
<tr class="memdesc:a07bf1722e3e347d7878ae44be98b4b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves an optimization program, with optional initial guess and solver options.  <a href="#a07bf1722e3e347d7878ae44be98b4b92">More...</a><br /></td></tr>
<tr class="separator:a07bf1722e3e347d7878ae44be98b4b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78328b8267370289c8c653bc67efde5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a78328b8267370289c8c653bc67efde5e">Solve</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog, const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;initial_guess)</td></tr>
<tr class="memdesc:a78328b8267370289c8c653bc67efde5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves an optimization program with a given initial guess.  <a href="#a78328b8267370289c8c653bc67efde5e">More...</a><br /></td></tr>
<tr class="separator:a78328b8267370289c8c653bc67efde5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8160cf69cc8a3cd41dfec1fb08a8fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a6f8160cf69cc8a3cd41dfec1fb08a8fa">Solve</a> (const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;prog)</td></tr>
<tr class="separator:a6f8160cf69cc8a3cd41dfec1fb08a8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8463238715a273b4709959e9bf23b9af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a8463238715a273b4709959e9bf23b9af">operator==</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;, const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;)</td></tr>
<tr class="separator:a8463238715a273b4709959e9bf23b9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710dbb02b7a2ce05760b1534cd7b32d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a710dbb02b7a2ce05760b1534cd7b32d9">operator!=</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;, const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;)</td></tr>
<tr class="separator:a710dbb02b7a2ce05760b1534cd7b32d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22da0124afc42f58ae6e42e1a97b724"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#af22da0124afc42f58ae6e42e1a97b724">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;)</td></tr>
<tr class="separator:af22da0124afc42f58ae6e42e1a97b724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16445fc3b260d8c58ea9082a3594f85f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a16445fc3b260d8c58ea9082a3594f85f">to_string</a> (const <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp;)</td></tr>
<tr class="separator:a16445fc3b260d8c58ea9082a3594f85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58cede9876421e050ac44deee7804ff"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#ad58cede9876421e050ac44deee7804ff">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp;)</td></tr>
<tr class="separator:ad58cede9876421e050ac44deee7804ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6703c1f6f99f3e06a86f6a54e7dbd63d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedrake_1_1solvers.html#a6703c1f6f99f3e06a86f6a54e7dbd63d">ConstructMonomialBasis</a> (const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">drake::symbolic::Polynomial</a> &amp;p)</td></tr>
<tr class="memdesc:a6703c1f6f99f3e06a86f6a54e7dbd63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given input polynomial p, outputs a set M of monomials with the following guarantee: if p = f1*f1 + f2*f2 + ...  <a href="#a6703c1f6f99f3e06a86f6a54e7dbd63d">More...</a><br /></td></tr>
<tr class="separator:a6703c1f6f99f3e06a86f6a54e7dbd63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa708f80d971209e3d46c1e41f05c1393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa708f80d971209e3d46c1e41f05c1393">&#9670;&nbsp;</a></span>DecisionVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#aa708f80d971209e3d46c1e41f05c1393">DecisionVariable</a> =  <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac27bca68509bbb001ab8073089b48031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27bca68509bbb001ab8073089b48031">&#9670;&nbsp;</a></span>IndeterminatesRefList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#ac27bca68509bbb001ab8073089b48031">IndeterminatesRefList</a> =  std::list&lt;Eigen::Ref&lt;const <a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf84184cb10b49233b007295d1880e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf84184cb10b49233b007295d1880e17">&#9670;&nbsp;</a></span>MatrixDecisionVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a> =  Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, rows, cols&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f19da4730aeebddf6a1d14f51f0b7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f19da4730aeebddf6a1d14f51f0b7ec">&#9670;&nbsp;</a></span>MatrixIndeterminate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a> =  Eigen::Matrix&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>, rows, cols&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable, int, int&gt;. </p>
<p>After resolving aliases, a compiler does not distinguish between these two. All indeterminates are a variable of type <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#a1d1cfd8ffb84e947f82999c682b666a7ab1fa9dd3af034b3ef4291579aa673c07" title="A CONTINUOUS variable takes a double value.">symbolic::Variable::Type::CONTINUOUS</a> (by default). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix containing indeterminates. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the new matrix containing indeterminates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac04cfbe6b8d63ecb463fc087385ce061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04cfbe6b8d63ecb463fc087385ce061">&#9670;&nbsp;</a></span>MatrixXDecisionVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#ac04cfbe6b8d63ecb463fc087385ce061">MatrixXDecisionVariable</a> =  <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;Eigen::Dynamic, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60e13290a9b854b4fee070764f978d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e13290a9b854b4fee070764f978d22">&#9670;&nbsp;</a></span>MatrixXIndeterminate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#a60e13290a9b854b4fee070764f978d22">MatrixXIndeterminate</a> =  <a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt;Eigen::Dynamic, Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MatrixXIndeterminate is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic, Eigen::Dynamic&gt;. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec" title="MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">MatrixIndeterminate&lt;int, int&gt;</a> </dd></dl>

</div>
</div>
<a id="adc2a57e87ae4e4088e12967a25a7c229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2a57e87ae4e4088e12967a25a7c229">&#9670;&nbsp;</a></span>MinimumValuePenaltyFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#adc2a57e87ae4e4088e12967a25a7c229">MinimumValuePenaltyFunction</a> =  std::function&lt;void(double x, double* penalty, double* dpenalty_dx)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the penalty function φ(x) and its derivatives dφ(x)/dx. </p>
<p>Valid penalty functions must meet the following criteria:</p>
<ol type="1">
<li>φ(x) ≥ 0 ∀ x ∈ ℝ.</li>
<li>dφ(x)/dx ≤ 0 ∀ x ∈ ℝ.</li>
<li>φ(x) = 0 ∀ x ≥ 0.</li>
<li>dφ(x)/dx &lt; 0 ∀ x &lt; 0.</li>
</ol>
<p>If <code>dpenalty_dx</code> is nullptr, the function should only compute φ(x). </p>

</div>
</div>
<a id="a5617ec1dc3b70cd1683d8850fe69585d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5617ec1dc3b70cd1683d8850fe69585d">&#9670;&nbsp;</a></span>ProgramAttributes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> =  std::unordered_set&lt;<a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a>, <a class="el" href="namespacedrake.html#a323dc8b0cc629c61d4da8feeaa8cd4f5">DefaultHash</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55b1b3c88fe94fd28d7564b90f50a00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b1b3c88fe94fd28d7564b90f50a00f">&#9670;&nbsp;</a></span>RollPitchYawLimits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="namespacedrake_1_1solvers.html#a55b1b3c88fe94fd28d7564b90f50a00f">RollPitchYawLimits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a062b182db5c52f5a71221a4c5958ea0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062b182db5c52f5a71221a4c5958ea0b">&#9670;&nbsp;</a></span>VariableRefList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> =  std::list&lt;Eigen::Ref&lt;const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa20d09ae94d1e722c2961fbaca37f967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20d09ae94d1e722c2961fbaca37f967">&#9670;&nbsp;</a></span>VectorDecisionVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a> =  <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;rows, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0943cc7cf2cc9bf7db6facfe53a8568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0943cc7cf2cc9bf7db6facfe53a8568">&#9670;&nbsp;</a></span>VectorIndeterminate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a> =  <a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec">MatrixIndeterminate</a>&lt;rows, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VectorIndeterminate&lt;int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable, int, 1&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>The number of rows in the new matrix containing indeterminates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec" title="MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">MatrixIndeterminate&lt;int, int&gt;</a> </dd></dl>

</div>
</div>
<a id="aca924499b3b011a50d3bd9d051295efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca924499b3b011a50d3bd9d051295efa">&#9670;&nbsp;</a></span>VectorXDecisionVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> =  <a class="el" href="namespacedrake_1_1solvers.html#aa20d09ae94d1e722c2961fbaca37f967">VectorDecisionVariable</a>&lt;Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91ed74a4ca04549f64c547dfba0724d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ed74a4ca04549f64c547dfba0724d5">&#9670;&nbsp;</a></span>VectorXIndeterminate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> =  <a class="el" href="namespacedrake_1_1solvers.html#ac0943cc7cf2cc9bf7db6facfe53a8568">VectorIndeterminate</a>&lt;Eigen::Dynamic&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VectorXIndeterminate is used as an alias for Eigen::Matrix&lt;symbolic::Variable, Eigen::Dynamic, 1&gt;. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1solvers.html#a0f19da4730aeebddf6a1d14f51f0b7ec" title="MatrixIndeterminate&lt;int, int&gt; is used as an alias for Eigen::Matrix&lt;symbolic::Variable,...">MatrixIndeterminate&lt;int, int&gt;</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae07229124cd16e9d8b62fe359c7d0b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07229124cd16e9d8b62fe359c7d0b40">&#9670;&nbsp;</a></span>CommonSolverOption</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1solvers.html#ae07229124cd16e9d8b62fe359c7d0b40">CommonSolverOption</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Some options can be applied to not one solver, but many solvers (for example, many solvers support printing out the progress in each iteration). </p>
<p>CommonSolverOption contain the names of these supported options. The user can use these options as "key" in SolverOption::SetOption(). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae07229124cd16e9d8b62fe359c7d0b40a222307df6fb67d2a524cade7227ca4f8"></a>kPrintFileName&#160;</td><td class="fielddoc"><p>Many solvers support printing the progress of each iteration to a file. </p>
<p>The user can call SolverOptions::SetOption(kPrintFileName, file_name) where file_name is a string. If the user doesn't want to print to a file, then use <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html#a64f5a75df2c33b77454e88fae4d08047">SolverOptions::SetOption</a>(kPrintFileName, ""), where the empty string "" indicates no print. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae07229124cd16e9d8b62fe359c7d0b40aca5719f05d0aceacc42e256644394100"></a>kPrintToConsole&#160;</td><td class="fielddoc"><p>Many solvers support printing the progress of each iteration to the console, the user can call SolverOptions::SetOption(kPrintToConsole, 1) to turn on printing to the console, or SolverOptions::SetOption(kPrintToConsole, 0) to turn off printing to the console. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6297509967536d29159910e5c51fd285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6297509967536d29159910e5c51fd285">&#9670;&nbsp;</a></span>IntervalBinning</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a continuous variable whose range is cut into small intervals, we will use binary variables to represent which interval the continuous variable is in. </p>
<p>We support two representations, either using logarithmic number of binary variables, or linear number of binary variables. For more details, </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1solvers.html#ac5b9149430052d822e7716abae61ff30" title="Adds the special ordered set 2 (SOS2) constraint,.">AddLogarithmicSos2Constraint</a> and <a class="el" href="namespacedrake_1_1solvers.html#ab46c83406ebd077e9c93b5ea05946ee2" title="Adds the special ordered set 2 (SOS2) constraint.">AddSos2Constraint</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6297509967536d29159910e5c51fd285a5bff8e60dc42878e194fb2d87460ed29"></a>kLogarithmic&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6297509967536d29159910e5c51fd285aac97f0008bcf7c7fe4f2ff94160e1385"></a>kLinear&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a115b732b5de5502e59437ee38babe95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115b732b5de5502e59437ee38babe95f">&#9670;&nbsp;</a></span>ProgramAttribute</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa597a3cf4953daab8ab5e6ffebeff44d0"></a>kGenericCost&#160;</td><td class="fielddoc"><p>A generic cost, doesn't belong to any specific cost type below. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fad7bf05f9b17385b6e8aa383fc67fc83f"></a>kGenericConstraint&#160;</td><td class="fielddoc"><p>A generic constraint, doesn't belong to any specific constraint type below. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa29122b5334de24190e886ea289d14a2a"></a>kQuadraticCost&#160;</td><td class="fielddoc"><p>A quadratic function as the cost. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fae8503f9b8b6fbe23f14ac068f665c9c0"></a>kQuadraticConstraint&#160;</td><td class="fielddoc"><p>A constraint on a quadratic function. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa302b09f3d249d023c8aaad1097b50edb"></a>kLinearCost&#160;</td><td class="fielddoc"><p>A linear function as the cost. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa42f1335762da576901b57e5b118858e9"></a>kLinearConstraint&#160;</td><td class="fielddoc"><p>A constraint on a linear function. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa48d237e8d01c95129ecc34be15f4b789"></a>kLinearEqualityConstraint&#160;</td><td class="fielddoc"><p>An equality constraint on a linear function. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa8c8fa060b46a40b2fd97509493514f33"></a>kLinearComplementarityConstraint&#160;</td><td class="fielddoc"><p>A linear complementarity constraint in the form 0 ≤ z ⊥ Mz+q ≥ 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95faa19344b8110a4be1b5581a25f612713f"></a>kLorentzConeConstraint&#160;</td><td class="fielddoc"><p>A Lorentz cone constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa9e8364decaab78121a0ceaabb57c72cc"></a>kRotatedLorentzConeConstraint&#160;</td><td class="fielddoc"><p>A rotated Lorentz cone constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa59e241294144c7cdf7ea7c8e64b361aa"></a>kPositiveSemidefiniteConstraint&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa6186f6ad8f4222b61ec29ea48a046299"></a>kExponentialConeConstraint&#160;</td><td class="fielddoc"><p>A positive semidefinite constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa12a1034a77cf500ebcff46f8e493bb10"></a>kBinaryVariable&#160;</td><td class="fielddoc"><p>An exponential cone constraint. </p>
</td></tr>
<tr><td class="fieldname"><a id="a115b732b5de5502e59437ee38babe95fa288767e402655671f06cd5313e8bada9"></a>kCallback&#160;</td><td class="fielddoc"><p>variable taking binary value {0, 1}. </p>
</td></tr>
</table>

</div>
</div>
<a id="a121673ddbdadd10b2e3ceab52a93f5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121673ddbdadd10b2e3ceab52a93f5d3">&#9670;&nbsp;</a></span>RemoveFreeVariableMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SDPA format doesn't accept free variables, namely the problem it solves is in this form P1. </p>
<pre class="fragment">max tr(C * X)
s.t tr(Aᵢ*X) = aᵢ
    X ≽ 0.
</pre><p>Notice that the decision variable X has to be in the proper cone X ≽ 0, and it doesn't accept free variable (without the conic constraint). On the other hand, most real-world applications require free variables, namely problems in this form P2 </p><pre class="fragment">max tr(C * X) + dᵀs
s.t tr(Aᵢ*X) + bᵢᵀs = aᵢ
    X ≽ 0
    s is free.
</pre><p>In order to remove the free variables, we consider three approaches.</p><ol type="1">
<li>Replace a free variable s with two variables s = p - q, p ≥ 0, q ≥ 0.</li>
<li><p class="startli">First write the dual of the problem P2 as D2 </p><pre class="fragment">min aᵀy
s.t ∑ᵢ yᵢAᵢ - C = Z
    Z ≽ 0
    Bᵀ * y = d,
</pre><p class="startli">where bᵢᵀ is the i'th row of B. The last constraint Bᵀ * y = d means y = ŷ + Nt, where Bᵀ * ŷ = d, and N is the null space of Bᵀ. Hence, D2 is equivalent to the following problem, D3 </p><pre class="fragment">min aᵀNt + aᵀŷ
s.t ∑ᵢ tᵢFᵢ - (C -∑ᵢ ŷᵢAᵢ) = Z
    Z ≽ 0,
</pre><p class="startli">where Fᵢ = ∑ⱼ NⱼᵢAⱼ. D3 is the dual of the following primal problem P3 without free variables </p><pre class="fragment">max tr((C-∑ᵢ ŷᵢAᵢ)*X̂) + aᵀŷ
s.t tr(FᵢX̂) = (Nᵀa)(i)
    X̂ ≽ 0.
</pre><p class="startli">Then (X, s) = (X̂, B⁻¹(a - tr(Aᵢ X̂))) is the solution to the original problem P2.</p>
</li>
<li>Add a slack variable t, with the Lorentz cone constraint t ≥ sqrt(sᵀs). </li>
</ol>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a121673ddbdadd10b2e3ceab52a93f5d3a268e3bfe4e48f70785a46a8d3552e552"></a>kTwoSlackVariables&#160;</td><td class="fielddoc"><p>Approach 1, replace a free variable s as s = y⁺ - y⁻, y⁺ ≥ 0, y⁻ ≥ 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690"></a>kNullspace&#160;</td><td class="fielddoc"><p>Approach 2, reformulate the dual problem by considering the nullspace of the linear constraint in the dual. </p>
</td></tr>
<tr><td class="fieldname"><a id="a121673ddbdadd10b2e3ceab52a93f5d3a2992c87df2428b480924bf6c6509edec"></a>kLorentzConeSlack&#160;</td><td class="fielddoc"><p>Approach 3, add a slack variable t with the lorentz cone constraint t ≥ sqrt(sᵀs). </p>
</td></tr>
</table>

</div>
</div>
<a id="a1949f5edc628077e2d780c150de88d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1949f5edc628077e2d780c150de88d74">&#9670;&nbsp;</a></span>RollPitchYawLimitOptions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74">RollPitchYawLimitOptions</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74a34bbac4b028a742de1b931cc2694dcea"></a>kNoLimits&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74af029ec457c6dc0bdc5bee0edc2baf12d"></a>kRPYError&#160;</td><td class="fielddoc"><p>Do not use, to avoid &amp; vs. &amp;&amp; typos. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74af69f0d7bda8d330fcf89df333412794d"></a>kRoll_NegPI_2_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74a6973c9c90ce92aa52ce62a6e0fc4664d"></a>kRoll_0_to_PI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74adb2b51a6cdf2edf29dc2bfdcefef6ce0"></a>kPitch_NegPI_2_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74a56192ce118646021d72474e9520a804a"></a>kPitch_0_to_PI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74aa059fc525d6d174e5e070c7261ff8e43"></a>kYaw_NegPI_2_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74aca450e45c136c14aabb606a09e0775a8"></a>kYaw_0_to_PI&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74a27402335e74462e03adf2c79e903705e"></a>kRoll_0_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74af031fdd95c7b0bd771a160bf2905eaae"></a>kPitch_0_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1949f5edc628077e2d780c150de88d74aae2b1591bba5a77450b0df77a207be8f"></a>kYaw_0_to_PI_2&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a331f41a3139a87d16e1422bc818c136f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331f41a3139a87d16e1422bc818c136f">&#9670;&nbsp;</a></span>SolutionResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa15e1c4845b9467d880999c78de6afe45"></a>kSolutionFound&#160;</td><td class="fielddoc"><p>Found the optimal solution. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa78cb430cc349315a2ba0f3602ef64b6d"></a>kInvalidInput&#160;</td><td class="fielddoc"><p>Invalid input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa4f17cb26e989bf3f8c2990cd51fcede9"></a>kInfeasibleConstraints&#160;</td><td class="fielddoc"><p>The primal is infeasible. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa4b9de95ee3087851acd98262e09f0be8"></a>kUnbounded&#160;</td><td class="fielddoc"><p>The primal is unbounded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fabca339897d605430456c35a1a10a4a9f"></a>kUnknownError&#160;</td><td class="fielddoc"><p>Unknown error. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa49c70e81a2c58028009dbd993fd85dd3"></a>kInfeasible_Or_Unbounded&#160;</td><td class="fielddoc"><p>The primal is either infeasible or unbounded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fa97600ae7efdb5c8fecf91e99463ef4ef"></a>kIterationLimit&#160;</td><td class="fielddoc"><p>Reaches the iteration limits. </p>
</td></tr>
<tr><td class="fieldname"><a id="a331f41a3139a87d16e1422bc818c136fae1f645d6b81b09a506f807a18d5e1d4b"></a>kDualInfeasible&#160;</td><td class="fielddoc"><p>Dual problem is infeasible. </p>
<p>In this case we cannot infer the status of the primal problem. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8b06041d7c1fb05f379714f4312306ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b06041d7c1fb05f379714f4312306ec">&#9670;&nbsp;</a></span>SolverType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacedrake_1_1solvers.html#a8b06041d7c1fb05f379714f4312306ec">SolverType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecae654b0ad8f79045aff33844a0c3cdf81"></a>kCsdp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca65fbd0baf8ecc955767af55707dbd36d"></a>kDReal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca71cedba88b736e372f499099329d5173"></a>kEqualityConstrainedQP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecabc8ddfb8a00bb405e68545ce187ac238"></a>kGurobi&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecaa1f0780f88b19c3a73710b47fc57d795"></a>kIpopt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecaebb0e280cb0e7da8a3868247749a4d9d"></a>kLinearSystem&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecabd0a61a2cf9acec23fccd41c7402ef56"></a>kMobyLCP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca18bc9cbd9bb764958e636263b1b53a9d"></a>kMosek&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca64e0ff0ce277a08ed59a9fe9140a8fd7"></a>kNlopt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca6e645ae8d30d672d9800a422f4be4c9d"></a>kOsqp&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca6619293bd01e7ea8efb3682f16bf55c4"></a>kSnopt&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306ecad1ddb13aaaf649f197e0f6549596571c"></a>kScs&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8b06041d7c1fb05f379714f4312306eca045139748552611db2ba18934b6f89f6"></a>kUnrevisedLemke&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a81f7d44186352e1090de1343d468cad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f7d44186352e1090de1343d468cad2">&#9670;&nbsp;</a></span>AddBilinearProductMcCormickEnvelopeMultipleChoice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AddBilinearProductMcCormickEnvelopeMultipleChoice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>By</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add constraints to the optimization program, such that the bilinear product x * y is approximated by w, using Mixed Integer constraint with "Multiple
Choice" model. </p>
<p>To do so, we assume that the range of x is [x_min, x_max], and the range of y is [y_min, y_max]. We first consider two arrays φˣ, φʸ, satisfying </p><div class="fragment"><div class="line">x_min = φˣ₀ &lt; φˣ₁ &lt; ... &lt; φˣₘ = x_max</div><div class="line">y_min = φʸ₀ &lt; φʸ₁ &lt; ... &lt; φʸₙ = y_max</div></div><!-- fragment --><p> , and divide the range of x into intervals [φˣ₀, φˣ₁], [φˣ₁, φˣ₂], ... , [φˣₘ₋₁, φˣₘ] and the range of y into intervals [φʸ₀, φʸ₁], [φʸ₁, φʸ₂], ... , [φʸₙ₋₁, φʸₙ]. The xy plane is thus cut into rectangles, with each rectangle as [φˣᵢ, φˣᵢ₊₁] x [φʸⱼ, φʸⱼ₊₁]. The convex hull of the surface z = x * y for x, y in each rectangle is a tetrahedron. We then approximate the bilinear product x * y with w, such that (x, y, w) is in one of the tetrahedrons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The optimization problem to which the constraints will be added. </td></tr>
    <tr><td class="paramname">x</td><td>A variable in the bilinear product. </td></tr>
    <tr><td class="paramname">y</td><td>A variable in the bilinear product. </td></tr>
    <tr><td class="paramname">w</td><td>The expression that approximates the bilinear product x * y. </td></tr>
    <tr><td class="paramname">phi_x</td><td>φˣ in the documentation above. Will be used to cut the range of x into small intervals. </td></tr>
    <tr><td class="paramname">phi_y</td><td>φʸ in the documentation above. Will be used to cut the range of y into small intervals. </td></tr>
    <tr><td class="paramname">Bx</td><td>The binary-valued expression indicating which interval x is in. Bx(i) = 1 =&gt; φˣᵢ ≤ x ≤ φˣᵢ₊₁. </td></tr>
    <tr><td class="paramname">By</td><td>The binary-valued expression indicating which interval y is in. By(i) = 1 =&gt; φʸⱼ ≤ y ≤ φʸⱼ₊₁.</td></tr>
  </table>
  </dd>
</dl>
<p>One formulation of the constraint is </p><div class="fragment"><div class="line">x = ∑ᵢⱼ x̂ᵢⱼ</div><div class="line">y = ∑ᵢⱼ ŷᵢⱼ</div><div class="line">Bˣʸᵢⱼ = Bˣᵢ ∧ Bʸⱼ</div><div class="line">∑ᵢⱼ Bˣʸᵢⱼ = 1</div><div class="line">φˣᵢ Bˣʸᵢⱼ ≤ x̂ᵢⱼ ≤ φˣᵢ₊₁ Bˣʸᵢⱼ</div><div class="line">φʸⱼ Bˣʸᵢⱼ ≤ ŷᵢⱼ ≤ φʸⱼ₊₁ Bˣʸᵢⱼ</div><div class="line">w ≥ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ   + φˣᵢ   ŷᵢⱼ - φˣᵢ  φʸⱼ   Bˣʸᵢⱼ)</div><div class="line">w ≥ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ₊₁ + φˣᵢ₊₁ ŷᵢⱼ - φˣᵢ₊₁ φʸⱼ₊₁ Bˣʸᵢⱼ)</div><div class="line">w ≤ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ   + φˣᵢ₊₁ ŷᵢⱼ - φˣᵢ₊₁ φʸⱼ   Bˣʸᵢⱼ)</div><div class="line">w ≤ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ₊₁ + φˣᵢ   ŷᵢⱼ - φˣᵢ   φʸⱼ₊₁ Bˣʸᵢⱼ)</div></div><!-- fragment --><p>The "logical and" constraint Bˣʸᵢⱼ = Bˣᵢ ∧ Bʸⱼ can be imposed as </p><div class="fragment"><div class="line">Bˣʸᵢⱼ ≥ Bˣᵢ + Bʸⱼ - 1</div><div class="line">Bˣʸᵢⱼ ≤ Bˣᵢ</div><div class="line">Bˣʸᵢⱼ ≤ Bʸⱼ</div><div class="line">0 ≤ Bˣʸᵢⱼ ≤ 1</div></div><!-- fragment --><p> This formulation will introduce slack variables x̂, ŷ and Bˣʸ, in total 3 * m * n variables.</p>
<p>In order to reduce the number of slack variables, we can further simplify these constraints, by defining two vectors <code>x̅ ∈ ℝⁿ</code>, <code>y̅ ∈ ℝᵐ</code> as </p><div class="fragment"><div class="line">x̅ⱼ = ∑ᵢ x̂ᵢⱼ</div><div class="line">y̅ᵢ = ∑ⱼ ŷᵢⱼ</div></div><!-- fragment --><p> and the constraints above can be re-formulated using <code>x̅</code> and <code>y̅</code> as </p><div class="fragment"><div class="line">x = ∑ⱼ x̅ⱼ</div><div class="line">y = ∑ᵢ y̅ᵢ</div><div class="line">Bˣʸᵢⱼ = Bˣᵢ ∧ Bʸⱼ</div><div class="line">∑ᵢⱼ Bˣʸᵢⱼ = 1</div><div class="line">∑ᵢ φˣᵢ Bˣʸᵢⱼ ≤ x̅ⱼ ≤ ∑ᵢ φˣᵢ₊₁ Bˣʸᵢⱼ</div><div class="line">∑ⱼ φʸⱼ Bˣʸᵢⱼ ≤ y̅ᵢ ≤ ∑ⱼ φʸⱼ₊₁ Bˣʸᵢⱼ</div><div class="line">w ≥ ∑ⱼ( x̅ⱼ φʸⱼ   ) + ∑ᵢ( φˣᵢ   y̅ᵢ ) - ∑ᵢⱼ( φˣᵢ   φʸⱼ   Bˣʸᵢⱼ )</div><div class="line">w ≥ ∑ⱼ( x̅ⱼ φʸⱼ₊₁ ) + ∑ᵢ( φˣᵢ₊₁ y̅ᵢ ) - ∑ᵢⱼ( φˣᵢ₊₁ φʸⱼ₊₁ Bˣʸᵢⱼ )</div><div class="line">w ≤ ∑ⱼ( x̅ⱼ φʸⱼ   ) + ∑ᵢ( φˣᵢ₊₁ y̅ⱼ ) - ∑ᵢⱼ( φˣᵢ₊₁ φʸⱼ   Bˣʸᵢⱼ )</div><div class="line">w ≤ ∑ⱼ( x̅ⱼ φʸⱼ₊₁ ) + ∑ᵢ( φˣᵢ   y̅ᵢ ) - ∑ᵢⱼ( φˣᵢ   φʸⱼ₊₁ Bˣʸᵢⱼ ).</div></div><!-- fragment --><p> In this formulation, we introduce new continuous variables <code>x̅</code>, <code>y̅</code>, <code>Bˣʸ</code>. The total number of new variables is m + n + m * n.</p>
<p>In section 3.3 of Mixed-Integer Models for Nonseparable Piecewise Linear Optimization: Unifying Framework and Extensions by Juan P Vielma, Shabbir Ahmed and George Nemhauser, this formulation is called "Multiple Choice
Model".</p>
<dl class="section note"><dt>Note</dt><dd>We DO NOT add the constraint Bx(i) ∈ {0, 1}, By(j) ∈ {0, 1} in this function. It is the user's responsibility to ensure that these binary constraints are enforced. The users can also add cutting planes ∑ᵢBx(i) = 1, ∑ⱼBy(j) = 1. Without these two cutting planes, (x, y, w) is still in the McCormick envelope of z = x * y, but these two cutting planes "might" improve the computation speed in the mixed-integer solver. </dd></dl>

</div>
</div>
<a id="af9f1dadcfa983a3f1b2068a3fc882dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f1dadcfa983a3f1b2068a3fc882dfc">&#9670;&nbsp;</a></span>AddBilinearProductMcCormickEnvelopeSos2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedPhiX, double&gt;::value &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedPhiY, double&gt;::value &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedBx, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;::value &amp;&amp; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">is_eigen_vector_of</a>&lt;DerivedBy, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;::value, <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;DerivedPhiX::RowsAtCompileTime, DerivedPhiY::RowsAtCompileTime&gt; &gt;::type drake::solvers::AddBilinearProductMcCormickEnvelopeSos2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedPhiX &amp;&#160;</td>
          <td class="paramname"><em>phi_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedPhiY &amp;&#160;</td>
          <td class="paramname"><em>phi_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedBx &amp;&#160;</td>
          <td class="paramname"><em>Bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DerivedBy &amp;&#160;</td>
          <td class="paramname"><em>By</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a>&#160;</td>
          <td class="paramname"><em>binning</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add constraints to the optimization program, such that the bilinear product x * y is approximated by w, using Special Ordered Set of Type 2 (sos2) constraint. </p>
<p>To do so, we assume that the range of x is [x_min, x_max], and the range of y is [y_min, y_max]. We first consider two arrays φˣ, φʸ, satisfying </p><div class="fragment"><div class="line">x_min = φˣ₀ &lt; φˣ₁ &lt; ... &lt; φˣₘ = x_max</div><div class="line">y_min = φʸ₀ &lt; φʸ₁ &lt; ... &lt; φʸₙ = y_max</div></div><!-- fragment --><p> , and divide the range of x into intervals [φˣ₀, φˣ₁], [φˣ₁, φˣ₂], ... , [φˣₘ₋₁, φˣₘ] and the range of y into intervals [φʸ₀, φʸ₁], [φʸ₁, φʸ₂], ... , [φʸₙ₋₁, φʸₙ]. The xy plane is thus cut into rectangles, with each rectangle as [φˣᵢ, φˣᵢ₊₁] x [φʸⱼ, φʸⱼ₊₁]. The convex hull of the surface z = x * y for x, y in each rectangle is a tetrahedron. We then approximate the bilinear product x * y with w, such that (x, y, w) is in one of the tetrahedrons.</p>
<p>We use two different encoding schemes on the binary variables, to determine which interval is active. We can choose either linear or logarithmic binning. When using linear binning, for a variable with N intervals, we use N binary variables, and B(i) = 1 indicates the variable is in the i'th interval. When using logarithmic binning, we use ⌈log₂(N)⌉ binary variables. If these binary variables represent integer M in the reflected Gray code, then the continuous variable is in the M'th interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The program to which the bilinear product constraint is added </td></tr>
    <tr><td class="paramname">x</td><td>The decision variable. </td></tr>
    <tr><td class="paramname">y</td><td>The decision variable. </td></tr>
    <tr><td class="paramname">w</td><td>The expression to approximate x * y </td></tr>
    <tr><td class="paramname">phi_x</td><td>The end points of the intervals for <code>x</code>. </td></tr>
    <tr><td class="paramname">phi_y</td><td>The end points of the intervals for <code>y</code>. </td></tr>
    <tr><td class="paramname">Bx</td><td>The binary variables for the interval in which x stays encoded as described above. </td></tr>
    <tr><td class="paramname">By</td><td>The binary variables for the interval in which y stays encoded as described above. </td></tr>
    <tr><td class="paramname">binning</td><td>Determine whether to use linear binning or logarithmic binning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lambda The auxiliary continuous variables.</dd></dl>
<p>The constraints we impose are </p><div class="fragment"><div class="line">x = (φˣ)ᵀ * ∑ⱼ λᵢⱼ</div><div class="line">y = (φʸ)ᵀ * ∑ᵢ λᵢⱼ</div><div class="line">w = ∑ᵢⱼ φˣᵢ * φʸⱼ * λᵢⱼ</div><div class="line">Both ∑ⱼ λᵢⱼ = λ.rowwise().sum() and ∑ᵢ λᵢⱼ = λ.colwise().sum() satisfy SOS2</div><div class="line">constraint.</div></div><!-- fragment --><p>If x ∈ [φx(M), φx(M+1)] and y ∈ [φy(N), φy(N+1)], then only λ(M, N), λ(M + 1, N), λ(M, N + 1) and λ(M+1, N+1) can be strictly positive, all other λ(i, j) are zero.</p>
<dl class="section note"><dt>Note</dt><dd>We DO NOT add the constraint Bx(i) ∈ {0, 1}, By(j) ∈ {0, 1} in this function. It is the user's responsibility to ensure that these constraints are enforced. </dd></dl>

</div>
</div>
<a id="a0c7466e7ce1b8db6de94ad0524f8106d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7466e7ce1b8db6de94ad0524f8106d">&#9670;&nbsp;</a></span>AddBoundingBoxConstraintsImpliedByRollPitchYawLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AddBoundingBoxConstraintsImpliedByRollPitchYawLimits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#a55b1b3c88fe94fd28d7564b90f50a00f">RollPitchYawLimits</a>&#160;</td>
          <td class="paramname"><em>limits</em> = <code><a class="el" href="namespacedrake_1_1solvers.html#a1949f5edc628077e2d780c150de88d74a34bbac4b028a742de1b931cc2694dcea">kNoLimits</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies <em>very conservative</em> limits on the entries of R for the cases when rotations can be limited (for instance, if you want to search over rotations, but there is an obvious symmetry in the problem so that e.g. </p>
<p>0 &lt; pitch &lt; PI need not be considered). A matrix so constrained may still contain rotations outside of this envelope. Note: For simple rotational symmetry over PI, prefer kPitch_NegPI_2_to_PI_2 (over 0_to_PI) because it adds one more constraint (when combined with constraints on roll and yaw). Note: The Roll-Pitch-Yaw angles follow the convention in RollPitchYaw, namely extrinsic rotations about Space-fixed x-y-z axes, respectively. </p>

</div>
</div>
<a id="ab3dd262dc400586c539cd57b1bb311ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3dd262dc400586c539cd57b1bb311ed">&#9670;&nbsp;</a></span>AddLogarithmicSos1Constraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AddLogarithmicSos1Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>binary_encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the special ordered set of type 1 (SOS1) constraint. </p>
<p>Namely </p><pre>
  λ(0) + ... + λ(n-1) = 1
  λ(i) ≥ 0 ∀i
  ∃ j ∈ {0, 1, ..., n-1}, s.t λ(j) = 1
</pre><p> where one and only one of λ(i) is 1, all other λ(j) are 0. We will need to add ⌈log₂(n)⌉ binary variables, where n is the number of rows in λ. For more information, please refer to Modeling Disjunctive Constraints with a Logarithmic Number of Binary Variables and Constraints by J. Vielma and G. Nemhauser, 2011. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The program to which the SOS1 constraint is added. </td></tr>
    <tr><td class="paramname">lambda</td><td>lambda is in SOS1. </td></tr>
    <tr><td class="paramname">y</td><td>The binary variables indicating which λ is positive. For a given assignment on the binary variable <code>y</code>, if (y(0), ..., y(⌈log₂(n)⌉) represents integer M in <code>binary_encoding</code>, then only λ(M) is positive. Namely, if (y(0), ..., y(⌈log₂(n)⌉) equals to binary_encoding.row(M), then λ(M) = 1 </td></tr>
    <tr><td class="paramname">binary_encoding</td><td>A n x ⌈log₂(n)⌉ matrix. binary_encoding.row(i) represents integer i. No two rows of <code>binary_encoding</code> can be the same. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>binary_encoding</code> has a non-binary entry (0, 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a8dc4e6bf90d7180583c31a7c06381b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8dc4e6bf90d7180583c31a7c06381b">&#9670;&nbsp;</a></span>AddLogarithmicSos1Constraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt;, <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt; &gt; drake::solvers::AddLogarithmicSos1Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the special ordered set of type 1 (SOS1) constraint. </p>
<p>Namely </p><pre>
  λ(0) + ... + λ(n-1) = 1
  λ(i) ≥ 0 ∀i
  ∃ j ∈ {0, 1, ..., n-1}, s.t λ(j) = 1
</pre><p> where one and only one of λ(i) is 1, all other λ(j) are 0. We will need to add ⌈log₂(n)⌉ binary variables, where n is the number of rows in λ. For more information, please refer to Modeling Disjunctive Constraints with a Logarithmic Number of Binary Variables and Constraints by J. Vielma and G. Nemhauser, 2011. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The program to which the SOS1 constraint is added. </td></tr>
    <tr><td class="paramname">num_lambda</td><td>n in the documentation above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(lambda, y) lambda is λ in the documentation above. Notice that λ are declared as continuous variables, but they only admit binary solutions. y are binary variables of size ⌈log₂(n)⌉. When this sos1 constraint is satisfied, suppose that λ(i)=1 and λ(j)=0 ∀ j≠i, then y is the Reflected Gray code of i. For example, suppose n = 8, i = 5, then y is a vector of size ⌈log₂(n)⌉ = 3, and the value of y is (1, 1, 0) which equals to 5 according to reflected Gray code. </dd></dl>

</div>
</div>
<a id="ac5b9149430052d822e7716abae61ff30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b9149430052d822e7716abae61ff30">&#9670;&nbsp;</a></span>AddLogarithmicSos2Constraint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structdrake_1_1is__eigen__vector__of.html">drake::is_eigen_vector_of</a>&lt;Derived, <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a>&gt;::value, typename <a class="el" href="structdrake_1_1solvers_1_1_logarithmic_sos2_new_binary_variables.html">LogarithmicSos2NewBinaryVariables</a>&lt; Derived::RowsAtCompileTime&gt;::type&gt;::type drake::solvers::AddLogarithmicSos2Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>binary_variable_name</em> = <code>&quot;y&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the special ordered set 2 (SOS2) constraint,. </p>
<pre>
  λ(0) + ... + λ(n) = 1
  ∀i. λ(i) ≥ 0
  ∃ j ∈ {0, 1, ..., n-1}, s.t λ(i) = 0 if i ≠ j and i ≠ j + 1
</pre><p> Namely at most two entries in λ can be strictly positive, and these two entries have to be adjacent. All other λ should be zero. Moreover, the non-zero λ satisfies λ(j) + λ(j + 1) = 1. We will need to add ⌈log₂(n - 1)⌉ binary variables, where n is the number of rows in λ. For more information, please refer to Modeling Disjunctive Constraints with a Logarithmic Number of Binary Variables and Constraints by J. Vielma and G. Nemhauser, 2011. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>Add the SOS2 constraint to this mathematical program. </td></tr>
    <tr><td class="paramname">lambda</td><td>At most two entries in λ can be strictly positive, and these two entries have to be adjacent. All other entries are zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>y The newly added binary variables. The assignment of the binary variable y implies which two λ can be strictly positive. With a binary assignment on y, and suppose the integer M corresponds to (y(0), y(1), ..., y(⌈log₂(n - 1)⌉)) in Gray code, then only λ(M) and λ(M + 1) can be non-zero. For example, if the assignment of y = (1, 1), in Gray code, (1, 1) represents integer 2, so only λ(2) and λ(3) can be strictly positive. </dd></dl>

</div>
</div>
<a id="af49d99f80f15d8e6bdd6a6c2d2fdcc23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af49d99f80f15d8e6bdd6a6c2d2fdcc23">&#9670;&nbsp;</a></span>AddLogarithmicSos2Constraint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AddLogarithmicSos2Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the special ordered set 2 (SOS2) constraint,. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1solvers.html#ac5b9149430052d822e7716abae61ff30" title="Adds the special ordered set 2 (SOS2) constraint,.">AddLogarithmicSos2Constraint</a>. </dd></dl>

</div>
</div>
<a id="aea88a3c59172c77e8537633348a057a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea88a3c59172c77e8537633348a057a9">&#9670;&nbsp;</a></span>AddRelaxNonConvexQuadraticConstraintInTrustRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt;, std::vector&lt;<a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_rotated_lorentz_cone_constraint.html">RotatedLorentzConeConstraint</a>&gt; &gt;, <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a>&gt; drake::solvers::AddRelaxNonConvexQuadraticConstraintInTrustRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>linearization_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>trust_region_gap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a non-convex quadratic constraint lb ≤ xᵀQ₁x - xᵀQ₂x + pᵀy ≤ ub where Q₁, Q₂ are both positive semidefinite matrices. </p>
<p><code>y</code> is a vector that can overlap with <code>x</code>. We relax this non-convex constraint by several convex constraints. The steps are</p><ol type="1">
<li>Introduce two new variables z₁, z₂, to replace xᵀQ₁x and xᵀQ₂x respectively. The constraint becomes <pre>
     lb ≤ z₁ - z₂ + pᵀy ≤ ub              (1)
   </pre></li>
<li>Ideally, we would like to enforce z₁ = xᵀQ₁x and z₂ = xᵀQ₂x through convex constraints. To this end, we first bound z₁ and z₂ from below, as <pre>
     z₁ ≥ xᵀQ₁x                            (2)
     z₂ ≥ xᵀQ₂x                            (3)
   </pre> These two constraints are second order cone constraints.</li>
<li>To bound z₁ and z₂ from above, we linearize the quadratic forms xᵀQ₁x and xᵀQ₂x at a point x₀. Due to the convexity of the quadratic form, we know that given a positive scalar d &gt; 0, there exists a neighbourhood N(x₀) around x₀, s.t ∀ x ∈ N(x₀) <pre>
   xᵀQ₁x ≤ 2 x₀ᵀQ₁(x - x₀) + x₀ᵀQ₁x₀ + d   (4)
   xᵀQ₂x ≤ 2 x₀ᵀQ₂(x - x₀) + x₀ᵀQ₂x₀ + d   (5)
   </pre> Notice N(x₀) is the intersection of two ellipsoids, as formulated in (4) and (5). Therefore, we also enforce the linear constraints <pre>
     z₁ ≤ 2 x₀ᵀQ₁(x - x₀) + x₀ᵀQ₁x₀ + d    (6)
     z₂ ≤ 2 x₀ᵀQ₂(x - x₀) + x₀ᵀQ₂x₀ + d    (7)
   </pre> So we relax the original non-convex constraint, with the convex constraints (1)-(3), (6) and (7).</li>
</ol>
<p>The trust region is the neighbourhood N(x₀) around x₀, such that the inequalities (4), (5) are satisfied ∀ x ∈ N(x₀).</p>
<p>The positive scalar d controls both how much the constraint relaxation is (the original constraint can be violated by at most d), and how big the trust region is.</p>
<p>If there is a solution satisfying the relaxed constraint, this solution can violate the original non-convex constraint by at most d; on the other hand, if there is not a solution satisfying the relaxed constraint, it proves that the original non-convex constraint does not have a solution in the trust region.</p>
<p>This approach is outlined in section III of On Time Optimization of Centroidal Momentum Dynamics by Brahayam Ponton, Alexander Herzog, Stefan Schaal and Ludovic Righetti, ICRA, 2018</p>
<p>The special cases are when Q₁ = 0 or Q₂ = 0.</p><ol type="1">
<li>When Q₁ = 0, the original constraint becomes lb ≤ -xᵀQ₂x + pᵀy ≤ ub If ub = +∞, then the original constraint is the convex rotated Lorentz cone constraint xᵀQ₂x ≤ pᵀy - lb. The user should not call this function to relax this convex constraint. <dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if Q₁ = 0 and ub = +∞. If ub &lt; +∞, then we introduce a new variable z, with the constraints lb ≤ -z + pᵀy ≤ ub z ≥ xᵀQ₂x z ≤ 2 x₀ᵀQ₂(x - x₀) + x₀ᵀQ₂x₀ + d</td></tr>
  </table>
  </dd>
</dl>
</li>
<li>When Q₂ = 0, the constraint becomes lb ≤ xᵀQ₁x + pᵀy ≤ ub If lb = -∞, then the original constraint is the convex rotated Lorentz cone constraint xᵀQ₁x ≤ ub - pᵀy. The user should not call this function to relax this convex constraint. <dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if Q₂ = 0 and lb = -∞. If lb &gt; -∞, then we introduce a new variable z, with the constraints lb ≤ z + pᵀy ≤ ub z ≥ xᵀQ₁x z ≤ 2 x₀ᵀQ₁(x - x₀) + x₀ᵀQ₁x₀ + d</td></tr>
  </table>
  </dd>
</dl>
</li>
<li>If both Q₁ and Q₂ are zero, then the original constraint is a convex linear constraint lb ≤ pᵀx ≤ ub. The user should not call this function to relax this convex constraint. Throw a runtime error. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> to which the relaxed constraints are added. </td></tr>
    <tr><td class="paramname">x</td><td>The decision variables which appear in the original non-convex constraint. </td></tr>
    <tr><td class="paramname">Q1</td><td>A positive semidefinite matrix. </td></tr>
    <tr><td class="paramname">Q2</td><td>A positive semidefinite matrix. </td></tr>
    <tr><td class="paramname">y</td><td>A vector, the variables in the linear term of the quadratic form. </td></tr>
    <tr><td class="paramname">p</td><td>A vector, the linear coefficients of the quadratic form. </td></tr>
    <tr><td class="paramname">linearization_point</td><td>The vector <code>x₀</code> in the documentation above. </td></tr>
    <tr><td class="paramname">lower_bound</td><td>The left-hand side of the original non-convex constraint. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>The right-hand side of the original non-convex constraint. </td></tr>
    <tr><td class="paramname">trust_region_gap</td><td>The user-specified positive scalar, <code>d</code> in the documentation above. This gap determines both the maximal constraint violation and the size of the trust region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;linear_constraint,rotated_lorentz_cones,z&gt;</td><td>linear_constraint includes (1)(6)(7) rotated_lorentz_cones are (2) (3) When either Q1 or Q2 is zero, rotated_lorentz_cones contains only one rotated Lorentz cone, either (2) or (3). z is the newly added variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>1. Q1, Q2 are positive semidefinite.<ol type="a">
<li>d is positive.</li>
<li>Q1, Q2, x, x₀ are all of the consistent size.</li>
<li>p and y are of the consistent size.</li>
<li>lower_bound ≤ upper_bound. </li>
</ol>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>when the precondition is not satisfied. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ol>

</div>
</div>
<a id="af86dd14a5111afdacac8ccbbd0fafc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86dd14a5111afdacac8ccbbd0fafc9a">&#9670;&nbsp;</a></span>AddRotationMatrixBoxSphereIntersectionMilpConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1solvers_1_1_add_rotation_matrix_box_sphere_intersection_return.html">AddRotationMatrixBoxSphereIntersectionReturn</a> drake::solvers::AddRotationMatrixBoxSphereIntersectionMilpConstraints </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>num_intervals_per_half_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds binary variables that constrain the value of the column <em>and</em> row vectors of R, in order to add the following (in some cases non-convex) constraints as an MILP. </p>
<p>Specifically, for column vectors Ri, we constrain:</p>
<ul>
<li>forall i, |Ri| = 1 ± envelope,</li>
<li>forall i,j. i ≠ j, Ri.dot(Rj) = 0 ± envelope,</li>
<li>R2 = R0.cross(R1) ± envelope, and again for R0=R1.cross(R2), and R1=R2.cross(R0).</li>
</ul>
<p>Then all of the same constraints are also added to R^T. The size of the envelope decreases quickly as num_binary_variables_per_half_axis is is increased.</p>
<dl class="section note"><dt>Note</dt><dd>Creates <code>9*2*num_binary_variables_per_half_axis binary</code> variables named "BRpos*(*,*)" and "BRneg*(*,*)", and the same number of continuous variables named "CRpos*(*,*)" and "CRneg*(*,*)".</dd>
<dd>
The particular representation/algorithm here was developed in an attempt:<ul>
<li>to enable efficient reuse of the variables between the constraints between multiple rows/columns (e.g. the constraints on Rᵀ use the same variables as the constraints on R), and</li>
<li>to facilitate branch-and-bound solution techniques &ndash; binary regions are layered so that constraining one region establishes constraints on large portions of SO(3), and confers hopefully "useful" constraints the on other binary variables. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>The rotation matrix </td></tr>
    <tr><td class="paramname">num_intervals_per_half_axis</td><td>number of intervals for a half axis. </td></tr>
    <tr><td class="paramname">prog</td><td>The mathematical program to which the constraints are added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method uses the same approach as <a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html" title="We relax the non-convex SO(3) constraint on rotation matrix R to mixed-integer linear constraints.">MixedIntegerRotationConstraintGenerator</a> with kBoxSphereIntersection, namely the feasible sets to both relaxation are the same. But they use different sets of binary variables, and thus the computation speed can be different inside optimization solvers. </dd></dl>

</div>
</div>
<a id="a6304aed086cdd57240ad1f57b66a7986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6304aed086cdd57240ad1f57b66a7986">&#9670;&nbsp;</a></span>AddRotationMatrixOrthonormalSocpConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AddRotationMatrixOrthonormalSocpConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a set of convex constraints which approximate the set of orthogonal matrices, O(3). </p>
<p>Adds the bilinear constraints that the each column Ri has length &lt;= 1 and that Ri'Rj approx 0 via -2 + |Ri|^2 + |Rj|^2 &lt;= 2Ri'Rj &lt;= 2 - |Ri|^2 - |Rj|^2 (for all i!=j), using a second-order-cone relaxation. Additionally, the same constraints are applied to all of the rows. </p>

</div>
</div>
<a id="a9202a27d1c86559e9496ec01fde853e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9202a27d1c86559e9496ec01fde853e9">&#9670;&nbsp;</a></span>AddRotationMatrixSpectrahedralSdpConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AddRotationMatrixSpectrahedralSdpConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt; 3, 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraint (10) from <a href="https://arxiv.org/pdf/1403.4914.pdf">https://arxiv.org/pdf/1403.4914.pdf</a> , which exactly represents the convex hull of all rotation matrices in 3D. </p>

</div>
</div>
<a id="ab46c83406ebd077e9c93b5ea05946ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46c83406ebd077e9c93b5ea05946ee2">&#9670;&nbsp;</a></span>AddSos2Constraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::AddSos2Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the special ordered set 2 (SOS2) constraint. </p>
<p>y(i) takes binary values (either 0 or 1). </p><pre>
  y(i) = 1 =&gt; λ(i) + λ(i + 1) = 1.
</pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacedrake_1_1solvers.html#ac5b9149430052d822e7716abae61ff30" title="Adds the special ordered set 2 (SOS2) constraint,.">AddLogarithmicSos2Constraint</a> for a complete explanation on SOS2 constraint. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>The optimization program to which the SOS2 constraint is added. </td></tr>
    <tr><td class="paramname">lambda</td><td>At most two entries in λ can be strictly positive, and these two entries have to be adjacent. All other entries are zero. Moreover, these two entries should sum up to 1. </td></tr>
    <tr><td class="paramname">y</td><td>y(i) takes binary value, and determines which two entries in λ can be strictly positive. Throw a runtime error if y.rows() != lambda.rows() - 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a186a9635874aed6b476d60870d57da01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186a9635874aed6b476d60870d57da01">&#9670;&nbsp;</a></span>AreRequiredAttributesSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::solvers::AreRequiredAttributesSupported </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>required</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;&#160;</td>
          <td class="paramname"><em>supported</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>required</code> is a subset of <code>supported</code>. </p>

</div>
</div>
<a id="a2f7d6f23d494612f72e8efc99b87143c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7d6f23d494612f72e8efc99b87143c">&#9670;&nbsp;</a></span>CeilLog2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classint.html">int</a> drake::solvers::CeilLog2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return ⌈log₂(n)⌉, namely the minimal integer no smaller than log₂(n), with base 2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A positive integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimal integer no smaller than log₂(n). </dd></dl>

</div>
</div>
<a id="af2e1d0462e0e3506873f993879d48898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e1d0462e0e3506873f993879d48898">&#9670;&nbsp;</a></span>ChooseBestSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> drake::solvers::ChooseBestSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose the best solver given the formulation in the optimization program and the availability of the solvers. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>if there is no available solver for <code>prog</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca547471b139de0956139286cbfe5f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca547471b139de0956139286cbfe5f10">&#9670;&nbsp;</a></span>ConcatenateIndeterminatesRefList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#a91ed74a4ca04549f64c547dfba0724d5">VectorXIndeterminate</a> drake::solvers::ConcatenateIndeterminatesRefList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#ac27bca68509bbb001ab8073089b48031">IndeterminatesRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>var_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates each element in <code>var_list</code> into a single Eigen vector of indeterminates, returns this concatenated vector. </p>

</div>
</div>
<a id="a8f304c33d467b0bf0ad02e25a2ced143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f304c33d467b0bf0ad02e25a2ced143">&#9670;&nbsp;</a></span>ConcatenateVariableRefList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> drake::solvers::ConcatenateVariableRefList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a062b182db5c52f5a71221a4c5958ea0b">VariableRefList</a> &amp;&#160;</td>
          <td class="paramname"><em>var_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates each element in <code>var_list</code> into a single Eigen vector of decision variables, returns this concatenated vector. </p>

</div>
</div>
<a id="a6703c1f6f99f3e06a86f6a54e7dbd63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6703c1f6f99f3e06a86f6a54e7dbd63d">&#9670;&nbsp;</a></span>ConstructMonomialBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">drake::VectorX</a>&lt;<a class="el" href="classdrake_1_1symbolic_1_1_monomial.html">symbolic::Monomial</a>&gt; drake::solvers::ConstructMonomialBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_polynomial.html">drake::symbolic::Polynomial</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given input polynomial p, outputs a set M of monomials with the following guarantee: if p = f1*f1 + f2*f2 + ... </p>
<ul>
<li>fn*fn for some (unknown) polynomials f1, f2, ..., fn, then the span of M contains f1, f2, ..., fn, Given M, one can then find the polynomials fi using semidefinite programming; see, e.g., Chapter 3 of Semidefinite Optimization and Convex Algebraic Geometry by G. Blekherman, P. Parrilo, R. Thomas. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A polynomial </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector whose entries are the elements of M </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a1460b4c245321e57b234a724d774fc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1460b4c245321e57b234a724d774fc50">&#9670;&nbsp;</a></span>CreateBinaryCodeMatchConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; drake::solvers::CreateBinaryCodeMatchConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create linear constraints such that, when these constraints are satisfied, match = 1 if and only if code == expected, otherwise match = 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>code(i) should only take binary values. </td></tr>
    <tr><td class="paramname">expected</td><td>The expected matched value for code. </td></tr>
    <tr><td class="paramname">match</td><td>an expression that takes binary value, representing if code == expected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the linear constraints.</dd></dl>
<p>This function is useful integer optimization, for example, if we have a constraint match = ((b1 == 0) &amp;&amp; (b2 == 1) &amp;&amp; (b3 == 1)), we can call the function CreateBinaryCodeMatchConstraint({b1, b2, b3}, {0, 1, 1}, match) to create the constraint. </p>

</div>
</div>
<a id="ab3ba521ece6e61a25713f11610b01d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ba521ece6e61a25713f11610b01d97">&#9670;&nbsp;</a></span>CreateLogicalAndConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; drake::solvers::CreateLogicalAndConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b1_and_b2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints, such that when b1, b2, b1_and_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_and_b2 = b1 ∧ b2 (b1 and b2). </p>
<p>The constraints are </p><pre>
  b1_and_b2 &gt;= b1 + b2 - 1
  b1_and_b2 &lt;= b1
  b1_and_b2 &lt;= b2
  0 &lt;= b1_and_b2 &lt;= 1
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b2</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b1_and_b2</td><td>Should be the logical and between <code>b1</code> and <code>b2</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added constraints, such that when b1, b2, b1_and_b2 satisfy the constraints, it is guaranteed that b1_and_b2 = b1 ∧ b2. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>b1, b2, b1_and_b2 are all linear expressions. </dd></dl>

</div>
</div>
<a id="ada3cfbf9597820039fe2d6c3f175731b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3cfbf9597820039fe2d6c3f175731b">&#9670;&nbsp;</a></span>CreateLogicalOrConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; drake::solvers::CreateLogicalOrConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b1_or_b2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds linear constraints, such that when b1, b2, b1_or_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_or_b2 = b1 ∨ b2 (b1 or b2). </p>
<p>The constraints are </p><pre>
  b1_or_b2 &lt;= b1 + b2
  b1_or_b2 &gt;= b1
  b1_or_b2 &gt;= b2
  0 &lt;= b1_or_b2 &lt;= 1
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b2</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b1_or_b2</td><td>Should be the logical or between <code>b1</code> and <code>b2</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added constraints, such that when b1, b2, b1_or_b2 satisfy the constraints, it is guaranteed that b1_or_b2 = b1 ∨ b2. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>b1, b2, b1_or_b2 are all linear expressions. </dd></dl>

</div>
</div>
<a id="aa7a863c255da14a1441e3ac58d082472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a863c255da14a1441e3ac58d082472">&#9670;&nbsp;</a></span>CreateLogicalXorConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt;<a class="el" href="classdrake_1_1solvers_1_1_linear_constraint.html">LinearConstraint</a>&gt; drake::solvers::CreateLogicalXorConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>b1_xor_b2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add linear constraints, such that when b1, b2, b1_xor_b2 satisfy the constraints, and b1, b2 take binary values, it is guaranteed that b1_xor_b2 = b1 ⊕ b2 (b1 exclusive xor b2). </p>
<p>The constraints are </p><pre>
  b1_xor_b2 &lt;= b1 + b2
  b1_xor_b2 &gt;= b1 - b2
  b1_xor_b2 &gt;= b2 - b1
  b1_xor_b2 &lt;= 2 - b1 - b2
  0 &lt;= b1_xor_b2 &lt;= 1
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b1</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b2</td><td>An expression that should only take a binary value. </td></tr>
    <tr><td class="paramname">b1_xor_b2</td><td>Should be the logical exclusive or between <code>b1</code> and <code>b2</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added constraints, such that when b1, b2, b1_xor_b2 satisfy the constraints, it is guaranteed that b1_xor_b2 = b1 ⊕ b2. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>b1, b2, b1_xor_b2 are all linear expressions. </dd></dl>

</div>
</div>
<a id="af6b2d302506a6a2fe144c79bd2598131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b2d302506a6a2fe144c79bd2598131">&#9670;&nbsp;</a></span>DecomposeNonConvexQuadraticForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;Eigen::MatrixXd, Eigen::MatrixXd&gt; drake::solvers::DecomposeNonConvexQuadraticForm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a non-convex homogeneous quadratic form xᵀQx, where Q is not necessarily a positive semidefinite matrix, we decompose it as a difference between two convex homogeneous quadratic forms xᵀQx = xᵀQ₁x - xᵀQ₂x, Q₁, Q₂ are positive semidefinite. </p>
<p>To find the optimal Q₁ and Q₂, we solve the following semidefinite programming problem min s s.t s &gt;= trace(Q₁) s &gt;= trace(Q₂) Q₁ - Q₂ = (Q + Qᵀ) / 2 Q₁, Q₂ are positive semidefinite The decomposition Q = Q₁ - Q₂ can be used later, to solve the non-convex optimization problem involving a quadratic form xᵀQx. For more information, please refer to the papers on difference of convex decomposition, for example Undominated d.c Decompositions of Quadratic Functions and Applications to Branch-and-Bound Approaches By I.M.Bomze and M. Locatelli Computational Optimization and Applications, 2004 DC Decomposition of Nonconvex Polynomials with Algebraic Techniques By A. A. Ahmadi and G. Hall Mathematical Programming, 2015 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>A square matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if Q is not square. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The optimal decomposition (Q₁, Q₂) </dd></dl>

</div>
</div>
<a id="a897158ddd3d5fd975edd151850ecc639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897158ddd3d5fd975edd151850ecc639">&#9670;&nbsp;</a></span>EnumerateIntegerSolutions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;<a class="el" href="classint.html">int</a>, -1, -1, Eigen::RowMajor&gt; drake::solvers::EnumerateIntegerSolutions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all integer solutions x to the linear inequalities. </p>
<pre>
                   Ax &lt;= b,
                   x &lt;= upper_bound,
                   x &gt;= lower_bound.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>An (m x n) integer matrix. </td></tr>
    <tr><td class="paramname">b</td><td>An (m x 1) integer vector. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>A (n x 1) integer vector. </td></tr>
    <tr><td class="paramname">lower_bound</td><td>A (n x 1) integer vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A (p x n) matrix whose rows are the solutions. </dd></dl>

</div>
</div>
<a id="a0d06c693e90f6849f70d4b549f015e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d06c693e90f6849f70d4b549f015e1e">&#9670;&nbsp;</a></span>ExponentiallySmoothedHingeLoss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::ExponentiallySmoothedHingeLoss </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>penalty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpenalty_dx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A hinge loss function smoothed by exponential function. </p>
<p>This loss function is differentiable everywhere. The fomulation is described in section II.C of [2]. The penalty is </p><pre class="unicode-art">
       ⎧ 0            if x ≥ 0
φ(x) = ⎨
       ⎩ -x exp(1/x)  if x &lt; 0.
</pre><p> [2] "Whole-body Motion Planning with Centroidal Dynamics and Full
Kinematics" by Hongkai Dai, Andres Valenzuela and Russ Tedrake, IEEE-RAS International Conference on Humanoid Robots, 2014. </p>

</div>
</div>
<a id="aeb2470f8cacd8e5f5a473b10d0acf6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2470f8cacd8e5f5a473b10d0acf6cc">&#9670;&nbsp;</a></span>GenerateSDPA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::solvers::GenerateSDPA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3">RemoveFreeVariableMethod</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code><a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690">RemoveFreeVariableMethod::kNullspace</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SDPA is a format to record an SDP problem. </p>
<pre class="fragment">max tr(C*X)
s.t tr(Aᵢ*X) = gᵢ
    X ≽ 0
</pre><p>or the dual of the problem </p><pre class="fragment">min gᵀy
s.t ∑ᵢ yᵢAᵢ - C ≽ 0
</pre><p>where X is a symmetric block diagonal matrix. The format is described in <a href="http://plato.asu.edu/ftp/sdpa_format.txt">http://plato.asu.edu/ftp/sdpa_format.txt</a>. Many solvers, such as CSDP, DSDP, SDPA, sedumi and SDPT3, accept an SDPA format file as the input. This function reads a <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html" title="MathematicalProgram stores the decision variables, the constraints and costs of an optimization probl...">MathematicalProgram</a> that can be formulated as above, and write an SDPA file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>a program that contains an optimization program. </td></tr>
    <tr><td class="paramname">file_name</td><td>The name of the file, note that the extension will be added automatically. </td></tr>
    <tr><td class="paramname">method</td><td>If <code>prog</code> contains free variables (i.e., variables without bounds), then we need to remove these free variables to write the program in the SDPA format. Please refer to RemoveFreeVariableMethod for details on how to remove the free variables. <br />
 <em>Default:</em> is <a class="el" href="namespacedrake_1_1solvers.html#a121673ddbdadd10b2e3ceab52a93f5d3a54b9d7601ece96fc42e2ffd67aae2690" title="Approach 2, reformulate the dual problem by considering the nullspace of the linear constraint in the...">RemoveFreeVariableMethod::kNullspace</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">is_success.</td><td>Returns true if we can generate the SDPA file. The failure could be<ol type="1">
<li><code>prog</code> cannot be captured by the formulation above.</li>
<li><code>prog</code> cannot create a file with the given name, etc. </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55b69ef16f17a627abcbe62dde1d4807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b69ef16f17a627abcbe62dde1d4807">&#9670;&nbsp;</a></span>GetKnownSolvers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt;<a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a>&gt;&amp; drake::solvers::GetKnownSolvers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of solvers known to ChooseBestSolver. </p>

</div>
</div>
<a id="a014d2838aa5fae12520da4ebf46005ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014d2838aa5fae12520da4ebf46005ca">&#9670;&nbsp;</a></span>GetVariableValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double drake::solvers::GetVariableValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>variable_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>variable_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the value of a single variable <code>var</code> from <code>variable_values</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>The variable whose value is going to be retrieved. <code>var.get_id()</code> must be a key in <code>variable_index</code>. </td></tr>
    <tr><td class="paramname">variable_index</td><td>maps the variable ID to its index in <code>variable_values</code>. </td></tr>
    <tr><td class="paramname">variable_values</td><td>The values of all variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variable_values(variable_index[var.get_id()]) if var.get_id() is a valid key of <code>variable_index</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">an</td><td>invalid_argument error if var.get_id() is not a valid key of <code>variable_index</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All the mapped value in variable_index is in the range [0, variable_values.rows()) </dd></dl>

</div>
</div>
<a id="a7ea397eafcfb30a40737ceb69dcea0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea397eafcfb30a40737ceb69dcea0e4">&#9670;&nbsp;</a></span>GetVariableValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same&lt;typename Derived::Scalar, <a class="el" href="classdrake_1_1symbolic_1_1_variable.html">symbolic::Variable</a>&gt;::value, Eigen::Matrix&lt;double, Derived::RowsAtCompileTime, Derived::ColsAtCompileTime&gt; &gt; drake::solvers::GetVariableValue </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; std::unordered_map&lt; <a class="el" href="classdrake_1_1symbolic_1_1_variable.html#ad045777573c866588ca72937e92c1a2c">symbolic::Variable::Id</a>, <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>variable_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>variable_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload <a class="el" href="namespacedrake_1_1solvers.html#a014d2838aa5fae12520da4ebf46005ca" title="Retrieve the value of a single variable var from variable_values.">GetVariableValue()</a> function, but for an Eigen matrix of decision variables. </p>

</div>
</div>
<a id="a9d268ea8150fb094f1499a958c50defb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d268ea8150fb094f1499a958c50defb">&#9670;&nbsp;</a></span>MakeFunctionCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1solvers_1_1_cost.html">Cost</a>&gt; drake::solvers::MakeFunctionCost </td>
          <td>(</td>
          <td class="paramtype">FF &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an input of type <code>F</code> to a nonlinear cost. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FF</td><td>The forwarded function type (e.g., <code>const F&amp;,</code>F&amp;&amp;<code>, ...). The class</code>F` should have functions numInputs(), numOutputs(), and eval(x, y). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bad4d69748b5e84448a51d04f672f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bad4d69748b5e84448a51d04f672f76">&#9670;&nbsp;</a></span>MakeL2NormCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; drake::solvers::MakeL2NormCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a cost term of the form | Ax - b |^2. </p>

</div>
</div>
<a id="a5f972e77c40a9afab91907620c621e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f972e77c40a9afab91907620c621e11">&#9670;&nbsp;</a></span>MakeQuadraticErrorCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classdrake_1_1solvers_1_1_quadratic_cost.html">QuadraticCost</a>&gt; drake::solvers::MakeQuadraticErrorCost </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_desired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a cost term of the form (x-x_desired)'<em>Q</em>(x-x_desired). </p>

</div>
</div>
<a id="ac0a32aadfdc1241e4e39f206479b6000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a32aadfdc1241e4e39f206479b6000">&#9670;&nbsp;</a></span>MakeSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classdrake_1_1solvers_1_1_solver_interface.html">SolverInterface</a>&gt; drake::solvers::MakeSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the solver ID, create the solver with the matching ID. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>if there is no matching solver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cfb56c6154dc071912945d08ee6833b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfb56c6154dc071912945d08ee6833b">&#9670;&nbsp;</a></span>NewRotationMatrixVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1solvers.html#acf84184cb10b49233b007295d1880e17">MatrixDecisionVariable</a>&lt;3, 3&gt; drake::solvers::NewRotationMatrixVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> *&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;R&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a 3x3 matrix of decision variables with the trivial bounding box constraint ensuring all elements are [-1,1], and the linear constraint imposing -1 &lt;= trace(R) &lt;= 3. </p>

</div>
</div>
<a id="a710dbb02b7a2ce05760b1534cd7b32d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710dbb02b7a2ce05760b1534cd7b32d9">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::solvers::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a269b7066a168f80390ed6c496829ffcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269b7066a168f80390ed6c496829ffcd">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a>&#160;</td>
          <td class="paramname"><em>solution_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed794af38e7da9270528fd2185861862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed794af38e7da9270528fd2185861862">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#ae07229124cd16e9d8b62fe359c7d0b40">CommonSolverOption</a>&#160;</td>
          <td class="paramname"><em>common_solver_option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fa3414cee7c7ef46d8549673b42e344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa3414cee7c7ef46d8549673b42e344">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d9c2c72528e25a82932f03228d9c867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9c2c72528e25a82932f03228d9c867">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af22da0124afc42f58ae6e42e1a97b724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22da0124afc42f58ae6e42e1a97b724">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab097e2ddc8c73cd83a8ae0e801b9071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab097e2ddc8c73cd83a8ae0e801b9071">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_binding.html">Binding</a>&lt; C &gt; &amp;&#160;</td>
          <td class="paramname"><em>binding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out the <a class="el" href="classdrake_1_1solvers_1_1_binding.html" title="A binding on constraint type C is a mapping of the decision variables onto the inputs of C.">Binding</a>. </p>

</div>
</div>
<a id="ad58cede9876421e050ac44deee7804ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58cede9876421e050ac44deee7804ff">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9bfa8de91e5e18137f387121fb80933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bfa8de91e5e18137f387121fb80933">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html#a50cc1069474becb0998889b417d7b4ff">MixedIntegerRotationConstraintGenerator::Approach</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c59daf7e576403f76128d2063303e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c59daf7e576403f76128d2063303e9b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a> &amp;&#160;</td>
          <td class="paramname"><em>binning</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82dddde3ce550bdc321a2240ab12cec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dddde3ce550bdc321a2240ab12cec0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; drake::solvers::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_evaluator_base.html">EvaluatorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out the evaluator. </p>

</div>
</div>
<a id="a8463238715a273b4709959e9bf23b9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8463238715a273b4709959e9bf23b9af">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drake::solvers::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_id.html">SolverId</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c445985c8e0f84a2f88f2e70c8f9983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c445985c8e0f84a2f88f2e70c8f9983">&#9670;&nbsp;</a></span>QuadraticallySmoothedHingeLoss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drake::solvers::QuadraticallySmoothedHingeLoss </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>penalty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>dpenalty_dx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A linear hinge loss, smoothed with a quadratic loss near the origin. </p>
<p>The formulation is in equation (6) of [1]. The penalty is </p><pre class="unicode-art">
       ⎧  0        if x ≥ 0
φ(x) = ⎨  x²/2     if -1 &lt; x &lt; 0
       ⎩  -0.5 - x if x ≤ -1.
</pre><p> [1] "Loss Functions for Preference Levels: Regression with Discrete Ordered
Labels." by Jason Rennie and Nathan Srebro, Proceedings of IJCAI multidisciplinary workshop on Advances in preference handling. </p>

</div>
</div>
<a id="ab9867f403bc6e247a2b55c9022f6fa3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9867f403bc6e247a2b55c9022f6fa3a">&#9670;&nbsp;</a></span>ReplaceBilinearTerms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> drake::solvers::ReplaceBilinearTerms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake_1_1solvers.html#aca924499b3b011a50d3bd9d051295efa">VectorXDecisionVariable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all the bilinear product terms in the expression <code>e</code>, with the corresponding terms in <code>W</code>, where <code>W</code> represents the matrix x * yᵀ, such that after replacement, <code>e</code> does not have bilinear terms involving <code>x</code> and <code>y</code>. </p>
<p>For example, if e = x(0)*y(0) + 2 * x(0)*y(1) + x(1) * y(1) + 3 * x(1), <code>e</code> has bilinear terms x(0)*y(0), x(0) * y(1) and x(2) * y(1), if we call ReplaceBilinearTerms(e, x, y, W) where W(i, j) represent the term x(i) * y(j), then this function returns W(0, 0) + 2 * W(0, 1) + W(1, 1) + 3 * x(1). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>An expression potentially contains bilinear products between x and y. </td></tr>
    <tr><td class="paramname">x</td><td>The bilinear product between <code>x</code> and <code>y</code> will be replaced by the corresponding term in <code>W</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>x</code> contains duplicate entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The bilinear product between <code>x</code> and <code>y</code> will be replaced by the corresponding term in <code>W. @throws std::runtime_error if</code>y` contains duplicate entries. </td></tr>
    <tr><td class="paramname">W</td><td>Bilinear product term x(i) * y(j) will be replaced by W(i, j). If W(i,j) is not a single variable, but an expression, then this expression cannot contain a variable in either x or y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error,if</td><td>W(i, j) is not a single variable, and also contains a variable in x or y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The symbolic expression after replacing x(i) * y(j) with W(i, j). </dd></dl>

</div>
</div>
<a id="a07bf1722e3e347d7878ae44be98b4b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bf1722e3e347d7878ae44be98b4b92">&#9670;&nbsp;</a></span>Solve() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> drake::solvers::Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>solver_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves an optimization program, with optional initial guess and solver options. </p>
<p>This function first chooses the best solver depending on the availability of the solver and the program formulation; it then constructs that solver and call the Solve function of that solver. The optimization result is stored in the return argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prog</td><td>Contains the formulation of the program, and possibly solver options. </td></tr>
    <tr><td class="paramname">initial_guess</td><td>The initial guess for the decision variables. </td></tr>
    <tr><td class="paramname">solver_options</td><td>The options in addition to those stored in <code>prog</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result The result of solving the program through the solver. </dd></dl>

</div>
</div>
<a id="a78328b8267370289c8c653bc67efde5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78328b8267370289c8c653bc67efde5e">&#9670;&nbsp;</a></span>Solve() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> drake::solvers::Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_guess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves an optimization program with a given initial guess. </p>

</div>
</div>
<a id="a6f8160cf69cc8a3cd41dfec1fb08a8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8160cf69cc8a3cd41dfec1fb08a8fa">&#9670;&nbsp;</a></span>Solve() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1solvers_1_1_mathematical_program_result.html">MathematicalProgramResult</a> drake::solvers::Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_mathematical_program.html">MathematicalProgram</a> &amp;&#160;</td>
          <td class="paramname"><em>prog</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb1201a087105dc635e2bd748486171c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1201a087105dc635e2bd748486171c">&#9670;&nbsp;</a></span>to_string() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::solvers::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#a331f41a3139a87d16e1422bc818c136f">SolutionResult</a>&#160;</td>
          <td class="paramname"><em>solution_result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adfb26b995d486732f1b2867751dbbee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb26b995d486732f1b2867751dbbee7">&#9670;&nbsp;</a></span>to_string() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::solvers::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a115b732b5de5502e59437ee38babe95f">ProgramAttribute</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab3eb74236fcb577dba315f884034169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3eb74236fcb577dba315f884034169">&#9670;&nbsp;</a></span>to_string() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::solvers::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1solvers.html#a5617ec1dc3b70cd1683d8850fe69585d">ProgramAttributes</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16445fc3b260d8c58ea9082a3594f85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16445fc3b260d8c58ea9082a3594f85f">&#9670;&nbsp;</a></span>to_string() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::solvers::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1solvers_1_1_solver_options.html">SolverOptions</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd1311acfcf14624ea4089d19783d824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1311acfcf14624ea4089d19783d824">&#9670;&nbsp;</a></span>to_string() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::solvers::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1solvers_1_1_mixed_integer_rotation_constraint_generator.html#a50cc1069474becb0998889b417d7b4ff">MixedIntegerRotationConstraintGenerator::Approach</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc62e1bcb70d02de2cb87f7bea20bc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc62e1bcb70d02de2cb87f7bea20bc77">&#9670;&nbsp;</a></span>to_string() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string drake::solvers::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1solvers.html#a6297509967536d29159910e5c51fd285">IntervalBinning</a>&#160;</td>
          <td class="paramname"><em>interval_binning</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1solvers.html">solvers</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
