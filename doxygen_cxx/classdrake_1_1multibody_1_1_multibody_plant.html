<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: MultibodyPlant&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1multibody_1_1_multibody_plant.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classdrake_1_1multibody_1_1_multibody_plant-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MultibodyPlant&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__systems.html">Modeling Dynamical Systems</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::multibody::MultibodyPlant&lt; T &gt;</h3>

<p>MultibodyPlant is a Drake system framework representation (see <a class="el" href="classdrake_1_1systems_1_1_system.html" title="Base class for all System functionality that is dependent on the templatized scalar type T for input,...">systems::System</a>) for the model of a physical system consisting of a collection of interconnected bodies. </p>
<p>See <a class="el" href="group__multibody.html">Multibody Kinematics and Dynamics</a> for an overview of concepts/notation.</p>
<table align="center" cellpadding="0" cellspacing="0">
<tr align="center">
<td style="vertical-align:middle"><table cellspacing="0" cellpadding="0">
<tr>
<td align="right" style="padding:5px 0px 5px 0px">applied_generalized_force&rarr;</td></tr>
<tr>
<td align="right" style="padding:5px 0px 5px 0px">applied_spatial_force&rarr;</td></tr>
<tr>
<td align="right" style="padding:5px 0px 5px 0px"><em style="color:gray">model_instance_name[i]</em>_actuation&rarr;</td></tr>
<tr>
<td align="right" style="padding:5px 0px 5px 0px"><span style="color:green">geometry_query</span>&rarr;</td></tr>
</table>
</td><td align="center" style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor="#F0F0F0"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a></td><td style="vertical-align:middle"><table cellspacing="0" cellpadding="0">
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; continuous_state</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; body_poses</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; body_spatial_velocities</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; body_spatial_accelerations</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; generalized_acceleration</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; reaction_forces</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; contact_results</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray">model_instance_name[i]</em>_continuous_state</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray"> model_instance_name[i]</em>_generalized_acceleration</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; <em style="color:gray"> model_instance_name[i]</em>_generalized_contact_forces</td></tr>
<tr>
<td align="left" style="padding:5px 0px 5px 0px">&rarr; <span style="color:green">geometry_pose</span></td></tr>
</table>
</td></tr>
</table>
<p>The ports whose names begin with <em style="color:gray"> model_instance_name[i]</em> represent groups of ports, one for each of the <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#model_instances">model instances</a>, with i ∈ {0, ..., N-1} for the N model instances. If a model instance does not contain any data of the indicated type the port will still be present but its value will be a zero-length vector. (Model instances <code><a class="el" href="namespacedrake_1_1multibody.html#a777a2894881e59d27fc9eb7b4413406f" title="Returns the model instance containing the world body.">world_model_instance()</a></code> and <code><a class="el" href="namespacedrake_1_1multibody.html#a786cd667a624e8cbd915cf50b02c8792" title="Returns the model instance which contains all tree elements with no explicit model instance specified...">default_model_instance()</a></code> always exist.)</p>
<p>The ports shown in <span style="color:green"> green</span> are for communication with Drake's <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">SceneGraph</a> system for dealing with geometry.</p>
<p>MultibodyPlant provides a user-facing API for:</p>
<ul>
<li><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_input_and_output_ports">Ports</a>: Access input and output ports.</li>
<li><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_construction">Construction</a>: Add bodies, joints, frames, force elements, and actuators.</li>
<li><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_geometry">Geometry</a>: Register geometries to a provided SceneGraph instance.</li>
<li><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_contact_modeling">Contact modeling</a>: Select and parameterize contact models.</li>
<li><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_state_accessors_and_mutators">State access and modification</a>: Obtain and manipulate position and velocity state variables.</li>
<li><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_working_with_free_bodies">Free bodies</a>: Work conveniently with free (floating) bodies.</li>
<li><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_kinematic_and_dynamic_computations">Kinematics and dynamics</a>: Perform <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>-dependent kinematic and dynamic queries.</li>
<li><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_system_matrix_computations">System matrices</a>: Explicitly form matrices that appear in the equations of motion.</li>
<li><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_introspection">Introspection</a>: Perform introspection to find out what's in the MultibodyPlant.</li>
</ul>
<p><a class="anchor" id="model_instances"></a></p><h3>Model Instances</h3>
<p>A MultiBodyPlant may contain multiple model instances. Each model instance corresponds to a set of bodies and their connections (joints). Model instances provide methods to get or set the state of the set of bodies (e.g., through <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abda564c1168979bb8422343d46925b9a" title="Returns a const vector reference containing the vector [q; v] with q the vector of generalized positi...">GetPositionsAndVelocities()</a> and <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5f77c6666edaa725dbd5dd060d2f5b00" title="Sets all generalized positions and velocities from the given vector [q; v].">SetPositionsAndVelocities()</a>), connecting controllers (through <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ad4e8834bd252d1265e99b8ac85fad0b5" title="Returns a constant reference to the output port for the multibody state x = [q, v] of the model.">get_state_output_port()</a> and <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8c9e7974ae1d996a6ca3430893bd5df2" title="Returns a constant reference to the input port for external actuation for a specific model instance.">get_actuation_input_port()</a>), and organizing duplicate models (read through a parser). In fact, many MultibodyPlant methods are overloaded to allow operating on the entire plant or just the subset corresponding to the model instance; for example, one <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4b48791a474f442ccb628dc9b76a24b9" title="Returns a const vector reference containing the vector of generalized positions.">GetPositions()</a> method obtains the generalized positions for the entire plant while another <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4b48791a474f442ccb628dc9b76a24b9" title="Returns a const vector reference containing the vector of generalized positions.">GetPositions()</a> method obtains the generalized positions for model instance.</p>
<p>Model instances are frequently defined through SDF files (using the <code>model</code> tag) and are automatically created when SDF files are parsed (by <a class="el" href="classdrake_1_1multibody_1_1_parser.html" title="Parses SDF and URDF input files into a MultibodyPlant and (optionally) a SceneGraph.">Parser</a>). There are two special <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0" title="Type used to identify model instances by index within a multibody tree system.">multibody::ModelInstanceIndex</a> values. The world body is always <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0" title="Type used to identify model instances by index within a multibody tree system.">multibody::ModelInstanceIndex</a> 0. <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0" title="Type used to identify model instances by index within a multibody tree system.">multibody::ModelInstanceIndex</a> 1 is reserved for all elements with no explicit model instance and is generally only relevant for elements created programmatically (and only when a model instance is not explicitly specified). Note that <a class="el" href="classdrake_1_1multibody_1_1_parser.html" title="Parses SDF and URDF input files into a MultibodyPlant and (optionally) a SceneGraph.">Parser</a> creates model instances (resulting in a <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0" title="Type used to identify model instances by index within a multibody tree system.">multibody::ModelInstanceIndex</a> ≥ 2) as needed.</p>
<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac89140adb93cb9e507f71c30eb783198" title="Returns the number of model instances in the model.">num_model_instances()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae3fc8de8de8eaf2d37a24c79d6be8e97" title="Returns the total number of actuated degrees of freedom.">num_actuated_dofs()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4edf1daa65069a26255c903b02bce4c6" title="Creates a new model instance.">AddModelInstance()</a> <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abda564c1168979bb8422343d46925b9a" title="Returns a const vector reference containing the vector [q; v] with q the vector of generalized positi...">GetPositionsAndVelocities()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4b48791a474f442ccb628dc9b76a24b9" title="Returns a const vector reference containing the vector of generalized positions.">GetPositions()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a800453060fc1f94455dff6c07dfde2d1" title="Returns a const vector reference containing the generalized velocities.">GetVelocities()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5f77c6666edaa725dbd5dd060d2f5b00" title="Sets all generalized positions and velocities from the given vector [q; v].">SetPositionsAndVelocities()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abfb9f945ca5577141351e60bd45156ef" title="Sets all generalized positions from the given vector.">SetPositions()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1ee483fa25d16a1ab99da1e0bface016" title="Sets all generalized velocities from the given vector.">SetVelocities()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9b8a17ef762452f820bdd351f8bb41b4" title="Returns a vector of generalized positions for model_instance from a vector q_array of generalized pos...">GetPositionsFromArray()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9f32c59d0fb31b2bb9258bd9ee86f55d" title="Returns a vector of generalized velocities for model_instance from a vector v of generalized velociti...">GetVelocitiesFromArray()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3de72c319632f5a263fe6c9e96c70614" title="Sets the vector of generalized positions for model_instance in q using q_instance,...">SetPositionsInArray()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a60e9928aa7802359eaddab6ef5d92763" title="Sets the vector of generalized velocities for model_instance in v using v_instance,...">SetVelocitiesInArray()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aec851e17ae2c34da1b87a03ce85f460a" title="Given the actuation values u_instance for all actuators in model_instance, this method sets the actua...">SetActuationInArray()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a05b71664c8e2e91bc3fc92fef222a9bf">HasModelInstanceNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab99be499eb59f00037b05ec60b51e177" title="Returns the name of a model_instance.">GetModelInstanceName()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ad4e8834bd252d1265e99b8ac85fad0b5" title="Returns a constant reference to the output port for the multibody state x = [q, v] of the model.">get_state_output_port()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8c9e7974ae1d996a6ca3430893bd5df2" title="Returns a constant reference to the input port for external actuation for a specific model instance.">get_actuation_input_port()</a>.</p>
<p><a class="anchor" id="mbp_equations_of_motion"></a></p><h3>System dynamics</h3>
<p>The state of a multibody system <code>x = [q; v]</code> is given by its generalized positions vector q, of size <code>nq</code> (see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a>), and by its generalized velocities vector v, of size <code>nv</code> (see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>). As a Drake <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a>, MultibodyPlant implements the governing equations for a multibody dynamical system in the form <code>ẋ = f(t, x, u)</code> with t being time and u the actuation forces. The governing equations for the dynamics of a multibody system modeled with MultibodyPlant are [Featherstone 2008, Jain 2010]: </p><pre>
         q̇ = N(q)v
  (1)    M(q)v̇ + C(q, v)v = τ
</pre><p> where <code>M(q)</code> is the mass matrix of the multibody system, <code>C(q, v)v</code> contains Coriolis, centripetal, and gyroscopic terms and <code>N(q)</code> is the kinematic coupling matrix describing the relationship between q̇ (the time derivatives of the generalized positions) and the generalized velocities v, [Seth 2010]. <code>N(q)</code> is an <code>nq x nv</code> matrix. The vector <code>τ ∈ ℝⁿᵛ</code> on the right hand side of Eq. (1) is the system's generalized forces. These incorporate gravity, springs, externally applied body forces, constraint forces, and contact forces.</p>
<p><a class="anchor" id="sdf_loading"></a></p><h3>Loading models from SDF files</h3>
<p>Drake has the capability to load multibody models from SDF and URDF files. Consider the example below which loads an acrobot model: </p><div class="fragment"><div class="line">MultibodyPlant&lt;T&gt; acrobot;</div><div class="line">SceneGraph&lt;T&gt; scene_graph;</div><div class="line">Parser parser(&amp;acrobot, &amp;scene_graph);</div><div class="line"><span class="keyword">const</span> std::string relative_name =</div><div class="line">  <span class="stringliteral">&quot;drake/multibody/benchmarks/acrobot/acrobot.sdf&quot;</span>;</div><div class="line"><span class="keyword">const</span> std::string full_name = <a class="code" href="namespacedrake.html#ac72eb43ba982b5a4d188c85aa14e0cc6">FindResourceOrThrow</a>(relative_name);</div><div class="line">parser.AddModelFromFile(full_name);</div></div><!-- fragment --><p> As in the example above, for models including visual geometry, collision geometry or both, the user must specify a SceneGraph for geometry handling. You can find a full example of the LQR controlled acrobot in examples/multibody/acrobot/run_lqr.cc.</p>
<p>AddModelFromFile() can be invoked multiple times on the same plant in order to load multiple model instances. Other methods are available on <a class="el" href="classdrake_1_1multibody_1_1_parser.html" title="Parses SDF and URDF input files into a MultibodyPlant and (optionally) a SceneGraph.">Parser</a> such as AddAllModelsFromFile() which allows creating model instances per each <code>&lt;model&gt;</code> tag found in the file. Please refer to each of these methods' documentation for further details.</p>
<p><a class="anchor" id="working_with_scenegraph"></a></p><h3>Working with SceneGraph</h3>
<p><a class="anchor" id="add_multibody_plant_scene_graph"></a></p><h4>Adding a MultibodyPlant connected to a SceneGraph to your Diagram</h4>
<p>Probably the simplest way to add and wire up a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> with a SceneGraph in your Diagram is using <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aac66563a5f3eb9e2041bd4fa8d438827" title="Makes a new MultibodyPlant with discrete update period time_step and adds it to a diagram builder tog...">AddMultibodyPlantSceneGraph()</a>.</p>
<p>Recommended usages:</p>
<p>Assign to a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> reference (ignoring the SceneGraph): </p><div class="fragment"><div class="line">MultibodyPlant&lt;double&gt;&amp; plant =</div><div class="line">    <a class="code" href="classdrake_1_1multibody_1_1_multibody_plant.html#aac66563a5f3eb9e2041bd4fa8d438827">AddMultibodyPlantSceneGraph</a>(&amp;builder, 0.0 <span class="comment">/* time_step */</span>);</div><div class="line">plant.DoFoo(...);</div></div><!-- fragment --><p> This flavor is the simplest, when the SceneGraph is not explicitly needed. (It can always be retrieved later via GetSubsystemByName("scene_graph").)</p>
<p>Assign to auto, and use the named public fields: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> items = <a class="code" href="classdrake_1_1multibody_1_1_multibody_plant.html#aac66563a5f3eb9e2041bd4fa8d438827">AddMultibodyPlantSceneGraph</a>(&amp;builder, 0.0 <span class="comment">/* time_step */</span>);</div><div class="line">items.plant.DoFoo(...);</div><div class="line">items.scene_graph.DoBar(...);</div></div><!-- fragment --><p> or taking advantage of C++17's structured binding </p><div class="fragment"><div class="line"><span class="keyword">auto</span> [plant, scene_graph] = <a class="code" href="classdrake_1_1multibody_1_1_multibody_plant.html#aac66563a5f3eb9e2041bd4fa8d438827">AddMultibodyPlantSceneGraph</a>(&amp;builder, 0.0);</div><div class="line">...</div><div class="line">plant.DoFoo(...);</div><div class="line">scene_graph.DoBar(...);</div></div><!-- fragment --><p> This is the easiest way to use both the plant and scene_graph.</p>
<p>Assign to already-declared pointer variables: </p><div class="fragment"><div class="line">MultibodyPlant&lt;double&gt;* plant{};</div><div class="line">SceneGraph&lt;double&gt;* scene_graph{};</div><div class="line">std::tie(plant, scene_graph) =</div><div class="line">    <a class="code" href="classdrake_1_1multibody_1_1_multibody_plant.html#aac66563a5f3eb9e2041bd4fa8d438827">AddMultibodyPlantSceneGraph</a>(&amp;builder, 0.0 <span class="comment">/* time_step */</span>);</div><div class="line">plant-&gt;DoFoo(...);</div><div class="line">scene_graph-&gt;DoBar(...);</div></div><!-- fragment --><p> This flavor is most useful when the pointers are class member fields (and so perhaps cannot be references).</p>
<p><a class="anchor" id="mbp_geometry_registration"></a></p><h4>Registering geometry with a SceneGraph</h4>
<p>MultibodyPlant users can register geometry with a SceneGraph for essentially two purposes; a) visualization and, b) contact modeling.</p>
<p>Before any geometry registration takes place, a user <b>must</b> first make a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4a6d28ce9c8119bee923e827eb6f02ed" title="Registers this plant to serve as a source for an instance of SceneGraph.">RegisterAsSourceForSceneGraph()</a> in order to register the MultibodyPlant as a client of a SceneGraph instance, point at which the plant will have assigned a valid <a class="el" href="namespacedrake_1_1geometry.html#ac53cb597123131fb23a7af26e8d350bf" title="Type used to identify geometry sources in SceneGraph.">geometry::SourceId</a>. At <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>, MultibodyPlant will declare input/output ports as appropriate to communicate with the SceneGraph instance on which registrations took place. All geometry registration <b>must</b> be performed pre-finalize.</p>
<p>Multibodyplant declares an input port for geometric queries, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aecfca4e84a8ed96fb3004ff979e89154" title="Returns a constant reference to the input port used to perform geometric queries on a SceneGraph.">get_geometry_query_input_port()</a>. If MultibodyPlant registers geometry with a SceneGraph via calls to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac9b4f41a4f2575707d43ea031ce5a9ea" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for the contact modeling o...">RegisterCollisionGeometry()</a>, users may use this port for geometric queries. Users must connect this input port to the output port for geometric queries of the SceneGraph used for registration, which can be obtained with SceneGraph::get_query_output_port(). In summary, if MultibodyPlant registers collision geometry, the setup process will include:</p>
<ol type="1">
<li>Call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4a6d28ce9c8119bee923e827eb6f02ed" title="Registers this plant to serve as a source for an instance of SceneGraph.">RegisterAsSourceForSceneGraph()</a>.</li>
<li>Calls to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac9b4f41a4f2575707d43ea031ce5a9ea" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for the contact modeling o...">RegisterCollisionGeometry()</a>, as many as needed.</li>
<li>Call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>, user is done specifying the model.</li>
<li>Connect SceneGraph::get_query_output_port() to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aecfca4e84a8ed96fb3004ff979e89154" title="Returns a constant reference to the input port used to perform geometric queries on a SceneGraph.">get_geometry_query_input_port()</a>.</li>
</ol>
<p>Refer to the documentation provided in each of the methods above for further details. <a class="anchor" id="accessing_contact_properties"></a></p><h4>Accessing point contact parameters</h4>
<p>MultibodyPlant's point contact model looks for model parameters stored as <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html" title="The set of properties for geometry used in a proximity role.">geometry::ProximityProperties</a> by <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">geometry::SceneGraph</a>. These properties can be obtained before or after context creation through <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">geometry::SceneGraphInspector</a> APIs as outlined below. MultibodyPlant expects the following properties for point contact modeling:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Group name  </th><th class="markdownTableHeadCenter">Property Name  </th><th class="markdownTableHeadCenter">Required  </th><th class="markdownTableHeadCenter">Property Type  </th><th class="markdownTableHeadLeft">Property Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">material  </td><td class="markdownTableBodyCenter">coulomb_friction  </td><td class="markdownTableBodyCenter">yes¹  </td><td class="markdownTableBodyCenter">CoulombFriction&lt;T&gt;  </td><td class="markdownTableBodyLeft">Static and Dynamic friction.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">material  </td><td class="markdownTableBodyCenter">point_contact_stiffness  </td><td class="markdownTableBodyCenter">no²  </td><td class="markdownTableBodyCenter">T  </td><td class="markdownTableBodyLeft">Penalty method stiffness.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">material  </td><td class="markdownTableBodyCenter">hunt_crossley_dissipation  </td><td class="markdownTableBodyCenter">no²  </td><td class="markdownTableBodyCenter">T  </td><td class="markdownTableBodyLeft">Penalty method dissipation.   </td></tr>
</table>
<p>¹ Collision geometry is required to be registered with a <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html" title="The set of properties for geometry used in a proximity role.">geometry::ProximityProperties</a> object that contains the ("material", "coulomb_friction") property. If the property is missing, MultibodyPlant will throw an exeception.</p>
<p>² If the property is missing, MultibodyPlant will use a heuristic value as the default. Refer to the section <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_penalty_method">Penalty method point contact</a> for further details.</p>
<p>Accessing and modifying contact properties requires interfacing with <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">geometry::SceneGraph</a>'s model inspector. Interfacing with a model inspector obtained from <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">geometry::SceneGraph</a> will provide the default registered values for a given parameter. These are the values that will initially appear in a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">systems::Context</a> created by <a class="el" href="classdrake_1_1systems_1_1_system.html#ad047317ab91889c6743d5e47a64c7f08" title="This convenience method allocates a context using AllocateContext() and sets its default values using...">CreateDefaultContext()</a>. Subsequently, true system paramters can be accessed and changed through a <a class="el" href="classdrake_1_1systems_1_1_context.html" title="Context is an abstract class template that represents all the typed values that are used in a System&#39;...">systems::Context</a> once available. For both of the above cases, proximity properties are accessed through <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">geometry::SceneGraphInspector</a> APIs.</p>
<p>Before context creation an inspector can be retrieved directly from SceneGraph as: </p><div class="fragment"><div class="line"><span class="comment">// For a SceneGraph&lt;T&gt; instance called scene_graph.</span></div><div class="line"><span class="keyword">const</span> geometry::SceneGraphInspector&lt;T&gt;&amp; inspector =</div><div class="line">    scene_graph.model_inspector();</div></div><!-- fragment --><p> After context creation, an inspector can be retrieved from the state stored in the context by the plant's geometry query input port: </p><div class="fragment"><div class="line"><span class="comment">// For a MultibodyPlant&lt;T&gt; instance called mbp and a</span></div><div class="line"><span class="comment">// Context&lt;T&gt; called context.</span></div><div class="line"><span class="keyword">const</span> geometry::QueryObject&lt;T&gt;&amp; query_object =</div><div class="line">    mbp.get_geometry_query_input_port()</div><div class="line">        .template Eval&lt;geometry::QueryObject&lt;T&gt;&gt;(context);</div><div class="line"><span class="keyword">const</span> geometry::SceneGraphInspector&lt;T&gt;&amp; inspector =</div><div class="line">    query_object.inspector();</div></div><!-- fragment --><p> Once an inspector is available, proximity properties can be retrieved as: </p><div class="fragment"><div class="line"><span class="comment">// For a body with GeometryId called geometry_id</span></div><div class="line"><span class="keyword">const</span> geometry::ProximityProperties* props =</div><div class="line">    inspector.GetProximityProperties(geometry_id);</div><div class="line"><span class="keyword">const</span> CoulombFriction&lt;T&gt;&amp; geometry_friction =</div><div class="line">    props-&gt;GetProperty&lt;CoulombFriction&lt;T&gt;&gt;(<span class="stringliteral">&quot;material&quot;</span>,</div><div class="line">                                           <span class="stringliteral">&quot;coulomb_friction&quot;</span>);</div></div><!-- fragment --><p><a class="anchor" id="mbp_adding_elements"></a></p><h3>Adding modeling elements</h3>
<p>Add multibody elements to a MultibodyPlant with methods like:</p>
<ul>
<li>Bodies: <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9f6a68c31772eaa0c855ebb44eeaa0b7" title="Creates a rigid body with the provided name and spatial inertia.">AddRigidBody()</a></li>
<li>Joints: <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a437f86026a2268c0fb06936b899ba8d7" title="This method adds a Joint of type JointType between two bodies.">AddJoint()</a></li>
<li>see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_construction">Construction</a> for more.</li>
</ul>
<p>All modeling elements <b>must</b> be added before <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> is called. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_finalize_stage">Finalize stage</a> for a discussion.</p>
<p><a class="anchor" id="mbp_modeling_contact"></a></p><h3>Modeling contact</h3>
<p>Please refer to <a class="el" href="group__drake__contacts.html">Contact Modeling in Drake</a> for details on the available approximations, setup, and considerations for a multibody simulation with frictional contact.</p>
<p><a class="anchor" id="mbp_energy_and_power"></a></p><h3>Energy and Power</h3>
<p>MultibodyPlant implements the System energy and power methods, with some limitations.</p><ul>
<li>Kinetic energy: fully implemented.</li>
<li>Potential energy and conservative power: currently include only gravity and contributions from <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> objects; potential energy from compliant contact and joint limits are not included.</li>
<li>Nonconservative power: currently includes only contributions from <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> objects; actuation and input port forces, joint damping, and dissipation from joint limits, friction, and contact dissipation are not included.</li>
</ul>
<p>See Drake issue #12942 for more discussion.</p>
<p><a class="anchor" id="mbp_finalize_stage"></a></p><h3>Finalize() stage</h3>
<p>Once the user is done adding modeling elements and registering geometry, a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> must be performed. This call will:</p><ul>
<li>Build the underlying MultibodyTree topology, see MultibodyTree::Finalize() for details,</li>
<li>declare the plant's state,</li>
<li>declare the plant's input and output ports,</li>
<li>declare input and output ports for communication with a SceneGraph.</li>
</ul>
<p><a class="anchor" id="mbp_table_of_contents"></a> <a class="anchor" id="mbp_references"></a></p><h3>References</h3>
<ul>
<li>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics algorithms. Springer.</li>
<li>[Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis and algorithms. Springer Science &amp; Business Media.</li>
<li>[Seth 2010] Seth, A., Sherman, M., Eastman, P. and Delp, S., 2010. Minimal formulation of joint motion for biomechanisms. Nonlinear dynamics, 62(1), pp.291-303.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/multibody/tree/multibody_element.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Does not allow copy, move, or assignment</div></td></tr>
<tr class="memitem:a3aeb03d90d213da4702f2dc5e484fc86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3aeb03d90d213da4702f2dc5e484fc86">MultibodyPlant</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> &amp;)=delete</td></tr>
<tr class="separator:a3aeb03d90d213da4702f2dc5e484fc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc2576d314d5baf56ad6ad593b26f9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aecc2576d314d5baf56ad6ad593b26f9f">operator=</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> &amp;)=delete</td></tr>
<tr class="separator:aecc2576d314d5baf56ad6ad593b26f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359ae04bf7eabd0461c5f12ab35fee1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a359ae04bf7eabd0461c5f12ab35fee1d">MultibodyPlant</a> (<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a359ae04bf7eabd0461c5f12ab35fee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f43a6f72128af8e926d32c37ed7580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af4f43a6f72128af8e926d32c37ed7580">operator=</a> (<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:af4f43a6f72128af8e926d32c37ed7580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input and output ports</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="mbp_input_and_output_ports"></a> These methods provide access to the Drake <a class="el" href="classdrake_1_1systems_1_1_system.html">System</a> input and output ports as depicted in the <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> class documentation.</p>
<p>Actuation values can be provided through a single input port which describes the entire plant (in the case where only a single model instance has actuated dofs), or through multiple input ports which each provide the actuation values for a specific model instance. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af528f7747dc75227fdec76aba89e7d2b" title="Creates and adds a JointActuator model for an actuator acting on a given joint.">AddJointActuator()</a> and <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8601c026e9807127b4dd41e7585d2cfc" title="Returns the number of joint actuators in the model.">num_actuators()</a>.</p>
<p>Output ports provide information about the entire MultibodyPlant or its individual model instances. </p>
</div></td></tr>
<tr class="memitem:aea0f8aca5f15e90f11e14602b3ba7068"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aea0f8aca5f15e90f11e14602b3ba7068">get_body_poses_output_port</a> () const</td></tr>
<tr class="memdesc:aea0f8aca5f15e90f11e14602b3ba7068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output port of all body poses in the world frame.  <a href="#aea0f8aca5f15e90f11e14602b3ba7068">More...</a><br /></td></tr>
<tr class="separator:aea0f8aca5f15e90f11e14602b3ba7068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc63dd8f7d1461b1f6a263003ab4f819"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#afc63dd8f7d1461b1f6a263003ab4f819">get_body_spatial_velocities_output_port</a> () const</td></tr>
<tr class="memdesc:afc63dd8f7d1461b1f6a263003ab4f819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output port of all body spatial velocities in the world frame.  <a href="#afc63dd8f7d1461b1f6a263003ab4f819">More...</a><br /></td></tr>
<tr class="separator:afc63dd8f7d1461b1f6a263003ab4f819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665427ce00158743b848918b19efbc9f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a665427ce00158743b848918b19efbc9f">get_body_spatial_accelerations_output_port</a> () const</td></tr>
<tr class="memdesc:a665427ce00158743b848918b19efbc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output port of all body spatial accelerations in the world frame.  <a href="#a665427ce00158743b848918b19efbc9f">More...</a><br /></td></tr>
<tr class="separator:a665427ce00158743b848918b19efbc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9e7974ae1d996a6ca3430893bd5df2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8c9e7974ae1d996a6ca3430893bd5df2">get_actuation_input_port</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a8c9e7974ae1d996a6ca3430893bd5df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the input port for external actuation for a specific model instance.  <a href="#a8c9e7974ae1d996a6ca3430893bd5df2">More...</a><br /></td></tr>
<tr class="separator:a8c9e7974ae1d996a6ca3430893bd5df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc1d71e6c2e91fcd215105ae4ed01e4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1cc1d71e6c2e91fcd215105ae4ed01e4">get_actuation_input_port</a> () const</td></tr>
<tr class="memdesc:a1cc1d71e6c2e91fcd215105ae4ed01e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the input port for external actuation for the case where only one model instance has actuated dofs.  <a href="#a1cc1d71e6c2e91fcd215105ae4ed01e4">More...</a><br /></td></tr>
<tr class="separator:a1cc1d71e6c2e91fcd215105ae4ed01e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af393d5659ac9a8807671a1efc0d78a5c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af393d5659ac9a8807671a1efc0d78a5c">get_applied_generalized_force_input_port</a> () const</td></tr>
<tr class="memdesc:af393d5659ac9a8807671a1efc0d78a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the vector-valued input port for applied generalized forces, and the vector will be added directly into <code>tau</code> (see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_equations_of_motion">System dynamics</a>).  <a href="#af393d5659ac9a8807671a1efc0d78a5c">More...</a><br /></td></tr>
<tr class="separator:af393d5659ac9a8807671a1efc0d78a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ad1faa7547d440f008cdddd32d85e8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab2ad1faa7547d440f008cdddd32d85e8">get_applied_spatial_force_input_port</a> () const</td></tr>
<tr class="memdesc:ab2ad1faa7547d440f008cdddd32d85e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the input port for applying spatial forces to bodies in the plant.  <a href="#ab2ad1faa7547d440f008cdddd32d85e8">More...</a><br /></td></tr>
<tr class="separator:ab2ad1faa7547d440f008cdddd32d85e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfca4e84a8ed96fb3004ff979e89154"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aecfca4e84a8ed96fb3004ff979e89154">get_geometry_query_input_port</a> () const</td></tr>
<tr class="memdesc:aecfca4e84a8ed96fb3004ff979e89154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the input port used to perform geometric queries on a SceneGraph.  <a href="#aecfca4e84a8ed96fb3004ff979e89154">More...</a><br /></td></tr>
<tr class="separator:aecfca4e84a8ed96fb3004ff979e89154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e8834bd252d1265e99b8ac85fad0b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ad4e8834bd252d1265e99b8ac85fad0b5">get_state_output_port</a> () const</td></tr>
<tr class="memdesc:ad4e8834bd252d1265e99b8ac85fad0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the output port for the multibody state x = [q, v] of the model.  <a href="#ad4e8834bd252d1265e99b8ac85fad0b5">More...</a><br /></td></tr>
<tr class="separator:ad4e8834bd252d1265e99b8ac85fad0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00693ff4108f9634a03e5799c9306428"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a00693ff4108f9634a03e5799c9306428">get_state_output_port</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a00693ff4108f9634a03e5799c9306428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the output port for the state xᵢ = [qᵢ vᵢ] of model instance i.  <a href="#a00693ff4108f9634a03e5799c9306428">More...</a><br /></td></tr>
<tr class="separator:a00693ff4108f9634a03e5799c9306428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4023fdbc98667217be9f14a5073a87cf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4023fdbc98667217be9f14a5073a87cf">get_generalized_acceleration_output_port</a> () const</td></tr>
<tr class="memdesc:a4023fdbc98667217be9f14a5073a87cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the output port for generalized accelerations v̇ of the model.  <a href="#a4023fdbc98667217be9f14a5073a87cf">More...</a><br /></td></tr>
<tr class="separator:a4023fdbc98667217be9f14a5073a87cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e127b9f8310b3eeb8a82b40c5d80114"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a7e127b9f8310b3eeb8a82b40c5d80114">get_generalized_acceleration_output_port</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a7e127b9f8310b3eeb8a82b40c5d80114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the output port for the generalized accelerations v̇ᵢ ⊆ v̇ for model instance i.  <a href="#a7e127b9f8310b3eeb8a82b40c5d80114">More...</a><br /></td></tr>
<tr class="separator:a7e127b9f8310b3eeb8a82b40c5d80114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df9a2d4c286d8da80719d8ed314fcdc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8df9a2d4c286d8da80719d8ed314fcdc">get_generalized_contact_forces_output_port</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a8df9a2d4c286d8da80719d8ed314fcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the output port of generalized contact forces for a specific model instance.  <a href="#a8df9a2d4c286d8da80719d8ed314fcdc">More...</a><br /></td></tr>
<tr class="separator:a8df9a2d4c286d8da80719d8ed314fcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b03afbfe072f83e3681cf9798121eb2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5b03afbfe072f83e3681cf9798121eb2">get_reaction_forces_output_port</a> () const</td></tr>
<tr class="memdesc:a5b03afbfe072f83e3681cf9798121eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the port for joint reaction forces.  <a href="#a5b03afbfe072f83e3681cf9798121eb2">More...</a><br /></td></tr>
<tr class="separator:a5b03afbfe072f83e3681cf9798121eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f63e059613961ba0abb2c1c4532e7c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aa6f63e059613961ba0abb2c1c4532e7c">get_contact_results_output_port</a> () const</td></tr>
<tr class="memdesc:aa6f63e059613961ba0abb2c1c4532e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the port that outputs <a class="el" href="classdrake_1_1multibody_1_1_contact_results.html" title="A container class storing the contact results information for each contact pair for a given state of ...">ContactResults</a>.  <a href="#aa6f63e059613961ba0abb2c1c4532e7c">More...</a><br /></td></tr>
<tr class="separator:aa6f63e059613961ba0abb2c1c4532e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f20f6e2e2de42a5225e86baff2ca0e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1f20f6e2e2de42a5225e86baff2ca0e5">get_geometry_poses_output_port</a> () const</td></tr>
<tr class="memdesc:a1f20f6e2e2de42a5225e86baff2ca0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output port of frames' poses to communicate with a SceneGraph.  <a href="#a1f20f6e2e2de42a5225e86baff2ca0e5">More...</a><br /></td></tr>
<tr class="separator:a1f20f6e2e2de42a5225e86baff2ca0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="mbp_construction"></a> To add modeling elements like bodies, joints, force elements, constraints, etc. to a MultibodyPlant, use one of the following construction methods. Once <em>all</em> modeling elements have been added, the <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> method <b>must</b> be called. A call to any construction method <b>after</b> a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> causes an exception to be thrown. After calling <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>, you may invoke MultibodyPlant methods that perform computations. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> for details. </p>
</div></td></tr>
<tr class="memitem:a3296be9fa9bc35e6639460f54029c4c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3296be9fa9bc35e6639460f54029c4c9">MultibodyPlant</a> (double <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8daceb7a3c384d6ad9f305e42b5fc1c6">time_step</a>)</td></tr>
<tr class="memdesc:a3296be9fa9bc35e6639460f54029c4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor creates a plant with a single "world" body.  <a href="#a3296be9fa9bc35e6639460f54029c4c9">More...</a><br /></td></tr>
<tr class="separator:a3296be9fa9bc35e6639460f54029c4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912adb84c4940893eb4634155e6e7e8b"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a912adb84c4940893eb4634155e6e7e8b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a912adb84c4940893eb4634155e6e7e8b">MultibodyPlant</a> (const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; U &gt; &amp;other)</td></tr>
<tr class="memdesc:a912adb84c4940893eb4634155e6e7e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar-converting copy constructor. See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a>.  <a href="#a912adb84c4940893eb4634155e6e7e8b">More...</a><br /></td></tr>
<tr class="separator:a912adb84c4940893eb4634155e6e7e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6a68c31772eaa0c855ebb44eeaa0b7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9f6a68c31772eaa0c855ebb44eeaa0b7">AddRigidBody</a> (const std::string &amp;name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; double &gt; &amp;M_BBo_B)</td></tr>
<tr class="memdesc:a9f6a68c31772eaa0c855ebb44eeaa0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid body with the provided name and spatial inertia.  <a href="#a9f6a68c31772eaa0c855ebb44eeaa0b7">More...</a><br /></td></tr>
<tr class="separator:a9f6a68c31772eaa0c855ebb44eeaa0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461a59b672f8c3f7c0dcc5caed56d245"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a461a59b672f8c3f7c0dcc5caed56d245">AddRigidBody</a> (const std::string &amp;name, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; double &gt; &amp;M_BBo_B)</td></tr>
<tr class="memdesc:a461a59b672f8c3f7c0dcc5caed56d245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid body with the provided name and spatial inertia.  <a href="#a461a59b672f8c3f7c0dcc5caed56d245">More...</a><br /></td></tr>
<tr class="separator:a461a59b672f8c3f7c0dcc5caed56d245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474c90a0b3e4f9349533207026413186"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class FrameType&gt; </td></tr>
<tr class="memitem:a474c90a0b3e4f9349533207026413186"><td class="memTemplItemLeft" align="right" valign="top">const FrameType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a474c90a0b3e4f9349533207026413186">AddFrame</a> (std::unique_ptr&lt; FrameType&lt; T &gt;&gt; frame)</td></tr>
<tr class="memdesc:a474c90a0b3e4f9349533207026413186"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method adds a <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame),...">Frame</a> of type <code>FrameType&lt;T&gt;</code>.  <a href="#a474c90a0b3e4f9349533207026413186">More...</a><br /></td></tr>
<tr class="separator:a474c90a0b3e4f9349533207026413186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437f86026a2268c0fb06936b899ba8d7"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename Scalar &gt; class JointType&gt; </td></tr>
<tr class="memitem:a437f86026a2268c0fb06936b899ba8d7"><td class="memTemplItemLeft" align="right" valign="top">const JointType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a437f86026a2268c0fb06936b899ba8d7">AddJoint</a> (std::unique_ptr&lt; JointType&lt; T &gt;&gt; joint)</td></tr>
<tr class="memdesc:a437f86026a2268c0fb06936b899ba8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method adds a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <code>JointType</code> between two bodies.  <a href="#a437f86026a2268c0fb06936b899ba8d7">More...</a><br /></td></tr>
<tr class="separator:a437f86026a2268c0fb06936b899ba8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578a71ed3566fd2589958f5ed05f9c2e"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class JointType, typename... Args&gt; </td></tr>
<tr class="memitem:a578a71ed3566fd2589958f5ed05f9c2e"><td class="memTemplItemLeft" align="right" valign="top">const JointType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a578a71ed3566fd2589958f5ed05f9c2e">AddJoint</a> (const std::string &amp;name, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;parent, const std::optional&lt; <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt;&gt; &amp;X_PF, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;child, const std::optional&lt; <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt;&gt; &amp;X_BM, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a578a71ed3566fd2589958f5ed05f9c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method adds a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <code>JointType</code> between two bodies.  <a href="#a578a71ed3566fd2589958f5ed05f9c2e">More...</a><br /></td></tr>
<tr class="separator:a578a71ed3566fd2589958f5ed05f9c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff819644b0d96ba73c9dddebc673ba64"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html">WeldJoint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aff819644b0d96ba73c9dddebc673ba64">WeldFrames</a> (const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;B, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;X_AB=<a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt;::Identity())</td></tr>
<tr class="memdesc:aff819644b0d96ba73c9dddebc673ba64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Welds frames A and B with relative pose <code>X_AB</code>.  <a href="#aff819644b0d96ba73c9dddebc673ba64">More...</a><br /></td></tr>
<tr class="separator:aff819644b0d96ba73c9dddebc673ba64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48009c793b01c5a6dd079d33265435a3"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename Scalar &gt; class ForceElementType, typename... Args&gt; </td></tr>
<tr class="memitem:a48009c793b01c5a6dd079d33265435a3"><td class="memTemplItemLeft" align="right" valign="top">const ForceElementType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a48009c793b01c5a6dd079d33265435a3">AddForceElement</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a48009c793b01c5a6dd079d33265435a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new force element model of type <code>ForceElementType</code> to <code>this</code> MultibodyPlant.  <a href="#a48009c793b01c5a6dd079d33265435a3">More...</a><br /></td></tr>
<tr class="separator:a48009c793b01c5a6dd079d33265435a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af528f7747dc75227fdec76aba89e7d2b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af528f7747dc75227fdec76aba89e7d2b">AddJointActuator</a> (const std::string &amp;name, const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;joint, double effort_limit=std::numeric_limits&lt; double &gt;::infinity())</td></tr>
<tr class="memdesc:af528f7747dc75227fdec76aba89e7d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and adds a <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> model for an actuator acting on a given <code>joint</code>.  <a href="#af528f7747dc75227fdec76aba89e7d2b">More...</a><br /></td></tr>
<tr class="separator:af528f7747dc75227fdec76aba89e7d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edf1daa65069a26255c903b02bce4c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4edf1daa65069a26255c903b02bce4c6">AddModelInstance</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a4edf1daa65069a26255c903b02bce4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new model instance.  <a href="#a4edf1daa65069a26255c903b02bce4c6">More...</a><br /></td></tr>
<tr class="separator:a4edf1daa65069a26255c903b02bce4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fee61d7a783cade1a3d07fe86284d27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27">Finalize</a> ()</td></tr>
<tr class="memdesc:a8fee61d7a783cade1a3d07fe86284d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method must be called after all elements in the model (joints, bodies, force elements, constraints, etc.) are added and before any computations are performed.  <a href="#a8fee61d7a783cade1a3d07fe86284d27">More...</a><br /></td></tr>
<tr class="separator:a8fee61d7a783cade1a3d07fe86284d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Geometry</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="mbp_geometry"></a></p>
<p>The following geometry methods provide a convenient means for associating geometries with bodies. Ultimately, the geometries are owned by <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">SceneGraph</a>. These methods do the work of registering the requested geometries with SceneGraph and maintaining a mapping between the body and the registered data. Particularly, SceneGraph knows nothing about the concepts inherent in the MultibodyPlant. These methods account for those differences as documented below.</p>
<h4>Geometry registration with roles</h4>
<p>Geometries can be associated with bodies via the <code>RegisterFooGeometry</code> family of methods. In SceneGraph, geometries have <a class="el" href="group__geometry__roles.html">roles</a>. The <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac9b4f41a4f2575707d43ea031ce5a9ea" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for the contact modeling o...">RegisterCollisionGeometry()</a></code> methods register geometry with SceneGraph and assign it the proximity role. The <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac2ae40642e0504217ada31209e1ecb80" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for visualization of a giv...">RegisterVisualGeometry()</a></code> methods do the same, but assign the illustration role.</p>
<p>All geometry registration methods return a <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> GeometryId. This is how SceneGraph refers to the geometries. The properties of an individual geometry can be accessed with its id and <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">geometry::SceneGraphInspector</a> and <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry.">geometry::QueryObject</a> (for its state-dependent pose in world).</p>
<h4>Body frames and SceneGraph frames</h4>
<p>The first time a geometry registration method is called on a particular body, that body's frame B is registered with SceneGraph. As SceneGraph knows nothing about bodies, in the SceneGraph domain, the frame is simply notated as F; this is merely an alias for the body frame. Thus, the pose of the geometry G in the SceneGraph frame F is the same as the pose of the geometry in the body frame B; <code>X_FG = X_BG</code>.</p>
<p>The model instance index of the body is passed to the SceneGraph frame as its "frame group". This can be retrieved from the geometry::SceneGraphInspector::GetFrameGroup(FrameId) method.</p>
<p>Given a GeometryId, SceneGraph cannot report what <em>body</em> it is affixed to. It can only report the SceneGraph alias frame F. But the following idiom can report the body:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MultibodyPlant&lt;T&gt;&amp; plant = ...;</div><div class="line"><span class="keyword">const</span> SceneGraphInspector&lt;T&gt;&amp; inspector =  ...;</div><div class="line"><span class="keyword">const</span> GeometryId g_id = id_from_some_query;</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> f_id = inspector.GetFrameId(g_id);</div><div class="line"><span class="keyword">const</span> Body&lt;T&gt;* body = plant.GetBodyFromFrameId(f_id);</div></div><!-- fragment --><p> See documentation of <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">geometry::SceneGraphInspector</a> on where to get an inspector.</p>
<p>In MultibodyPlant, frame names only have to be unique in a single model instance. However, SceneGraph knows nothing of model instances. So, to generate unique names for the corresponding frames in SceneGraph, when MultibodyPlant registers the corresponding SceneGraph frame, it is named with a "scoped name". This is a concatenation of <code>[model instance name]::[body name]</code>. Searching for a frame with just the name <code>body name</code> will fail. (See <a class="el" href="classdrake_1_1multibody_1_1_body.html#ad8227ba86a01f26e4f173cd5e219d5d1" title="Gets the name associated with this body.">Body::name()</a> and <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab99be499eb59f00037b05ec60b51e177" title="Returns the name of a model_instance.">GetModelInstanceName()</a> for those values.) </p>
</div></td></tr>
<tr class="memitem:a4a6d28ce9c8119bee923e827eb6f02ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry.html#ac53cb597123131fb23a7af26e8d350bf">geometry::SourceId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4a6d28ce9c8119bee923e827eb6f02ed">RegisterAsSourceForSceneGraph</a> (<a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *scene_graph)</td></tr>
<tr class="memdesc:a4a6d28ce9c8119bee923e827eb6f02ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers <code>this</code> plant to serve as a source for an instance of SceneGraph.  <a href="#a4a6d28ce9c8119bee923e827eb6f02ed">More...</a><br /></td></tr>
<tr class="separator:a4a6d28ce9c8119bee923e827eb6f02ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ae40642e0504217ada31209e1ecb80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac2ae40642e0504217ada31209e1ecb80">RegisterVisualGeometry</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;X_BG, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const std::string &amp;name, const <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html">geometry::IllustrationProperties</a> &amp;properties)</td></tr>
<tr class="memdesc:ac2ae40642e0504217ada31209e1ecb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers geometry in a SceneGraph with a given <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications.">geometry::Shape</a> to be used for visualization of a given <code>body</code>.  <a href="#ac2ae40642e0504217ada31209e1ecb80">More...</a><br /></td></tr>
<tr class="separator:ac2ae40642e0504217ada31209e1ecb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31bebf1580d051c3a2e243c9b511175"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ad31bebf1580d051c3a2e243c9b511175">RegisterVisualGeometry</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;X_BG, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const std::string &amp;name, const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; double &gt; &amp;diffuse_color)</td></tr>
<tr class="memdesc:ad31bebf1580d051c3a2e243c9b511175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for visual geometry registration; it converts the <code>diffuse_color</code> (RGBA with values in the range [0, 1]) into a <a class="el" href="group__visualization.html#ga20c8d0e933cfdd8684cf77b15d8bef15" title="Extends a Diagram with the required components to interface with drake_visualizer.">geometry::ConnectDrakeVisualizer()</a>-compatible set of <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role.">geometry::IllustrationProperties</a>.  <a href="#ad31bebf1580d051c3a2e243c9b511175">More...</a><br /></td></tr>
<tr class="separator:ad31bebf1580d051c3a2e243c9b511175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27da771f6b43d4944b33dc6d6338f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ad27da771f6b43d4944b33dc6d6338f8e">RegisterVisualGeometry</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;X_BG, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const std::string &amp;name)</td></tr>
<tr class="memdesc:ad27da771f6b43d4944b33dc6d6338f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for visual geometry registration; it relies on the downstream <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role.">geometry::IllustrationProperties</a> <em>consumer</em> to provide default parameter values (see <a class="el" href="group__geometry__roles.html">Geometry Queries and Roles</a> for details).  <a href="#ad27da771f6b43d4944b33dc6d6338f8e">More...</a><br /></td></tr>
<tr class="separator:ad27da771f6b43d4944b33dc6d6338f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad289f0686c9d29d3f5b4ca360947c6f1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ad289f0686c9d29d3f5b4ca360947c6f1">GetVisualGeometriesForBody</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:ad289f0686c9d29d3f5b4ca360947c6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of GeometryId's identifying the different visual geometries for <code>body</code> previously registered with a SceneGraph.  <a href="#ad289f0686c9d29d3f5b4ca360947c6f1">More...</a><br /></td></tr>
<tr class="separator:ad289f0686c9d29d3f5b4ca360947c6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b4f41a4f2575707d43ea031ce5a9ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac9b4f41a4f2575707d43ea031ce5a9ea">RegisterCollisionGeometry</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;X_BG, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const std::string &amp;name, <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">geometry::ProximityProperties</a> properties)</td></tr>
<tr class="memdesc:ac9b4f41a4f2575707d43ea031ce5a9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers geometry in a SceneGraph with a given <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications.">geometry::Shape</a> to be used for the contact modeling of a given <code>body</code>.  <a href="#ac9b4f41a4f2575707d43ea031ce5a9ea">More...</a><br /></td></tr>
<tr class="separator:ac9b4f41a4f2575707d43ea031ce5a9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602bd19cfdb283686f9051b674611baa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a602bd19cfdb283686f9051b674611baa">RegisterCollisionGeometry</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;X_BG, const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;shape, const std::string &amp;name, const <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; double &gt; &amp;coulomb_friction)</td></tr>
<tr class="memdesc:a602bd19cfdb283686f9051b674611baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload which specifies a single property: coulomb_friction.  <a href="#a602bd19cfdb283686f9051b674611baa">More...</a><br /></td></tr>
<tr class="separator:a602bd19cfdb283686f9051b674611baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2b21ccb8a93f1929cdec2dc19a6b7f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#acb2b21ccb8a93f1929cdec2dc19a6b7f">GetCollisionGeometriesForBody</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:acb2b21ccb8a93f1929cdec2dc19a6b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array of GeometryId's identifying the different contact geometries for <code>body</code> previously registered with a SceneGraph.  <a href="#acb2b21ccb8a93f1929cdec2dc19a6b7f">More...</a><br /></td></tr>
<tr class="separator:acb2b21ccb8a93f1929cdec2dc19a6b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41edc1b3c920a1e48f27ad5661584fad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a41edc1b3c920a1e48f27ad5661584fad">ExcludeCollisionGeometriesWithCollisionFilterGroupPair</a> (const std::pair&lt; std::string, <a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">geometry::GeometrySet</a> &gt; &amp;collision_filter_group_a, const std::pair&lt; std::string, <a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">geometry::GeometrySet</a> &gt; &amp;collision_filter_group_b)</td></tr>
<tr class="memdesc:a41edc1b3c920a1e48f27ad5661584fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Excludes the collision geometries between two given collision filter groups.  <a href="#a41edc1b3c920a1e48f27ad5661584fad">More...</a><br /></td></tr>
<tr class="separator:a41edc1b3c920a1e48f27ad5661584fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830e17ff113f70e86e1c6a8b1b60d662"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">geometry::GeometrySet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a830e17ff113f70e86e1c6a8b1b60d662">CollectRegisteredGeometries</a> (const std::vector&lt; const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; * &gt; &amp;bodies) const</td></tr>
<tr class="memdesc:a830e17ff113f70e86e1c6a8b1b60d662"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each of the provided <code>bodies</code>, collects up all geometries that have been registered to that body.  <a href="#a830e17ff113f70e86e1c6a8b1b60d662">More...</a><br /></td></tr>
<tr class="separator:a830e17ff113f70e86e1c6a8b1b60d662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf36bc0dadc3f1e72bc17072c5f9e4f2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#adf36bc0dadc3f1e72bc17072c5f9e4f2">GetBodyFromFrameId</a> (<a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">geometry::FrameId</a> frame_id) const</td></tr>
<tr class="memdesc:adf36bc0dadc3f1e72bc17072c5f9e4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a geometry frame identifier, returns a pointer to the body associated with that id (nullptr if there is no such body).  <a href="#adf36bc0dadc3f1e72bc17072c5f9e4f2">More...</a><br /></td></tr>
<tr class="separator:adf36bc0dadc3f1e72bc17072c5f9e4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5705fe2856b52119e1d713213ae3300"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">geometry::FrameId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aa5705fe2856b52119e1d713213ae3300">GetBodyFrameIdIfExists</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_index) const</td></tr>
<tr class="memdesc:aa5705fe2856b52119e1d713213ae3300"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the body with <code>body_index</code> belongs to the called plant, it returns the <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb" title="Type used to identify geometry frames in SceneGraph.">geometry::FrameId</a> associated with it.  <a href="#aa5705fe2856b52119e1d713213ae3300">More...</a><br /></td></tr>
<tr class="separator:aa5705fe2856b52119e1d713213ae3300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcdcb4e7798a5aef9bc3111402dfa5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">geometry::FrameId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#afdcdcb4e7798a5aef9bc3111402dfa5e">GetBodyFrameIdOrThrow</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_index) const</td></tr>
<tr class="memdesc:afdcdcb4e7798a5aef9bc3111402dfa5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the body with <code>body_index</code> belongs to the called plant, it returns the <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb" title="Type used to identify geometry frames in SceneGraph.">geometry::FrameId</a> associated with it.  <a href="#afdcdcb4e7798a5aef9bc3111402dfa5e">More...</a><br /></td></tr>
<tr class="separator:afdcdcb4e7798a5aef9bc3111402dfa5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Contact modeling</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="mbp_contact_modeling"></a> Use methods in this section to choose the contact model and to provide parameters for that model. Currently Drake supports an advanced compliant contact model we call <em>Hydroelastic contact</em> that is still experimental, and a penalty-based point contact model as a reliable fallback.</p>
<p><a class="anchor" id="mbp_hydroelastic_materials_properties"></a></p><h4>Hydroelastic contact</h4>
<p>To understand how material properties enter into the modeling of contact traction in the hydroelastic model, the user is referred to [R. Elandt 2019] for details. For brevity, here we limit ourselves to state the relationship between the material properties and the computation of the normal traction or "pressure" <code>p(x)</code> at each point <code>x</code> in the contact patch. Given two bodies A and B, with elastic moduli <code>Eᵃ</code> and <code>Eᵇ</code> respectively and dissipation <code>dᵃ</code> and <code>dᵇ</code> respectively, we define the effective material properties of the pair according to: </p><pre>
  E = Eᵃ⋅Eᵇ/(Eᵃ + Eᵇ),
  d = E/Eᵃ⋅dᵃ + E/Eᵇ⋅dᵇ = Eᵇ/(Eᵃ+Eᵇ)⋅dᵃ + Eᵃ/(Eᵃ+Eᵇ)⋅dᵇ
</pre><p> The effective modulus of elasticity is computed in accordance with the Hertz theory of contact. Dissipation is weighted in accordance with the fact that the softer material will deform more and faster and thus the softer material dissipation is given more importance. Elastic modulus has units of pressure, i.e. <code>Pa (N/m²)</code>. The elastic modulus is often estimated based on the Young's modulus of the material though in the hydroelastic model it represents an effective elastic property. For instance, [R. Elandt 2019] chooses to use <code>E = G</code>, with <code>G</code> the P-wave elastic modulus <code>G = (1-ν)/(1+ν)/(1-2ν)E</code>, with ν the Poisson ratio, consistent with the theory of layered solids in which plane sections remain planar after compression. Another possibility is to specify <code>E = E*</code>, with <code>E*</code> the effective elastic modulus given by the Hertz theory of contact, <code>E* = E/(1-ν²)</code>. In all of these cases a sound estimation of <code>elastic_modulus</code> starts with the Young's modulus of the material.</p>
<p>We use a dissipation model inspired by the model in [Hunt and Crossley, 1975], parameterized by a dissipation constant with units of inverse of velocity, i.e. <code>s/m</code>.</p>
<p>The elastic modulus and dissipation can be specified in one of two ways:</p>
<ul>
<li>define them in an instance of <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html" title="The set of properties for geometry used in a proximity role.">geometry::ProximityProperties</a> using the function <a class="el" href="namespacedrake_1_1geometry.html#a75b8bc3ef835424639b5aa5e0874121b">geometry::AddContactMaterial()</a>, or</li>
<li>define them in an input URDF/SDF as detailed <a class="el" href="/media/ephemeral0/ubuntu/workspace/linux-bionic-gcc-bazel-nightly-documentation/src/doxygen_tmp/input/drake/multibody/parsing/detail_scene_graph.h.html#sdf_contact_material">here for SDF</a> or <a class="el" href="/media/ephemeral0/ubuntu/workspace/linux-bionic-gcc-bazel-nightly-documentation/src/doxygen_tmp/input/drake/multibody/parsing/detail_urdf_geometry.h.html#urdf_contact_material">here for URDF</a>.</li>
</ul>
<p>With the effective properties of the pair defined as above, the hydroelastic model pressure field is computed according to: </p><pre>
  p(x) = E⋅ε(x)⋅(1 - d⋅vₙ(x))₊
</pre><p> where we defined the effective strain: </p><pre>
  ε(x) = εᵃ(x) + εᵇ(x)
</pre><p> which relates to the quasi-static pressure field p₀(x) (i.e. when velocity is neglected) by: </p><pre>
  p₀(x) = E⋅ε(x) = Eᵃ⋅εᵃ(x) = Eᵇ⋅εᵇ(x)
</pre><p> that is, the hydroelastic model computes the contact patch assuming quasi-static equilibrium. The separation speed <code>vₙ(x)</code> is computed as the component in the direction of the contact surface's normal <code>n̂(x)</code> of the relative velocity between points <code>Ax</code> and <code>Bx</code> at point <code>x</code> instantaneously moving with body frames A and B respectively, i.e. <code>vₙ(x) = ᴬˣvᴮˣ⋅n̂(x)</code>, where the normal <code>n̂(x)</code> points from body A into body B.</p>
<p>[Elandt 2019] R. Elandt, E. Drumwright, M. Sherman, and A. Ruina. A pressure field model for fast, robust approximation of net contact force and moment between nominally rigid objects. Proc. IEEE/RSJ Intl. Conf. on Intelligent Robots and Systems (IROS), 2019. [Hunt and Crossley 1975] Hunt, KH and Crossley, FRE, 1975. Coefficient of restitution interpreted as damping in vibroimpact. Journal of Applied Mechanics, vol. 42, pp. 440–445.</p>
<p><a class="anchor" id="mbp_penalty_method"></a></p><h4>Penalty method point contact</h4>
<p>Currently MultibodyPlant uses a rigid contact model that is, bodies in the model are infinitely stiff or ideal rigid bodies. Therefore, the mathematical description of the rigid contact model needs to include non-penetration constraints among bodies in the formulation. There are several numerical methods to impose and solve these constraints. In a penalty method approach, we allow for a certain amount of interpenetration and we compute contact forces according to a simple law of the form: </p><pre>
  fₙ = k(1+dẋ)x
</pre><p> where the normal contact force <code>fₙ</code> is made a continuous function of the penetration distance x between the bodies (defined to be positive when the bodies are in contact) and the penetration distance rate ẋ (with ẋ &gt; 0 meaning the penetration distance is increasing and therefore the interpenetration between the bodies is also increasing). k and d are the combined penalty method coefficients for stiffness and dissipation, given a pair of colliding geometries. For flexibility of parameterization, stiffness and dissipation are set on a per-geometry basis (<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#accessing_contact_properties">accessing_contact_properties</a>). Given two geometries with individual stiffness and dissipation parameters (k₁, d₁) and (k₂, d₂), we define the rule for combined stiffness (k) and dissipation (d) as: </p><pre>
    k = (k₁⋅k₂)/(k₁+k₂)
    d = (k₂/(k₁+k₂))⋅d₁ + (k₁/(k₁+k₂))⋅d₂
</pre><p> These parameters are optional for each geometry. For any geometry not assigned these parameters by a user Pre-Finalize, MultibodyPlant will assign default values such that the combined parameters of two geometries with default values match those estimated using the user-supplied "penetration allowance", as described below.</p>
<p>These are ad-hoc parameters which need to be tuned as a trade-off between:</p><ul>
<li>The accuracy of the numerical approximation to rigid contact, which requires a stiffness that approaches infinity, and</li>
<li>the computational cost of the numerical integration, which will require smaller time steps for stiffer systems.</li>
</ul>
<p>There is no exact procedure for choosing these coefficients, and estimating them manually can be cumbersome since in general they will depend on the scale of the problem including masses, speeds and even body sizes. However, MultibodyPlant aids the estimation of these coefficients using a heuristic function based on a user-supplied "penetration allowance", see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8cdb3408c412b2af94476886dc35cc71" title="Sets the penetration allowance used to estimate the coefficients in the penalty method used to impose...">set_penetration_allowance()</a>. The penetration allowance is a number in meters that specifies the order of magnitude of the average penetration between bodies in the system that the user is willing to accept as reasonable for the problem being solved. For instance, in the robotics manipulation of ordinary daily objects the user might set this number to 1 millimeter. However, the user might want to increase it for the simulation of heavy walking robots for which an allowance of 1 millimeter would result in a very stiff system.</p>
<p>As for the dissipation coefficient in the simple law above, MultibodyPlant chooses the dissipation coefficient d to model inelastic collisions and therefore sets it so that the penetration distance x behaves as a critically damped oscillator. That is, at the limit of ideal rigid contact (very stiff penalty coefficient k or equivalently the penetration allowance goes to zero), this method behaves as a unilateral constraint on the penetration distance, which models a perfect inelastic collision. For most applications, such as manipulation and walking, this is the desired behavior.</p>
<p>When <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8cdb3408c412b2af94476886dc35cc71" title="Sets the penetration allowance used to estimate the coefficients in the penalty method used to impose...">set_penetration_allowance()</a> is called, MultibodyPlant will estimate reasonable penalty method coefficients as a function of the input penetration allowance. Users will want to run their simulation a number of times and assess they are satisfied with the level of inter-penetration actually observed in the simulation; if the observed penetration is too large, the user will want to set a smaller penetration allowance. If the system is too stiff and the time integration requires very small time steps while at the same time the user can afford larger inter-penetrations, the user will want to increase the penetration allowance. Typically, the observed penetration will be proportional to the penetration allowance. Thus scaling the penetration allowance by say a factor of 0.5, would typically results in inter-penetrations being reduced by the same factor of 0.5. In summary, users should choose the largest penetration allowance that results in inter-penetration levels that are acceptable for the particular application (even when in theory this penetration should be zero for perfectly rigid bodies.)</p>
<p>For a given penetration allowance, the contact interaction that takes two bodies with a non-zero approaching velocity to zero approaching velocity, takes place in a finite amount of time (for ideal rigid contact this time is zero.) A good estimate of this time period is given by a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3338392f611d5d9f93d0ea90e172c68c" title="Returns a time-scale estimate tc based on the requested penetration allowance δ set with set_penetrat...">get_contact_penalty_method_time_scale()</a>. Users might want to query this value to either set the maximum time step in error-controlled time integration or to set the time step for fixed time step integration. As a guidance, typical fixed time step integrators will become unstable for time steps larger than about a tenth of this time scale.</p>
<p>For further details on contact modeling in Drake, please refer to the section <a class="el" href="group__drake__contacts.html">Contact Modeling in Drake</a> of our documentation. </p>
</div></td></tr>
<tr class="memitem:ad253ab790ff8e142080cedd210e982da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ad253ab790ff8e142080cedd210e982da">set_contact_model</a> (<a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4e">ContactModel</a> model)</td></tr>
<tr class="memdesc:ad253ab790ff8e142080cedd210e982da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the contact model to be used by <code>this</code> MultibodyPlant, see ContactModel for available options.  <a href="#ad253ab790ff8e142080cedd210e982da">More...</a><br /></td></tr>
<tr class="separator:ad253ab790ff8e142080cedd210e982da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdb3408c412b2af94476886dc35cc71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8cdb3408c412b2af94476886dc35cc71">set_penetration_allowance</a> (double penetration_allowance=0.001)</td></tr>
<tr class="memdesc:a8cdb3408c412b2af94476886dc35cc71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the penetration allowance used to estimate the coefficients in the penalty method used to impose non-penetration among bodies.  <a href="#a8cdb3408c412b2af94476886dc35cc71">More...</a><br /></td></tr>
<tr class="separator:a8cdb3408c412b2af94476886dc35cc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3338392f611d5d9f93d0ea90e172c68c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3338392f611d5d9f93d0ea90e172c68c">get_contact_penalty_method_time_scale</a> () const</td></tr>
<tr class="memdesc:a3338392f611d5d9f93d0ea90e172c68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a time-scale estimate <code>tc</code> based on the requested penetration allowance δ set with <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8cdb3408c412b2af94476886dc35cc71" title="Sets the penetration allowance used to estimate the coefficients in the penalty method used to impose...">set_penetration_allowance()</a>.  <a href="#a3338392f611d5d9f93d0ea90e172c68c">More...</a><br /></td></tr>
<tr class="separator:a3338392f611d5d9f93d0ea90e172c68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce165180ba1d40e2a120eea631e4cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3ce165180ba1d40e2a120eea631e4cb1">set_stiction_tolerance</a> (double v_stiction=0.001)</td></tr>
<tr class="separator:a3ce165180ba1d40e2a120eea631e4cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">State accessors and mutators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="mbp_state_accessors_and_mutators"></a> The following state methods allow getting and setting the kinematic state variables <code>[q; v]</code>, where <code>q</code> is the vector of generalized positions and <code>v</code> is the vector of generalized velocities. The state resides in a <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a> that is supplied as the first argument to every method.</p>
<p>There are also utilities for accessing and mutating portions of state or actuation arrays corresponding to just a single model instance. </p>
</div></td></tr>
<tr class="memitem:abda564c1168979bb8422343d46925b9a"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abda564c1168979bb8422343d46925b9a">GetPositionsAndVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:abda564c1168979bb8422343d46925b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const vector reference containing the vector <code>[q; v]</code> with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities.  <a href="#abda564c1168979bb8422343d46925b9a">More...</a><br /></td></tr>
<tr class="separator:abda564c1168979bb8422343d46925b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0be270734139ba7fd908effc13dd54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#afa0be270734139ba7fd908effc13dd54">GetPositionsAndVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:afa0be270734139ba7fd908effc13dd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector <code>[q; v]</code> of the model with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities for model instance <code>model_instance</code>.  <a href="#afa0be270734139ba7fd908effc13dd54">More...</a><br /></td></tr>
<tr class="separator:afa0be270734139ba7fd908effc13dd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1036e869271ac77a82f891a5f7187210"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1036e869271ac77a82f891a5f7187210">GetMutablePositionsAndVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a1036e869271ac77a82f891a5f7187210"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns a mutable vector containing the vector <code>[q; v]</code> of the model with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities (<b>see warning</b>).  <a href="#a1036e869271ac77a82f891a5f7187210">More...</a><br /></td></tr>
<tr class="separator:a1036e869271ac77a82f891a5f7187210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f77c6666edaa725dbd5dd060d2f5b00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5f77c6666edaa725dbd5dd060d2f5b00">SetPositionsAndVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;q_v) const</td></tr>
<tr class="memdesc:a5f77c6666edaa725dbd5dd060d2f5b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all generalized positions and velocities from the given vector [q; v].  <a href="#a5f77c6666edaa725dbd5dd060d2f5b00">More...</a><br /></td></tr>
<tr class="separator:a5f77c6666edaa725dbd5dd060d2f5b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16955a0cd87697a6806d99e9d6de0651"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a16955a0cd87697a6806d99e9d6de0651">SetPositionsAndVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;q_v) const</td></tr>
<tr class="memdesc:a16955a0cd87697a6806d99e9d6de0651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets generalized positions and velocities from the given vector [q; v] for the specified model instance.  <a href="#a16955a0cd87697a6806d99e9d6de0651">More...</a><br /></td></tr>
<tr class="separator:a16955a0cd87697a6806d99e9d6de0651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b48791a474f442ccb628dc9b76a24b9"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4b48791a474f442ccb628dc9b76a24b9">GetPositions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a4b48791a474f442ccb628dc9b76a24b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const vector reference containing the vector of generalized positions.  <a href="#a4b48791a474f442ccb628dc9b76a24b9">More...</a><br /></td></tr>
<tr class="separator:a4b48791a474f442ccb628dc9b76a24b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2a085e96321a9d821551c479aed347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abe2a085e96321a9d821551c479aed347">GetPositions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:abe2a085e96321a9d821551c479aed347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an vector containing the generalized positions (<code>q</code>) for the given model instance.  <a href="#abe2a085e96321a9d821551c479aed347">More...</a><br /></td></tr>
<tr class="separator:abe2a085e96321a9d821551c479aed347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2984079483027345739f5e1bc8a19c"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ace2984079483027345739f5e1bc8a19c">GetMutablePositions</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:ace2984079483027345739f5e1bc8a19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns a mutable vector reference containing the vector of generalized positions (<b>see warning</b>).  <a href="#ace2984079483027345739f5e1bc8a19c">More...</a><br /></td></tr>
<tr class="separator:ace2984079483027345739f5e1bc8a19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91bd90e38673df63e04209d0a43e2f6"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af91bd90e38673df63e04209d0a43e2f6">GetMutablePositions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state) const</td></tr>
<tr class="memdesc:af91bd90e38673df63e04209d0a43e2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns a mutable vector reference containing the vector of generalized positions (<b>see warning</b>).  <a href="#af91bd90e38673df63e04209d0a43e2f6">More...</a><br /></td></tr>
<tr class="separator:af91bd90e38673df63e04209d0a43e2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb9f945ca5577141351e60bd45156ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abfb9f945ca5577141351e60bd45156ef">SetPositions</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;q) const</td></tr>
<tr class="memdesc:abfb9f945ca5577141351e60bd45156ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all generalized positions from the given vector.  <a href="#abfb9f945ca5577141351e60bd45156ef">More...</a><br /></td></tr>
<tr class="separator:abfb9f945ca5577141351e60bd45156ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0258f954570e8d3df3b81e5e1f6e192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0258f954570e8d3df3b81e5e1f6e192">SetPositions</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;q_instance) const</td></tr>
<tr class="memdesc:ae0258f954570e8d3df3b81e5e1f6e192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the positions for a particular model instance from the given vector.  <a href="#ae0258f954570e8d3df3b81e5e1f6e192">More...</a><br /></td></tr>
<tr class="separator:ae0258f954570e8d3df3b81e5e1f6e192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7236c8f0806c512c3d64d301a326ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1a7236c8f0806c512c3d64d301a326ee">SetPositions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;q_instance) const</td></tr>
<tr class="memdesc:a1a7236c8f0806c512c3d64d301a326ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the positions for a particular model instance from the given vector.  <a href="#a1a7236c8f0806c512c3d64d301a326ee">More...</a><br /></td></tr>
<tr class="separator:a1a7236c8f0806c512c3d64d301a326ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800453060fc1f94455dff6c07dfde2d1"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a800453060fc1f94455dff6c07dfde2d1">GetVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:a800453060fc1f94455dff6c07dfde2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const vector reference containing the generalized velocities.  <a href="#a800453060fc1f94455dff6c07dfde2d1">More...</a><br /></td></tr>
<tr class="separator:a800453060fc1f94455dff6c07dfde2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcd0c2630b23058791b7a3d6bac07a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#acbcd0c2630b23058791b7a3d6bac07a8">GetVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:acbcd0c2630b23058791b7a3d6bac07a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the generalized velocities (<code>v</code>) for the given model instance.  <a href="#acbcd0c2630b23058791b7a3d6bac07a8">More...</a><br /></td></tr>
<tr class="separator:acbcd0c2630b23058791b7a3d6bac07a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c6efdadb0dd091590e9474d9039f64"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a25c6efdadb0dd091590e9474d9039f64">GetMutableVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state) const</td></tr>
<tr class="memdesc:a25c6efdadb0dd091590e9474d9039f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Advanced) Returns a mutable vector reference containing the vector of generalized velocities (<b>see warning</b>).  <a href="#a25c6efdadb0dd091590e9474d9039f64">More...</a><br /></td></tr>
<tr class="separator:a25c6efdadb0dd091590e9474d9039f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe7c6fe93604e71b9d277b76fab5932"><td class="memItemLeft" align="right" valign="top">Eigen::VectorBlock&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a7fe7c6fe93604e71b9d277b76fab5932">GetMutableVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context) const</td></tr>
<tr class="memdesc:a7fe7c6fe93604e71b9d277b76fab5932"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a25c6efdadb0dd091590e9474d9039f64" title="(Advanced) Returns a mutable vector reference containing the vector of generalized velocities (see wa...">GetMutableVelocities()</a> method above.  <a href="#a7fe7c6fe93604e71b9d277b76fab5932">More...</a><br /></td></tr>
<tr class="separator:a7fe7c6fe93604e71b9d277b76fab5932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee483fa25d16a1ab99da1e0bface016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1ee483fa25d16a1ab99da1e0bface016">SetVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;v) const</td></tr>
<tr class="memdesc:a1ee483fa25d16a1ab99da1e0bface016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all generalized velocities from the given vector.  <a href="#a1ee483fa25d16a1ab99da1e0bface016">More...</a><br /></td></tr>
<tr class="separator:a1ee483fa25d16a1ab99da1e0bface016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae66a553c5df6ea662e219586fd306bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aae66a553c5df6ea662e219586fd306bb">SetVelocities</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;v_instance) const</td></tr>
<tr class="memdesc:aae66a553c5df6ea662e219586fd306bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the generalized velocities for a particular model instance from the given vector.  <a href="#aae66a553c5df6ea662e219586fd306bb">More...</a><br /></td></tr>
<tr class="separator:aae66a553c5df6ea662e219586fd306bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac13b1f67afe352e62d292c1bd3a6e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#acac13b1f67afe352e62d292c1bd3a6e0">SetVelocities</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;v_instance) const</td></tr>
<tr class="memdesc:acac13b1f67afe352e62d292c1bd3a6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the generalized velocities for a particular model instance from the given vector.  <a href="#acac13b1f67afe352e62d292c1bd3a6e0">More...</a><br /></td></tr>
<tr class="separator:acac13b1f67afe352e62d292c1bd3a6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73edc00d493b3f15ba7679cc14830a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae73edc00d493b3f15ba7679cc14830a0">SetDefaultState</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state) const override</td></tr>
<tr class="memdesc:ae73edc00d493b3f15ba7679cc14830a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>state</code> according to defaults set by the user for joints (e.g.  <a href="#ae73edc00d493b3f15ba7679cc14830a0">More...</a><br /></td></tr>
<tr class="separator:ae73edc00d493b3f15ba7679cc14830a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470c99c41ab31927ae50c9996786bd10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a470c99c41ab31927ae50c9996786bd10">SetRandomState</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state, <a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *generator) const override</td></tr>
<tr class="memdesc:a470c99c41ab31927ae50c9996786bd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns random values to all elements of the state, by drawing samples independently for each joint/free body (coming soon: and then solving a mathematical program to "project" these samples onto the registered system constraints).  <a href="#a470c99c41ab31927ae50c9996786bd10">More...</a><br /></td></tr>
<tr class="separator:a470c99c41ab31927ae50c9996786bd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc148ddec26f8c109c233b8b2ec1e2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1fc148ddec26f8c109c233b8b2ec1e2d">GetActuationFromArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;u) const</td></tr>
<tr class="memdesc:a1fc148ddec26f8c109c233b8b2ec1e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of actuation values for <code>model_instance</code> from a vector <code>u</code> of actuation values for the entire model.  <a href="#a1fc148ddec26f8c109c233b8b2ec1e2d">More...</a><br /></td></tr>
<tr class="separator:a1fc148ddec26f8c109c233b8b2ec1e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec851e17ae2c34da1b87a03ce85f460a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aec851e17ae2c34da1b87a03ce85f460a">SetActuationInArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;u_instance, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; u) const</td></tr>
<tr class="memdesc:aec851e17ae2c34da1b87a03ce85f460a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the actuation values <code>u_instance</code> for all actuators in <code>model_instance</code>, this method sets the actuation vector u for the entire model to which this actuator belongs to.  <a href="#aec851e17ae2c34da1b87a03ce85f460a">More...</a><br /></td></tr>
<tr class="separator:aec851e17ae2c34da1b87a03ce85f460a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8a17ef762452f820bdd351f8bb41b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9b8a17ef762452f820bdd351f8bb41b4">GetPositionsFromArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;q) const</td></tr>
<tr class="memdesc:a9b8a17ef762452f820bdd351f8bb41b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of generalized positions for <code>model_instance</code> from a vector <code>q_array</code> of generalized positions for the entire model model.  <a href="#a9b8a17ef762452f820bdd351f8bb41b4">More...</a><br /></td></tr>
<tr class="separator:a9b8a17ef762452f820bdd351f8bb41b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de72c319632f5a263fe6c9e96c70614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3de72c319632f5a263fe6c9e96c70614">SetPositionsInArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;q_instance, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; q) const</td></tr>
<tr class="memdesc:a3de72c319632f5a263fe6c9e96c70614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vector of generalized positions for <code>model_instance</code> in <code>q</code> using <code>q_instance</code>, leaving all other elements in the array untouched.  <a href="#a3de72c319632f5a263fe6c9e96c70614">More...</a><br /></td></tr>
<tr class="separator:a3de72c319632f5a263fe6c9e96c70614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f32c59d0fb31b2bb9258bd9ee86f55d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9f32c59d0fb31b2bb9258bd9ee86f55d">GetVelocitiesFromArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;v) const</td></tr>
<tr class="memdesc:a9f32c59d0fb31b2bb9258bd9ee86f55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of generalized velocities for <code>model_instance</code> from a vector <code>v</code> of generalized velocities for the entire <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> model.  <a href="#a9f32c59d0fb31b2bb9258bd9ee86f55d">More...</a><br /></td></tr>
<tr class="separator:a9f32c59d0fb31b2bb9258bd9ee86f55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e9928aa7802359eaddab6ef5d92763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a60e9928aa7802359eaddab6ef5d92763">SetVelocitiesInArray</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;v_instance, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; v) const</td></tr>
<tr class="memdesc:a60e9928aa7802359eaddab6ef5d92763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vector of generalized velocities for <code>model_instance</code> in <code>v</code> using <code>v_instance</code>, leaving all other elements in the array untouched.  <a href="#a60e9928aa7802359eaddab6ef5d92763">More...</a><br /></td></tr>
<tr class="separator:a60e9928aa7802359eaddab6ef5d92763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Working with free bodies</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="mbp_working_with_free_bodies"></a></p>
<p>A MultibodyPlant user adds sets of <a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a> and <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> objects to <code>this</code> plant to build a physical representation of a mechanical model. At <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>, MultibodyPlant builds a mathematical representation of such system, consisting of a tree representation. In this representation each body is assigned a Mobilizer, which grants a certain number of degrees of freedom in accordance to the physical specification. In this regard, the modeling representation can be seen as a forest of tree structures each of which contains a single body at the root of the tree. If the root body has six degrees of freedom with respect to the world, it is called a "free body" (sometimes called a "floating body"). A user can request the set of all free bodies with a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a6a2813d5472e88bc58bbb9c3129811f5" title="Returns the set of body indexes corresponding to the free (floating) bodies in the model,...">GetFloatingBaseBodies()</a>. Alternatively, a user can query whether a <a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a> is free (floating) or not with <a class="el" href="classdrake_1_1multibody_1_1_body.html#a7df065349a370f3007ee52c6ede868d0" title="(Advanced) Returns true if this body is granted 6-dofs by a Mobilizer.">Body::is_floating()</a>. For many applications, a user might need to work with indexes in the multibody state vector. For such applications, <a class="el" href="classdrake_1_1multibody_1_1_body.html#a8e98e34e5da5ecfc7e03086b70cf5489" title="(Advanced) For floating bodies (see is_floating()) this method returns the index of the first general...">Body::floating_positions_start()</a> and <a class="el" href="classdrake_1_1multibody_1_1_body.html#adc1bbbf124d24c628bb23796cfa5c594" title="(Advanced) For floating bodies (see is_floating()) this method returns the index of the first general...">Body::floating_velocities_start()</a> offer the additional level of introspection needed. </p>
</div></td></tr>
<tr class="memitem:a6a2813d5472e88bc58bbb9c3129811f5"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; <a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a6a2813d5472e88bc58bbb9c3129811f5">GetFloatingBaseBodies</a> () const</td></tr>
<tr class="memdesc:a6a2813d5472e88bc58bbb9c3129811f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of body indexes corresponding to the free (floating) bodies in the model, in no particular order.  <a href="#a6a2813d5472e88bc58bbb9c3129811f5">More...</a><br /></td></tr>
<tr class="separator:a6a2813d5472e88bc58bbb9c3129811f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38b99ebc8a1c3b0a97832f91c8b751c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae38b99ebc8a1c3b0a97832f91c8b751c">GetFreeBodyPose</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:ae38b99ebc8a1c3b0a97832f91c8b751c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pose of a given <code>body</code> in the world frame W.  <a href="#ae38b99ebc8a1c3b0a97832f91c8b751c">More...</a><br /></td></tr>
<tr class="separator:ae38b99ebc8a1c3b0a97832f91c8b751c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f73bcbe2af96a9f46479536f2ad3ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a11f73bcbe2af96a9f46479536f2ad3ab">SetFreeBodyPose</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_WB) const</td></tr>
<tr class="memdesc:a11f73bcbe2af96a9f46479536f2ad3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>context</code> to store the pose <code>X_WB</code> of a given <code>body</code> B in the world frame W.  <a href="#a11f73bcbe2af96a9f46479536f2ad3ab">More...</a><br /></td></tr>
<tr class="separator:a11f73bcbe2af96a9f46479536f2ad3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55401ca376182fd5025d534c63963d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab55401ca376182fd5025d534c63963d0">SetFreeBodyPose</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_WB) const</td></tr>
<tr class="memdesc:ab55401ca376182fd5025d534c63963d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>state</code> to store the pose <code>X_WB</code> of a given <code>body</code> B in the world frame W, for a given <code>context</code> of <code>this</code> model.  <a href="#ab55401ca376182fd5025d534c63963d0">More...</a><br /></td></tr>
<tr class="separator:ab55401ca376182fd5025d534c63963d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054aef89f09b26103692515fea766e9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a054aef89f09b26103692515fea766e9e">SetDefaultFreeBodyPose</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;X_WB)</td></tr>
<tr class="memdesc:a054aef89f09b26103692515fea766e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default pose of <code>body</code>.  <a href="#a054aef89f09b26103692515fea766e9e">More...</a><br /></td></tr>
<tr class="separator:a054aef89f09b26103692515fea766e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029fdc34c3aea2d69b86715030273d42"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a029fdc34c3aea2d69b86715030273d42">GetDefaultFreeBodyPose</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:a029fdc34c3aea2d69b86715030273d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default pose of <code>body</code> as set by <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a054aef89f09b26103692515fea766e9e" title="Sets the default pose of body.">SetDefaultFreeBodyPose()</a>.  <a href="#a029fdc34c3aea2d69b86715030273d42">More...</a><br /></td></tr>
<tr class="separator:a029fdc34c3aea2d69b86715030273d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c3b2ef66032df5f2a377c47e90ccb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae4c3b2ef66032df5f2a377c47e90ccb7">SetFreeBodySpatialVelocity</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;V_WB) const</td></tr>
<tr class="memdesc:ae4c3b2ef66032df5f2a377c47e90ccb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>context</code> to store the spatial velocity <code>V_WB</code> of a given <code>body</code> B in the world frame W.  <a href="#ae4c3b2ef66032df5f2a377c47e90ccb7">More...</a><br /></td></tr>
<tr class="separator:ae4c3b2ef66032df5f2a377c47e90ccb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecd07546b94fae6038ff66f389b7d23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a7ecd07546b94fae6038ff66f389b7d23">SetFreeBodySpatialVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *state, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;V_WB) const</td></tr>
<tr class="memdesc:a7ecd07546b94fae6038ff66f389b7d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>state</code> to store the spatial velocity <code>V_WB</code> of a given <code>body</code> B in the world frame W, for a given <code>context</code> of <code>this</code> model.  <a href="#a7ecd07546b94fae6038ff66f389b7d23">More...</a><br /></td></tr>
<tr class="separator:a7ecd07546b94fae6038ff66f389b7d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0e75333c80fb63dd99945520e41b6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3c0e75333c80fb63dd99945520e41b6b">SetFreeBodyRandomPositionDistribution</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;position)</td></tr>
<tr class="memdesc:a3c0e75333c80fb63dd99945520e41b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the distribution used by <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a470c99c41ab31927ae50c9996786bd10" title="Assigns random values to all elements of the state, by drawing samples independently for each joint/f...">SetRandomState()</a> to populate the free body's x-y-z <code>position</code> with respect to World.  <a href="#a3c0e75333c80fb63dd99945520e41b6b">More...</a><br /></td></tr>
<tr class="separator:a3c0e75333c80fb63dd99945520e41b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c0870fc64428fdd97f76d23f05b43e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a51c0870fc64428fdd97f76d23f05b43e">SetFreeBodyRandomRotationDistribution</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const Eigen::Quaternion&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;rotation)</td></tr>
<tr class="memdesc:a51c0870fc64428fdd97f76d23f05b43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the distribution used by <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a470c99c41ab31927ae50c9996786bd10" title="Assigns random values to all elements of the state, by drawing samples independently for each joint/f...">SetRandomState()</a> to populate the free body's <code>rotation</code> with respect to World.  <a href="#a51c0870fc64428fdd97f76d23f05b43e">More...</a><br /></td></tr>
<tr class="separator:a51c0870fc64428fdd97f76d23f05b43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df65f4ca090714b8ff84be535cfc635"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a0df65f4ca090714b8ff84be535cfc635">SetFreeBodyRandomRotationDistributionToUniform</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body)</td></tr>
<tr class="memdesc:a0df65f4ca090714b8ff84be535cfc635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the distribution used by <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a470c99c41ab31927ae50c9996786bd10" title="Assigns random values to all elements of the state, by drawing samples independently for each joint/f...">SetRandomState()</a> to populate the free body's rotation with respect to World using uniformly random rotations.  <a href="#a0df65f4ca090714b8ff84be535cfc635">More...</a><br /></td></tr>
<tr class="separator:a0df65f4ca090714b8ff84be535cfc635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6dfcf87981848b3eb491a6d59ce5ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ace6dfcf87981848b3eb491a6d59ce5ab">SetFreeBodyPoseInWorldFrame</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_WB) const</td></tr>
<tr class="memdesc:ace6dfcf87981848b3eb491a6d59ce5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <code>context</code> to store the pose <code>X_WB</code> of a given <code>body</code> B in the world frame W.  <a href="#ace6dfcf87981848b3eb491a6d59ce5ab">More...</a><br /></td></tr>
<tr class="separator:ace6dfcf87981848b3eb491a6d59ce5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403d4d02300c8a3184423fb7041b3fba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a403d4d02300c8a3184423fb7041b3fba">SetFreeBodyPoseInAnchoredFrame</a> (<a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body, const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;X_FB) const</td></tr>
<tr class="memdesc:a403d4d02300c8a3184423fb7041b3fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates <code>context</code> to store the pose <code>X_FB</code> of a given <code>body</code> B in a frame F.  <a href="#a403d4d02300c8a3184423fb7041b3fba">More...</a><br /></td></tr>
<tr class="separator:a403d4d02300c8a3184423fb7041b3fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Kinematic and dynamic computations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="mbp_kinematic_and_dynamic_computations"></a> These methods return kinematic results for the state supplied in the given <a class="el" href="classdrake_1_1systems_1_1_context.html">Context</a>. Methods whose names being with <code>Eval</code> return a reference into the Context's cache, performing computation first only if the relevant state has changed. Methods beginning with <code>Calc</code> perform computation unconditionally and return a result without updating the cache. </p>
</div></td></tr>
<tr class="memitem:a6f1fff1ed5cdfefba9e2ce717380783b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a6f1fff1ed5cdfefba9e2ce717380783b">EvalBodyPoseInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body_B) const</td></tr>
<tr class="memdesc:a6f1fff1ed5cdfefba9e2ce717380783b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the pose <code>X_WB</code> of a body B in the world frame W.  <a href="#a6f1fff1ed5cdfefba9e2ce717380783b">More...</a><br /></td></tr>
<tr class="separator:a6f1fff1ed5cdfefba9e2ce717380783b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8377774b012b4975b46941b3197f29c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8377774b012b4975b46941b3197f29c3">EvalBodySpatialVelocityInWorld</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body_B) const</td></tr>
<tr class="memdesc:a8377774b012b4975b46941b3197f29c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the spatial velocity <code>V_WB</code> of a body B in the world frame W.  <a href="#a8377774b012b4975b46941b3197f29c3">More...</a><br /></td></tr>
<tr class="separator:a8377774b012b4975b46941b3197f29c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf801449932225a58b7daeb64a8f911"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html">geometry::PenetrationAsPointPair</a>&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aecf801449932225a58b7daeb64a8f911">EvalPointPairPenetrations</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:aecf801449932225a58b7daeb64a8f911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates all point pairs of contact for a given state of the model stored in <code>context</code>.  <a href="#aecf801449932225a58b7daeb64a8f911">More...</a><br /></td></tr>
<tr class="separator:aecf801449932225a58b7daeb64a8f911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff38c1d07aa9cbaf82c256dace67f29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8ff38c1d07aa9cbaf82c256dace67f29">CalcRelativeTransform</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_G) const</td></tr>
<tr class="memdesc:a8ff38c1d07aa9cbaf82c256dace67f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rigid transform (pose) <code>X_FG</code> relating frame F and frame G.  <a href="#a8ff38c1d07aa9cbaf82c256dace67f29">More...</a><br /></td></tr>
<tr class="separator:a8ff38c1d07aa9cbaf82c256dace67f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e779bd785d02c0b0e14264b9055391"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af8e779bd785d02c0b0e14264b9055391">CalcRelativeRotationMatrix</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_G) const</td></tr>
<tr class="memdesc:af8e779bd785d02c0b0e14264b9055391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rotation matrix <code>R_FG</code> relating frame F and frame G.  <a href="#af8e779bd785d02c0b0e14264b9055391">More...</a><br /></td></tr>
<tr class="separator:af8e779bd785d02c0b0e14264b9055391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bce36db6170b2ed1ee53481f8017a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a27bce36db6170b2ed1ee53481f8017a5">CalcPointsPositions</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;p_BQi, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; p_AQi) const</td></tr>
<tr class="memdesc:a27bce36db6170b2ed1ee53481f8017a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the positions <code>p_BQi</code> for a set of points <code>Qi</code> measured and expressed in a frame B, this method computes the positions <code>p_AQi(q)</code> of each point <code>Qi</code> in the set as measured and expressed in another frame A, as a function of the generalized positions q of the model.  <a href="#a27bce36db6170b2ed1ee53481f8017a5">More...</a><br /></td></tr>
<tr class="separator:a27bce36db6170b2ed1ee53481f8017a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ba70b7920dc9df4a1e25c4ecf7830f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab0ba70b7920dc9df4a1e25c4ecf7830f">CalcCenterOfMassPosition</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:ab0ba70b7920dc9df4a1e25c4ecf7830f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method computes the center of mass position p_WCcm of all bodies in <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a></code> measured and expressed in world frame W.  <a href="#ab0ba70b7920dc9df4a1e25c4ecf7830f">More...</a><br /></td></tr>
<tr class="separator:ab0ba70b7920dc9df4a1e25c4ecf7830f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04e0b90b27a703272d586946ad33eff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aa04e0b90b27a703272d586946ad33eff">CalcCenterOfMassPosition</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;model_instances) const</td></tr>
<tr class="memdesc:aa04e0b90b27a703272d586946ad33eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method computes the center of mass position p_WCcm of specified model instances measured and expressed in world frame W.  <a href="#aa04e0b90b27a703272d586946ad33eff">More...</a><br /></td></tr>
<tr class="separator:aa04e0b90b27a703272d586946ad33eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa1c5393d7cab419a944009cc93aa6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aefa1c5393d7cab419a944009cc93aa6c">CalcSpatialAccelerationsFromVdot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;known_vdot, std::vector&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&gt; *A_WB_array) const</td></tr>
<tr class="memdesc:aefa1c5393d7cab419a944009cc93aa6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the state of this model in <code>context</code> and a known vector of generalized accelerations <code>known_vdot</code>, this method computes the spatial acceleration <code>A_WB</code> for each body as measured and expressed in the world frame W.  <a href="#aefa1c5393d7cab419a944009cc93aa6c">More...</a><br /></td></tr>
<tr class="separator:aefa1c5393d7cab419a944009cc93aa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb4de9b58cb375d056da7e8ec30937a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#afcb4de9b58cb375d056da7e8ec30937a">CalcInverseDynamics</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;known_vdot, const <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; &amp;external_forces) const</td></tr>
<tr class="memdesc:afcb4de9b58cb375d056da7e8ec30937a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the state of this model in <code>context</code> and a known vector of generalized accelerations <code>vdot</code>, this method computes the set of generalized forces <code>tau</code> that would need to be applied in order to attain the specified generalized accelerations.  <a href="#afcb4de9b58cb375d056da7e8ec30937a">More...</a><br /></td></tr>
<tr class="separator:afcb4de9b58cb375d056da7e8ec30937a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b54c8562f107e4d6e11b4b0f8d53c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae1b54c8562f107e4d6e11b4b0f8d53c5">CalcForceElementsContribution</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; *forces) const</td></tr>
<tr class="memdesc:ae1b54c8562f107e4d6e11b4b0f8d53c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the combined force contribution of <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> objects in the model.  <a href="#ae1b54c8562f107e4d6e11b4b0f8d53c5">More...</a><br /></td></tr>
<tr class="separator:ae1b54c8562f107e4d6e11b4b0f8d53c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad877d988ac4cd1942aa84e91e3c5d49a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ad877d988ac4cd1942aa84e91e3c5d49a">CalcGravityGeneralizedForces</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context) const</td></tr>
<tr class="memdesc:ad877d988ac4cd1942aa84e91e3c5d49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the generalized forces <code>tau_g(q)</code> due to gravity as a function of the generalized positions <code>q</code> stored in the input <code>context</code>.  <a href="#ad877d988ac4cd1942aa84e91e3c5d49a">More...</a><br /></td></tr>
<tr class="separator:ad877d988ac4cd1942aa84e91e3c5d49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb24fed19f16a76450eece1857b92dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a7bb24fed19f16a76450eece1857b92dc">MapVelocityToQDot</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;v, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; qdot) const</td></tr>
<tr class="memdesc:a7bb24fed19f16a76450eece1857b92dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms generalized velocities v to time derivatives <code>qdot</code> of the generalized positions vector <code>q</code> (stored in <code>context</code>).  <a href="#a7bb24fed19f16a76450eece1857b92dc">More...</a><br /></td></tr>
<tr class="separator:a7bb24fed19f16a76450eece1857b92dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab128a8bba10523922358bc35df103753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab128a8bba10523922358bc35df103753">MapQDotToVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;qdot, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; v) const</td></tr>
<tr class="memdesc:ab128a8bba10523922358bc35df103753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the time derivative <code>qdot</code> of the generalized positions vector <code>q</code> (stored in <code>context</code>) to generalized velocities <code>v</code>.  <a href="#ab128a8bba10523922358bc35df103753">More...</a><br /></td></tr>
<tr class="separator:ab128a8bba10523922358bc35df103753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">System matrix computations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="mbp_system_matrix_computations"></a> Methods in this section compute and return various matrices that appear in the system equations of motion. For better performance, prefer to use direct computations where available rather than work with explicit matrices. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_kinematic_and_dynamic_computations">Kinematic and dynamics computations</a> for available computations. For example, you can obtain the mass matrix, Coriolis, centripetal, and gyroscopic "bias" terms, and a variety of Jacobian and actuation matrices. </p>
</div></td></tr>
<tr class="memitem:a574e59c853d14d59bde09b40a88ff019"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a574e59c853d14d59bde09b40a88ff019">CalcMassMatrixViaInverseDynamics</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; M) const</td></tr>
<tr class="memdesc:a574e59c853d14d59bde09b40a88ff019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the computation of the mass matrix <code>M(q)</code> of the model using inverse dynamics, where the generalized positions q are stored in <code>context</code>.  <a href="#a574e59c853d14d59bde09b40a88ff019">More...</a><br /></td></tr>
<tr class="separator:a574e59c853d14d59bde09b40a88ff019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf95c4544e8855015c110ba173ccdd0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#adf95c4544e8855015c110ba173ccdd0b">CalcMassMatrix</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; M) const</td></tr>
<tr class="memdesc:adf95c4544e8855015c110ba173ccdd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the computation of the mass matrix <code>M(q)</code> of the model, as a function of the generalized positions q stored in <code>context</code>.  <a href="#adf95c4544e8855015c110ba173ccdd0b">More...</a><br /></td></tr>
<tr class="separator:adf95c4544e8855015c110ba173ccdd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843e1ba389c017c706df10935784b4e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a843e1ba389c017c706df10935784b4e5">CalcBiasTerm</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; Cv) const</td></tr>
<tr class="memdesc:a843e1ba389c017c706df10935784b4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the bias term <code>C(q, v)v</code> containing Coriolis, centripetal, and gyroscopic effects in the multibody equations of motion:  <a href="#a843e1ba389c017c706df10935784b4e5">More...</a><br /></td></tr>
<tr class="separator:a843e1ba389c017c706df10935784b4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add53749e8bb0ec1b0c564bdc14d3c74e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#add53749e8bb0ec1b0c564bdc14d3c74e">CalcBiasTranslationalAcceleration</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt;&gt; &amp;p_BoBi_B, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E) const</td></tr>
<tr class="memdesc:add53749e8bb0ec1b0c564bdc14d3c74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi, Bi's translational acceleration bias in frame A with respect to "speeds" 𝑠, where 𝑠 is either q̇ (time-derivatives of generalized positions) or v (generalized velocities).  <a href="#add53749e8bb0ec1b0c564bdc14d3c74e">More...</a><br /></td></tr>
<tr class="separator:add53749e8bb0ec1b0c564bdc14d3c74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa238d2cebe527f4da55e0ec5d75e8dda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aa238d2cebe527f4da55e0ec5d75e8dda">CalcBiasSpatialAcceleration</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;p_BoBp_B, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E) const</td></tr>
<tr class="memdesc:aa238d2cebe527f4da55e0ec5d75e8dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">For one point Bp affixed/welded to a frame B, calculates A𝑠Bias_ABp, Bp's spatial acceleration bias in frame A with respect to "speeds" 𝑠, where 𝑠 is either q̇ (time-derivatives of generalized positions) or v (generalized velocities).  <a href="#aa238d2cebe527f4da55e0ec5d75e8dda">More...</a><br /></td></tr>
<tr class="separator:aa238d2cebe527f4da55e0ec5d75e8dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72169faa39827ad74deb36e4a9bd18e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a72169faa39827ad74deb36e4a9bd18e9">CalcBiasForJacobianTranslationalVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;p_FP_list, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E) const</td></tr>
<tr class="memdesc:a72169faa39827ad74deb36e4a9bd18e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a point Fp that is fixed to a frame F, calculates Fp's translational acceleration "bias" term <code>abias_AFp = J̇s_v_AFp(q, s) * s</code> in frame A with respect to "speeds" 𝑠.  <a href="#a72169faa39827ad74deb36e4a9bd18e9">More...</a><br /></td></tr>
<tr class="separator:a72169faa39827ad74deb36e4a9bd18e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1acb4f78f307092671567a002b39c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">Vector6</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab1acb4f78f307092671567a002b39c4b">CalcBiasForJacobianSpatialVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_F, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;p_FoFp_F, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E) const</td></tr>
<tr class="memdesc:ab1acb4f78f307092671567a002b39c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a point Fp that is fixed to a frame F, calculates Fp's spatial acceleration "bias" term <code>Abias_AFp = J̇s_V_AFp * s</code> in frame A with respect to "speeds" 𝑠.  <a href="#ab1acb4f78f307092671567a002b39c4b">More...</a><br /></td></tr>
<tr class="separator:ab1acb4f78f307092671567a002b39c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f39a8f68fae3de53767a281503a3313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5f39a8f68fae3de53767a281503a3313">CalcJacobianSpatialVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;p_BoBp_B, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Js_V_ABp_E) const</td></tr>
<tr class="memdesc:a5f39a8f68fae3de53767a281503a3313"><td class="mdescLeft">&#160;</td><td class="mdescRight">For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp's spatial velocity Jacobian in frame A with respect to "speeds" 𝑠.  <a href="#a5f39a8f68fae3de53767a281503a3313">More...</a><br /></td></tr>
<tr class="separator:a5f39a8f68fae3de53767a281503a3313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6058b002bdb83057539ad9785267b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aac6058b002bdb83057539ad9785267b7">CalcJacobianAngularVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, const <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt;&gt; Js_w_AB_E) const</td></tr>
<tr class="memdesc:aac6058b002bdb83057539ad9785267b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates J𝑠_w_AB, a frame B's angular velocity Jacobian in a frame A with respect to "speeds" 𝑠.  <a href="#aac6058b002bdb83057539ad9785267b7">More...</a><br /></td></tr>
<tr class="separator:aac6058b002bdb83057539ad9785267b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2516569f5a2cc27e76ee0cc8b728746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae2516569f5a2cc27e76ee0cc8b728746">CalcJacobianTranslationalVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_B, const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt;&gt; &amp;p_BoBi_B, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; Js_v_ABi_E) const</td></tr>
<tr class="memdesc:ae2516569f5a2cc27e76ee0cc8b728746"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi, Bi's translational velocity Jacobian in frame A with respect to "speeds" 𝑠.  <a href="#ae2516569f5a2cc27e76ee0cc8b728746">More...</a><br /></td></tr>
<tr class="separator:ae2516569f5a2cc27e76ee0cc8b728746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e686199a5e9ddee98538741b7a0382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aa4e686199a5e9ddee98538741b7a0382">CalcJacobianCenterOfMassTranslationalVelocity</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E, <a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt;&gt; Js_v_ACcm_E) const</td></tr>
<tr class="memdesc:aa4e686199a5e9ddee98538741b7a0382"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method computes J𝑠_v_ACcm_E, point Ccm's translational velocity Jacobian in frame A with respect to "speeds" 𝑠, expressed in frame E, where point Ccm is the composite center of mass of the system of all bodies in the <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> (except <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a29ef779ddfeea96c5d80c27d68a4f864" title="Returns a constant reference to the world body.">world_body()</a>).  <a href="#aa4e686199a5e9ddee98538741b7a0382">More...</a><br /></td></tr>
<tr class="separator:aa4e686199a5e9ddee98538741b7a0382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029b22a36d5c6ee85247b9c1cfe84c6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a029b22a36d5c6ee85247b9c1cfe84c6b">CalcBiasCenterOfMassTranslationalAcceleration</a> (const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;context, <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a> with_respect_to, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_A, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;frame_E) const</td></tr>
<tr class="memdesc:a029b22a36d5c6ee85247b9c1cfe84c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates abias_ACcm_E, point Ccm's translational "bias" acceleration term in frame A with respect to "speeds" 𝑠, expressed in frame E, where point Ccm is the composite center of mass of the system of all bodies (except <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a29ef779ddfeea96c5d80c27d68a4f864" title="Returns a constant reference to the world body.">world_body()</a>) in the <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>.  <a href="#a029b22a36d5c6ee85247b9c1cfe84c6b">More...</a><br /></td></tr>
<tr class="separator:a029b22a36d5c6ee85247b9c1cfe84c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7b2e7b0c09b6479d25250405ffd0c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5c7b2e7b0c09b6479d25250405ffd0c4">MakeStateSelectorMatrix</a> (const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;user_to_joint_index_map) const</td></tr>
<tr class="memdesc:a5c7b2e7b0c09b6479d25250405ffd0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows users to map the state of <code>this</code> model, x, into a vector of selected state xₛ with a given preferred ordering.  <a href="#a5c7b2e7b0c09b6479d25250405ffd0c4">More...</a><br /></td></tr>
<tr class="separator:a5c7b2e7b0c09b6479d25250405ffd0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7f5496735d233ea0b984c5a290671f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a0d7f5496735d233ea0b984c5a290671f">MakeActuatorSelectorMatrix</a> (const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> &gt; &amp;user_to_actuator_index_map) const</td></tr>
<tr class="memdesc:a0d7f5496735d233ea0b984c5a290671f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows user to map a vector <code>uₛ</code> containing the actuation for a set of selected actuators into the vector u containing the actuation values for <code>this</code> full model.  <a href="#a0d7f5496735d233ea0b984c5a290671f">More...</a><br /></td></tr>
<tr class="separator:a0d7f5496735d233ea0b984c5a290671f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78463f908367335926f461a19978d89b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a78463f908367335926f461a19978d89b">MakeActuationMatrix</a> () const</td></tr>
<tr class="memdesc:a78463f908367335926f461a19978d89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method creates an actuation matrix B mapping a vector of actuation values u into generalized forces <code>tau_u = B * u</code>, where B is a matrix of size <code>nv x nu</code> with <code>nu</code> equal to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8601c026e9807127b4dd41e7585d2cfc" title="Returns the number of joint actuators in the model.">num_actuators()</a> and <code>nv</code> equal to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>.  <a href="#a78463f908367335926f461a19978d89b">More...</a><br /></td></tr>
<tr class="separator:a78463f908367335926f461a19978d89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029244fdbe2f10a7bfaf5c21175d834c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a029244fdbe2f10a7bfaf5c21175d834c">MakeActuatorSelectorMatrix</a> (const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;user_to_joint_index_map) const</td></tr>
<tr class="memdesc:a029244fdbe2f10a7bfaf5c21175d834c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative signature to build an actuation selector matrix <code>Su</code> such that <code>u = Su⋅uₛ</code>, where u is the vector of actuation values for the full model (ordered by JointActuatorIndex) and uₛ is a vector of actuation values for the actuators acting on the joints listed by <code>user_to_joint_index_map</code>.  <a href="#a029244fdbe2f10a7bfaf5c21175d834c">More...</a><br /></td></tr>
<tr class="separator:a029244fdbe2f10a7bfaf5c21175d834c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Introspection</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="mbp_introspection"></a> These methods allow a user to query whether a given multibody element is part of this plant's model. These queries can be performed at any time during the lifetime of a MultibodyPlant model, i.e. there is no restriction on whether they must be called before or after <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. These queries can be performed while new multibody elements are being added to the model. These methods allow a user to retrieve a reference to a multibody element by its name. An exception is thrown if there is no element with the requested name.</p>
<p>If the named element is present in more than one model instance and a model instance is not explicitly specified, std::logic_error is thrown. </p>
</div></td></tr>
<tr class="memitem:a8daceb7a3c384d6ad9f305e42b5fc1c6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8daceb7a3c384d6ad9f305e42b5fc1c6">time_step</a> () const</td></tr>
<tr class="memdesc:a8daceb7a3c384d6ad9f305e42b5fc1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time step (or period) used to model <code>this</code> plant as a discrete system with periodic updates.  <a href="#a8daceb7a3c384d6ad9f305e42b5fc1c6">More...</a><br /></td></tr>
<tr class="separator:a8daceb7a3c384d6ad9f305e42b5fc1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7bb2a3531c09a97fb3623ac582d840"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#acf7bb2a3531c09a97fb3623ac582d840">is_finalized</a> () const</td></tr>
<tr class="memdesc:acf7bb2a3531c09a97fb3623ac582d840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if this MultibodyPlant was finalized with a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>.  <a href="#acf7bb2a3531c09a97fb3623ac582d840">More...</a><br /></td></tr>
<tr class="separator:acf7bb2a3531c09a97fb3623ac582d840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ef779ddfeea96c5d80c27d68a4f864"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a29ef779ddfeea96c5d80c27d68a4f864">world_body</a> () const</td></tr>
<tr class="memdesc:a29ef779ddfeea96c5d80c27d68a4f864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the <em>world</em> body.  <a href="#a29ef779ddfeea96c5d80c27d68a4f864">More...</a><br /></td></tr>
<tr class="separator:a29ef779ddfeea96c5d80c27d68a4f864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95da38020c32452f62a8cf973057c7a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html">BodyFrame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac95da38020c32452f62a8cf973057c7a">world_frame</a> () const</td></tr>
<tr class="memdesc:ac95da38020c32452f62a8cf973057c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the <em>world</em> frame.  <a href="#ac95da38020c32452f62a8cf973057c7a">More...</a><br /></td></tr>
<tr class="separator:ac95da38020c32452f62a8cf973057c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92b53211e54243aff4490a700168eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af92b53211e54243aff4490a700168eb4">num_bodies</a> () const</td></tr>
<tr class="memdesc:af92b53211e54243aff4490a700168eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bodies in the model, including the "world" body, which is always part of the model.  <a href="#af92b53211e54243aff4490a700168eb4">More...</a><br /></td></tr>
<tr class="separator:af92b53211e54243aff4490a700168eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9547075b5a67b2354f3dabf0f2f787"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ada9547075b5a67b2354f3dabf0f2f787">get_body</a> (<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> body_index) const</td></tr>
<tr class="memdesc:ada9547075b5a67b2354f3dabf0f2f787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the body with unique index <code>body_index</code>.  <a href="#ada9547075b5a67b2354f3dabf0f2f787">More...</a><br /></td></tr>
<tr class="separator:ada9547075b5a67b2354f3dabf0f2f787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f05c3d8f8284a9d9056a4ae47cc0e18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4f05c3d8f8284a9d9056a4ae47cc0e18">IsAnchored</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:a4f05c3d8f8284a9d9056a4ae47cc0e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>body</code> is anchored (i.e.  <a href="#a4f05c3d8f8284a9d9056a4ae47cc0e18">More...</a><br /></td></tr>
<tr class="separator:a4f05c3d8f8284a9d9056a4ae47cc0e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a198b6549e543018c7c9873d4e6dc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:a89a198b6549e543018c7c9873d4e6dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5aa85a70a9f0f196091ed298266c57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a2c5aa85a70a9f0f196091ed298266c57">HasBodyNamed</a> (const std::string &amp;name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="separator:a2c5aa85a70a9f0f196091ed298266c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b40d661d83759731ad9a54553fc13f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af3b40d661d83759731ad9a54553fc13f">GetBodyByName</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:af3b40d661d83759731ad9a54553fc13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a body that is identified by the string <code>name</code> in <code>this</code> MultibodyPlant.  <a href="#af3b40d661d83759731ad9a54553fc13f">More...</a><br /></td></tr>
<tr class="separator:af3b40d661d83759731ad9a54553fc13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d93818409f0144bb63248dc64a9130f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3d93818409f0144bb63248dc64a9130f">GetBodyByName</a> (const std::string &amp;name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a3d93818409f0144bb63248dc64a9130f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the body that is uniquely identified by the string <code>name</code> and <code>model_instance</code> in <code>this</code> MultibodyPlant.  <a href="#a3d93818409f0144bb63248dc64a9130f">More...</a><br /></td></tr>
<tr class="separator:a3d93818409f0144bb63248dc64a9130f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e826bbe6f7a8768bea8d2a41be7f0ac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9e826bbe6f7a8768bea8d2a41be7f0ac">GetBodyIndices</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a9e826bbe6f7a8768bea8d2a41be7f0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of body indices associated with <code>model_instance</code>.  <a href="#a9e826bbe6f7a8768bea8d2a41be7f0ac">More...</a><br /></td></tr>
<tr class="separator:a9e826bbe6f7a8768bea8d2a41be7f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef21c2455a83e7a086df24f8411e26b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1ef21c2455a83e7a086df24f8411e26b">GetRigidBodyByName</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a1ef21c2455a83e7a086df24f8411e26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a rigid body that is identified by the string <code>name</code> in <code>this</code> model.  <a href="#a1ef21c2455a83e7a086df24f8411e26b">More...</a><br /></td></tr>
<tr class="separator:a1ef21c2455a83e7a086df24f8411e26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1b9a39c20706b20221ea2c142d2cfd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a0b1b9a39c20706b20221ea2c142d2cfd">GetRigidBodyByName</a> (const std::string &amp;name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a0b1b9a39c20706b20221ea2c142d2cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the rigid body that is uniquely identified by the string <code>name</code> in <code>model_instance</code>.  <a href="#a0b1b9a39c20706b20221ea2c142d2cfd">More...</a><br /></td></tr>
<tr class="separator:a0b1b9a39c20706b20221ea2c142d2cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90383f3338a41a9de4db1eb9f5aba385"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a90383f3338a41a9de4db1eb9f5aba385">GetBodiesWeldedTo</a> (const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;body) const</td></tr>
<tr class="memdesc:a90383f3338a41a9de4db1eb9f5aba385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all bodies that are transitively welded, or rigidly affixed, to <code>body</code>, per these two definitions:  <a href="#a90383f3338a41a9de4db1eb9f5aba385">More...</a><br /></td></tr>
<tr class="separator:a90383f3338a41a9de4db1eb9f5aba385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636804b6c40e538d83d5c2dfefb7929e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a636804b6c40e538d83d5c2dfefb7929e">num_joints</a> () const</td></tr>
<tr class="memdesc:a636804b6c40e538d83d5c2dfefb7929e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of joints in the model.  <a href="#a636804b6c40e538d83d5c2dfefb7929e">More...</a><br /></td></tr>
<tr class="separator:a636804b6c40e538d83d5c2dfefb7929e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad293b63a81a28c455fdfb7e5f04c35b0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ad293b63a81a28c455fdfb7e5f04c35b0">get_joint</a> (<a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> joint_index) const</td></tr>
<tr class="memdesc:ad293b63a81a28c455fdfb7e5f04c35b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the joint with unique index <code>joint_index</code>.  <a href="#ad293b63a81a28c455fdfb7e5f04c35b0">More...</a><br /></td></tr>
<tr class="separator:ad293b63a81a28c455fdfb7e5f04c35b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c811258a0d93dd116d61648334a392"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a02c811258a0d93dd116d61648334a392">HasJointNamed</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:a02c811258a0d93dd116d61648334a392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ebee03109f4cb8990124949e97caa1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac7ebee03109f4cb8990124949e97caa1">HasJointNamed</a> (const std::string &amp;name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="separator:ac7ebee03109f4cb8990124949e97caa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56a3621a122cdff1729f71b756a75d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab56a3621a122cdff1729f71b756a75d0">get_mutable_joint</a> (<a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> joint_index)</td></tr>
<tr class="memdesc:ab56a3621a122cdff1729f71b756a75d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable reference to the joint with unique index <code>joint_index</code>.  <a href="#ab56a3621a122cdff1729f71b756a75d0">More...</a><br /></td></tr>
<tr class="separator:ab56a3621a122cdff1729f71b756a75d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7918857fc5c0c9deffef433ca5cb85f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af7918857fc5c0c9deffef433ca5cb85f">GetJointIndices</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:af7918857fc5c0c9deffef433ca5cb85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of joint indices associated with <code>model_instance</code>.  <a href="#af7918857fc5c0c9deffef433ca5cb85f">More...</a><br /></td></tr>
<tr class="separator:af7918857fc5c0c9deffef433ca5cb85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ef5b8184105111a26093a17d45f971"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class JointType = Joint&gt; </td></tr>
<tr class="memitem:a50ef5b8184105111a26093a17d45f971"><td class="memTemplItemLeft" align="right" valign="top">const JointType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a50ef5b8184105111a26093a17d45f971">GetJointByName</a> (const std::string &amp;name, std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; model_instance=std::nullopt) const</td></tr>
<tr class="memdesc:a50ef5b8184105111a26093a17d45f971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a joint that is identified by the string <code>name</code> in <code>this</code> MultibodyPlant.  <a href="#a50ef5b8184105111a26093a17d45f971">More...</a><br /></td></tr>
<tr class="separator:a50ef5b8184105111a26093a17d45f971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bbed0c9b8611d58c399a4a0e7533dd"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class JointType = Joint&gt; </td></tr>
<tr class="memitem:a28bbed0c9b8611d58c399a4a0e7533dd"><td class="memTemplItemLeft" align="right" valign="top">JointType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a28bbed0c9b8611d58c399a4a0e7533dd">GetMutableJointByName</a> (const std::string &amp;name, std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; model_instance=std::nullopt)</td></tr>
<tr class="memdesc:a28bbed0c9b8611d58c399a4a0e7533dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A version of GetJointByName that returns a mutable reference.  <a href="#a28bbed0c9b8611d58c399a4a0e7533dd">More...</a><br /></td></tr>
<tr class="separator:a28bbed0c9b8611d58c399a4a0e7533dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7f02e861a8f89fc0b575b2f30333d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ada7f02e861a8f89fc0b575b2f30333d3">num_frames</a> () const</td></tr>
<tr class="memdesc:ada7f02e861a8f89fc0b575b2f30333d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame),...">Frame</a> objects in this model.  <a href="#ada7f02e861a8f89fc0b575b2f30333d3">More...</a><br /></td></tr>
<tr class="separator:ada7f02e861a8f89fc0b575b2f30333d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cafdc0efac53fe097f9380b955e396"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a95cafdc0efac53fe097f9380b955e396">get_frame</a> (<a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a> frame_index) const</td></tr>
<tr class="memdesc:a95cafdc0efac53fe097f9380b955e396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the frame with unique index <code>frame_index</code>.  <a href="#a95cafdc0efac53fe097f9380b955e396">More...</a><br /></td></tr>
<tr class="separator:a95cafdc0efac53fe097f9380b955e396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3530f8f6747cb603a24accba5901bd00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3530f8f6747cb603a24accba5901bd00">HasFrameNamed</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:a3530f8f6747cb603a24accba5901bd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab3a66ab482037c12c4d556800c550a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a7ab3a66ab482037c12c4d556800c550a">HasFrameNamed</a> (const std::string &amp;name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="separator:a7ab3a66ab482037c12c4d556800c550a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b557087f117859fd5246112f0d829cd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4b557087f117859fd5246112f0d829cd">GetFrameByName</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a4b557087f117859fd5246112f0d829cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a frame that is identified by the string <code>name</code> in <code>this</code> model.  <a href="#a4b557087f117859fd5246112f0d829cd">More...</a><br /></td></tr>
<tr class="separator:a4b557087f117859fd5246112f0d829cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d552a24e1ad06c0b16004cec20fe94"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af4d552a24e1ad06c0b16004cec20fe94">GetFrameByName</a> (const std::string &amp;name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:af4d552a24e1ad06c0b16004cec20fe94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the frame that is uniquely identified by the string <code>name</code> in <code>model_instance</code>.  <a href="#af4d552a24e1ad06c0b16004cec20fe94">More...</a><br /></td></tr>
<tr class="separator:af4d552a24e1ad06c0b16004cec20fe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8601c026e9807127b4dd41e7585d2cfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8601c026e9807127b4dd41e7585d2cfc">num_actuators</a> () const</td></tr>
<tr class="memdesc:a8601c026e9807127b4dd41e7585d2cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of joint actuators in the model.  <a href="#a8601c026e9807127b4dd41e7585d2cfc">More...</a><br /></td></tr>
<tr class="separator:a8601c026e9807127b4dd41e7585d2cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fc8de8de8eaf2d37a24c79d6be8e97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae3fc8de8de8eaf2d37a24c79d6be8e97">num_actuated_dofs</a> () const</td></tr>
<tr class="memdesc:ae3fc8de8de8eaf2d37a24c79d6be8e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of actuated degrees of freedom.  <a href="#ae3fc8de8de8eaf2d37a24c79d6be8e97">More...</a><br /></td></tr>
<tr class="separator:ae3fc8de8de8eaf2d37a24c79d6be8e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279e31367e76849d4a45fd7db0f116f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a279e31367e76849d4a45fd7db0f116f1">num_actuated_dofs</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a279e31367e76849d4a45fd7db0f116f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of actuated degrees of freedom for a specific model instance.  <a href="#a279e31367e76849d4a45fd7db0f116f1">More...</a><br /></td></tr>
<tr class="separator:a279e31367e76849d4a45fd7db0f116f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb237ffaadc7323d817ba0e07e78a8f4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abb237ffaadc7323d817ba0e07e78a8f4">get_joint_actuator</a> (<a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> actuator_index) const</td></tr>
<tr class="memdesc:abb237ffaadc7323d817ba0e07e78a8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the joint actuator with unique index <code>actuator_index</code>.  <a href="#abb237ffaadc7323d817ba0e07e78a8f4">More...</a><br /></td></tr>
<tr class="separator:abb237ffaadc7323d817ba0e07e78a8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dd7e61bafa3221193e7d68e4be7cbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a30dd7e61bafa3221193e7d68e4be7cbc">HasJointActuatorNamed</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:a30dd7e61bafa3221193e7d68e4be7cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6ad707643bf5220e76678e71291175"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a0f6ad707643bf5220e76678e71291175">HasJointActuatorNamed</a> (const std::string &amp;name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="separator:a0f6ad707643bf5220e76678e71291175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab835365a3c40185b23454f7e08cad083"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab835365a3c40185b23454f7e08cad083">GetJointActuatorByName</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ab835365a3c40185b23454f7e08cad083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to an actuator that is identified by the string <code>name</code> in <code>this</code> MultibodyPlant.  <a href="#ab835365a3c40185b23454f7e08cad083">More...</a><br /></td></tr>
<tr class="separator:ab835365a3c40185b23454f7e08cad083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760fbe4384415d8cfd39c9e7e4f31422"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a760fbe4384415d8cfd39c9e7e4f31422">GetJointActuatorByName</a> (const std::string &amp;name, <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a760fbe4384415d8cfd39c9e7e4f31422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the actuator that is uniquely identified by the string <code>name</code> and <code>model_instance</code> in <code>this</code> MultibodyPlant.  <a href="#a760fbe4384415d8cfd39c9e7e4f31422">More...</a><br /></td></tr>
<tr class="separator:a760fbe4384415d8cfd39c9e7e4f31422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7f0267d163693025fa04f78bb18333"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a6b7f0267d163693025fa04f78bb18333">num_force_elements</a> () const</td></tr>
<tr class="memdesc:a6b7f0267d163693025fa04f78bb18333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> objects.  <a href="#a6b7f0267d163693025fa04f78bb18333">More...</a><br /></td></tr>
<tr class="separator:a6b7f0267d163693025fa04f78bb18333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0506236fd49c1dab4ab5bdd8102ba9fc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_force_element.html">ForceElement</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a0506236fd49c1dab4ab5bdd8102ba9fc">get_force_element</a> (<a class="el" href="namespacedrake_1_1multibody.html#add80e949328b179d78312d1455319868">ForceElementIndex</a> force_element_index) const</td></tr>
<tr class="memdesc:a0506236fd49c1dab4ab5bdd8102ba9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to the force element with unique index <code>force_element_index</code>.  <a href="#a0506236fd49c1dab4ab5bdd8102ba9fc">More...</a><br /></td></tr>
<tr class="separator:a0506236fd49c1dab4ab5bdd8102ba9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551f8c3bf88b0f325a7a2be7f5bdecea"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class ForceElementType = ForceElement&gt; </td></tr>
<tr class="memitem:a551f8c3bf88b0f325a7a2be7f5bdecea"><td class="memTemplItemLeft" align="right" valign="top">const ForceElementType&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a551f8c3bf88b0f325a7a2be7f5bdecea">GetForceElement</a> (<a class="el" href="namespacedrake_1_1multibody.html#add80e949328b179d78312d1455319868">ForceElementIndex</a> force_element_index) const</td></tr>
<tr class="memdesc:a551f8c3bf88b0f325a7a2be7f5bdecea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a force element identified by its unique index in <code>this</code> MultibodyPlant.  <a href="#a551f8c3bf88b0f325a7a2be7f5bdecea">More...</a><br /></td></tr>
<tr class="separator:a551f8c3bf88b0f325a7a2be7f5bdecea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2487c077b5f43019cb90dfe876ad967"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html">UniformGravityFieldElement</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac2487c077b5f43019cb90dfe876ad967">gravity_field</a> () const</td></tr>
<tr class="memdesc:ac2487c077b5f43019cb90dfe876ad967"><td class="mdescLeft">&#160;</td><td class="mdescRight">An accessor to the current gravity field.  <a href="#ac2487c077b5f43019cb90dfe876ad967">More...</a><br /></td></tr>
<tr class="separator:ac2487c077b5f43019cb90dfe876ad967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011da7195d022b5768df17eeb86ae707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html">UniformGravityFieldElement</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a011da7195d022b5768df17eeb86ae707">mutable_gravity_field</a> ()</td></tr>
<tr class="memdesc:a011da7195d022b5768df17eeb86ae707"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable accessor to the current gravity field.  <a href="#a011da7195d022b5768df17eeb86ae707">More...</a><br /></td></tr>
<tr class="separator:a011da7195d022b5768df17eeb86ae707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89140adb93cb9e507f71c30eb783198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac89140adb93cb9e507f71c30eb783198">num_model_instances</a> () const</td></tr>
<tr class="memdesc:ac89140adb93cb9e507f71c30eb783198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of model instances in the model.  <a href="#ac89140adb93cb9e507f71c30eb783198">More...</a><br /></td></tr>
<tr class="separator:ac89140adb93cb9e507f71c30eb783198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99be499eb59f00037b05ec60b51e177"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab99be499eb59f00037b05ec60b51e177">GetModelInstanceName</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:ab99be499eb59f00037b05ec60b51e177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of a <code>model_instance</code>.  <a href="#ab99be499eb59f00037b05ec60b51e177">More...</a><br /></td></tr>
<tr class="separator:ab99be499eb59f00037b05ec60b51e177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b71664c8e2e91bc3fc92fef222a9bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a05b71664c8e2e91bc3fc92fef222a9bf">HasModelInstanceNamed</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:a05b71664c8e2e91bc3fc92fef222a9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a177e855cc5efe12d15adc4c697930f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a2a177e855cc5efe12d15adc4c697930f">GetModelInstanceByName</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a2a177e855cc5efe12d15adc4c697930f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index to the model instance that is uniquely identified by the string <code>name</code> in <code>this</code> MultibodyPlant.  <a href="#a2a177e855cc5efe12d15adc4c697930f">More...</a><br /></td></tr>
<tr class="separator:a2a177e855cc5efe12d15adc4c697930f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113f30d2b1b3a8151b638300231975fa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a113f30d2b1b3a8151b638300231975fa">GetTopologyGraphvizString</a> () const</td></tr>
<tr class="memdesc:a113f30d2b1b3a8151b638300231975fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Graphviz string describing the topology of this plant.  <a href="#a113f30d2b1b3a8151b638300231975fa">More...</a><br /></td></tr>
<tr class="separator:a113f30d2b1b3a8151b638300231975fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553">num_positions</a> () const</td></tr>
<tr class="memdesc:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the generalized position vector q for this model.  <a href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">More...</a><br /></td></tr>
<tr class="separator:aba2887f0ca1fbbdfb49cf6b0ee21e553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab669e070e6178c4aeeb067a1f4b6122e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab669e070e6178c4aeeb067a1f4b6122e">num_positions</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:ab669e070e6178c4aeeb067a1f4b6122e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the generalized position vector qᵢ for model instance i.  <a href="#ab669e070e6178c4aeeb067a1f4b6122e">More...</a><br /></td></tr>
<tr class="separator:ab669e070e6178c4aeeb067a1f4b6122e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0163ac0976659d811e3337647ff0313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313">num_velocities</a> () const</td></tr>
<tr class="memdesc:ae0163ac0976659d811e3337647ff0313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the generalized velocity vector v for this model.  <a href="#ae0163ac0976659d811e3337647ff0313">More...</a><br /></td></tr>
<tr class="separator:ae0163ac0976659d811e3337647ff0313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a686a8389beffdc5fb8a7690967e741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a0a686a8389beffdc5fb8a7690967e741">num_velocities</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a0a686a8389beffdc5fb8a7690967e741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the generalized velocity vector vᵢ for model instance i.  <a href="#a0a686a8389beffdc5fb8a7690967e741">More...</a><br /></td></tr>
<tr class="separator:a0a686a8389beffdc5fb8a7690967e741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80c61762d32b97a34f02a0374fc6fe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac80c61762d32b97a34f02a0374fc6fe3">num_multibody_states</a> () const</td></tr>
<tr class="memdesc:ac80c61762d32b97a34f02a0374fc6fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the multibody system state vector x = [q v].  <a href="#ac80c61762d32b97a34f02a0374fc6fe3">More...</a><br /></td></tr>
<tr class="separator:ac80c61762d32b97a34f02a0374fc6fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d0d29cbbe6e1de7cbaf90fefc5e652"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a07d0d29cbbe6e1de7cbaf90fefc5e652">num_multibody_states</a> (<a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance) const</td></tr>
<tr class="memdesc:a07d0d29cbbe6e1de7cbaf90fefc5e652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the multibody system state vector xᵢ = [qᵢ vᵢ] for model instance i.  <a href="#a07d0d29cbbe6e1de7cbaf90fefc5e652">More...</a><br /></td></tr>
<tr class="separator:a07d0d29cbbe6e1de7cbaf90fefc5e652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1473641a4389162ee68d6468a4e664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ada1473641a4389162ee68d6468a4e664">GetPositionLowerLimits</a> () const</td></tr>
<tr class="memdesc:ada1473641a4389162ee68d6468a4e664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of size <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a></code> containing the lower position limits for every generalized position coordinate.  <a href="#ada1473641a4389162ee68d6468a4e664">More...</a><br /></td></tr>
<tr class="separator:ada1473641a4389162ee68d6468a4e664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdbea9ebcb04bc6a5f3d62cffd35b1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3fdbea9ebcb04bc6a5f3d62cffd35b1e">GetPositionUpperLimits</a> () const</td></tr>
<tr class="memdesc:a3fdbea9ebcb04bc6a5f3d62cffd35b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper limit analog of GetPositionsLowerLimits(), where any unbounded or unspecified limits will be +infinity.  <a href="#a3fdbea9ebcb04bc6a5f3d62cffd35b1e">More...</a><br /></td></tr>
<tr class="separator:a3fdbea9ebcb04bc6a5f3d62cffd35b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f34d1e0732d72d601b3a17c54c8de5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9f34d1e0732d72d601b3a17c54c8de5e">GetVelocityLowerLimits</a> () const</td></tr>
<tr class="memdesc:a9f34d1e0732d72d601b3a17c54c8de5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of size <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a></code> containing the lower velocity limits for every generalized velocity coordinate.  <a href="#a9f34d1e0732d72d601b3a17c54c8de5e">More...</a><br /></td></tr>
<tr class="separator:a9f34d1e0732d72d601b3a17c54c8de5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cbd4d7b77f1021660c007125c88ece"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab7cbd4d7b77f1021660c007125c88ece">GetVelocityUpperLimits</a> () const</td></tr>
<tr class="memdesc:ab7cbd4d7b77f1021660c007125c88ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper limit analog of GetVelocitysLowerLimits(), where any unbounded or unspecified limits will be +infinity.  <a href="#ab7cbd4d7b77f1021660c007125c88ece">More...</a><br /></td></tr>
<tr class="separator:ab7cbd4d7b77f1021660c007125c88ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc751e3bc4dea699d3c1f9d3ff1f214e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abc751e3bc4dea699d3c1f9d3ff1f214e">GetAccelerationLowerLimits</a> () const</td></tr>
<tr class="memdesc:abc751e3bc4dea699d3c1f9d3ff1f214e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of size <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a></code> containing the lower acceleration limits for every generalized velocity coordinate.  <a href="#abc751e3bc4dea699d3c1f9d3ff1f214e">More...</a><br /></td></tr>
<tr class="separator:abc751e3bc4dea699d3c1f9d3ff1f214e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f96a969efb888b8528a43fdb19108b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a99f96a969efb888b8528a43fdb19108b">GetAccelerationUpperLimits</a> () const</td></tr>
<tr class="memdesc:a99f96a969efb888b8528a43fdb19108b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper limit analog of GetAccelerationsLowerLimits(), where any unbounded or unspecified limits will be +infinity.  <a href="#a99f96a969efb888b8528a43fdb19108b">More...</a><br /></td></tr>
<tr class="separator:a99f96a969efb888b8528a43fdb19108b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d1093944c929bd5ca5322836b91bd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4e">ContactModel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a94d1093944c929bd5ca5322836b91bd4">get_contact_model</a> () const</td></tr>
<tr class="memdesc:a94d1093944c929bd5ca5322836b91bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the model used for contact. See documentation for ContactModel.  <a href="#a94d1093944c929bd5ca5322836b91bd4">More...</a><br /></td></tr>
<tr class="separator:a94d1093944c929bd5ca5322836b91bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38608634b36afab217b71de1f31fbc85"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a38608634b36afab217b71de1f31fbc85">default_coulomb_friction</a> (<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> id) const</td></tr>
<tr class="memdesc:a38608634b36afab217b71de1f31fbc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the friction coefficients provided during geometry registration for the given geometry <code>id</code>.  <a href="#a38608634b36afab217b71de1f31fbc85">More...</a><br /></td></tr>
<tr class="separator:a38608634b36afab217b71de1f31fbc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c0b698e0102d42f085ca39f337b019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aa7c0b698e0102d42f085ca39f337b019">num_visual_geometries</a> () const</td></tr>
<tr class="memdesc:aa7c0b698e0102d42f085ca39f337b019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of geometries registered for visualization.  <a href="#aa7c0b698e0102d42f085ca39f337b019">More...</a><br /></td></tr>
<tr class="separator:aa7c0b698e0102d42f085ca39f337b019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b107ecf3446e56cb203461440200c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac1b107ecf3446e56cb203461440200c1">num_collision_geometries</a> () const</td></tr>
<tr class="memdesc:ac1b107ecf3446e56cb203461440200c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of geometries registered for contact modeling.  <a href="#ac1b107ecf3446e56cb203461440200c1">More...</a><br /></td></tr>
<tr class="separator:ac1b107ecf3446e56cb203461440200c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e13ba788ae1f46c3a847b025a5f0347"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespacedrake_1_1geometry.html#ac53cb597123131fb23a7af26e8d350bf">geometry::SourceId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a0e13ba788ae1f46c3a847b025a5f0347">get_source_id</a> () const</td></tr>
<tr class="memdesc:a0e13ba788ae1f46c3a847b025a5f0347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique id identifying <code>this</code> plant as a source for a SceneGraph.  <a href="#a0e13ba788ae1f46c3a847b025a5f0347">More...</a><br /></td></tr>
<tr class="separator:a0e13ba788ae1f46c3a847b025a5f0347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad783d7e7e513feb7a73384c8080041"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#afad783d7e7e513feb7a73384c8080041">geometry_source_is_registered</a> () const</td></tr>
<tr class="memdesc:afad783d7e7e513feb7a73384c8080041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>this</code> MultibodyPlant was registered with a SceneGraph.  <a href="#afad783d7e7e513feb7a73384c8080041">More...</a><br /></td></tr>
<tr class="separator:afad783d7e7e513feb7a73384c8080041"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a47a63154823dffd5838329527aafbd58"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a47a63154823dffd5838329527aafbd58"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a47a63154823dffd5838329527aafbd58">MultibodyPlant</a></td></tr>
<tr class="separator:a47a63154823dffd5838329527aafbd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42efef893a4d8eed1d593caff328f599"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a42efef893a4d8eed1d593caff328f599">MultibodyPlantTester</a></td></tr>
<tr class="separator:a42efef893a4d8eed1d593caff328f599"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aac66563a5f3eb9e2041bd4fa8d438827"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aac66563a5f3eb9e2041bd4fa8d438827"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1multibody_1_1_add_multibody_plant_scene_graph_result.html">AddMultibodyPlantSceneGraphResult</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aac66563a5f3eb9e2041bd4fa8d438827">AddMultibodyPlantSceneGraph</a> (<a class="el" href="classdrake_1_1systems_1_1_diagram_builder.html">systems::DiagramBuilder</a>&lt; T &gt; *builder, double <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8daceb7a3c384d6ad9f305e42b5fc1c6">time_step</a>, std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt;&gt; scene_graph=nullptr)</td></tr>
<tr class="memdesc:aac66563a5f3eb9e2041bd4fa8d438827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> with discrete update period <code>time_step</code> and adds it to a diagram builder together with the provided SceneGraph instance, connecting the geometry ports.  <a href="#aac66563a5f3eb9e2041bd4fa8d438827">More...</a><br /></td></tr>
<tr class="separator:aac66563a5f3eb9e2041bd4fa8d438827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad665c93a561c6ccbe2bba07d1d6193a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad665c93a561c6ccbe2bba07d1d6193a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1multibody_1_1_add_multibody_plant_scene_graph_result.html">AddMultibodyPlantSceneGraphResult</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aad665c93a561c6ccbe2bba07d1d6193a">AddMultibodyPlantSceneGraph</a> (<a class="el" href="classdrake_1_1systems_1_1_diagram_builder.html">systems::DiagramBuilder</a>&lt; T &gt; *builder, std::unique_ptr&lt; <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; T &gt;&gt; plant, std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt;&gt; scene_graph=nullptr)</td></tr>
<tr class="memdesc:aad665c93a561c6ccbe2bba07d1d6193a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> and a SceneGraph instance to a diagram builder, connecting the geometry ports.  <a href="#aad665c93a561c6ccbe2bba07d1d6193a">More...</a><br /></td></tr>
<tr class="separator:aad665c93a561c6ccbe2bba07d1d6193a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3aeb03d90d213da4702f2dc5e484fc86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aeb03d90d213da4702f2dc5e484fc86">&#9670;&nbsp;</a></span>MultibodyPlant() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a359ae04bf7eabd0461c5f12ab35fee1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359ae04bf7eabd0461c5f12ab35fee1d">&#9670;&nbsp;</a></span>MultibodyPlant() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3296be9fa9bc35e6639460f54029c4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3296be9fa9bc35e6639460f54029c4c9">&#9670;&nbsp;</a></span>MultibodyPlant() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_step</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This constructor creates a plant with a single "world" body. </p>
<p>Therefore, right after creation, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af92b53211e54243aff4490a700168eb4" title="Returns the number of bodies in the model, including the &quot;world&quot; body, which is always part of the mo...">num_bodies()</a> returns one.</p>
<p>MultibodyPlant offers two different modalities to model mechanical systems in time. These are:</p><ol type="1">
<li>As a discrete system with periodic updates, <code>time_step</code> is strictly greater than zero.</li>
<li>As a continuous system, <code>time_step</code> equals exactly zero.</li>
</ol>
<p>Currently the discrete model is preferred for simulation given its robustness and speed in problems with frictional contact. However this might change as we work towards developing better strategies to model contact. See <a class="el" href="group__contact__engineering.html#time_advancement_strategy">Choice of Time Advancement Strategy</a> for further details.</p>
<dl class="section warning"><dt>Warning</dt><dd>Users should be aware of current limitations in either modeling modality. While the discrete model is often the preferred option for problems with frictional contact given its robustness and speed, it might become unstable when using large feedback gains, high damping or large external forcing. MultibodyPlant will throw an exception whenever the discrete solver is detected to fail. Conversely, the continuous modality has the potential to leverage the robustness and accuracy control provide by Drake's integrators. However thus far this has proved difficult in practice and especially due to poor performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time_step</td><td>Indicates whether <code>this</code> plant is modeled as a continuous system (<code>time_step = 0</code>) or as a discrete system with periodic updates of period <code>time_step &gt; 0</code>. See <a class="el" href="group__contact__engineering.html#time_advancement_strategy">Choice of Time Advancement Strategy</a> for further details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Currently the continuous modality with <code>time_step = 0</code> does not support joint limits for simulation, these are ignored. MultibodyPlant prints a warning to console if joint limits are provided. If your simulation requires joint limits currently you must use a discrete MultibodyPlant model.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>time_step</code> is negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a912adb84c4940893eb4634155e6e7e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912adb84c4940893eb4634155e6e7e8b">&#9670;&nbsp;</a></span>MultibodyPlant() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar-converting copy constructor. See <a class="el" href="group__system__scalar__conversion.html">System Scalar Conversion</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a48009c793b01c5a6dd079d33265435a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48009c793b01c5a6dd079d33265435a3">&#9670;&nbsp;</a></span>AddForceElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ForceElementType&lt;T&gt;&amp; AddForceElement </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new force element model of type <code>ForceElementType</code> to <code>this</code> MultibodyPlant. </p>
<p>The arguments to this method <code>args</code> are forwarded to <code>ForceElementType</code>'s constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Zero or more parameters provided to the constructor of the new force element. It must be the case that <code>ForceElementType&lt;T&gt;(args)</code> is a valid constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForceElementType</td><td>The type of the <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> to add. As there is always a <a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html" title="This ForceElement allows modeling the effect of a uniform gravity field as felt by bodies on the surf...">UniformGravityFieldElement</a> present (accessible through <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac2487c077b5f43019cb90dfe876ad967" title="An accessor to the current gravity field.">gravity_field()</a>), an exception will be thrown if this function is called to add another <a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html" title="This ForceElement allows modeling the effect of a uniform gravity field as felt by bodies on the surf...">UniformGravityFieldElement</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> just added, of type <code>ForceElementType&lt;T&gt;</code> specialized on the scalar type T of <code>this</code> MultibodyPlant. It will remain valid for the lifetime of <code>this</code> MultibodyPlant. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>The <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> class's documentation for further details on how a force element is defined. </dd></dl>

</div>
</div>
<a id="a474c90a0b3e4f9349533207026413186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474c90a0b3e4f9349533207026413186">&#9670;&nbsp;</a></span>AddFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const FrameType&lt;T&gt;&amp; AddFrame </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; FrameType&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method adds a <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame),...">Frame</a> of type <code>FrameType&lt;T&gt;</code>. </p>
<p>For more information, please see the corresponding constructor of <code>FrameType</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FrameType</td><td>Template which will be instantiated on <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>Unique pointer frame instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame),...">Frame</a> just added, which will remain valid for the lifetime of <code>this</code> MultibodyPlant. </dd></dl>

</div>
</div>
<a id="a437f86026a2268c0fb06936b899ba8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437f86026a2268c0fb06936b899ba8d7">&#9670;&nbsp;</a></span>AddJoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const JointType&lt;T&gt;&amp; AddJoint </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; JointType&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>joint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method adds a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <code>JointType</code> between two bodies. </p>
<p>For more information, see the below overload of <code>AddJoint&lt;&gt;</code>, and the related <code>MultibodyTree::AddJoint&lt;&gt;</code> method. </p>

</div>
</div>
<a id="a578a71ed3566fd2589958f5ed05f9c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578a71ed3566fd2589958f5ed05f9c2e">&#9670;&nbsp;</a></span>AddJoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const JointType&lt;T&gt;&amp; AddJoint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X_PF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method adds a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> of type <code>JointType</code> between two bodies. </p>
<p>The two bodies connected by this <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> object are referred to as the <em>parent</em> and <em>child</em> bodies. Although the terms <em>parent</em> and <em>child</em> are sometimes used synonymously to describe the relationship between inboard and outboard bodies in multibody models, this usage is wholly unrelated and implies nothing about the inboard-outboard relationship between the bodies. As explained in the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class's documentation, in Drake we define a frame F attached to the parent body P with pose <code>X_PF</code> and a frame M attached to the child body B with pose <code>X_BM</code>. This method helps creating a joint between two bodies with fixed poses <code>X_PF</code> and <code>X_BM</code>. Refer to the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class's documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>A string that uniquely identifies the new joint to be added to <code>this</code> model. A std::runtime_error is thrown if a joint named <code>name</code> already is part of the model. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a02c811258a0d93dd116d61648334a392">HasJointNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_joint.html#ad8227ba86a01f26e4f173cd5e219d5d1" title="Returns the name of this joint.">Joint::name()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>The parent body connected by the new joint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_PF</td><td>The fixed pose of frame F attached to the parent body, measured in the frame P of that body. <code>X_PF</code> is an optional parameter; empty curly braces <code>{}</code> imply that frame F <b>is</b> the same body frame P. If instead your intention is to make a frame F with pose <code>X_PF</code> equal to the identity pose, provide <code>RigidTransform&lt;double&gt;::Identity()</code> as your input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">child</td><td>The child body connected by the new joint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_BM</td><td>The fixed pose of frame M attached to the child body, measured in the frame B of that body. <code>X_BM</code> is an optional parameter; empty curly braces <code>{}</code> imply that frame M <b>is</b> the same body frame B. If instead your intention is to make a frame M with pose <code>X_BM</code> equal to the identity pose, provide <code>RigidTransform&lt;double&gt;::Identity()</code> as your input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Zero or more parameters provided to the constructor of the new joint. It must be the case that <code>JointType&lt;T&gt;( const std::string&amp;, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame),...">Frame</a>&lt;T&gt;&amp;, const <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame),...">Frame</a>&lt;T&gt;&amp;, args)</code> is a valid constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">JointType</td><td>The type of the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new joint just added, of type <code>JointType&lt;T&gt;</code> specialized on the scalar type T of <code>this</code> MultibodyPlant. It will remain valid for the lifetime of <code>this</code> MultibodyPlant.</dd></dl>
<p>Example of usage: </p><div class="fragment"><div class="line">MultibodyPlant&lt;T&gt; plant;</div><div class="line"><span class="comment">// Code to define bodies serving as the joint&#39;s parent and child bodies.</span></div><div class="line"><span class="keyword">const</span> RigidBody&lt;double&gt;&amp; body_1 =</div><div class="line">  plant.AddRigidBody(<span class="stringliteral">&quot;Body1&quot;</span>, SpatialInertia&lt;double&gt;(...));</div><div class="line"><span class="keyword">const</span> RigidBody&lt;double&gt;&amp; body_2 =</div><div class="line">  plant.AddRigidBody(<span class="stringliteral">&quot;Body2&quot;</span>, SpatialInertia&lt;double&gt;(...));</div><div class="line"><span class="comment">// Body 1 serves as parent, Body 2 serves as child.</span></div><div class="line"><span class="comment">// Define the pose X_BM of a frame M rigidly attached to child body B.</span></div><div class="line"><span class="keyword">const</span> RevoluteJoint&lt;double&gt;&amp; elbow =</div><div class="line">  plant.AddJoint&lt;RevoluteJoint&gt;(</div><div class="line">    <span class="stringliteral">&quot;Elbow&quot;</span>,                <span class="comment">/* joint name */</span></div><div class="line">    body_1,                 <span class="comment">/* parent body */</span></div><div class="line">    {},                     <span class="comment">/* frame F IS the parent body frame P */</span></div><div class="line">    body_2,                 <span class="comment">/* child body, the pendulum */</span></div><div class="line">    X_BM,                   <span class="comment">/* pose of frame M in the body frame B */</span></div><div class="line">    Vector3d::UnitZ());     <span class="comment">/* revolute axis in this case */</span></div></div><!-- fragment --><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>this</code> MultibodyPlant already contains a joint with the given <code>name</code>. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a02c811258a0d93dd116d61648334a392">HasJointNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_joint.html#ad8227ba86a01f26e4f173cd5e219d5d1" title="Returns the name of this joint.">Joint::name()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>The <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> class's documentation for further details on how a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> is defined. </dd></dl>

</div>
</div>
<a id="af528f7747dc75227fdec76aba89e7d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af528f7747dc75227fdec76aba89e7d2b">&#9670;&nbsp;</a></span>AddJointActuator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt;T&gt;&amp; AddJointActuator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>joint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>effort_limit</em> = <code>std::numeric_limits&lt;double&gt;::infinity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and adds a <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> model for an actuator acting on a given <code>joint</code>. </p>
<p>This method returns a constant reference to the actuator just added, which will remain valid for the lifetime of <code>this</code> plant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that uniquely identifies the new actuator to be added to <code>this</code> model. A std::runtime_error is thrown if an actuator with the same name already exists in the model. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a30dd7e61bafa3221193e7d68e4be7cbc">HasJointActuatorNamed()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">joint</td><td>The <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> to be actuated by the new <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">effort_limit</td><td>The maximum effort for the actuator. It must be strictly positive, otherwise an std::exception is thrown. If +∞, the actuator has no limit, which is the default. The effort limit has physical units in accordance to the joint type it actuates. For instance, it will have units of N⋅m (torque) for revolute joints while it will have units of N (force) for prismatic joints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a> just added, which will remain valid for the lifetime of <code>this</code> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>joint.num_velocities() &gt; 1</code> since for now we only support actuators for single dof joints. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4edf1daa65069a26255c903b02bce4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edf1daa65069a26255c903b02bce4c6">&#9670;&nbsp;</a></span>AddModelInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> AddModelInstance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new model instance. </p>
<p>Returns the index for the model instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that uniquely identifies the new instance to be added to <code>this</code> model. An exception is thrown if an instance with the same name already exists in the model. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a05b71664c8e2e91bc3fc92fef222a9bf">HasModelInstanceNamed()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f6a68c31772eaa0c855ebb44eeaa0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6a68c31772eaa0c855ebb44eeaa0b7">&#9670;&nbsp;</a></span>AddRigidBody() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; AddRigidBody </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_BBo_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a rigid body with the provided name and spatial inertia. </p>
<p>This method returns a constant reference to the body just added, which will remain valid for the lifetime of <code>this</code> MultibodyPlant.</p>
<p>Example of usage: </p><div class="fragment"><div class="line">MultibodyPlant&lt;T&gt; plant;</div><div class="line"><span class="comment">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span></div><div class="line"><a class="code" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> model_instance = plant.AddModelInstance(<span class="stringliteral">&quot;instance&quot;</span>);</div><div class="line"><span class="keyword">const</span> RigidBody&lt;T&gt;&amp; body =</div><div class="line">  plant.AddRigidBody(<span class="stringliteral">&quot;BodyName&quot;</span>, model_instance, spatial_inertia);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that identifies the new body to be added to <code>this</code> model. A std::runtime_error is thrown if a body named <code>name</code> already is part of <code>model_instance</code>. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_body.html#ad8227ba86a01f26e4f173cd5e219d5d1" title="Gets the name associated with this body.">Body::name()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instance</td><td>A model instance index which this body is part of. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M_BBo_B</td><td>The <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia.">SpatialInertia</a> of the new rigid body to be added to <code>this</code> MultibodyPlant, computed about the body frame origin <code>Bo</code> and expressed in the body frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> just added, which will remain valid for the lifetime of <code>this</code> MultibodyPlant. </dd></dl>

</div>
</div>
<a id="a461a59b672f8c3f7c0dcc5caed56d245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461a59b672f8c3f7c0dcc5caed56d245">&#9670;&nbsp;</a></span>AddRigidBody() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; AddRigidBody </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html">SpatialInertia</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M_BBo_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a rigid body with the provided name and spatial inertia. </p>
<p>This method returns a constant reference to the body just added, which will remain valid for the lifetime of <code>this</code> MultibodyPlant. The body will use the default model instance (<a class="el" href="model__instance_8h.html#model_instance">more on model instances</a>).</p>
<p>Example of usage: </p><div class="fragment"><div class="line">MultibodyPlant&lt;T&gt; plant;</div><div class="line"><span class="comment">// ... Code to define spatial_inertia, a SpatialInertia&lt;T&gt; object ...</span></div><div class="line"><span class="keyword">const</span> RigidBody&lt;T&gt;&amp; body =</div><div class="line">  plant.AddRigidBody(<span class="stringliteral">&quot;BodyName&quot;</span>, spatial_inertia);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A string that identifies the new body to be added to <code>this</code> model. A std::runtime_error is thrown if a body named <code>name</code> already is part of the model in the default model instance. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed()</a>, <a class="el" href="classdrake_1_1multibody_1_1_body.html#ad8227ba86a01f26e4f173cd5e219d5d1" title="Gets the name associated with this body.">Body::name()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M_BBo_B</td><td>The <a class="el" href="classdrake_1_1multibody_1_1_spatial_inertia.html" title="This class represents the physical concept of a Spatial Inertia.">SpatialInertia</a> of the new rigid body to be added to <code>this</code> MultibodyPlant, computed about the body frame origin <code>Bo</code> and expressed in the body frame B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the new <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a> just added, which will remain valid for the lifetime of <code>this</code> MultibodyPlant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if additional model instances have been created beyond the world and default instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a029b22a36d5c6ee85247b9c1cfe84c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029b22a36d5c6ee85247b9c1cfe84c6b">&#9670;&nbsp;</a></span>CalcBiasCenterOfMassTranslationalAcceleration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; CalcBiasCenterOfMassTranslationalAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a>&#160;</td>
          <td class="paramname"><em>with_respect_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates abias_ACcm_E, point Ccm's translational "bias" acceleration term in frame A with respect to "speeds" 𝑠, expressed in frame E, where point Ccm is the composite center of mass of the system of all bodies (except <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a29ef779ddfeea96c5d80c27d68a4f864" title="Returns a constant reference to the world body.">world_body()</a>) in the <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </p>
<p>abias_ACcm is the part of a_ACcm (Ccm's translational acceleration) that does not multiply ṡ, equal to abias_ACcm = J̇𝑠_v_ACcm ⋅ s. This allows a_ACcm to be written as a_ACcm = J𝑠_v_ACcm ⋅ ṡ + abias_ACcm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the Jacobian <code>abias_ACcm</code> is partial derivatives with respect to 𝑠 = q̇ (time-derivatives of generalized positions) or with respect to 𝑠 = v (generalized velocities). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame in which abias_ACcm is measured. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which abias_ACcm is expressed on output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">abias_ACcm_E</td><td>Point Ccm's translational "bias" acceleration term in frame A with respect to "speeds" 𝑠, expressed in frame E. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if Ccm does not exist, which occurs if there are no massive bodies in <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> (except <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a29ef779ddfeea96c5d80c27d68a4f864" title="Returns a constant reference to the world body.">world_body()</a>). </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>unless composite_mass &gt; 0, where composite_mass is the total mass of all bodies except <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a29ef779ddfeea96c5d80c27d68a4f864" title="Returns a constant reference to the world body.">world_body()</a> in <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if frame_A is not the world frame. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1acb4f78f307092671567a002b39c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1acb4f78f307092671567a002b39c4b">&#9670;&nbsp;</a></span>CalcBiasForJacobianSpatialVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a14aa433aedda321a15238f2d4074d4c3">Vector6</a>&lt;T&gt; CalcBiasForJacobianSpatialVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a>&#160;</td>
          <td class="paramname"><em>with_respect_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_FoFp_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a point Fp that is fixed to a frame F, calculates Fp's spatial acceleration "bias" term <code>Abias_AFp = J̇s_V_AFp * s</code> in frame A with respect to "speeds" 𝑠. </p>
<pre>
  A_AFp = J𝑠_V_AFp(q)⋅ṡ + Abias_AFp(q, v)
</pre><p> A_AFp is point Fp's spatial acceleration in frame A and 𝑠 is either q̇ ≜ [q̇₁ ... q̇ⱼ]ᵀ (time-derivatives of generalized positions) or v ≜ [v₁ ... vₖ]ᵀ (generalized velocities). Note: <code>Abias_AFp = J̇s_V_AFp(q, s)⋅s</code>  is quadratic in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ Note: This method is misnamed CalcBiasForJacobianSpatialVelocity. Expect a name change to reflect its acceleration (not velocity) nature.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5f39a8f68fae3de53767a281503a3313" title="For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp&#39;s spatial velocity Jacobian in fr...">CalcJacobianSpatialVelocity()</a> to compute <code>J𝑠_V_AFp</code>, point Fp's spatial velocity Jacobian in frame A with respect to 𝑠.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system, which includes the generalized positions q and generalized velocities v. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the Jacobian <code>J𝑠_v_AFp</code> is partial derivatives with respect to 𝑠 = q̇ (time-derivatives of generalized positions) or with respect to 𝑠 = v (generalized velocities). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_F</td><td>The frame on which point Fp is fixed/welded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_FoFp_F</td><td>position vector from Fo (frame F's origin) to point Fp, expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame that measures <code>Abias_AFp</code>. Currently, an exception is thrown if frame_A is not the World frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which <code>Abias_AFp</code> is expressed on output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Abias_AFp_E Fp's spatial acceleration bias in frame_A is returned in a <code>6 x 1</code> matrix whose first three elements are frame_F's angular acceleration bias in frame_A (expressed in frame_E) and whose last three elements are point Fp's translational acceleration bias in frame_A (expressed in frame_E). These bias terms are functions of the generalized positions q and the generalized velocities v and depend on whether <code>with_respect_to</code> is kQDot or kV. Note: Although the return quantity is a Vector6, it is actually a <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html" title="This class is used to represent a spatial acceleration that combines rotational (angular acceleration...">SpatialAcceleration</a> (having units of that type). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>with_respect_to</code> is not <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a> </td></tr>
    <tr><td class="paramname">std::exception</td><td>if frame_A is not the world frame. (Deprecated.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>"Use CalcBiasSpatialAcceleration() instead " "of CalcBiasForJacobianSpatialVelocity()." <br />
 This will be removed from Drake on or after "2020-09-01" .</dd></dl>

</div>
</div>
<a id="a72169faa39827ad74deb36e4a9bd18e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72169faa39827ad74deb36e4a9bd18e9">&#9670;&nbsp;</a></span>CalcBiasForJacobianTranslationalVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; CalcBiasForJacobianTranslationalVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a>&#160;</td>
          <td class="paramname"><em>with_respect_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_FP_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a point Fp that is fixed to a frame F, calculates Fp's translational acceleration "bias" term <code>abias_AFp = J̇s_v_AFp(q, s) * s</code> in frame A with respect to "speeds" 𝑠. </p>
<pre>
  a_AFp = J𝑠_v_AFp(q)⋅ṡ + abias_AFp(q, v)
</pre><p> a_AFp is point Fp's translational acceleration in frame A and 𝑠 is either q̇ ≜ [q̇₁ ... q̇ⱼ]ᵀ (time-derivatives of generalized positions) or v ≜ [v₁ ... vₖ]ᵀ (generalized velocities). Note: <code>abias_AFp = J̇s_v_AFp(q, s)⋅s</code>  is quadratic in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ Note: This method is misnamed CalcBiasForJacobianTranslationalVelocity. Expect a name change to reflect its acceleration (not velocity) nature.</p>
<p>This method computes <code>abias_AFp</code> for each point Fp in the <code>p_FP_list</code>. The <code>p_FP_list</code> is a list of position vectors from Fo (<a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame),...">Frame</a> F's origin) to each such point Fp, expressed in frame F.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae2516569f5a2cc27e76ee0cc8b728746" title="For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi, Bi&#39;s translational velocity Jacob...">CalcJacobianTranslationalVelocity()</a> to compute <code>J𝑠_v_AFp</code>, point Fp's translational velocity Jacobian in frame A with respect to s.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system, which includes the generalized positions q and generalized velocities v. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the Jacobian <code>J𝑠_v_AFp</code> is partial derivatives with respect to 𝑠 = q̇ (time-derivatives of generalized positions) or with respect to 𝑠 = v (generalized velocities). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_F</td><td>The frame on which point Fp is fixed/welded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_FP_list</td><td><code>3 x n</code> matrix of position vectors <code>p_FoFp_F</code> from Fo (frame F's origin) to each such point Fp, expressed in frame F. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame that measures <code>abias_AFp</code>. Currently, an exception is thrown if frame_A is not the World frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which <code>abias_AFp</code> is expressed on output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>abias_AFp_E matrix of translational acceleration bias terms in frame_A and expressed in frame_E for each of the <code>n</code> points associated with p_FP_list. These bias terms are functions of the generalized positions q and the generalized velocities v and depend on whether <code>with_respect_to</code> is kQDot or kV. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>p_FP_list</code> does not have 3 rows. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>with_respect_to</code> is not <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a> </td></tr>
    <tr><td class="paramname">std::exception</td><td>if frame_A is not the world frame. (Deprecated.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>"Use CalcBiasTranslationalAcceleration " "instead of CalcBiasForJacobianTranslationalVelocity()." <br />
 This will be removed from Drake on or after "2020-09-01" .</dd></dl>

</div>
</div>
<a id="aa238d2cebe527f4da55e0ec5d75e8dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa238d2cebe527f4da55e0ec5d75e8dda">&#9670;&nbsp;</a></span>CalcBiasSpatialAcceleration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt;T&gt; CalcBiasSpatialAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a>&#160;</td>
          <td class="paramname"><em>with_respect_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BoBp_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For one point Bp affixed/welded to a frame B, calculates A𝑠Bias_ABp, Bp's spatial acceleration bias in frame A with respect to "speeds" 𝑠, where 𝑠 is either q̇ (time-derivatives of generalized positions) or v (generalized velocities). </p>
<p>A𝑠Bias_ABp is the term in A_ABp (Bp's spatial acceleration in A) that does not include 𝑠̇, i.e., A𝑠Bias_ABp is Bi's translational acceleration in A when 𝑠̇ = 0. </p><pre>
  A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   (𝑠 = q̇ or 𝑠 = v), hence
  A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠
</pre><p> where J𝑠_V_ABp is Bp's spatial velocity Jacobian in frame A for speeds s (see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5f39a8f68fae3de53767a281503a3313" title="For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp&#39;s spatial velocity Jacobian in fr...">CalcJacobianSpatialVelocity()</a> for details on J𝑠_V_ABp). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the spatial accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame on which point Bp is affixed/welded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BoBp_B</td><td>Position vector from Bo (frame_B's origin) to point Bp (regarded as affixed/welded to B), expressed in frame_B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame that measures A𝑠Bias_ABp. Currently, an exception is thrown if frame_A is not the World frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which A𝑠Bias_ABp is expressed on output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A𝑠Bias_ABp_E Point Bp's spatial acceleration bias in frame A with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Shown below, A𝑠Bias_ABp_E = J̇𝑠_V_ABp ⋅ 𝑠 is quadratic in 𝑠. <pre>
 V_ABp =  J𝑠_V_ABp ⋅ 𝑠        which upon vector differentiation in A gives
 A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   Since J̇𝑠_V_ABp is linear in 𝑠,
 A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠                             is quadratic in 𝑠.
</pre> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5f39a8f68fae3de53767a281503a3313" title="For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp&#39;s spatial velocity Jacobian in fr...">CalcJacobianSpatialVelocity()</a> to compute J𝑠_V_ABp, point Bp's translational velocity Jacobian in frame A with respect to 𝑠. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if with_respect_to is not <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a> </td></tr>
    <tr><td class="paramname">std::exception</td><td>if frame_A is not the world frame. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a843e1ba389c017c706df10935784b4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843e1ba389c017c706df10935784b4e5">&#9670;&nbsp;</a></span>CalcBiasTerm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcBiasTerm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Cv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the bias term <code>C(q, v)v</code> containing Coriolis, centripetal, and gyroscopic effects in the multibody equations of motion: </p>
<pre>
  M(q) v̇ + C(q, v) v = tau_app + ∑ (Jv_V_WBᵀ(q) ⋅ Fapp_Bo_W)
</pre><p> where <code>M(q)</code> is the multibody model's mass matrix and <code>tau_app</code> is a vector of generalized forces. The last term is a summation over all bodies of the dot-product of <code>Fapp_Bo_W</code> (applied spatial force on body B at Bo) with <code>Jv_V_WB(q)</code> (B's spatial Jacobian in world W with respect to generalized velocities v). Note: B's spatial velocity in W can be written <code>V_WB = Jv_V_WB * v</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q and the generalized velocities v. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Cv</td><td>On output, <code>Cv</code> will contain the product <code>C(q, v)v</code>. It must be a valid (non-null) pointer to a column vector in <code>ℛⁿ</code> with n the number of generalized velocities (<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>) of the model. This method aborts if Cv is nullptr or if it does not have the proper size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add53749e8bb0ec1b0c564bdc14d3c74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add53749e8bb0ec1b0c564bdc14d3c74e">&#9670;&nbsp;</a></span>CalcBiasTranslationalAcceleration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt;T&gt; CalcBiasTranslationalAcceleration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a>&#160;</td>
          <td class="paramname"><em>with_respect_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BoBi_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi, Bi's translational acceleration bias in frame A with respect to "speeds" 𝑠, where 𝑠 is either q̇ (time-derivatives of generalized positions) or v (generalized velocities). </p>
<p>a𝑠Bias_ABi is the term in a_ABi (Bi's translational acceleration in A) that does not include 𝑠̇, i.e., a𝑠Bias_ABi is Bi's translational acceleration in A when 𝑠̇ = 0. </p><pre>
  a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇  +  J̇𝑠_v_ABi ⋅ 𝑠  (𝑠 = q̇ or 𝑠 = v), hence
  a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠
</pre><p> where J𝑠_v_ABi is Bi's translational velocity Jacobian in frame A for s (see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae2516569f5a2cc27e76ee0cc8b728746" title="For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi, Bi&#39;s translational velocity Jacob...">CalcJacobianTranslationalVelocity()</a> for details on J𝑠_v_ABi). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the translational accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame on which points Bi are affixed/welded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BoBi_B</td><td>A position vector or list of p position vectors from Bo (frame_B's origin) to points Bi (regarded as affixed to B), where each position vector is expressed in frame_B. Each column in the <code>3 x p</code> matrix p_BoBi_B corresponds to a position vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame that measures a𝑠Bias_ABi. Currently, an exception is thrown if frame_A is not the World frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which a𝑠Bias_ABi is expressed on output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a𝑠Bias_ABi_E Point Bi's translational acceleration bias in frame A with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E. a𝑠Bias_ABi_E is a <code>3 x p</code> matrix, where p is the number of points Bi. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Shown below, a𝑠Bias_ABi_E = J̇𝑠_v_ABp ⋅ 𝑠 is quadratic in 𝑠.<pre>
 v_ABi =  J𝑠_v_ABi ⋅ 𝑠        which upon vector differentiation in A gives
 a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇ + J̇𝑠_v_ABi ⋅ 𝑠     Since J̇𝑠_v_ABi is linear in 𝑠,
 a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠                             is quadratic in 𝑠.
</pre> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae2516569f5a2cc27e76ee0cc8b728746" title="For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi, Bi&#39;s translational velocity Jacob...">CalcJacobianTranslationalVelocity()</a> to compute J𝑠_v_ABi, point Bi's translational velocity Jacobian in frame A with respect to 𝑠. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>p_BoBi_B must have 3 rows. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if with_respect_to is not <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a> </td></tr>
    <tr><td class="paramname">std::exception</td><td>if frame_A is not the world frame. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0ba70b7920dc9df4a1e25c4ecf7830f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ba70b7920dc9df4a1e25c4ecf7830f">&#9670;&nbsp;</a></span>CalcCenterOfMassPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; CalcCenterOfMassPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method computes the center of mass position p_WCcm of all bodies in <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a></code> measured and expressed in world frame W. </p>
<p>The bodies are considered as a single composite body C, whose center of mass <code>composite_mass</code> is located at Ccm. The <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a29ef779ddfeea96c5d80c27d68a4f864" title="Returns a constant reference to the world body.">world_body()</a> is ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q of the model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">p_WCcm</td><td>The output position of center of mass in the world frame W.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a></code> has no body except <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a29ef779ddfeea96c5d80c27d68a4f864" title="Returns a constant reference to the world body.">world_body()</a></code>. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>unless <code>composite_mass &gt; 0</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa04e0b90b27a703272d586946ad33eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04e0b90b27a703272d586946ad33eff">&#9670;&nbsp;</a></span>CalcCenterOfMassPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; CalcCenterOfMassPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_instances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method computes the center of mass position p_WCcm of specified model instances measured and expressed in world frame W. </p>
<p>The specified model instances are considered as a single composite body C, whose center of mass <code>composite_mass</code> is located at Ccm. The models are selected by a vector of model instances <code>model_instances</code>. This function does not distinguish between welded bodies, joint connected bodies and free bodies in the <code>model_instances</code>. The <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a29ef779ddfeea96c5d80c27d68a4f864" title="Returns a constant reference to the world body.">world_body()</a> is ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_instances</td><td>The vector of selected model instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">p_WCcm</td><td>The output position of center of mass in the world frame W.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a></code> has no model_instance except <code><a class="el" href="namespacedrake_1_1multibody.html#a777a2894881e59d27fc9eb7b4413406f" title="Returns the model instance containing the world body.">world_model_instance()</a></code>. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>unless <code>composite_mass &gt; 0</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1b54c8562f107e4d6e11b4b0f8d53c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b54c8562f107e4d6e11b4b0f8d53c5">&#9670;&nbsp;</a></span>CalcForceElementsContribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcForceElementsContribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>forces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the combined force contribution of <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> objects in the model. </p>
<p>A <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> can apply forces as a spatial force per body or as generalized forces, depending on the <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> model. <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> contributions are a function of the state and time only. The output from this method can immediately be used as input to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#afcb4de9b58cb375d056da7e8ec30937a" title="Given the state of this model in context and a known vector of generalized accelerations vdot,...">CalcInverseDynamics()</a> to include the effect of applied forces by force elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of this model. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">forces</td><td>A pointer to a valid, non nullptr, multibody forces object. On output <code>forces</code> will store the forces exerted by all the <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> objects in the model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>forces</code> is null or not compatible with this model, per MultibodyForces::CheckInvariants(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad877d988ac4cd1942aa84e91e3c5d49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad877d988ac4cd1942aa84e91e3c5d49a">&#9670;&nbsp;</a></span>CalcGravityGeneralizedForces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; CalcGravityGeneralizedForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the generalized forces <code>tau_g(q)</code> due to gravity as a function of the generalized positions <code>q</code> stored in the input <code>context</code>. </p>
<p>The vector of generalized forces due to gravity <code>tau_g(q)</code> is defined such that it appears on the right hand side of the equations of motion together with any other generalized forces, like so: </p><pre>
  Mv̇ + C(q, v)v = tau_g(q) + tau_app
</pre><p> where <code>tau_app</code> includes any other generalized forces applied on the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context storing the state of the model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tau_g A vector containing the generalized forces due to gravity. The generalized forces are consistent with the vector of generalized velocities <code>v</code> for <code>this</code> so that the inner product <code>v⋅tau_g</code> corresponds to the power applied by the gravity forces on the mechanical system. That is, <code>v⋅tau_g &gt; 0</code> corresponds to potential energy going into the system, as either mechanical kinetic energy, some other potential energy, or heat, and therefore to a decrease of the gravitational potential energy. </dd></dl>

</div>
</div>
<a id="afcb4de9b58cb375d056da7e8ec30937a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb4de9b58cb375d056da7e8ec30937a">&#9670;&nbsp;</a></span>CalcInverseDynamics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; CalcInverseDynamics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>known_vdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html">MultibodyForces</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>external_forces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the state of this model in <code>context</code> and a known vector of generalized accelerations <code>vdot</code>, this method computes the set of generalized forces <code>tau</code> that would need to be applied in order to attain the specified generalized accelerations. </p>
<p>Mathematically, this method computes: </p><pre>
  tau = M(q)v̇ + C(q, v)v - tau_app - ∑ J_WBᵀ(q) Fapp_Bo_W
</pre><p> where <code>M(q)</code> is the model's mass matrix, <code>C(q, v)v</code> is the bias term containing Coriolis and gyroscopic effects and <code>tau_app</code> consists of a vector applied generalized forces. The last term is a summation over all bodies in the model where <code>Fapp_Bo_W</code> is an applied spatial force on body B at <code>Bo</code> which gets projected into the space of generalized forces with the transpose of <code>Jv_V_WB(q)</code> (where <code>Jv_V_WB</code> is B's spatial velocity Jacobian in W with respect to generalized velocities v). Note: B's spatial velocity in W can be written as <code>V_WB = Jv_V_WB * v</code>. This method does not compute explicit expressions for the mass matrix nor for the bias term, which would be of at least <code>O(n²)</code> complexity, but it implements an <code>O(n)</code> Newton-Euler recursive algorithm, where n is the number of bodies in the model. The explicit formation of the mass matrix <code>M(q)</code> would require the calculation of <code>O(n²)</code> entries while explicitly forming the product <code>C(q, v) * v</code> could require up to <code>O(n³)</code> operations (see [Featherstone 1987, §4]), depending on the implementation. The recursive Newton-Euler algorithm is the most efficient currently known general method for solving inverse dynamics [Featherstone 2008].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">known_vdot</td><td>A vector with the known generalized accelerations <code>vdot</code> for the full model. Use the provided <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> APIs in order to access entries into this array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">external_forces</td><td>A set of forces to be applied to the system either as body spatial forces <code>Fapp_Bo_W</code> or generalized forces <code>tau_app</code>, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_forces.html" title="A class to hold a set of forces applied to a MultibodyTree system.">MultibodyForces</a> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector of generalized forces that would need to be applied to the mechanical system in order to achieve the desired acceleration given by <code>known_vdot</code>. </dd></dl>

</div>
</div>
<a id="aac6058b002bdb83057539ad9785267b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6058b002bdb83057539ad9785267b7">&#9670;&nbsp;</a></span>CalcJacobianAngularVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcJacobianAngularVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a>&#160;</td>
          <td class="paramname"><em>with_respect_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Js_w_AB_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates J𝑠_w_AB, a frame B's angular velocity Jacobian in a frame A with respect to "speeds" 𝑠. </p>
<pre>
     J𝑠_w_AB ≜ [ ∂(w_AB)/∂𝑠₁,  ...  ∂(w_AB)/∂𝑠ₙ ]    (n is j or k)
     w_AB = J𝑠_w_AB ⋅ 𝑠          w_AB is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre><p> <code>w_AB</code> is B's angular velocity in frame A and "speeds" 𝑠 is either q̇ ≜ [q̇₁ ... q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v ≜ [v₁ ... vₖ]ᵀ (k generalized velocities).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the Jacobian <code>J𝑠_w_AB</code> is partial derivatives with respect to 𝑠 = q̇ (time-derivatives of generalized positions) or with respect to 𝑠 = v (generalized velocities). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame B in <code>w_AB</code> (B's angular velocity in A). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame A in <code>w_AB</code> (B's angular velocity in A). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which <code>w_AB</code> is expressed on input and the frame in which the Jacobian <code>J𝑠_w_AB</code> is expressed on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J𝑠_w_AB_E</td><td><a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame),...">Frame</a> B's angular velocity Jacobian in frame A with respect to speeds 𝑠 (which is either q̇ or v), expressed in frame E. The Jacobian is a function of only generalized positions q (which are pulled from the context). The previous definition shows <code>J𝑠_w_AB_E</code> is a matrix of size <code>3 x n</code>, where n is the number of elements in 𝑠. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>J𝑠_w_AB_E</code> is nullptr or not of size <code>3 x n</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4e686199a5e9ddee98538741b7a0382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e686199a5e9ddee98538741b7a0382">&#9670;&nbsp;</a></span>CalcJacobianCenterOfMassTranslationalVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcJacobianCenterOfMassTranslationalVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a>&#160;</td>
          <td class="paramname"><em>with_respect_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Js_v_ACcm_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method computes J𝑠_v_ACcm_E, point Ccm's translational velocity Jacobian in frame A with respect to "speeds" 𝑠, expressed in frame E, where point Ccm is the composite center of mass of the system of all bodies in the <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> (except <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a29ef779ddfeea96c5d80c27d68a4f864" title="Returns a constant reference to the world body.">world_body()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the Jacobian <code>J𝑠_v_ACcm_E</code> is partial derivatives with respect to 𝑠 = q̇ (time-derivatives of generalized positions) or with respect to 𝑠 = v (generalized velocities). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame in which the translational velocity v_ACcm and its Jacobian J𝑠_v_ACcm are measured. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which the Jacobian J𝑠_v_ACcm is expressed on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J𝑠_v_ACcm_E</td><td>Point Ccm's translational velocity Jacobian in frame A with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E. J𝑠_v_ACcm_E is a 3 x n matrix, where n is the number of elements in 𝑠. The Jacobian is a function of only generalized positions q (which are pulled from the context). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if CCm does not exist, which occurs if there are no massive bodies in <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> (except <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a29ef779ddfeea96c5d80c27d68a4f864" title="Returns a constant reference to the world body.">world_body()</a>). </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>unless composite_mass &gt; 0, where composite_mass is the total mass of all bodies except <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a29ef779ddfeea96c5d80c27d68a4f864" title="Returns a constant reference to the world body.">world_body()</a> in <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f39a8f68fae3de53767a281503a3313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f39a8f68fae3de53767a281503a3313">&#9670;&nbsp;</a></span>CalcJacobianSpatialVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcJacobianSpatialVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a>&#160;</td>
          <td class="paramname"><em>with_respect_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BoBp_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Js_V_ABp_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp's spatial velocity Jacobian in frame A with respect to "speeds" 𝑠. </p>
<pre>
     J𝑠_V_ABp ≜ [ ∂(V_ABp)/∂𝑠₁,  ...  ∂(V_ABp)/∂𝑠ₙ ]    (n is j or k)
     V_ABp = J𝑠_V_ABp ⋅ 𝑠          V_ABp is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre><p> <code>V_ABp</code> is Bp's spatial velocity in frame A and "speeds" 𝑠 is either q̇ ≜ [q̇₁ ... q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v ≜ [v₁ ... vₖ]ᵀ (k generalized velocities).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the Jacobian <code>J𝑠_V_ABp</code> is partial derivatives with respect to 𝑠 = q̇ (time-derivatives of generalized positions) or with respect to 𝑠 = v (generalized velocities). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame on which point Bp is fixed/welded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BoBp_B</td><td>A position vector from Bo (frame_B's origin) to point Bp (regarded as fixed/welded to B), expressed in frame_B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame that measures <code>v_ABp</code> (Bp's velocity in A). Note: It is natural to wonder why there is no parameter p_AoAp_A (similar to the parameter p_BoBp_B for frame_B). There is no need for p_AoAp_A because Bp's velocity in A is defined as the derivative in frame A of Bp's position vector from <em>any</em> point fixed to A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which <code>v_ABp</code> is expressed on input and the frame in which the Jacobian <code>J𝑠_V_ABp</code> is expressed on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J𝑠_V_ABp_E</td><td>Point Bp's spatial velocity Jacobian in frame A with respect to speeds 𝑠 (which is either q̇ or v), expressed in frame E. <code>J𝑠_V_ABp_E</code> is a <code>6 x n</code> matrix, where n is the number of elements in 𝑠. The Jacobian is a function of only generalized positions q (which are pulled from the context). Note: The returned <code>6 x n</code> matrix stores frame B's angular velocity Jacobian in A in rows 1-3 and stores point Bp's translational velocity Jacobian in A in rows 4-6, i.e., <pre>
    J𝑠_w_AB_E = J𝑠_V_ABp_E.topRows&lt;3&gt;();
    J𝑠_v_ABp_E = J𝑠_V_ABp_E.bottomRows&lt;3&gt;();
</pre> Note: Consider <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae2516569f5a2cc27e76ee0cc8b728746" title="For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi, Bi&#39;s translational velocity Jacob...">CalcJacobianTranslationalVelocity()</a> for multiple points fixed to frame B and consider <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aac6058b002bdb83057539ad9785267b7" title="Calculates J𝑠_w_AB, a frame B&#39;s angular velocity Jacobian in a frame A with respect to &quot;speeds&quot; 𝑠.">CalcJacobianAngularVelocity()</a> to calculate frame B's angular velocity Jacobian. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>J𝑠_V_ABp_E</code> is nullptr or not sized <code>6 x n</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2516569f5a2cc27e76ee0cc8b728746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2516569f5a2cc27e76ee0cc8b728746">&#9670;&nbsp;</a></span>CalcJacobianTranslationalVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcJacobianTranslationalVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658">JacobianWrtVariable</a>&#160;</td>
          <td class="paramname"><em>with_respect_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#acfe2dee57bc492bfbd96fe078b65ab00">Matrix3X</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BoBi_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>Js_v_ABi_E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi, Bi's translational velocity Jacobian in frame A with respect to "speeds" 𝑠. </p>
<pre>
     J𝑠_v_ABi ≜ [ ∂(v_ABi)/∂𝑠₁,  ...  ∂(v_ABi)/∂𝑠ₙ ]    (n is j or k)
     v_ABi = J𝑠_v_ABi ⋅ 𝑠          v_ABi is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre><p> <code>v_ABi</code> is Bi's translational velocity in frame A and "speeds" 𝑠 is either q̇ ≜ [q̇₁ ... q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v ≜ [v₁ ... vₖ]ᵀ (k generalized velocities).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">with_respect_to</td><td>Enum equal to <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a08a6dd2b7a7e7a0a13886a70c696f72b" title="J = ∂V/∂q̇">JacobianWrtVariable::kQDot</a> or <a class="el" href="namespacedrake_1_1multibody.html#ad95b5f6a8d72582ad91a1aca26d76658a63b39853c60d1092c257c1ab898bad0a" title="J = ∂V/∂v.">JacobianWrtVariable::kV</a>, indicating whether the Jacobian <code>J𝑠_v_ABi</code> is partial derivatives with respect to 𝑠 = q̇ (time-derivatives of generalized positions) or with respect to 𝑠 = v (generalized velocities). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame on which point Bi is affixed/welded. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BoBi_B</td><td>A position vector or list of p position vectors from Bo (frame_B's origin) to points Bi (regarded as affixed to B), where each position vector is expressed in frame_B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame that measures <code>v_ABi</code> (Bi's velocity in A). Note: It is natural to wonder why there is no parameter p_AoAi_A (similar to the parameter p_BoBi_B for frame_B). There is no need for p_AoAi_A because Bi's velocity in A is defined as the derivative in frame A of Bi's position vector from <em>any</em> point affixed to A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_E</td><td>The frame in which <code>v_ABi</code> is expressed on input and the frame in which the Jacobian <code>J𝑠_v_ABi</code> is expressed on output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J𝑠_v_ABi_E</td><td>Point Bi's velocity Jacobian in frame A with respect to speeds 𝑠 (which is either q̇ or v), expressed in frame E. <code>J𝑠_v_ABi_E</code> is a <code>3*p x n</code> matrix, where p is the number of points Bi and n is the number of elements in 𝑠. The Jacobian is a function of only generalized positions q (which are pulled from the context). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>J𝑠_v_ABi_E</code> is nullptr or not sized <code>3*p x n</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When 𝑠 = q̇, <code>Jq̇_v_ABi = Jq_p_AoBi</code>. In other words, point Bi's velocity Jacobian in frame A with respect to q̇ is equal to point Bi's position Jacobian from Ao (A's origin) in frame A with respect to q. <pre>
[∂(v_ABi)/∂q̇₁,  ...  ∂(v_ABi)/∂q̇ⱼ] = [∂(p_AoBi)/∂q₁,  ...  ∂(p_AoBi)/∂qⱼ]
</pre> Note: Each partial derivative of p_AoBi is taken in frame A. </dd></dl>

</div>
</div>
<a id="adf95c4544e8855015c110ba173ccdd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf95c4544e8855015c110ba173ccdd0b">&#9670;&nbsp;</a></span>CalcMassMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcMassMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the computation of the mass matrix <code>M(q)</code> of the model, as a function of the generalized positions q stored in <code>context</code>. </p>
<p>This method employs the Composite <a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a> Algorithm, which is known to be the fastest O(n²) algorithm to compute the mass matrix of a multibody system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>A valid (non-null) pointer to a squared matrix in <code>ℛⁿˣⁿ</code> with n the number of generalized velocities (<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>) of the model. This method aborts if M is nullptr or if it does not have the proper size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This is an O(n²) algorithm. Avoid the explicit computation of the mass matrix whenever possible. </dd></dl>

</div>
</div>
<a id="a574e59c853d14d59bde09b40a88ff019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574e59c853d14d59bde09b40a88ff019">&#9670;&nbsp;</a></span>CalcMassMatrixViaInverseDynamics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcMassMatrixViaInverseDynamics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the computation of the mass matrix <code>M(q)</code> of the model using inverse dynamics, where the generalized positions q are stored in <code>context</code>. </p>
<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#afcb4de9b58cb375d056da7e8ec30937a" title="Given the state of this model in context and a known vector of generalized accelerations vdot,...">CalcInverseDynamics()</a>.</p>
<p>Use <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#adf95c4544e8855015c110ba173ccdd0b" title="Performs the computation of the mass matrix M(q) of the model, as a function of the generalized posit...">CalcMassMatrix()</a> for a faster implementation using the Composite <a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a> Algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>A valid (non-null) pointer to a squared matrix in <code>ℛⁿˣⁿ</code> with n the number of generalized velocities (<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>) of the model. This method aborts if H is nullptr or if it does not have the proper size.</td></tr>
  </table>
  </dd>
</dl>
<p>The algorithm used to build <code>M(q)</code> consists in computing one column of <code>M(q)</code> at a time using inverse dynamics. The result from inverse dynamics, with no applied forces, is the vector of generalized forces: </p><pre>
  tau = M(q)v̇ + C(q, v)v
</pre><p> where q and v are the generalized positions and velocities, respectively. When <code>v = 0</code> the Coriolis and gyroscopic forces term <code>C(q, v)v</code> is zero. Therefore the <code>i-th</code> column of <code>M(q)</code> can be obtained performing inverse dynamics with an acceleration vector <code>v̇ = eᵢ</code>, with <code>eᵢ</code> the standard (or natural) basis of <code>ℛⁿ</code> with n the number of generalized velocities. We write this as: </p><pre>
  M.ᵢ(q) = M(q) * e_i
</pre><p> where <code>M.ᵢ(q)</code> (notice the dot for the rows index) denotes the <code>i-th</code> column in M(q).</p>
<dl class="section warning"><dt>Warning</dt><dd>This is an O(n²) algorithm. Avoid the explicit computation of the mass matrix whenever possible. </dd></dl>

</div>
</div>
<a id="a27bce36db6170b2ed1ee53481f8017a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27bce36db6170b2ed1ee53481f8017a5">&#9670;&nbsp;</a></span>CalcPointsPositions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcPointsPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p_BQi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>p_AQi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the positions <code>p_BQi</code> for a set of points <code>Qi</code> measured and expressed in a frame B, this method computes the positions <code>p_AQi(q)</code> of each point <code>Qi</code> in the set as measured and expressed in another frame A, as a function of the generalized positions q of the model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. It stores the generalized positions q of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_B</td><td>The frame B in which the positions <code>p_BQi</code> of a set of points <code>Qi</code> are given. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_BQi</td><td>The input positions of each point <code>Qi</code> in frame B. <code>p_BQi ∈ ℝ³ˣⁿᵖ</code> with <code>np</code> the number of points in the set. Each column of <code>p_BQi</code> corresponds to a vector in ℝ³ holding the position of one of the points in the set as measured and expressed in frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_A</td><td>The frame A in which it is desired to compute the positions <code>p_AQi</code> of each point <code>Qi</code> in the set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_AQi</td><td>The output positions of each point <code>Qi</code> now computed as measured and expressed in frame A. The output <code>p_AQi</code> <b>must</b> have the same size as the input <code>p_BQi</code> or otherwise this method aborts. That is <code>p_AQi</code> <b>must</b> be in <code>ℝ³ˣⁿᵖ</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Both <code>p_BQi</code> and <code>p_AQi</code> must have three rows. Otherwise this method will throw a std::runtime_error exception. This method also throws a std::runtime_error exception if <code>p_BQi</code> and <code>p_AQi</code> differ in the number of columns. </dd></dl>

</div>
</div>
<a id="af8e779bd785d02c0b0e14264b9055391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e779bd785d02c0b0e14264b9055391">&#9670;&nbsp;</a></span>CalcRelativeRotationMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rotation_matrix.html">math::RotationMatrix</a>&lt;T&gt; CalcRelativeRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the rotation matrix <code>R_FG</code> relating frame F and frame G. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system, which includes the system's generalized positions q. Note: <code>R_FG</code> is a function of q. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_F</td><td>The frame F designated in the rigid transform <code>R_FG</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_G</td><td>The frame G designated in the rigid transform <code>R_FG</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">R_FG</td><td>The RigidTransform relating frame F and frame G. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ff38c1d07aa9cbaf82c256dace67f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff38c1d07aa9cbaf82c256dace67f29">&#9670;&nbsp;</a></span>CalcRelativeTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;T&gt; CalcRelativeTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the rigid transform (pose) <code>X_FG</code> relating frame F and frame G. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The state of the multibody system, which includes the system's generalized positions q. Note: <code>X_FG</code> is a function of q. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_F</td><td>The frame F designated in the rigid transform <code>X_FG</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_G</td><td>The frame G designated in the rigid transform <code>X_FG</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_FG</td><td>The RigidTransform relating frame F and frame G. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefa1c5393d7cab419a944009cc93aa6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa1c5393d7cab419a944009cc93aa6c">&#9670;&nbsp;</a></span>CalcSpatialAccelerationsFromVdot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CalcSpatialAccelerationsFromVdot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>known_vdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdrake_1_1multibody_1_1_spatial_acceleration.html">SpatialAcceleration</a>&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>A_WB_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the state of this model in <code>context</code> and a known vector of generalized accelerations <code>known_vdot</code>, this method computes the spatial acceleration <code>A_WB</code> for each body as measured and expressed in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of this model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">known_vdot</td><td>A vector with the generalized accelerations for the full model. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A_WB_array</td><td>A pointer to a valid, non nullptr, vector of spatial accelerations containing the spatial acceleration <code>A_WB</code> for each body. It must be of size equal to the number of bodies in the model. On output, entries will be ordered by BodyIndex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if A_WB_array is not of size <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af92b53211e54243aff4490a700168eb4" title="Returns the number of bodies in the model, including the &quot;world&quot; body, which is always part of the mo...">num_bodies()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a830e17ff113f70e86e1c6a8b1b60d662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830e17ff113f70e86e1c6a8b1b60d662">&#9670;&nbsp;</a></span>CollectRegisteredGeometries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">geometry::GeometrySet</a> CollectRegisteredGeometries </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bodies</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each of the provided <code>bodies</code>, collects up all geometries that have been registered to that body. </p>
<p>Intended to be used in conjunction with SceneGraph::ExcludeCollisionsWithin() and SceneGraph::ExcludeCollisionsBetween() to filter collisions between the geometries registered to the bodies.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="comment">// Don&#39;t report on collisions between geometries affixed to `body1`,</span></div><div class="line"><span class="comment">// `body2`, or `body3`.</span></div><div class="line">std::vector&lt;const RigidBody&lt;T&gt;*&gt; bodies{&amp;body1, &amp;body2, &amp;body3};</div><div class="line">geometry::GeometrySet set = plant.CollectRegisteredGeometries(bodies);</div><div class="line">scene_graph.ExcludeCollisionsWithin(set);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>There is a <em>very</em> specific order of operations:</dd></dl>
<ol type="1">
<li>Bodies and geometries must be added to the MultibodyPlant.</li>
<li>The MultibodyPlant must be finalized (via <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>).</li>
<li>Create GeometrySet instances from bodies (via this method).</li>
<li>Invoke SceneGraph::ExcludeCollisions*() to filter collisions.</li>
<li>Allocate context.</li>
</ol>
<p>Changing the order will cause exceptions to be thrown.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38608634b36afab217b71de1f31fbc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38608634b36afab217b71de1f31fbc85">&#9670;&nbsp;</a></span>default_coulomb_friction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt;double&gt;&amp; default_coulomb_friction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the friction coefficients provided during geometry registration for the given geometry <code>id</code>. </p>
<p>We call these the "default" coefficients but note that we mean user-supplied per-geometry default, not something more global. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>id</code> does not correspond to a geometry in <code>this</code> model registered for contact modeling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac9b4f41a4f2575707d43ea031ce5a9ea" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for the contact modeling o...">RegisterCollisionGeometry()</a> for details on <a class="el" href="namespacedrake_1_1geometry.html">geometry</a> registration. (Deprecated.) </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>"default_coulomb_friction() will be removed. Please use SceneGraph which " "now stores friction properties in ProximityProperties. See the section " "\"Accessing point contact parameters" in the documentation for "       "<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>."   &lt;br&gt; This will be removed from Drake on or after   "2020-09-01" .</dd></dl>

</div>
</div>
<a id="a6f1fff1ed5cdfefba9e2ce717380783b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1fff1ed5cdfefba9e2ce717380783b">&#9670;&nbsp;</a></span>EvalBodyPoseInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;T&gt;&amp; EvalBodyPoseInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the pose <code>X_WB</code> of a body B in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context storing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">body_B</td><td>The body B for which the pose is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_WB</td><td>The pose of body frame B in the world frame W. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was not called on <code>this</code> model or if <code>body_B</code> does not belong to this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8377774b012b4975b46941b3197f29c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8377774b012b4975b46941b3197f29c3">&#9670;&nbsp;</a></span>EvalBodySpatialVelocityInWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt;T&gt;&amp; EvalBodySpatialVelocityInWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the spatial velocity <code>V_WB</code> of a body B in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context storing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">body_B</td><td>The body B for which the spatial velocity is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>V_WB The spatial velocity of body frame B in the world frame W. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was not called on <code>this</code> model or if <code>body_B</code> does not belong to this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecf801449932225a58b7daeb64a8f911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf801449932225a58b7daeb64a8f911">&#9670;&nbsp;</a></span>EvalPointPairPenetrations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html">geometry::PenetrationAsPointPair</a>&lt;T&gt; &gt;&amp; EvalPointPairPenetrations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates all point pairs of contact for a given state of the model stored in <code>context</code>. </p>
<p>Each entry in the returned vector corresponds to a single point pair corresponding to two interpenetrating bodies A and B. The size of the returned vector corresponds to the total number of contact penetration pairs. If no geometry was registered, the output vector is empty. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_geometry">Geometry</a> for <a class="el" href="namespacedrake_1_1geometry.html">geometry</a> registration. </dd>
<dd>
PenetrationAsPointPair for further details on the returned data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41edc1b3c920a1e48f27ad5661584fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41edc1b3c920a1e48f27ad5661584fad">&#9670;&nbsp;</a></span>ExcludeCollisionGeometriesWithCollisionFilterGroupPair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ExcludeCollisionGeometriesWithCollisionFilterGroupPair </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; std::string, <a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">geometry::GeometrySet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>collision_filter_group_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::string, <a class="el" href="classdrake_1_1geometry_1_1_geometry_set.html">geometry::GeometrySet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>collision_filter_group_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Excludes the collision geometries between two given collision filter groups. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4a6d28ce9c8119bee923e827eb6f02ed" title="Registers this plant to serve as a source for an instance of SceneGraph.">RegisterAsSourceForSceneGraph()</a> has been called. </dd>
<dd>
<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> has <em>not</em> been called. </dd></dl>

</div>
</div>
<a id="a8fee61d7a783cade1a3d07fe86284d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fee61d7a783cade1a3d07fe86284d27">&#9670;&nbsp;</a></span>Finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method must be called after all elements in the model (joints, bodies, force elements, constraints, etc.) are added and before any computations are performed. </p>
<p>It essentially compiles all the necessary "topological information", i.e. how bodies, joints and, any other elements connect with each other, and performs all the required pre-processing to enable computations at a later stage.</p>
<p>If the finalize stage is successful, the topology of this MultibodyPlant is valid, meaning that the topology is up-to-date after this call. No more multibody elements can be added after a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>.</p>
<p>At <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>, state and input/output ports for <code>this</code> plant are declared. If <code>this</code> plant registered geometry with a SceneGraph, input and output ports to enable communication with that SceneGraph are declared as well.</p>
<p>If geometry has been registered on a SceneGraph instance, that instance must be provided to the <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> method so that any geometric implications of the finalization process can be appropriately handled.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#acf7bb2a3531c09a97fb3623ac582d840" title="Returns true if this MultibodyPlant was finalized with a call to Finalize().">is_finalized()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the MultibodyPlant has already been finalized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afad783d7e7e513feb7a73384c8080041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad783d7e7e513feb7a73384c8080041">&#9670;&nbsp;</a></span>geometry_source_is_registered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool geometry_source_is_registered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>this</code> MultibodyPlant was registered with a SceneGraph. </p>
<p>This method can be called at any time during the lifetime of <code>this</code> plant to query if <code>this</code> plant has been registered with a SceneGraph, either pre- or post-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </p>

</div>
</div>
<a id="a8c9e7974ae1d996a6ca3430893bd5df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9e7974ae1d996a6ca3430893bd5df2">&#9670;&nbsp;</a></span>get_actuation_input_port() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt;T&gt;&amp; get_actuation_input_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the input port for external actuation for a specific model instance. </p>
<p>This input port is a vector valued port, which can be set with <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a0124c80b63b5acc2980e3a57107c43be" title="Given the actuation values u_instance for this actuator, this method sets the actuation vector u for ...">JointActuator::set_actuation_vector()</a>. </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <code>this</code> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the model instance does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cc1d71e6c2e91fcd215105ae4ed01e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc1d71e6c2e91fcd215105ae4ed01e4">&#9670;&nbsp;</a></span>get_actuation_input_port() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt;T&gt;&amp; get_actuation_input_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the input port for external actuation for the case where only one model instance has actuated dofs. </p>
<p>This input port is a vector valued port, which can be set with <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html#a0124c80b63b5acc2980e3a57107c43be" title="Given the actuation values u_instance for this actuator, this method sets the actuation vector u for ...">JointActuator::set_actuation_vector()</a>. </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <code>this</code> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>, if the model does not contain any actuators, or if multiple model instances have actuated dofs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af393d5659ac9a8807671a1efc0d78a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af393d5659ac9a8807671a1efc0d78a5c">&#9670;&nbsp;</a></span>get_applied_generalized_force_input_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt;T&gt;&amp; get_applied_generalized_force_input_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the vector-valued input port for applied generalized forces, and the vector will be added directly into <code>tau</code> (see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_equations_of_motion">System dynamics</a>). </p>
<p>This vector is ordered using the same convention as the plant velocities: you can set the generalized forces that will be applied to model instance i using, e.g., <code>SetVelocitiesInArray(i, model_forces, &amp;force_array)</code>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2ad1faa7547d440f008cdddd32d85e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ad1faa7547d440f008cdddd32d85e8">&#9670;&nbsp;</a></span>get_applied_spatial_force_input_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt;T&gt;&amp; get_applied_spatial_force_input_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the input port for applying spatial forces to bodies in the plant. </p>
<p>The data type for the port is an std::vector of <a class="el" href="structdrake_1_1multibody_1_1_externally_applied_spatial_force.html">ExternallyAppliedSpatialForce</a>; any number of spatial forces can be applied to any number of bodies in the plant. </p>

</div>
</div>
<a id="ada9547075b5a67b2354f3dabf0f2f787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9547075b5a67b2354f3dabf0f2f787">&#9670;&nbsp;</a></span>get_body()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;&amp; get_body </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the body with unique index <code>body_index</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body_index</code> does not correspond to a body in this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea0f8aca5f15e90f11e14602b3ba7068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0f8aca5f15e90f11e14602b3ba7068">&#9670;&nbsp;</a></span>get_body_poses_output_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt;T&gt;&amp; get_body_poses_output_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output port of all body poses in the world frame. </p>
<p>You can obtain the pose <code>X_WB</code> of a body B in the world frame W with: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; X_WB_all = plant.get_body_poses_output_port().</div><div class="line">    .Eval&lt;std::vector&lt;math::RigidTransform&lt;double&gt;&gt;&gt;(plant_context);</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> arm_body_index = plant.GetBodyByName(<span class="stringliteral">&quot;arm&quot;</span>).index();</div><div class="line"><span class="keyword">const</span> math::RigidTransform&lt;double&gt;&amp; X_WArm = X_WB_all[arm_body_index];</div></div><!-- fragment --><p> As shown in the example above, the resulting <code>std::vector</code> of body poses is indexed by BodyIndex, and it has size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af92b53211e54243aff4490a700168eb4" title="Returns the number of bodies in the model, including the &quot;world&quot; body, which is always part of the mo...">num_bodies()</a>. BodyIndex "zero" (0) always corresponds to the world body, with pose equal to the identity at all times. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a665427ce00158743b848918b19efbc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665427ce00158743b848918b19efbc9f">&#9670;&nbsp;</a></span>get_body_spatial_accelerations_output_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt;T&gt;&amp; get_body_spatial_accelerations_output_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output port of all body spatial accelerations in the world frame. </p>
<p>You can obtain the spatial acceleration <code>A_WB</code> of a body B in the world frame W with: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; A_WB_all =</div><div class="line">plant.get_body_spatial_accelerations_output_port().</div><div class="line">    .Eval&lt;std::vector&lt;SpatialAcceleration&lt;double&gt;&gt;&gt;(plant_context);</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> arm_body_index = plant.GetBodyByName(<span class="stringliteral">&quot;arm&quot;</span>).index();</div><div class="line"><span class="keyword">const</span> SpatialVelocity&lt;double&gt;&amp; A_WArm = A_WB_all[arm_body_index];</div></div><!-- fragment --><p> As shown in the example above, the resulting <code>std::vector</code> of body spatial accelerations is indexed by BodyIndex, and it has size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af92b53211e54243aff4490a700168eb4" title="Returns the number of bodies in the model, including the &quot;world&quot; body, which is always part of the mo...">num_bodies()</a>. BodyIndex "zero" (0) always corresponds to the world body, with zero spatial acceleration at all times. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc63dd8f7d1461b1f6a263003ab4f819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc63dd8f7d1461b1f6a263003ab4f819">&#9670;&nbsp;</a></span>get_body_spatial_velocities_output_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt;T&gt;&amp; get_body_spatial_velocities_output_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output port of all body spatial velocities in the world frame. </p>
<p>You can obtain the spatial velocity <code>V_WB</code> of a body B in the world frame W with: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; V_WB_all = plant.get_body_spatial_velocities_output_port().</div><div class="line">    .Eval&lt;std::vector&lt;SpatialVelocity&lt;double&gt;&gt;&gt;(plant_context);</div><div class="line"><span class="keyword">const</span> <a class="code" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a> arm_body_index = plant.GetBodyByName(<span class="stringliteral">&quot;arm&quot;</span>).index();</div><div class="line"><span class="keyword">const</span> SpatialVelocity&lt;double&gt;&amp; V_WArm = V_WB_all[arm_body_index];</div></div><!-- fragment --><p> As shown in the example above, the resulting <code>std::vector</code> of body spatial velocities is indexed by BodyIndex, and it has size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af92b53211e54243aff4490a700168eb4" title="Returns the number of bodies in the model, including the &quot;world&quot; body, which is always part of the mo...">num_bodies()</a>. BodyIndex "zero" (0) always corresponds to the world body, with zero spatial velocity at all times. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94d1093944c929bd5ca5322836b91bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d1093944c929bd5ca5322836b91bd4">&#9670;&nbsp;</a></span>get_contact_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4e">ContactModel</a> get_contact_model </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the model used for contact. See documentation for ContactModel. </p>

</div>
</div>
<a id="a3338392f611d5d9f93d0ea90e172c68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3338392f611d5d9f93d0ea90e172c68c">&#9670;&nbsp;</a></span>get_contact_penalty_method_time_scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_contact_penalty_method_time_scale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a time-scale estimate <code>tc</code> based on the requested penetration allowance δ set with <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8cdb3408c412b2af94476886dc35cc71" title="Sets the penetration allowance used to estimate the coefficients in the penalty method used to impose...">set_penetration_allowance()</a>. </p>
<p>For the penalty method in use to enforce non-penetration, this time scale relates to the time it takes the relative normal velocity between two bodies to go to zero. This time scale <code>tc</code> is artificially introduced by the penalty method and goes to zero in the limit to ideal rigid contact. Since numerical integration methods for continuum systems must be able to resolve a system's dynamics, the time step used by an integrator must in general be much smaller than the time scale <code>tc</code>. How much smaller will depend on the details of the problem and the convergence characteristics of the integrator and should be tuned appropriately. Another factor to take into account for setting up the simulation's time step is the speed of the objects in your simulation. If <code>vn</code> represents a reference velocity scale for the normal relative velocity between bodies, the new time scale <code>tn = δ / vn</code> represents the time it would take for the distance between two bodies approaching with relative normal velocity <code>vn</code> to decrease by the penetration_allowance δ. In this case a user should choose a time step for simulation that can resolve the smallest of the two time scales <code>tc</code> and <code>tn</code>. </p>

</div>
</div>
<a id="aa6f63e059613961ba0abb2c1c4532e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f63e059613961ba0abb2c1c4532e7c">&#9670;&nbsp;</a></span>get_contact_results_output_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt;T&gt;&amp; get_contact_results_output_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the port that outputs <a class="el" href="classdrake_1_1multibody_1_1_contact_results.html" title="A container class storing the contact results information for each contact pair for a given state of ...">ContactResults</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0506236fd49c1dab4ab5bdd8102ba9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0506236fd49c1dab4ab5bdd8102ba9fc">&#9670;&nbsp;</a></span>get_force_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_force_element.html">ForceElement</a>&lt;T&gt;&amp; get_force_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#add80e949328b179d78312d1455319868">ForceElementIndex</a>&#160;</td>
          <td class="paramname"><em>force_element_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the force element with unique index <code>force_element_index</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>when <code>force_element_index</code> does not correspond to a force element in this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95cafdc0efac53fe097f9380b955e396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cafdc0efac53fe097f9380b955e396">&#9670;&nbsp;</a></span>get_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;T&gt;&amp; get_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a51c69848adb64ae45eebc1e5af5dbaa6">FrameIndex</a>&#160;</td>
          <td class="paramname"><em>frame_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the frame with unique index <code>frame_index</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>frame_index</code> does not correspond to a frame in this plant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4023fdbc98667217be9f14a5073a87cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4023fdbc98667217be9f14a5073a87cf">&#9670;&nbsp;</a></span>get_generalized_acceleration_output_port() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt;T&gt;&amp; get_generalized_acceleration_output_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the output port for generalized accelerations v̇ of the model. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <code>this</code> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e127b9f8310b3eeb8a82b40c5d80114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e127b9f8310b3eeb8a82b40c5d80114">&#9670;&nbsp;</a></span>get_generalized_acceleration_output_port() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt;T&gt;&amp; get_generalized_acceleration_output_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the output port for the generalized accelerations v̇ᵢ ⊆ v̇ for model instance i. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <code>this</code> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the model instance does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8df9a2d4c286d8da80719d8ed314fcdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df9a2d4c286d8da80719d8ed314fcdc">&#9670;&nbsp;</a></span>get_generalized_contact_forces_output_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt;T&gt;&amp; get_generalized_contact_forces_output_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the output port of generalized contact forces for a specific model instance. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <code>this</code> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the model instance does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f20f6e2e2de42a5225e86baff2ca0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f20f6e2e2de42a5225e86baff2ca0e5">&#9670;&nbsp;</a></span>get_geometry_poses_output_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt;T&gt;&amp; get_geometry_poses_output_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output port of frames' poses to communicate with a SceneGraph. </p>

</div>
</div>
<a id="aecfca4e84a8ed96fb3004ff979e89154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfca4e84a8ed96fb3004ff979e89154">&#9670;&nbsp;</a></span>get_geometry_query_input_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_input_port.html">systems::InputPort</a>&lt;T&gt;&amp; get_geometry_query_input_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the input port used to perform geometric queries on a SceneGraph. </p>
<p>See SceneGraph::get_query_output_port(). Refer to section <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_geometry">Geometry</a> of this class's documentation for further details on collision geometry registration and connection with a SceneGraph. </p>

</div>
</div>
<a id="ad293b63a81a28c455fdfb7e5f04c35b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad293b63a81a28c455fdfb7e5f04c35b0">&#9670;&nbsp;</a></span>get_joint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt;T&gt;&amp; get_joint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a>&#160;</td>
          <td class="paramname"><em>joint_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the joint with unique index <code>joint_index</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>when <code>joint_index</code> does not correspond to a joint in this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb237ffaadc7323d817ba0e07e78a8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb237ffaadc7323d817ba0e07e78a8f4">&#9670;&nbsp;</a></span>get_joint_actuator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt;T&gt;&amp; get_joint_actuator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a>&#160;</td>
          <td class="paramname"><em>actuator_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the joint actuator with unique index <code>actuator_index</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>actuator_index</code> does not correspond to a joint actuator in this tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab56a3621a122cdff1729f71b756a75d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56a3621a122cdff1729f71b756a75d0">&#9670;&nbsp;</a></span>get_mutable_joint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_joint.html">Joint</a>&lt;T&gt;&amp; get_mutable_joint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a>&#160;</td>
          <td class="paramname"><em>joint_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable reference to the joint with unique index <code>joint_index</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>when <code>joint_index</code> does not correspond to a joint in this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b03afbfe072f83e3681cf9798121eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b03afbfe072f83e3681cf9798121eb2">&#9670;&nbsp;</a></span>get_reaction_forces_output_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt;T&gt;&amp; get_reaction_forces_output_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the port for joint reaction forces. </p>
<p>A <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> models the kinematical relationship which characterizes the possible relative motion between two bodies. In Drake, a joint connects a frame <code>Jp</code> on <em>parent</em> body P with a frame <code>Jc</code> on a <em>child</em> body C. This usage of the terms <em>parent</em> and <em>child</em> is just a convention and implies nothing about the inboard-outboard relationship between the bodies. Since a <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> imposes a kinematical relationship which characterizes the possible relative motion between frames Jp and Jc, reaction forces on each body are established. That is, we could cut the model at the joint and replace it with equivalent forces equal to these reaction forces in order to attain the same motions of the mechanical system.</p>
<p>This output port allows to evaluate the reaction force <code>F_CJc_Jc</code> on the <em>child</em> body C, at <code>Jc</code>, and expressed in Jc for all joints in the model. This port evaluates to a vector of type std::vector&lt;SpatialForce&lt;T&gt;&gt; and size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a636804b6c40e538d83d5c2dfefb7929e" title="Returns the number of joints in the model.">num_joints()</a> indexed by JointIndex, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#aab10b1c612e1455976fc9e71c4ba7df6" title="Returns this element&#39;s unique index.">Joint::index()</a>. Each entry corresponds to the spatial force <code>F_CJc_Jc</code> applied on the joint's child body C (<a class="el" href="classdrake_1_1multibody_1_1_joint.html#a9b1986cb6e6fa41d4711ae88f7b3fb85" title="Returns a const reference to the child body B.">Joint::child_body()</a>), at the joint's child frame <code>Jc</code> (<a class="el" href="classdrake_1_1multibody_1_1_joint.html#adeb59e44e49a847f2a338211882d00f6" title="Returns a const reference to the frame M attached on the child body B.">Joint::frame_on_child()</a>) and expressed in frame <code>Jc</code>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e13ba788ae1f46c3a847b025a5f0347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e13ba788ae1f46c3a847b025a5f0347">&#9670;&nbsp;</a></span>get_source_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="namespacedrake_1_1geometry.html#ac53cb597123131fb23a7af26e8d350bf">geometry::SourceId</a>&gt; get_source_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the unique id identifying <code>this</code> plant as a source for a SceneGraph. </p>
<p>Returns <code>nullopt</code> if <code>this</code> plant did not register any geometry. This method can be called at any time during the lifetime of <code>this</code> plant to query if <code>this</code> plant has been registered with a SceneGraph, either pre- or post-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. However, a <a class="el" href="namespacedrake_1_1geometry.html#ac53cb597123131fb23a7af26e8d350bf" title="Type used to identify geometry sources in SceneGraph.">geometry::SourceId</a> is only assigned once at the first call of any of this plant's geometry registration methods, and it does not change after that. Post-finalize calls will always return the same value. </p>

</div>
</div>
<a id="ad4e8834bd252d1265e99b8ac85fad0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e8834bd252d1265e99b8ac85fad0b5">&#9670;&nbsp;</a></span>get_state_output_port() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt;T&gt;&amp; get_state_output_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the output port for the multibody state x = [q, v] of the model. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <code>this</code> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00693ff4108f9634a03e5799c9306428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00693ff4108f9634a03e5799c9306428">&#9670;&nbsp;</a></span>get_state_output_port() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1systems_1_1_output_port.html">systems::OutputPort</a>&lt;T&gt;&amp; get_state_output_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the output port for the state xᵢ = [qᵢ vᵢ] of model instance i. </p>
<p>(Here qᵢ ⊆ q and vᵢ ⊆ v.) </p><dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> was already called on <code>this</code> plant. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called before <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if the model instance does not exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc751e3bc4dea699d3c1f9d3ff1f214e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc751e3bc4dea699d3c1f9d3ff1f214e">&#9670;&nbsp;</a></span>GetAccelerationLowerLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;double&gt; GetAccelerationLowerLimits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of size <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a></code> containing the lower acceleration limits for every generalized velocity coordinate. </p>
<p>These include joint and free body coordinates. Any unbounded or unspecified limits will be -infinity. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99f96a969efb888b8528a43fdb19108b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f96a969efb888b8528a43fdb19108b">&#9670;&nbsp;</a></span>GetAccelerationUpperLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;double&gt; GetAccelerationUpperLimits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upper limit analog of GetAccelerationsLowerLimits(), where any unbounded or unspecified limits will be +infinity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abc751e3bc4dea699d3c1f9d3ff1f214e" title="Returns a vector of size num_velocities() containing the lower acceleration limits for every generali...">GetAccelerationLowerLimits()</a> for more information. </dd></dl>

</div>
</div>
<a id="a1fc148ddec26f8c109c233b8b2ec1e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc148ddec26f8c109c233b8b2ec1e2d">&#9670;&nbsp;</a></span>GetActuationFromArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; GetActuationFromArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of actuation values for <code>model_instance</code> from a vector <code>u</code> of actuation values for the entire model. </p>
<p>This method throws an exception if <code>u</code> is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae3fc8de8de8eaf2d37a24c79d6be8e97" title="Returns the total number of actuated degrees of freedom.">MultibodyPlant::num_actuated_dofs()</a>. </p>

</div>
</div>
<a id="a90383f3338a41a9de4db1eb9f5aba385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90383f3338a41a9de4db1eb9f5aba385">&#9670;&nbsp;</a></span>GetBodiesWeldedTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;*&gt; GetBodiesWeldedTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all bodies that are transitively welded, or rigidly affixed, to <code>body</code>, per these two definitions: </p>
<ol type="1">
<li>A body is always considered welded to itself.</li>
<li>Two unique bodies are considered welded together exclusively by the presence of a weld joint, not by other constructs that prevent mobility (e.g. constraints).</li>
</ol>
<p>This method can be called at any time during the lifetime of <code>this</code> plant, either pre- or post-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>.</p>
<p>Meant to be used with <code>CollectRegisteredGeometries</code>.</p>
<p>The following example demonstrates filtering collisions between all bodies rigidly affixed to a door (which could be moving) and all bodies rigidly affixed to the world: </p><div class="fragment"><div class="line">GeometrySet g_world = plant.CollectRegisteredGeometries(</div><div class="line">    plant.GetBodiesWeldedTo(plant.world_body()));</div><div class="line">GeometrySet g_door = plant.CollectRegisteredGeometries(</div><div class="line">    plant.GetBodiesWeldedTo(plant.GetBodyByName(<span class="stringliteral">&quot;door&quot;</span>)));</div><div class="line">scene_graph.ExcludeCollisionsBetweeen(g_world, g_door);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Usages akin to this example may introduce redundant collision filtering; this will not have a functional impact, but may have a minor performance impact.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>all bodies rigidly fixed to <code>body</code>. This does not return the bodies in any prescribed order. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not part of this plant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3b40d661d83759731ad9a54553fc13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b40d661d83759731ad9a54553fc13f">&#9670;&nbsp;</a></span>GetBodyByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;&amp; GetBodyByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to a body that is identified by the string <code>name</code> in <code>this</code> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no body with the requested name. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the body name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed()</a> to query if there exists a body in <code>this</code> MultibodyPlant with a given specified name. </dd></dl>

</div>
</div>
<a id="a3d93818409f0144bb63248dc64a9130f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d93818409f0144bb63248dc64a9130f">&#9670;&nbsp;</a></span>GetBodyByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;&amp; GetBodyByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the body that is uniquely identified by the string <code>name</code> and <code>model_instance</code> in <code>this</code> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no body with the requested name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed()</a> to query if there exists a body in <code>this</code> MultibodyPlant with a given specified name. </dd></dl>

</div>
</div>
<a id="aa5705fe2856b52119e1d713213ae3300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5705fe2856b52119e1d713213ae3300">&#9670;&nbsp;</a></span>GetBodyFrameIdIfExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">geometry::FrameId</a>&gt; GetBodyFrameIdIfExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the body with <code>body_index</code> belongs to the called plant, it returns the <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb" title="Type used to identify geometry frames in SceneGraph.">geometry::FrameId</a> associated with it. </p>
<p>Otherwise, it returns nullopt. </p>

</div>
</div>
<a id="afdcdcb4e7798a5aef9bc3111402dfa5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcdcb4e7798a5aef9bc3111402dfa5e">&#9670;&nbsp;</a></span>GetBodyFrameIdOrThrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">geometry::FrameId</a> GetBodyFrameIdOrThrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&#160;</td>
          <td class="paramname"><em>body_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the body with <code>body_index</code> belongs to the called plant, it returns the <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb" title="Type used to identify geometry frames in SceneGraph.">geometry::FrameId</a> associated with it. </p>
<p>Otherwise this method throws an exception. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the called plant does not have the body indicated by <code>body_index</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf36bc0dadc3f1e72bc17072c5f9e4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf36bc0dadc3f1e72bc17072c5f9e4f2">&#9670;&nbsp;</a></span>GetBodyFromFrameId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt;T&gt;* GetBodyFromFrameId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">geometry::FrameId</a>&#160;</td>
          <td class="paramname"><em>frame_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a geometry frame identifier, returns a pointer to the body associated with that id (nullptr if there is no such body). </p>

</div>
</div>
<a id="a9e826bbe6f7a8768bea8d2a41be7f0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e826bbe6f7a8768bea8d2a41be7f0ac">&#9670;&nbsp;</a></span>GetBodyIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&gt; GetBodyIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of body indices associated with <code>model_instance</code>. </p>

</div>
</div>
<a id="acb2b21ccb8a93f1929cdec2dc19a6b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2b21ccb8a93f1929cdec2dc19a6b7f">&#9670;&nbsp;</a></span>GetCollisionGeometriesForBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a>&gt;&amp; GetCollisionGeometriesForBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of GeometryId's identifying the different contact geometries for <code>body</code> previously registered with a SceneGraph. </p>
<dl class="section note"><dt>Note</dt><dd>This method can be called at any time during the lifetime of <code>this</code> plant, either pre- or post-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. Post-finalize calls will always return the same value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac9b4f41a4f2575707d43ea031ce5a9ea" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for the contact modeling o...">RegisterCollisionGeometry()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> </dd></dl>

</div>
</div>
<a id="a029fdc34c3aea2d69b86715030273d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029fdc34c3aea2d69b86715030273d42">&#9670;&nbsp;</a></span>GetDefaultFreeBodyPose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;double&gt;&amp; GetDefaultFreeBodyPose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the default pose of <code>body</code> as set by <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a054aef89f09b26103692515fea766e9e" title="Sets the default pose of body.">SetDefaultFreeBodyPose()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body</td><td><a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a> whose default pose will be retrieved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a2813d5472e88bc58bbb9c3129811f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2813d5472e88bc58bbb9c3129811f5">&#9670;&nbsp;</a></span>GetFloatingBaseBodies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt;<a class="el" href="namespacedrake_1_1multibody.html#acbe033def48af7bf4857957f70f4d3e0">BodyIndex</a>&gt; GetFloatingBaseBodies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of body indexes corresponding to the free (floating) bodies in the model, in no particular order. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a551f8c3bf88b0f325a7a2be7f5bdecea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551f8c3bf88b0f325a7a2be7f5bdecea">&#9670;&nbsp;</a></span>GetForceElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ForceElementType&lt;T&gt;&amp; GetForceElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#add80e949328b179d78312d1455319868">ForceElementIndex</a>&#160;</td>
          <td class="paramname"><em>force_element_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to a force element identified by its unique index in <code>this</code> MultibodyPlant. </p>
<p>If the optional template argument is supplied, then the returned value is downcast to the specified <code>ForceElementType</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ForceElementType</td><td>The specific type of the <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> to be retrieved. It must be a subclass of <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the force element is not of type <code>ForceElementType</code> or if there is no <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> with that index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b557087f117859fd5246112f0d829cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b557087f117859fd5246112f0d829cd">&#9670;&nbsp;</a></span>GetFrameByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;T&gt;&amp; GetFrameByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to a frame that is identified by the string <code>name</code> in <code>this</code> model. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no frame with the requested name. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the frame name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3530f8f6747cb603a24accba5901bd00">HasFrameNamed()</a> to query if there exists a frame in <code>this</code> model with a given specified name. </dd></dl>

</div>
</div>
<a id="af4d552a24e1ad06c0b16004cec20fe94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d552a24e1ad06c0b16004cec20fe94">&#9670;&nbsp;</a></span>GetFrameByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt;T&gt;&amp; GetFrameByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the frame that is uniquely identified by the string <code>name</code> in <code>model_instance</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no frame with the requested name. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3530f8f6747cb603a24accba5901bd00">HasFrameNamed()</a> to query if there exists a frame in <code>this</code> model with a given specified name. </dd></dl>

</div>
</div>
<a id="ae38b99ebc8a1c3b0a97832f91c8b751c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38b99ebc8a1c3b0a97832f91c8b751c">&#9670;&nbsp;</a></span>GetFreeBodyPose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;T&gt; GetFreeBodyPose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the pose of a given <code>body</code> in the world frame W. </p>
<dl class="section note"><dt>Note</dt><dd>In general getting the pose of a body in the model would involve solving the kinematics. This method allows us to simplify this process when we know the body is free in space. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab835365a3c40185b23454f7e08cad083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab835365a3c40185b23454f7e08cad083">&#9670;&nbsp;</a></span>GetJointActuatorByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt;T&gt;&amp; GetJointActuatorByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to an actuator that is identified by the string <code>name</code> in <code>this</code> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no actuator with the requested name. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the actuator name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a30dd7e61bafa3221193e7d68e4be7cbc">HasJointActuatorNamed()</a> to query if there exists an actuator in <code>this</code> MultibodyPlant with a given specified name. </dd></dl>

</div>
</div>
<a id="a760fbe4384415d8cfd39c9e7e4f31422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760fbe4384415d8cfd39c9e7e4f31422">&#9670;&nbsp;</a></span>GetJointActuatorByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html">JointActuator</a>&lt;T&gt;&amp; GetJointActuatorByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the actuator that is uniquely identified by the string <code>name</code> and <code>model_instance</code> in <code>this</code> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no actuator with the requested name. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a30dd7e61bafa3221193e7d68e4be7cbc">HasJointActuatorNamed()</a> to query if there exists an actuator in <code>this</code> MultibodyPlant with a given specified name. </dd></dl>

</div>
</div>
<a id="a50ef5b8184105111a26093a17d45f971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ef5b8184105111a26093a17d45f971">&#9670;&nbsp;</a></span>GetJointByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const JointType&lt;T&gt;&amp; GetJointByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt;&#160;</td>
          <td class="paramname"><em>model_instance</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to a joint that is identified by the string <code>name</code> in <code>this</code> MultibodyPlant. </p>
<p>If the optional template argument is supplied, then the returned value is downcast to the specified <code>JointType</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">JointType</td><td>The specific type of the <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> to be retrieved. It must be a subclass of <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the named joint is not of type <code>JointType</code> or if there is no <a class="el" href="classdrake_1_1multibody_1_1_joint.html" title="A Joint models the kinematical relationship which characterizes the possible relative motion between ...">Joint</a> with that name. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a02c811258a0d93dd116d61648334a392">HasJointNamed()</a> to query if there exists a joint in <code>this</code> MultibodyPlant with a given specified name. </dd></dl>

</div>
</div>
<a id="af7918857fc5c0c9deffef433ca5cb85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7918857fc5c0c9deffef433ca5cb85f">&#9670;&nbsp;</a></span>GetJointIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a>&gt; GetJointIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of joint indices associated with <code>model_instance</code>. </p>

</div>
</div>
<a id="a2a177e855cc5efe12d15adc4c697930f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a177e855cc5efe12d15adc4c697930f">&#9670;&nbsp;</a></span>GetModelInstanceByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> GetModelInstanceByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index to the model instance that is uniquely identified by the string <code>name</code> in <code>this</code> MultibodyPlant. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no instance with the requested name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a05b71664c8e2e91bc3fc92fef222a9bf">HasModelInstanceNamed()</a> to query if there exists an instance in <code>this</code> MultibodyPlant with a given specified name. </dd></dl>

</div>
</div>
<a id="ab99be499eb59f00037b05ec60b51e177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99be499eb59f00037b05ec60b51e177">&#9670;&nbsp;</a></span>GetModelInstanceName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; GetModelInstanceName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of a <code>model_instance</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>when <code>model_instance</code> does not correspond to a model in this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28bbed0c9b8611d58c399a4a0e7533dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28bbed0c9b8611d58c399a4a0e7533dd">&#9670;&nbsp;</a></span>GetMutableJointByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">JointType&lt;T&gt;&amp; GetMutableJointByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a> &gt;&#160;</td>
          <td class="paramname"><em>model_instance</em> = <code>std::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A version of GetJointByName that returns a mutable reference. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a50ef5b8184105111a26093a17d45f971" title="Returns a constant reference to a joint that is identified by the string name in this MultibodyPlant.">GetJointByName</a>. </dd></dl>

</div>
</div>
<a id="ace2984079483027345739f5e1bc8a19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2984079483027345739f5e1bc8a19c">&#9670;&nbsp;</a></span>GetMutablePositions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; GetMutablePositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Returns a mutable vector reference containing the vector of generalized positions (<b>see warning</b>). </p>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You should use <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abfb9f945ca5577141351e60bd45156ef" title="Sets all generalized positions from the given vector.">SetPositions()</a> instead of this method unless you are fully aware of the possible interactions with the caching mechanism (see <a class="el" href="classdrake_1_1systems_1_1_context.html#dangerous_get_mutable">dangerous_get_mutable</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr or if it does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af91bd90e38673df63e04209d0a43e2f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91bd90e38673df63e04209d0a43e2f6">&#9670;&nbsp;</a></span>GetMutablePositions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; GetMutablePositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Returns a mutable vector reference containing the vector of generalized positions (<b>see warning</b>). </p>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You should use <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#abfb9f945ca5577141351e60bd45156ef" title="Sets all generalized positions from the given vector.">SetPositions()</a> instead of this method unless you are fully aware of the possible interactions with the caching mechanism (see <a class="el" href="classdrake_1_1systems_1_1_context.html#dangerous_get_mutable">dangerous_get_mutable</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>state</code> is nullptr or if the context does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>state</code> comes from this <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </dd></dl>

</div>
</div>
<a id="a1036e869271ac77a82f891a5f7187210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1036e869271ac77a82f891a5f7187210">&#9670;&nbsp;</a></span>GetMutablePositionsAndVelocities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; GetMutablePositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Returns a mutable vector containing the vector <code>[q; v]</code> of the model with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities (<b>see warning</b>). </p>
<dl class="section warning"><dt>Warning</dt><dd>You should use <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a5f77c6666edaa725dbd5dd060d2f5b00" title="Sets all generalized positions and velocities from the given vector [q; v].">SetPositionsAndVelocities()</a> instead of this method unless you are fully aware of the interactions with the caching mechanism (see <a class="el" href="classdrake_1_1systems_1_1_context.html#dangerous_get_mutable">dangerous_get_mutable</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr or if it does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25c6efdadb0dd091590e9474d9039f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c6efdadb0dd091590e9474d9039f64">&#9670;&nbsp;</a></span>GetMutableVelocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; GetMutableVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Advanced) Returns a mutable vector reference containing the vector of generalized velocities (<b>see warning</b>). </p>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>You should use <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a1ee483fa25d16a1ab99da1e0bface016" title="Sets all generalized velocities from the given vector.">SetVelocities()</a> instead of this method unless you are fully aware of the possible interactions with the caching mechanism (see <a class="el" href="classdrake_1_1systems_1_1_context.html#dangerous_get_mutable">dangerous_get_mutable</a>). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr or the context does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>state</code> comes from this <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </dd></dl>

</div>
</div>
<a id="a7fe7c6fe93604e71b9d277b76fab5932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe7c6fe93604e71b9d277b76fab5932">&#9670;&nbsp;</a></span>GetMutableVelocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;<a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; GetMutableVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a25c6efdadb0dd091590e9474d9039f64" title="(Advanced) Returns a mutable vector reference containing the vector of generalized velocities (see wa...">GetMutableVelocities()</a> method above. </p>

</div>
</div>
<a id="ada1473641a4389162ee68d6468a4e664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1473641a4389162ee68d6468a4e664">&#9670;&nbsp;</a></span>GetPositionLowerLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;double&gt; GetPositionLowerLimits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of size <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a></code> containing the lower position limits for every generalized position coordinate. </p>
<p>These include joint and free body coordinates. Any unbounded or unspecified limits will be -infinity. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b48791a474f442ccb628dc9b76a24b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b48791a474f442ccb628dc9b76a24b9">&#9670;&nbsp;</a></span>GetPositions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; GetPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const vector reference containing the vector of generalized positions. </p>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe2a085e96321a9d821551c479aed347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2a085e96321a9d821551c479aed347">&#9670;&nbsp;</a></span>GetPositions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; GetPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an vector containing the generalized positions (<code>q</code>) for the given model instance. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns a dense vector of dimension <code>q.size()</code> associated with <code>model_instance</code> in O(<code>q.size()</code>) time. </dd></dl>

</div>
</div>
<a id="abda564c1168979bb8422343d46925b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda564c1168979bb8422343d46925b9a">&#9670;&nbsp;</a></span>GetPositionsAndVelocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; GetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const vector reference containing the vector <code>[q; v]</code> with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities. </p>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa0be270734139ba7fd908effc13dd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0be270734139ba7fd908effc13dd54">&#9670;&nbsp;</a></span>GetPositionsAndVelocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; GetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vector <code>[q; v]</code> of the model with <code>q</code> the vector of generalized positions and <code>v</code> the vector of generalized velocities for model instance <code>model_instance</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> does not correspond to the context for a multibody model or <code>model_instance</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns a dense vector of dimension <code>q.size() + v.size()</code> associated with <code>model_instance</code> in O(<code>q.size()</code>) time. </dd></dl>

</div>
</div>
<a id="a9b8a17ef762452f820bdd351f8bb41b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8a17ef762452f820bdd351f8bb41b4">&#9670;&nbsp;</a></span>GetPositionsFromArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; GetPositionsFromArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of generalized positions for <code>model_instance</code> from a vector <code>q_array</code> of generalized positions for the entire model model. </p>
<p>This method throws an exception if <code>q</code> is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">MultibodyPlant::num_positions()</a>. </p>

</div>
</div>
<a id="a3fdbea9ebcb04bc6a5f3d62cffd35b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdbea9ebcb04bc6a5f3d62cffd35b1e">&#9670;&nbsp;</a></span>GetPositionUpperLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;double&gt; GetPositionUpperLimits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upper limit analog of GetPositionsLowerLimits(), where any unbounded or unspecified limits will be +infinity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ada1473641a4389162ee68d6468a4e664" title="Returns a vector of size num_positions() containing the lower position limits for every generalized p...">GetPositionLowerLimits()</a> for more information. </dd></dl>

</div>
</div>
<a id="a1ef21c2455a83e7a086df24f8411e26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef21c2455a83e7a086df24f8411e26b">&#9670;&nbsp;</a></span>GetRigidBodyByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; GetRigidBodyByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to a rigid body that is identified by the string <code>name</code> in <code>this</code> model. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no body with the requested name. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the body name occurs in multiple model instances. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the requested body is not a <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed()</a> to query if there exists a body in <code>this</code> model with a given specified name. </dd></dl>

</div>
</div>
<a id="a0b1b9a39c20706b20221ea2c142d2cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1b9a39c20706b20221ea2c142d2cfd">&#9670;&nbsp;</a></span>GetRigidBodyByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; GetRigidBodyByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the rigid body that is uniquely identified by the string <code>name</code> in <code>model_instance</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there is no body with the requested name. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if the requested body is not a <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html" title="The term rigid body implies that the deformations of the body under consideration are so small that t...">RigidBody</a>. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a89a198b6549e543018c7c9873d4e6dc1">HasBodyNamed()</a> to query if there exists a body in <code>this</code> model with a given specified name. </dd></dl>

</div>
</div>
<a id="a113f30d2b1b3a8151b638300231975fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113f30d2b1b3a8151b638300231975fa">&#9670;&nbsp;</a></span>GetTopologyGraphvizString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string GetTopologyGraphvizString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Graphviz string describing the topology of this plant. </p>
<p>To render the string, use the Graphviz tool, <code>dot</code>. <a href="http://www.graphviz.org/">http://www.graphviz.org/</a></p>
<p>Note: this method can be called either before or after <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a></code>. </p>

</div>
</div>
<a id="a800453060fc1f94455dff6c07dfde2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800453060fc1f94455dff6c07dfde2d1">&#9670;&nbsp;</a></span>GetVelocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorBlock&lt;const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; &gt; GetVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const vector reference containing the generalized velocities. </p>
<dl class="section note"><dt>Note</dt><dd>This method returns a reference to existing data, exhibits constant i.e., O(1) time complexity, and runs very quickly. </dd></dl>

</div>
</div>
<a id="acbcd0c2630b23058791b7a3d6bac07a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcd0c2630b23058791b7a3d6bac07a8">&#9670;&nbsp;</a></span>GetVelocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; GetVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector containing the generalized velocities (<code>v</code>) for the given model instance. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> does not correspond to the context for a multibody model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns a dense vector of dimension <code>v.size()</code> associated with <code>model_instance</code> in O(<code>v.size()</code>) time. </dd></dl>

</div>
</div>
<a id="a9f32c59d0fb31b2bb9258bd9ee86f55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f32c59d0fb31b2bb9258bd9ee86f55d">&#9670;&nbsp;</a></span>GetVelocitiesFromArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;T&gt; GetVelocitiesFromArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of generalized velocities for <code>model_instance</code> from a vector <code>v</code> of generalized velocities for the entire <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> model. </p>
<p>This method throws an exception if the input array is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">MultibodyPlant::num_velocities()</a>. </p>

</div>
</div>
<a id="a9f34d1e0732d72d601b3a17c54c8de5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f34d1e0732d72d601b3a17c54c8de5e">&#9670;&nbsp;</a></span>GetVelocityLowerLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;double&gt; GetVelocityLowerLimits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of size <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a></code> containing the lower velocity limits for every generalized velocity coordinate. </p>
<p>These include joint and free body coordinates. Any unbounded or unspecified limits will be -infinity. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7cbd4d7b77f1021660c007125c88ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cbd4d7b77f1021660c007125c88ece">&#9670;&nbsp;</a></span>GetVelocityUpperLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt;double&gt; GetVelocityUpperLimits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upper limit analog of GetVelocitysLowerLimits(), where any unbounded or unspecified limits will be +infinity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9f34d1e0732d72d601b3a17c54c8de5e" title="Returns a vector of size num_velocities() containing the lower velocity limits for every generalized ...">GetVelocityLowerLimits()</a> for more information. </dd></dl>

</div>
</div>
<a id="ad289f0686c9d29d3f5b4ca360947c6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad289f0686c9d29d3f5b4ca360947c6f1">&#9670;&nbsp;</a></span>GetVisualGeometriesForBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a>&gt;&amp; GetVisualGeometriesForBody </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an array of GeometryId's identifying the different visual geometries for <code>body</code> previously registered with a SceneGraph. </p>
<dl class="section note"><dt>Note</dt><dd>This method can be called at any time during the lifetime of <code>this</code> plant, either pre- or post-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. Post-finalize calls will always return the same value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ac2ae40642e0504217ada31209e1ecb80" title="Registers geometry in a SceneGraph with a given geometry::Shape to be used for visualization of a giv...">RegisterVisualGeometry()</a>, <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a> </dd></dl>

</div>
</div>
<a id="ac2487c077b5f43019cb90dfe876ad967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2487c077b5f43019cb90dfe876ad967">&#9670;&nbsp;</a></span>gravity_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html">UniformGravityFieldElement</a>&lt;T&gt;&amp; gravity_field </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An accessor to the current gravity field. </p>

</div>
</div>
<a id="a89a198b6549e543018c7c9873d4e6dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a198b6549e543018c7c9873d4e6dc1">&#9670;&nbsp;</a></span>HasBodyNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasBodyNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a body named <code>name</code> was added to the MultibodyPlant. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9f6a68c31772eaa0c855ebb44eeaa0b7" title="Creates a rigid body with the provided name and spatial inertia.">AddRigidBody()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the body name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c5aa85a70a9f0f196091ed298266c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5aa85a70a9f0f196091ed298266c57">&#9670;&nbsp;</a></span>HasBodyNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasBodyNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a body named <code>name</code> was added to the MultibodyPlant in <code>model_instance</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9f6a68c31772eaa0c855ebb44eeaa0b7" title="Creates a rigid body with the provided name and spatial inertia.">AddRigidBody()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3530f8f6747cb603a24accba5901bd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3530f8f6747cb603a24accba5901bd00">&#9670;&nbsp;</a></span>HasFrameNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasFrameNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a frame named <code>name</code> was added to the model. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a474c90a0b3e4f9349533207026413186" title="This method adds a Frame of type FrameType&lt;T&gt;.">AddFrame()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the frame name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ab3a66ab482037c12c4d556800c550a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab3a66ab482037c12c4d556800c550a">&#9670;&nbsp;</a></span>HasFrameNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasFrameNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a frame named <code>name</code> was added to <code>model_instance</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a474c90a0b3e4f9349533207026413186" title="This method adds a Frame of type FrameType&lt;T&gt;.">AddFrame()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30dd7e61bafa3221193e7d68e4be7cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30dd7e61bafa3221193e7d68e4be7cbc">&#9670;&nbsp;</a></span>HasJointActuatorNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasJointActuatorNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an actuator named <code>name</code> was added to this model. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af528f7747dc75227fdec76aba89e7d2b" title="Creates and adds a JointActuator model for an actuator acting on a given joint.">AddJointActuator()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the actuator name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f6ad707643bf5220e76678e71291175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6ad707643bf5220e76678e71291175">&#9670;&nbsp;</a></span>HasJointActuatorNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasJointActuatorNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an actuator named <code>name</code> was added to <code>model_instance</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af528f7747dc75227fdec76aba89e7d2b" title="Creates and adds a JointActuator model for an actuator acting on a given joint.">AddJointActuator()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02c811258a0d93dd116d61648334a392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c811258a0d93dd116d61648334a392">&#9670;&nbsp;</a></span>HasJointNamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasJointNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a joint named <code>name</code> was added to this model. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a437f86026a2268c0fb06936b899ba8d7" title="This method adds a Joint of type JointType between two bodies.">AddJoint()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the joint name occurs in multiple model instances. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7ebee03109f4cb8990124949e97caa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ebee03109f4cb8990124949e97caa1">&#9670;&nbsp;</a></span>HasJointNamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasJointNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a joint named <code>name</code> was added to <code>model_instance</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a437f86026a2268c0fb06936b899ba8d7" title="This method adds a Joint of type JointType between two bodies.">AddJoint()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>model_instance</code> is not valid for this model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05b71664c8e2e91bc3fc92fef222a9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b71664c8e2e91bc3fc92fef222a9bf">&#9670;&nbsp;</a></span>HasModelInstanceNamed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasModelInstanceNamed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a model instance named <code>name</code> was added to this model. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4edf1daa65069a26255c903b02bce4c6" title="Creates a new model instance.">AddModelInstance()</a>. </dd></dl>

</div>
</div>
<a id="acf7bb2a3531c09a97fb3623ac582d840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7bb2a3531c09a97fb3623ac582d840">&#9670;&nbsp;</a></span>is_finalized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_finalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if this MultibodyPlant was finalized with a call to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </dd></dl>

</div>
</div>
<a id="a4f05c3d8f8284a9d9056a4ae47cc0e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f05c3d8f8284a9d9056a4ae47cc0e18">&#9670;&nbsp;</a></span>IsAnchored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsAnchored </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>body</code> is anchored (i.e. </p>
<p>the kinematic path between <code>body</code> and the world only contains weld joints.) </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78463f908367335926f461a19978d89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78463f908367335926f461a19978d89b">&#9670;&nbsp;</a></span>MakeActuationMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;T&gt; MakeActuationMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method creates an actuation matrix B mapping a vector of actuation values u into generalized forces <code>tau_u = B * u</code>, where B is a matrix of size <code>nv x nu</code> with <code>nu</code> equal to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8601c026e9807127b4dd41e7585d2cfc" title="Returns the number of joint actuators in the model.">num_actuators()</a> and <code>nv</code> equal to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>. </p>
<p>The vector u of actuation values is of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8601c026e9807127b4dd41e7585d2cfc" title="Returns the number of joint actuators in the model.">num_actuators()</a>. For a given <a class="el" href="classdrake_1_1multibody_1_1_joint_actuator.html" title="The JointActuator class is mostly a simple bookkeeping structure to represent an actuator acting on a...">JointActuator</a>, <code>u[<a class="el" href="classdrake_1_1multibody_1_1_multibody_element.html#aab10b1c612e1455976fc9e71c4ba7df6" title="Returns this element&#39;s unique index.">JointActuator::index()</a>]</code> stores the value for the external actuation corresponding to that actuator. <code>tau_u</code> on the other hand is indexed by generalized velocity indexes according to <code><a class="el" href="classdrake_1_1multibody_1_1_joint.html#ae24835fcef569246252959b18d0027d6" title="Returns the index to the first generalized velocity for this joint within the vector v of generalized...">Joint::velocity_start()</a></code>. </p><dl class="section warning"><dt>Warning</dt><dd>B is a permutation matrix. While making a permutation has <code>O(n)</code> complexity, making a full B matrix has <code>O(n²)</code> complexity. For most applications this cost can be neglected but it could become significant for very large systems. </dd></dl>

</div>
</div>
<a id="a0d7f5496735d233ea0b984c5a290671f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7f5496735d233ea0b984c5a290671f">&#9670;&nbsp;</a></span>MakeActuatorSelectorMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;double&gt; MakeActuatorSelectorMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#acc810ff385ed4dede2e011b0b6fd3f2c">JointActuatorIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>user_to_actuator_index_map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allows user to map a vector <code>uₛ</code> containing the actuation for a set of selected actuators into the vector u containing the actuation values for <code>this</code> full model. </p>
<p>The mapping, or selection, is returned in the form of a selector matrix Su such that <code>u = Su⋅uₛ</code>. The size nₛ of uₛ is always smaller or equal than the size of the full vector of actuation values u. That is, a user might be interested in only a given subset of actuators in the model.</p>
<p>This selection matrix is particularly useful when adding PID control on a portion of the state, see <a class="el" href="classdrake_1_1systems_1_1controllers_1_1_pid_controller.html" title="Implements the PID controller.">systems::controllers::PidController</a>.</p>
<p>A user specifies the preferred order in uₛ via <code>user_to_actuator_index_map</code>. The actuation values in uₛ are a concatenation of the values for each actuator in the order they appear in <code>user_to_actuator_index_map</code>. The full vector of actuation values u is ordered by JointActuatorIndex. </p>

</div>
</div>
<a id="a029244fdbe2f10a7bfaf5c21175d834c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029244fdbe2f10a7bfaf5c21175d834c">&#9670;&nbsp;</a></span>MakeActuatorSelectorMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;double&gt; MakeActuatorSelectorMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>user_to_joint_index_map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternative signature to build an actuation selector matrix <code>Su</code> such that <code>u = Su⋅uₛ</code>, where u is the vector of actuation values for the full model (ordered by JointActuatorIndex) and uₛ is a vector of actuation values for the actuators acting on the joints listed by <code>user_to_joint_index_map</code>. </p>
<p>It is assumed that all joints referenced by <code>user_to_joint_index_map</code> are actuated. See MakeActuatorSelectorMatrix(const std::vector&lt;JointActuatorIndex&gt;&amp;) for details. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if any of the joints in <code>user_to_joint_index_map</code> does not have an actuator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c7b2e7b0c09b6479d25250405ffd0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7b2e7b0c09b6479d25250405ffd0c4">&#9670;&nbsp;</a></span>MakeStateSelectorMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a28c58d881c60e96f48a7a4e32a699b95">MatrixX</a>&lt;double&gt; MakeStateSelectorMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacedrake_1_1multibody.html#a27485be8a33f5ed2ee7f3f8de9dd40c0">JointIndex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>user_to_joint_index_map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allows users to map the state of <code>this</code> model, x, into a vector of selected state xₛ with a given preferred ordering. </p>
<p>The mapping, or selection, is returned in the form of a selector matrix Sx such that <code>xₛ = Sx⋅x</code>. The size nₛ of xₛ is always smaller or equal than the size of the full state x. That is, a user might be interested in only a given portion of the full state x.</p>
<p>This selection matrix is particularly useful when adding PID control on a portion of the state, see <a class="el" href="classdrake_1_1systems_1_1controllers_1_1_pid_controller.html" title="Implements the PID controller.">systems::controllers::PidController</a>.</p>
<p>A user specifies the preferred order in xₛ via <code>user_to_joint_index_map</code>. The selected state is built such that selected positions are followed by selected velocities, as in <code>xₛ = [qₛ, vₛ]</code>. The positions in qₛ are a concatenation of the positions for each joint in the order they appear in <code>user_to_joint_index_map</code>. That is, the positions for <code>user_to_joint_index_map[0]</code> are first, followed by the positions for <code>user_to_joint_index_map[1]</code>, etc. Similarly for the selected velocities vₛ.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there are repeated indexes in <code>user_to_joint_index_map</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab128a8bba10523922358bc35df103753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab128a8bba10523922358bc35df103753">&#9670;&nbsp;</a></span>MapQDotToVelocity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MapQDotToVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>qdot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the time derivative <code>qdot</code> of the generalized positions vector <code>q</code> (stored in <code>context</code>) to generalized velocities <code>v</code>. </p>
<p><code>v</code> and <code>q̇</code> are related linearly by <code>q̇ = N(q)⋅v</code>. Although <code>N(q)</code> is not necessarily square, its left pseudo-inverse <code>N⁺(q)</code> can be used to invert that relationship without residual error, provided that <code>qdot</code> is in the range space of <code>N(q)</code> (that is, if it <em>could</em> have been produced as <code>q̇ = N(q)⋅v</code> for some <code>v</code>). Using the configuration <code>q</code> stored in the given <code>context</code> this method calculates <code>v = N⁺(q)⋅q̇</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qdot</td><td>A vector containing the time derivatives of the generalized positions. This method aborts if <code>qdot</code> is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>A valid (non-null) pointer to a vector in <code>ℛⁿ</code> with n the number of generalized velocities. This method aborts if v is nullptr or if it is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a7bb24fed19f16a76450eece1857b92dc" title="Transforms generalized velocities v to time derivatives qdot of the generalized positions vector q (s...">MapVelocityToQDot()</a> </dd>
<dd>
Mobilizer::MapQDotToVelocity() </dd></dl>

</div>
</div>
<a id="a7bb24fed19f16a76450eece1857b92dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb24fed19f16a76450eece1857b92dc">&#9670;&nbsp;</a></span>MapVelocityToQDot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MapVelocityToQDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms generalized velocities v to time derivatives <code>qdot</code> of the generalized positions vector <code>q</code> (stored in <code>context</code>). </p>
<p><code>v</code> and <code>qdot</code> are related linearly by <code>q̇ = N(q)⋅v</code>. Using the configuration <code>q</code> stored in the given <code>context</code> this method calculates <code>q̇ = N(q)⋅v</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context containing the state of the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>A vector of of generalized velocities for this model. This method aborts if v is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">qdot</td><td>A valid (non-null) pointer to a vector in <code>ℝⁿ</code> with n being the number of generalized positions in this model, given by <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a></code>. This method aborts if <code>qdot</code> is nullptr or if it is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ab128a8bba10523922358bc35df103753" title="Transforms the time derivative qdot of the generalized positions vector q (stored in context) to gene...">MapQDotToVelocity()</a> </dd>
<dd>
Mobilizer::MapVelocityToQDot() </dd></dl>

</div>
</div>
<a id="a011da7195d022b5768df17eeb86ae707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011da7195d022b5768df17eeb86ae707">&#9670;&nbsp;</a></span>mutable_gravity_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_uniform_gravity_field_element.html">UniformGravityFieldElement</a>&lt;T&gt;&amp; mutable_gravity_field </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A mutable accessor to the current gravity field. </p>

</div>
</div>
<a id="ae3fc8de8de8eaf2d37a24c79d6be8e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fc8de8de8eaf2d37a24c79d6be8e97">&#9670;&nbsp;</a></span>num_actuated_dofs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_actuated_dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of actuated degrees of freedom. </p>
<p>That is, the vector of actuation values u has this size. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af528f7747dc75227fdec76aba89e7d2b" title="Creates and adds a JointActuator model for an actuator acting on a given joint.">AddJointActuator()</a>. </p>

</div>
</div>
<a id="a279e31367e76849d4a45fd7db0f116f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279e31367e76849d4a45fd7db0f116f1">&#9670;&nbsp;</a></span>num_actuated_dofs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_actuated_dofs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of actuated degrees of freedom for a specific model instance. </p>
<p>That is, the vector of actuation values u has this size. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af528f7747dc75227fdec76aba89e7d2b" title="Creates and adds a JointActuator model for an actuator acting on a given joint.">AddJointActuator()</a>. </p>

</div>
</div>
<a id="a8601c026e9807127b4dd41e7585d2cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8601c026e9807127b4dd41e7585d2cfc">&#9670;&nbsp;</a></span>num_actuators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_actuators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of joint actuators in the model. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#af528f7747dc75227fdec76aba89e7d2b" title="Creates and adds a JointActuator model for an actuator acting on a given joint.">AddJointActuator()</a>. </dd></dl>

</div>
</div>
<a id="af92b53211e54243aff4490a700168eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92b53211e54243aff4490a700168eb4">&#9670;&nbsp;</a></span>num_bodies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_bodies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bodies in the model, including the "world" body, which is always part of the model. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a9f6a68c31772eaa0c855ebb44eeaa0b7" title="Creates a rigid body with the provided name and spatial inertia.">AddRigidBody()</a>. </dd></dl>

</div>
</div>
<a id="ac1b107ecf3446e56cb203461440200c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b107ecf3446e56cb203461440200c1">&#9670;&nbsp;</a></span>num_collision_geometries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_collision_geometries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of geometries registered for contact modeling. </p>
<p>This method can be called at any time during the lifetime of <code>this</code> plant, either pre- or post-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. Post-finalize calls will always return the same value. </p>

</div>
</div>
<a id="a6b7f0267d163693025fa04f78bb18333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7f0267d163693025fa04f78bb18333">&#9670;&nbsp;</a></span>num_force_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_force_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of <a class="el" href="classdrake_1_1multibody_1_1_force_element.html" title="A ForceElement allows modeling state and time dependent forces in a MultibodyTree model.">ForceElement</a> objects. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a48009c793b01c5a6dd079d33265435a3" title="Adds a new force element model of type ForceElementType to this MultibodyPlant.">AddForceElement()</a>. </dd></dl>

</div>
</div>
<a id="ada7f02e861a8f89fc0b575b2f30333d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7f02e861a8f89fc0b575b2f30333d3">&#9670;&nbsp;</a></span>num_frames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_frames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of <a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame),...">Frame</a> objects in this model. </p>
<p>Frames include body frames associated with each of the bodies, including the <em>world</em> body. This means the minimum number of frames is one. </p>

</div>
</div>
<a id="a636804b6c40e538d83d5c2dfefb7929e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636804b6c40e538d83d5c2dfefb7929e">&#9670;&nbsp;</a></span>num_joints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_joints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of joints in the model. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a437f86026a2268c0fb06936b899ba8d7" title="This method adds a Joint of type JointType between two bodies.">AddJoint()</a>. </dd></dl>

</div>
</div>
<a id="ac89140adb93cb9e507f71c30eb783198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89140adb93cb9e507f71c30eb783198">&#9670;&nbsp;</a></span>num_model_instances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_model_instances </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of model instances in the model. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4edf1daa65069a26255c903b02bce4c6" title="Creates a new model instance.">AddModelInstance()</a>. </dd></dl>

</div>
</div>
<a id="ac80c61762d32b97a34f02a0374fc6fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80c61762d32b97a34f02a0374fc6fe3">&#9670;&nbsp;</a></span>num_multibody_states() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_multibody_states </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the multibody system state vector x = [q v]. </p>
<p>This will be <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a></code> plus <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a></code>. </p>

</div>
</div>
<a id="a07d0d29cbbe6e1de7cbaf90fefc5e652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d0d29cbbe6e1de7cbaf90fefc5e652">&#9670;&nbsp;</a></span>num_multibody_states() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_multibody_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the multibody system state vector xᵢ = [qᵢ vᵢ] for model instance i. </p>
<p>(Here qᵢ ⊆ q and vᵢ ⊆ v.) will be <code>num_positions(model_instance)</code> plus <code>num_velocities(model_instance)</code>. </p>

</div>
</div>
<a id="aba2887f0ca1fbbdfb49cf6b0ee21e553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2887f0ca1fbbdfb49cf6b0ee21e553">&#9670;&nbsp;</a></span>num_positions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_positions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the generalized position vector q for this model. </p>

</div>
</div>
<a id="ab669e070e6178c4aeeb067a1f4b6122e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab669e070e6178c4aeeb067a1f4b6122e">&#9670;&nbsp;</a></span>num_positions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_positions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the generalized position vector qᵢ for model instance i. </p>

</div>
</div>
<a id="ae0163ac0976659d811e3337647ff0313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0163ac0976659d811e3337647ff0313">&#9670;&nbsp;</a></span>num_velocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_velocities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the generalized velocity vector v for this model. </p>

</div>
</div>
<a id="a0a686a8389beffdc5fb8a7690967e741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a686a8389beffdc5fb8a7690967e741">&#9670;&nbsp;</a></span>num_velocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_velocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the generalized velocity vector vᵢ for model instance i. </p>

</div>
</div>
<a id="aa7c0b698e0102d42f085ca39f337b019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c0b698e0102d42f085ca39f337b019">&#9670;&nbsp;</a></span>num_visual_geometries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> num_visual_geometries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of geometries registered for visualization. </p>
<p>This method can be called at any time during the lifetime of <code>this</code> plant, either pre- or post-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. Post-finalize calls will always return the same value. </p>

</div>
</div>
<a id="af4f43a6f72128af8e926d32c37ed7580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f43a6f72128af8e926d32c37ed7580">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aecc2576d314d5baf56ad6ad593b26f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc2576d314d5baf56ad6ad593b26f9f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a6d28ce9c8119bee923e827eb6f02ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6d28ce9c8119bee923e827eb6f02ed">&#9670;&nbsp;</a></span>RegisterAsSourceForSceneGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake_1_1geometry.html#ac53cb597123131fb23a7af26e8d350bf">geometry::SourceId</a> RegisterAsSourceForSceneGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>scene_graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers <code>this</code> plant to serve as a source for an instance of SceneGraph. </p>
<p>This registration allows MultibodyPlant to register geometry with <code>scene_graph</code> for visualization and/or collision queries. Successive registration calls with SceneGraph <b>must</b> be performed on the same instance to which the pointer argument <code>scene_graph</code> points to. Failure to do so will result in runtime exceptions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scene_graph</td><td>A valid non nullptr to the SceneGraph instance for which <code>this</code> plant will sever as a source, see SceneGraph documentation for further details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the SourceId of <code>this</code> plant in <code>scene_graph</code>. It can also later on be retrieved with <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a0e13ba788ae1f46c3a847b025a5f0347" title="Returns the unique id identifying this plant as a source for a SceneGraph.">get_source_id()</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called post-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>scene_graph</code> is the nullptr. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called more than once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9b4f41a4f2575707d43ea031ce5a9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b4f41a4f2575707d43ea031ce5a9ea">&#9670;&nbsp;</a></span>RegisterCollisionGeometry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> RegisterCollisionGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html">geometry::ProximityProperties</a>&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers geometry in a SceneGraph with a given <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications.">geometry::Shape</a> to be used for the contact modeling of a given <code>body</code>. </p>
<p>More than one geometry can be registered with a body, in which case the body's contact geometry is the union of all geometries registered to that body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body</td><td>The body for which geometry is being registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_BG</td><td>The fixed pose of the geometry frame G in the body frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>The <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications.">geometry::Shape</a> used for visualization. E.g.: <a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere.">geometry::Sphere</a>, <a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder.">geometry::Cylinder</a>, etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">properties</td><td>The proximity properties associated with the collision geometry. They <em>must</em> include the (<code>material</code>, <code>coulomb_friction</code>) property of type <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction&lt;double&gt;</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called post-finalize or if the properties are missing the coulomb friction property (or if it is of the wrong type). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a602bd19cfdb283686f9051b674611baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602bd19cfdb283686f9051b674611baa">&#9670;&nbsp;</a></span>RegisterCollisionGeometry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> RegisterCollisionGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_coulomb_friction.html">CoulombFriction</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coulomb_friction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload which specifies a single property: coulomb_friction. </p>

</div>
</div>
<a id="ac2ae40642e0504217ada31209e1ecb80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ae40642e0504217ada31209e1ecb80">&#9670;&nbsp;</a></span>RegisterVisualGeometry() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> RegisterVisualGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html">geometry::IllustrationProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers geometry in a SceneGraph with a given <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications.">geometry::Shape</a> to be used for visualization of a given <code>body</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Currently, the visual geometry will <em>also</em> be assigned a perception role. Its render label's value will be equal to the body's index and its perception color will be the same as its illustration color (defaulting to gray if no color is provided). This behavior will change in the near future and code that directly relies on this behavior will break.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body</td><td>The body for which geometry is being registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_BG</td><td>The fixed pose of the geometry frame G in the body frame B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>The <a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications.">geometry::Shape</a> used for visualization. E.g.: <a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere.">geometry::Sphere</a>, <a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder.">geometry::Cylinder</a>, etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name for the geometry. It must satisfy the requirements defined in <a class="el" href="classdrake_1_1geometry_1_1_geometry_instance.html" title="A geometry instance combines a geometry definition (i.e., a shape of some sort), a pose (relative to ...">drake::geometry::GeometryInstance</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">properties</td><td>The illustration properties for this geometry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called post-finalize. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if <code>scene_graph</code> does not correspond to the same instance with which <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a4a6d28ce9c8119bee923e827eb6f02ed" title="Registers this plant to serve as a source for an instance of SceneGraph.">RegisterAsSourceForSceneGraph()</a> was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the id for the registered geometry. </dd></dl>

</div>
</div>
<a id="ad31bebf1580d051c3a2e243c9b511175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31bebf1580d051c3a2e243c9b511175">&#9670;&nbsp;</a></span>RegisterVisualGeometry() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> RegisterVisualGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#af7e96394aef85f13f3fc84d3c3c238b3">Vector4</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>diffuse_color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for visual geometry registration; it converts the <code>diffuse_color</code> (RGBA with values in the range [0, 1]) into a <a class="el" href="group__visualization.html#ga20c8d0e933cfdd8684cf77b15d8bef15" title="Extends a Diagram with the required components to interface with drake_visualizer.">geometry::ConnectDrakeVisualizer()</a>-compatible set of <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role.">geometry::IllustrationProperties</a>. </p>

</div>
</div>
<a id="ad27da771f6b43d4944b33dc6d6338f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27da771f6b43d4944b33dc6d6338f8e">&#9670;&nbsp;</a></span>RegisterVisualGeometry() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">geometry::GeometryId</a> RegisterVisualGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_BG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_shape.html">geometry::Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for visual geometry registration; it relies on the downstream <a class="el" href="classdrake_1_1geometry_1_1_illustration_properties.html" title="The set of properties for geometry used in an &quot;illustration&quot; role.">geometry::IllustrationProperties</a> <em>consumer</em> to provide default parameter values (see <a class="el" href="group__geometry__roles.html">Geometry Queries and Roles</a> for details). </p>

</div>
</div>
<a id="ad253ab790ff8e142080cedd210e982da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad253ab790ff8e142080cedd210e982da">&#9670;&nbsp;</a></span>set_contact_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_contact_model </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4e">ContactModel</a>&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the contact model to be used by <code>this</code> MultibodyPlant, see ContactModel for available options. </p>
<p>The default contact model is <a class="el" href="namespacedrake_1_1multibody.html#a6f6e054758d34b83e86bea87d65dfe4ea24d742e384e4b818c113620a6aebe0e5" title="Contact forces are computed using a point contact model, see Numerical Approximation of Point Contact...">ContactModel::kPointContactOnly</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>iff called post-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cdb3408c412b2af94476886dc35cc71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdb3408c412b2af94476886dc35cc71">&#9670;&nbsp;</a></span>set_penetration_allowance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_penetration_allowance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>penetration_allowance</em> = <code>0.001</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the penetration allowance used to estimate the coefficients in the penalty method used to impose non-penetration among bodies. </p>
<p>Refer to the section <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#mbp_penalty_method">Contact by penalty method</a> for further details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if penetration_allowance is not positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ce165180ba1d40e2a120eea631e4cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce165180ba1d40e2a120eea631e4cb1">&#9670;&nbsp;</a></span>set_stiction_tolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_stiction_tolerance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v_stiction</em> = <code>0.001</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="anchor" id="mbp_stribeck_model"></a></p><h3>Stribeck model of friction</h3>
<p>Currently MultibodyPlant uses the Stribeck approximation to model dry friction. The Stribeck model of friction is an approximation to Coulomb's law of friction that allows using continuous time integration without the need to specify complementarity constraints. While this results in a simpler model immediately tractable with standard numerical methods for integration of ODE's, it often leads to stiff dynamics that require an explicit integrator to take very small time steps. It is therefore recommended to use error controlled integrators when using this model or the discrete time stepping (see <a class="el" href="group__contact__engineering.html#time_advancement_strategy">Choice of Time Advancement Strategy</a>). See <a class="el" href="group__stribeck__approximation.html">Continuous Approximation of Coulomb</a> for a detailed discussion of the Stribeck model.</p>
<p>Sets the stiction tolerance <code>v_stiction</code> for the Stribeck model, where <code>v_stiction</code> must be specified in m/s (meters per second.) <code>v_stiction</code> defaults to a value of 1 millimeter per second. In selecting a value for <code>v_stiction</code>, you must ask yourself the question, "When two objects are ostensibly in stiction, how much slip am I willing
to allow?" There are two opposing design issues in picking a value for vₛ. On the one hand, small values of vₛ make the problem numerically stiff during stiction, potentially increasing the integration cost. On the other hand, it should be picked to be appropriate for the scale of the problem. For example, a car simulation could allow a "large" value for vₛ of 1 cm/s (1×10⁻² m/s), but reasonable stiction for grasping a 10 cm box might require limiting residual slip to 1×10⁻³ m/s or less. Ultimately, picking the largest viable value will allow your simulation to run faster and more robustly. Note that <code>v_stiction</code> is the slip velocity that we'd have when we are at edge of the friction cone. For cases when the friction force is well within the friction cone the slip velocity will always be smaller than this value. See also <a class="el" href="group__stribeck__approximation.html">Continuous Approximation of Coulomb</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>v_stiction</code> is non-positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec851e17ae2c34da1b87a03ce85f460a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec851e17ae2c34da1b87a03ce85f460a">&#9670;&nbsp;</a></span>SetActuationInArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetActuationInArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>u_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the actuation values <code>u_instance</code> for all actuators in <code>model_instance</code>, this method sets the actuation vector u for the entire model to which this actuator belongs to. </p>
<p>This method throws an exception if the size of <code>u_instance</code> is not equal to the number of degrees of freedom of all of the actuated joints in <code>model_instance</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u_instance</td><td>Actuation values for the actuators. It must be of size equal to the number of degrees of freedom of all of the actuated joints in <code>model_instance</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>The vector containing the actuation values for the entire model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a054aef89f09b26103692515fea766e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054aef89f09b26103692515fea766e9e">&#9670;&nbsp;</a></span>SetDefaultFreeBodyPose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetDefaultFreeBodyPose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_WB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the default pose of <code>body</code>. </p>
<p>If <code>body.is_floating()</code> is true, this will affect subsequent calls to <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae73edc00d493b3f15ba7679cc14830a0" title="Sets state according to defaults set by the user for joints (e.g.">SetDefaultState()</a>; otherwise, this value is effectively ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">body</td><td><a class="el" href="classdrake_1_1multibody_1_1_body.html" title="Body provides the general abstraction of a body with an API that makes no assumption about whether a ...">Body</a> whose default pose will be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X_WB</td><td>Default pose of the body. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae73edc00d493b3f15ba7679cc14830a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73edc00d493b3f15ba7679cc14830a0">&#9670;&nbsp;</a></span>SetDefaultState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetDefaultState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <code>state</code> according to defaults set by the user for joints (e.g. </p>
<p><a class="el" href="classdrake_1_1multibody_1_1_revolute_joint.html#a5608e4f04daa177004efade938e77fbf" title="Sets the default_positions of this joint (in this case a single angle).">RevoluteJoint::set_default_angle()</a>) and free bodies (<a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a054aef89f09b26103692515fea766e9e" title="Sets the default pose of body.">SetDefaultFreeBodyPose()</a>). If the user does not specify defaults, the state corresponds to zero generalized positions and velocities. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. See <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11f73bcbe2af96a9f46479536f2ad3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f73bcbe2af96a9f46479536f2ad3ab">&#9670;&nbsp;</a></span>SetFreeBodyPose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyPose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_WB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>context</code> to store the pose <code>X_WB</code> of a given <code>body</code> B in the world frame W. </p>
<dl class="section note"><dt>Note</dt><dd>In general setting the pose and/or velocity of a body in the model would involve a complex inverse kinematics problem. This method allows us to simplify this process when we know the body is free in space. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab55401ca376182fd5025d534c63963d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55401ca376182fd5025d534c63963d0">&#9670;&nbsp;</a></span>SetFreeBodyPose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyPose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_WB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>state</code> to store the pose <code>X_WB</code> of a given <code>body</code> B in the world frame W, for a given <code>context</code> of <code>this</code> model. </p>
<dl class="section note"><dt>Note</dt><dd>In general setting the pose and/or velocity of a body in the model would involve a complex inverse kinematics problem. This method allows us to simplify this process when we know the body is free in space. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>state</code> comes from this <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </dd></dl>

</div>
</div>
<a id="a403d4d02300c8a3184423fb7041b3fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403d4d02300c8a3184423fb7041b3fba">&#9670;&nbsp;</a></span>SetFreeBodyPoseInAnchoredFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyPoseInAnchoredFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>frame_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_FB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates <code>context</code> to store the pose <code>X_FB</code> of a given <code>body</code> B in a frame F. </p>
<p><a class="el" href="classdrake_1_1multibody_1_1_frame.html" title="Frame is an abstract class representing a material frame (also called a physical frame),...">Frame</a> F must be anchored, meaning that it is either directly welded to the world frame W or, more generally, that there is a kinematic path between frame F and the world frame W that only includes weld joints. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if called pre-finalize. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if frame F is not anchored to the world. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace6dfcf87981848b3eb491a6d59ce5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6dfcf87981848b3eb491a6d59ce5ab">&#9670;&nbsp;</a></span>SetFreeBodyPoseInWorldFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyPoseInWorldFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_WB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>context</code> to store the pose <code>X_WB</code> of a given <code>body</code> B in the world frame W. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context to store the pose <code>X_WB</code> of <code>body_B</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">body_B</td><td>The body B corresponding to the pose <code>X_WB</code> to be stored in <code>context</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">X_WB</td><td>The pose of body frame B in the world frame W. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In general setting the pose and/or velocity of a body in the model would involve a complex inverse kinematics problem. This method allows us to simplify this process when we know the body is free in space. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::logic_error</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c0e75333c80fb63dd99945520e41b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0e75333c80fb63dd99945520e41b6b">&#9670;&nbsp;</a></span>SetFreeBodyRandomPositionDistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyRandomPositionDistribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the distribution used by <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a470c99c41ab31927ae50c9996786bd10" title="Assigns random values to all elements of the state, by drawing samples independently for each joint/f...">SetRandomState()</a> to populate the free body's x-y-z <code>position</code> with respect to World. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51c0870fc64428fdd97f76d23f05b43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c0870fc64428fdd97f76d23f05b43e">&#9670;&nbsp;</a></span>SetFreeBodyRandomRotationDistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyRandomRotationDistribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternion&lt; <a class="el" href="classdrake_1_1symbolic_1_1_expression.html">symbolic::Expression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the distribution used by <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a470c99c41ab31927ae50c9996786bd10" title="Assigns random values to all elements of the state, by drawing samples independently for each joint/f...">SetRandomState()</a> to populate the free body's <code>rotation</code> with respect to World. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0df65f4ca090714b8ff84be535cfc635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df65f4ca090714b8ff84be535cfc635">&#9670;&nbsp;</a></span>SetFreeBodyRandomRotationDistributionToUniform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodyRandomRotationDistributionToUniform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the distribution used by <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a470c99c41ab31927ae50c9996786bd10" title="Assigns random values to all elements of the state, by drawing samples independently for each joint/f...">SetRandomState()</a> to populate the free body's rotation with respect to World using uniformly random rotations. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4c3b2ef66032df5f2a377c47e90ccb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c3b2ef66032df5f2a377c47e90ccb7">&#9670;&nbsp;</a></span>SetFreeBodySpatialVelocity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodySpatialVelocity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V_WB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>context</code> to store the spatial velocity <code>V_WB</code> of a given <code>body</code> B in the world frame W. </p>
<dl class="section note"><dt>Note</dt><dd>In general setting the pose and/or velocity of a body in the model would involve a complex inverse kinematics problem. This method allows us to simplify this process when we know the body is free in space. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ecd07546b94fae6038ff66f389b7d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecd07546b94fae6038ff66f389b7d23">&#9670;&nbsp;</a></span>SetFreeBodySpatialVelocity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetFreeBodySpatialVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_body.html">Body</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_spatial_velocity.html">SpatialVelocity</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V_WB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <code>state</code> to store the spatial velocity <code>V_WB</code> of a given <code>body</code> B in the world frame W, for a given <code>context</code> of <code>this</code> model. </p>
<dl class="section note"><dt>Note</dt><dd>In general setting the pose and/or velocity of a body in the model would involve a complex inverse kinematics problem. This method allows us to simplify this process when we know the body is free in space. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>body</code> is not a free body in the model. </td></tr>
    <tr><td class="paramname">std::exception</td><td>if called pre-finalize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>state</code> comes from this <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </dd></dl>

</div>
</div>
<a id="abfb9f945ca5577141351e60bd45156ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb9f945ca5577141351e60bd45156ef">&#9670;&nbsp;</a></span>SetPositions() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all generalized positions from the given vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr, if the context does not correspond to the context for a multibody model, or if the length of <code>q</code> is not equal to <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0258f954570e8d3df3b81e5e1f6e192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0258f954570e8d3df3b81e5e1f6e192">&#9670;&nbsp;</a></span>SetPositions() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPositions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the positions for a particular model instance from the given vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr, if the context does not correspond to the context for a multibody model, if the model instance index is invalid, or if the length of <code>q_instance</code> is not equal to <code>num_positions(model_instance)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a7236c8f0806c512c3d64d301a326ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7236c8f0806c512c3d64d301a326ee">&#9670;&nbsp;</a></span>SetPositions() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPositions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the positions for a particular model instance from the given vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>state</code> is nullptr, if the context does not correspond to the context for a multibody model, if the model instance index is invalid, or if the length of <code>q_instance</code> is not equal to <code>num_positions(model_instance)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>state</code> comes from this <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </dd></dl>

</div>
</div>
<a id="a5f77c6666edaa725dbd5dd060d2f5b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f77c6666edaa725dbd5dd060d2f5b00">&#9670;&nbsp;</a></span>SetPositionsAndVelocities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all generalized positions and velocities from the given vector [q; v]. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr, if the context does not correspond to the context for a multibody model, or if the length of <code>q_v</code> is not equal to <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">num_positions()</a> + <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16955a0cd87697a6806d99e9d6de0651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16955a0cd87697a6806d99e9d6de0651">&#9670;&nbsp;</a></span>SetPositionsAndVelocities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPositionsAndVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets generalized positions and velocities from the given vector [q; v] for the specified model instance. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr, if the context does not correspond to the context for a multibody model, if the model instance index is invalid, or if the length of <code>q_v</code> is not equal to <code>num_positions(model_instance) + num_velocities(model_instance)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3de72c319632f5a263fe6c9e96c70614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de72c319632f5a263fe6c9e96c70614">&#9670;&nbsp;</a></span>SetPositionsInArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPositionsInArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>q_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vector of generalized positions for <code>model_instance</code> in <code>q</code> using <code>q_instance</code>, leaving all other elements in the array untouched. </p>
<p>This method throws an exception if <code>q</code> is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#aba2887f0ca1fbbdfb49cf6b0ee21e553" title="Returns the size of the generalized position vector q for this model.">MultibodyPlant::num_positions()</a> or <code>q_instance</code> is not of size <code>MultibodyPlant::num_positions(model_instance)</code>. </p>

</div>
</div>
<a id="a470c99c41ab31927ae50c9996786bd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470c99c41ab31927ae50c9996786bd10">&#9670;&nbsp;</a></span>SetRandomState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SetRandomState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_random_generator.html">RandomGenerator</a> *&#160;</td>
          <td class="paramname"><em>generator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns random values to all elements of the state, by drawing samples independently for each joint/free body (coming soon: and then solving a mathematical program to "project" these samples onto the registered system constraints). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__stochastic__systems.html">Stochastic Systems</a> </dd></dl>

</div>
</div>
<a id="a1ee483fa25d16a1ab99da1e0bface016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee483fa25d16a1ab99da1e0bface016">&#9670;&nbsp;</a></span>SetVelocities() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all generalized velocities from the given vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr, if the context does not correspond to the context for a multibody model, or if the length of <code>v</code> is not equal to <code><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">num_velocities()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae66a553c5df6ea662e219586fd306bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae66a553c5df6ea662e219586fd306bb">&#9670;&nbsp;</a></span>SetVelocities() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetVelocities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_state.html">systems::State</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the generalized velocities for a particular model instance from the given vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr, if the context does not correspond to the context for a multibody model, if the model instance index is invalid, or if the length of <code>v_instance</code> is not equal to <code>num_velocities(model_instance)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>state</code> comes from this <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a>. </dd></dl>

</div>
</div>
<a id="acac13b1f67afe352e62d292c1bd3a6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac13b1f67afe352e62d292c1bd3a6e0">&#9670;&nbsp;</a></span>SetVelocities() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetVelocities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_context.html">systems::Context</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v_instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the generalized velocities for a particular model instance from the given vector. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if the <code>context</code> is nullptr, if the context does not correspond to the context for a multibody model, if the model instance index is invalid, or if the length of <code>v_instance</code> is not equal to <code>num_velocities(model_instance)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60e9928aa7802359eaddab6ef5d92763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e9928aa7802359eaddab6ef5d92763">&#9670;&nbsp;</a></span>SetVelocitiesInArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetVelocitiesInArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1multibody.html#af65439a17091283a89eb12f1955c6db0">ModelInstanceIndex</a>&#160;</td>
          <td class="paramname"><em>model_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>v_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1_eigen_ptr.html">EigenPtr</a>&lt; <a class="el" href="namespacedrake.html#a77dd228fb4dd66a2c17dd3f7f38ffd85">VectorX</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the vector of generalized velocities for <code>model_instance</code> in <code>v</code> using <code>v_instance</code>, leaving all other elements in the array untouched. </p>
<p>This method throws an exception if <code>v</code> is not of size <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#ae0163ac0976659d811e3337647ff0313" title="Returns the size of the generalized velocity vector v for this model.">MultibodyPlant::num_velocities()</a> or <code>v_instance</code> is not of size <code>MultibodyPlant::num_positions(model_instance)</code>. </p>

</div>
</div>
<a id="a8daceb7a3c384d6ad9f305e42b5fc1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8daceb7a3c384d6ad9f305e42b5fc1c6">&#9670;&nbsp;</a></span>time_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double time_step </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The time step (or period) used to model <code>this</code> plant as a discrete system with periodic updates. </p>
<p>Returns 0 (zero) if the plant is modeled as a continuous system. This property of the plant is specified at construction and therefore this query can be performed either pre- or post-finalize, see <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a8fee61d7a783cade1a3d07fe86284d27" title="This method must be called after all elements in the model (joints, bodies, force elements,...">Finalize()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3296be9fa9bc35e6639460f54029c4c9" title="This constructor creates a plant with a single &quot;world&quot; body.">MultibodyPlant::MultibodyPlant(double)</a> </dd></dl>

</div>
</div>
<a id="aff819644b0d96ba73c9dddebc673ba64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff819644b0d96ba73c9dddebc673ba64">&#9670;&nbsp;</a></span>WeldFrames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html">WeldJoint</a>&lt;T&gt;&amp; WeldFrames </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1multibody_1_1_frame.html">Frame</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_AB</em> = <code><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;&#160;double&#160;&gt;::Identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Welds frames A and B with relative pose <code>X_AB</code>. </p>
<p>That is, the pose of frame B in frame A is fixed, with value <code>X_AB</code>. The call to this method creates and adds a new <a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html" title="This Joint fixes the relative pose between two frames as if &quot;welding&quot; them together.">WeldJoint</a> to the model. The new <a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html" title="This Joint fixes the relative pose between two frames as if &quot;welding&quot; them together.">WeldJoint</a> is named as: A.name() + "_welds_to_" + B.name(). </p><dl class="section return"><dt>Returns</dt><dd>a constant reference to the <a class="el" href="classdrake_1_1multibody_1_1_weld_joint.html" title="This Joint fixes the relative pose between two frames as if &quot;welding&quot; them together.">WeldJoint</a> welding frames A and B. </dd></dl>

</div>
</div>
<a id="a29ef779ddfeea96c5d80c27d68a4f864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ef779ddfeea96c5d80c27d68a4f864">&#9670;&nbsp;</a></span>world_body()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_rigid_body.html">RigidBody</a>&lt;T&gt;&amp; world_body </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the <em>world</em> body. </p>

</div>
</div>
<a id="ac95da38020c32452f62a8cf973057c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95da38020c32452f62a8cf973057c7a">&#9670;&nbsp;</a></span>world_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1multibody_1_1_body_frame.html">BodyFrame</a>&lt;T&gt;&amp; world_frame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reference to the <em>world</em> frame. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aac66563a5f3eb9e2041bd4fa8d438827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac66563a5f3eb9e2041bd4fa8d438827">&#9670;&nbsp;</a></span>AddMultibodyPlantSceneGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1multibody_1_1_add_multibody_plant_scene_graph_result.html">AddMultibodyPlantSceneGraphResult</a>&lt; T &gt; AddMultibodyPlantSceneGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_diagram_builder.html">systems::DiagramBuilder</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>scene_graph</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a new <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> with discrete update period <code>time_step</code> and adds it to a diagram builder together with the provided SceneGraph instance, connecting the geometry ports. </p>
<dl class="section note"><dt>Note</dt><dd>Usage examples in <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#add_multibody_plant_scene_graph">AddMultibodyPlantSceneGraph</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">builder</td><td>Builder to add to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_step</td><td>The discrete update period for the new <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> to be added. Please refer to the documentation provided in <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#a3296be9fa9bc35e6639460f54029c4c9" title="This constructor creates a plant with a single &quot;world&quot; body.">MultibodyPlant::MultibodyPlant(double)</a> for further details on the parameter <code>time_step</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scene_graph</td><td>(optional) Constructed scene graph. If none is provided, one will be created and used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of the registered plant and scene graph. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>builder</code> must be non-null. </dd></dl>

</div>
</div>
<a id="aad665c93a561c6ccbe2bba07d1d6193a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad665c93a561c6ccbe2bba07d1d6193a">&#9670;&nbsp;</a></span>AddMultibodyPlantSceneGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1multibody_1_1_add_multibody_plant_scene_graph_result.html">AddMultibodyPlantSceneGraphResult</a>&lt; T &gt; AddMultibodyPlantSceneGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1systems_1_1_diagram_builder.html">systems::DiagramBuilder</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>plant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">geometry::SceneGraph</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>scene_graph</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html" title="MultibodyPlant is a Drake system framework representation (see systems::System) for the model of a ph...">MultibodyPlant</a> and a SceneGraph instance to a diagram builder, connecting the geometry ports. </p>
<dl class="section note"><dt>Note</dt><dd>Usage examples in <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html#add_multibody_plant_scene_graph">AddMultibodyPlantSceneGraph</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">builder</td><td>Builder to add to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plant</td><td>Plant to be added to the builder. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scene_graph</td><td>(optional) Constructed scene graph. If none is provided, one will be created and used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of the registered plant and scene graph. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>builder</code> and <code>plant</code> must be non-null. </dd></dl>

</div>
</div>
<a id="a47a63154823dffd5838329527aafbd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a63154823dffd5838329527aafbd58">&#9670;&nbsp;</a></span>MultibodyPlant</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42efef893a4d8eed1d593caff328f599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42efef893a4d8eed1d593caff328f599">&#9670;&nbsp;</a></span>MultibodyPlantTester</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1multibody_1_1_multibody_plant_tester.html">MultibodyPlantTester</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/multibody/plant/<a class="el" href="multibody__plant_8h.html">multibody_plant.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1multibody.html">multibody</a></li><li class="navelem"><a class="el" href="classdrake_1_1multibody_1_1_multibody_plant.html">MultibodyPlant</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
