<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: Python Bindings</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__python__bindings.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Python Bindings<div class="ingroups"><a class="el" href="group__technical__notes.html">Technical Notes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<p>Details on implementing python bindings for the C++ code. </p>
<h1>Overview</h1>
<p>Drake uses <a href="http://pybind11.readthedocs.io/en/stable/">pybind11</a> for binding its C++ API to Python.</p>
<p>At present, a fork of <code>pybind11</code> is used which permits bindings matrices with <code>dtype=object</code>, passing <code>unique_ptr</code> objects, and prevents aliasing for Python classes derived from <code>pybind11</code> classes.</p>
<p>Before delving too deep into this, please first review the user-facing documentation about <a href="https://drake.mit.edu/python_bindings.html#what-s-available-from-python">What's Available from Python</a>.</p>
<h2>Module Organization</h2>
<p>The structure of the bindings generally follow the <em>directory structure</em>, not the namespace structure. As an example, the following code in C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parser_8h.html">drake/multibody/parsing/parser.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multibody__plant_8h.html">drake/multibody/plant/multibody_plant.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="code" href="classdrake_1_1multibody_1_1_multibody_plant.html">drake::multibody::MultibodyPlant</a>;</div><div class="line"><span class="keyword">using</span> <a class="code" href="classdrake_1_1multibody_1_1_parser.html">drake::multibody::Parser</a>;</div></div><!-- fragment --><p>will look similar in Python, but you won't use the header file's name:</p>
<div class="fragment"><div class="line">from pydrake.multibody.parsing <span class="keyword">import</span> Parser</div><div class="line"><span class="keyword">from</span> pydrake.multibody.plant <span class="keyword">import</span> MultibodyPlant</div></div><!-- fragment --><p>In general, you can find where a symbol is bound by searching for the symbol's name in quotes underneath the directory <code>drake/bindings/pydrake</code>.</p>
<p>For example, you should search for <code>"MultibodyPlant"</code>, <code>"Parser"</code>, etc. To elaborate, the binding of <code>Parser</code> is found in <code>.../pydrake/multibody/parsing_py.cc</code>, and looks like this:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Class = Parser;</div><div class="line">py::class_&lt;Class&gt;(m, <span class="stringliteral">&quot;Parser&quot;</span>, ...)</div></div><!-- fragment --><p>and binding of <code>MultibodyPlant</code> template instantiations are in <code>.../pydrake/multibody/plant_py.cc</code> and look like this:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Class = MultibodyPlant&lt;T&gt;;</div><div class="line">DefineTemplateClassWithDefault&lt;Class, systems::LeafSystem&lt;T&gt;&gt;(</div><div class="line">    m, <span class="stringliteral">&quot;MultibodyPlant&quot;</span>, ...)</div></div><!-- fragment --><p>where the function containing this definition is templated on type <code>T</code> and invoked for the scalar types mentioned in <code><a class="el" href="default__scalars_8h.html">drake/common/default_scalars.h</a></code>.</p>
<p>Some (but not all) exceptions to the above rules:</p>
<ul>
<li><code><a class="el" href="common_2autodiff_8h.html">drake/common/autodiff.h</a></code> symbols live in <code>pydrake.autodiffutils</code>.</li>
<li><code><a class="el" href="symbolic_8h.html" title="Provides public header files of Drake&#39;s symbolic library.">drake/common/symbolic.h</a></code> symbols live in <code>pydrake.symbolic</code>.</li>
<li><code><a class="el" href="value_8h.html">drake/common/value.h</a></code> symbols live in <code>pydrake.common.value</code>.</li>
<li><code><a class="el" href="mathematical__program_8h.html">drake/solvers/mathematical_program.h</a></code> symbols live in <code>pydrake.solvers.mathematicalprogram</code> (notice the Python name has no underscore).</li>
<li><code>drake/systems/framework/*.h</code> symbols live in <code>pydrake.systems.framework</code> (per the rule) and the bindings are ultimately linked via <code>pydrake/systems/framework_py.cc</code>, but for compilation speed the binding definitions themselves are split into <code>./framework_py_{semantics,systems,values}.cc</code>.</li>
</ul>
<h2><code>pybind11</code> Tips</h2>
<h3>Python Types</h3>
<p>Throughout the Drake code, Python types provided by <code>pybind11</code> are used, such as <code>py::handle</code>, <code>py::object</code>, <code>py::module</code>, <code>py::str</code>, <code>py::list</code>, etc. For an overview, see the <a href="http://pybind11.readthedocs.io/en/stable/reference.html">pybind11 reference</a>.</p>
<p>All of these are effectively thin wrappers around <code>PyObject*</code>, and thus can be cheaply copied.</p>
<p>Mutating the referred-to object also does not require passing by reference, so you can always pass the object by value for functions, but you should document your method if it mutates the object in a non-obvious fashion.</p>
<h3>Python Type Conversions</h3>
<p>You can implicit convert between <code>py::object</code> and its derived classes (such as <code>py::list</code>, <code>py::class_</code>, etc.), assuming the actual Python types agree. You may also implicitly convert from <code>py::object</code> (and its derived classes) to <code>py::handle</code>.</p>
<p>If you wish to convert a <code>py::handle</code> (or <code>PyObject*</code>) to <code>py::object</code> or a derived class, you should use <a href="http://pybind11.readthedocs.io/en/stable/reference.html#_CPPv218reinterpret_borrow6handle"><code>py::reinterpret_borrow&lt;&gt;</code></a>.</p>
<h1>Conventions</h1>
<h2>API</h2>
<p>Any Python bindings of C++ code will maintain C++ naming conventions, as well as Python code that is directly related to C++ symbols (e.g. shims, wrappers, or extensions on existing bound classes).</p>
<p>All other Python code be Pythonic and use PEP 8 naming conventions.</p>
<p>For binding functions or methods, argument names should be provided that correspond exactly to the C++ signatures using <code>py::arg("arg_name")</code>. This permits the C++ documentation to be relevant to the Sphinx-generated <a class="el" href="group__python__bindings.html#PydrakeDoc">documentation</a>, and allows for the keyword-arguments to be used in Python.</p>
<p>For binding functions, methods, properties, and classes, docstrings should be provided. These should be provided as described <a class="el" href="group__python__bindings.html#PydrakeDoc">here</a>.</p>
<h2>Testing</h2>
<p>In general, since the Python bindings wrap tested C++ code, you do not (and should not) repeat intricate testing logic done in C++. Instead, ensure you exercise the Pythonic portion of the API, using kwargs when appropriate.</p>
<p>When testing the values of NumPy matrices, please review the documentation in <code>pydrake.common.test_utilities.numpy_compare</code> for guidance.</p>
<h2>Target Conventions</h2>
<h3>Names</h3>
<ul>
<li><code>*_py</code>: A Python library (can be pure Python or pybind)<ul>
<li>File Names: <code>*.py</code>, <code>*_py.cc</code><ul>
<li>Each <code>*_py.cc</code> file should only define one package (a module; optionally with multiple submodules under it).</li>
<li><em>Note</em>: If you need to split up a <code>{module}_py.cc</code> file for compilation speed and clarity, use <code>{module}_py_{part}.cc</code> for source and <code>{module}_py_{part}.h</code> for headers, and then include the headers into the original module source file. <code>{part}</code> may not necessarily be a submodule.</li>
</ul>
</li>
</ul>
</li>
<li><code>*_pybind</code>: A C++ library for adding pybind-specific utilities to be consumed by C++.<ul>
<li>File Names: <code>*_pybind.{h,cc}</code></li>
</ul>
</li>
</ul>
<p>File names should follow form with their respective target.</p>
<h3>Visibility</h3>
<ul>
<li>All Python libraries should generally be private, as <code>pydrake</code> will be consumed as one encapsulated target.</li>
<li>All C++ <code>*_pybind</code> libraries for binding utilities should be public to aide downstream Bazel projects. If the API is unstable, consider making it private with a TODO to make public once it stabilizes.</li>
</ul>
<h3>Bazel</h3>
<p>Given that <code>libdrake.so</code> relies on static linking for components, any common headers should be robust against ODR violations. This can be normally achieved by using header-only libraries.</p>
<p>For upstream dependencies of these libraries, do NOT depend on the direct targets (e.g. <code>//common:essential</code>), because this will introduce runtime ODR violations for objects that have static storage (UID counters, etc.).</p>
<p>Instead, you must temporarily violate IWYU because it will be satisfied by <code>drake_pybind_library</code>, which will incorporate <code>libdrake.so</code> and the transitive headers.</p>
<p>If singletons are required (e.g. for <code>util/cpp_param_pybind</code>), consider storing the singleton values using Python.</p>
<p>If you are developing bindings for a small portion of Drake and would like to avoid rebuilding a large number of components when testing, consider editing <code>//tools/install/libdrake:build_components.bzl</code> to reduce the number of components being built.</p>
<h2>pybind Module Definitions</h2>
<ul>
<li>Modules should be defined within the <a class="el" href="namespacedrake_1_1pydrake.html" title="For more high-level information, see the Python Bindings technical notes.">drake::pydrake</a> namespace. Please review this namespace for available helper methods / classes.</li>
<li>Any Drake pybind module should include <code><a class="el" href="pydrake__pybind_8h.html">pydrake_pybind.h</a></code>.</li>
<li><code>PYBIND_MODULE</code> should be used to define modules.</li>
<li>The alias <code>namespace py = pybind11</code> is defined as <code>drake::pydrake::py</code>. Drake modules should not re-define this alias at global scope.</li>
<li>If a certain namespace is being bound (e.g. <code><a class="el" href="namespacedrake_1_1systems_1_1sensors.html">drake::systems::sensors</a></code>), you may use <code>using namespace <a class="el" href="namespacedrake_1_1systems_1_1sensors.html">drake::systems::sensors</a></code> within functions or anonymous namespaces. Avoid <code>using namespace</code> directives otherwise.</li>
</ul>
<p><a class="anchor" id="PydrakeDoc"></a></p><h2>Documentation</h2>
<p>Drake uses a modified version of <code>mkdoc.py</code> from <code>pybind11</code>, where <code>libclang</code> Python bindings are used to generate C++ docstrings accessible to the C++ binding code.</p>
<p>These docstrings are available within <code>constexpr struct ... pydrake_doc</code> as <code>const char*</code> values . When these are not available or not suitable for Python documentation, provide custom strings. If this custom string is long, consider placing them in a heredoc string.</p>
<p>An example of incorporating docstrings from <code>pydrake_doc</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;drake/bindings/pydrake/documentation_pybind.h&quot;</span></div><div class="line"></div><div class="line">PYBIND11_MODULE(math, m) {</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedrake_1_1math.html">drake::math</a>;</div><div class="line">  constexpr <span class="keyword">auto</span>&amp; doc = pydrake_doc.drake.math;</div><div class="line">  <span class="keyword">using</span> T = double;</div><div class="line">  py::class_&lt;RigidTransform&lt;T&gt;&gt;(m, <span class="stringliteral">&quot;RigidTransform&quot;</span>, doc.RigidTransform.doc)</div><div class="line">      .def(py::init(), doc.RigidTransform.ctor.doc_0args)</div><div class="line">      ...</div><div class="line">      .def(py::init&lt;<span class="keyword">const</span> <a class="code" href="classdrake_1_1math_1_1_rotation_matrix.html">RotationMatrix&lt;T&gt;</a>&amp;&gt;(), py::arg(<span class="stringliteral">&quot;R&quot;</span>),</div><div class="line">          doc.RigidTransform.ctor.doc_1args_R)</div><div class="line">      .def(py::init&lt;<span class="keyword">const</span> Eigen::Quaternion&lt;T&gt;&amp;, <span class="keyword">const</span> Vector3&lt;T&gt;&amp;&gt;(),</div><div class="line">          py::arg(<span class="stringliteral">&quot;quaternion&quot;</span>), py::arg(<span class="stringliteral">&quot;p&quot;</span>),</div><div class="line">          doc.RigidTransform.ctor.doc_2args_quaternion_p)</div><div class="line">      ...</div><div class="line">      .def(<span class="stringliteral">&quot;set_rotation&quot;</span>, &amp;<a class="code" href="classdrake_1_1math_1_1_rigid_transform.html">RigidTransform&lt;T&gt;::set_rotation</a>, py::arg(<span class="stringliteral">&quot;R&quot;</span>),</div><div class="line">          doc.<a class="code" href="classdrake_1_1math_1_1_rigid_transform.html#a8bedd8c483aaf5bc48587d10d7a3d485">RigidTransform</a>.set_rotation.doc)</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>An example of supplying custom strings:</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">char</span> another_helper_doc[] = R<span class="stringliteral">&quot;&quot;&quot;(</span></div><div class="line"><span class="stringliteral">Another helper docstring. This is really long.</span></div><div class="line"><span class="stringliteral">And has multiple lines.</span></div><div class="line"><span class="stringliteral">)&quot;&quot;&quot;;</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">PYBIND11_MODULE(example, m) {</span></div><div class="line"><span class="stringliteral">  m.def(</span><span class="stringliteral">&quot;helper&quot;</span>, []() { <span class="keywordflow">return</span> 42; }, <span class="stringliteral">&quot;My helper method&quot;</span>);</div><div class="line">  m.def(<span class="stringliteral">&quot;another_helper&quot;</span>, []() { <span class="keywordflow">return</span> 10; }, another_helper_doc);</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Consider using scoped aliases to abbreviate both the usage of bound types and the docstring structures. Borrowing from above:</dd></dl>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">using</span> Class = RigidTransform&lt;T&gt;;</div><div class="line">  constexpr <span class="keyword">auto</span>&amp; cls_doc = doc.RigidTransform;</div><div class="line">  py::class_&lt;Class&gt;(m, <span class="stringliteral">&quot;RigidTransform&quot;</span>, cls_doc.doc)</div><div class="line">      .def(py::init(), cls_doc.ctor.doc_0args)</div><div class="line">      ...</div><div class="line">}</div></div><!-- fragment --><p>To view the documentation rendered in Sphinx: </p><pre class="fragment">bazel run //bindings/pydrake/doc:serve_sphinx [-- --browser=false]
</pre><dl class="section note"><dt>Note</dt><dd>Drake's online Python documentation is generated on Ubuntu Bionic, and it is suggested to preview documentation using this platform. Other platforms may have slightly different generated documentation.</dd></dl>
<p>To browse the generated documentation strings that are available for use (or especially, to find out the names for overloaded functions' documentation), generate and open the docstring header: </p><pre class="fragment">bazel build //bindings/pydrake:documentation_pybind.h
$EDITOR bazel-bin/bindings/pydrake/documentation_pybind.h
</pre><p>Search the comments for the symbol of interest, e.g., <code><a class="el" href="classdrake_1_1math_1_1_rigid_transform.html#a8bedd8c483aaf5bc48587d10d7a3d485">drake::math::RigidTransform::RigidTransform</a>&lt;T&gt;</code>, and view the include file and line corresponding to the symbol that the docstring was pulled from.</p>
<dl class="section note"><dt>Note</dt><dd>This file may be large, on the order of ~100K lines; be sure to use an efficient editor!</dd>
<dd>
If you are debugging a certain file and want quicker generation and a smaller generated file, you can hack <code>mkdoc.py</code> to focus only on your include file of chioce. As an example, debugging <code><a class="el" href="mathematical__program_8h.html">mathematical_program.h</a></code>: <div class="fragment"><div class="line">...</div><div class="line"><span class="keyword">assert</span> len(include_files) &gt; 0  <span class="comment"># Existing code.</span></div><div class="line">include_files = [<span class="stringliteral">&quot;drake/solvers/mathematical_program.h&quot;</span>]  <span class="comment"># HACK</span></div></div><!-- fragment --> This may break the bindings themselves, and should only be used for inspecting the output.</dd></dl>
<p>For more detail:</p>
<ul>
<li>Each docstring is stored in <code>documentation_pybind.h</code> in the nested structure <code>pydrake_doc</code>.</li>
<li>The docstring for a symbol without any overloads will be accessible via <code>pydrake_doc.drake.{namespace...}.{symbol}.doc</code>.</li>
<li>The docstring for an overloaded symbol will be <code>.doc_something</code> instead of just <code>.doc</code>, where the <code>_something</code> suffix conveys some information about the overload. Browse the documentation_pybind.h (described above) for details. Most commonly, the names will be <code>doc_1args</code>, <code>doc_3args</code>, etc. Be sure that the pydrake binding's signature is consistent with the docstring argument count.</li>
<li>If two or more docstrings are the same, only one new symbol is introduced.</li>
<li>To suppress a Doxygen comment from mkdoc, add the custom Doxygen command <code>@exclude_from_pydrake_mkdoc{Explanation}</code> to the API comment text. This is useful to help dismiss unbound overloads, so that mkdoc's choice of <code>_something</code> name suffix is simpler for the remaining overloads, especially if you see the symbol <code>.doc_was_unable_to_choose_unambiguous_names</code> in the generated documentation.</li>
<li>To manually specify the <code>.doc_foobar</code> identifier name, add the line <code>@pydrake_mkdoc_identifier{foobar}</code> to the Doxygen comment.</li>
<li>The docstring for a method that is marked as deprecated in C++ Doxygen will be named <code>.doc_deprecated...</code> instead of just <code>.doc...</code>.</li>
</ul>
<p><a class="anchor" id="PydrakeDeprecation"></a></p><h2>Deprecation</h2>
<p>Decorators and utilites for deprecation in pure Python are available in <a href="https://drake.mit.edu/pydrake/pydrake.common.deprecation.html"><code>pydrake.common.deprecation</code></a>.</p>
<p>Deprecations for Python bindings in C++ are available in <a href="https://drake.mit.edu/doxygen_cxx/deprecation__pybind_8h.html"><code>drake/bindings/pydrake/common/deprecation_pybind.h</code></a>.</p>
<p>For examples of how to use the deprecations and what side effects they will have, please see:</p>
<ul>
<li><a href="https://github.com/RobotLocomotion/drake/tree/master/bindings/pydrake/common/test/deprecation_example"><code>drake/bindings/.../deprecation_example/</code></a></li>
<li><a href="https://github.com/RobotLocomotion/drake/blob/master/bindings/pydrake/common/test/deprecation_test.py"><code>drake/bindings/.../deprecation_test.py</code></a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>All deprecations in Drake should ultimately use the <a href="https://docs.python.org/3.6/library/warnings.html">Python <code>warnings</code> module</a>, and the <a href="https://drake.mit.edu/pydrake/pydrake.common.deprecation.html#pydrake.common.deprecation.DrakeDeprecationWarning"><code>DrakeDeprecationWarning</code></a> class. The utilities mentioned above use them.</dd></dl>
<p><a class="anchor" id="PydrakeKeepAlive"></a></p><h2>Keep Alive Behavior</h2>
<p><code>py::keep_alive&lt;Nurse, Patient&gt;()</code> is used heavily throughout this code. Please first review <a href="http://pybind11.readthedocs.io/en/stable/advanced/functions.html#keep-alive">the pybind11 documentation</a>.</p>
<p><code>py::keep_alive</code> decorations should be added after all <code>py::arg</code>s are specified. Terse comments should be added above these decorations to indicate the relationship between the Nurse and the Patient and decode the meaning of the Nurse and Patient integers by spelling out either the <code>py::arg</code> name (for named arguments), <code>return</code> for index 0, or <code>self</code> (not <code>this</code>) for index 1 when dealing with methods / members. The primary relationships:</p><ul>
<li>"Keep alive, ownership" implies that a Patient owns the Nurse (or vice versa).</li>
<li>"Keep alive, reference" implies a Patient that is referred to by the Nurse. If there is an indirect / transitive relationship (storing a reference to an argument's member or a transfer of ownership, as with <code>DiagramBuilder.Build()</code>), append <code>(tr.)</code> to the relationship.</li>
</ul>
<p>Some example comments:</p>
<div class="fragment"><div class="line"><span class="comment">// Keep alive, reference: `self` keeps `context` alive.</span></div><div class="line"><span class="comment">// Keep alive, ownership (tr.): `return` keeps `self` alive.</span></div></div><!-- fragment --><p><a class="anchor" id="PydrakeReturnValuePolicy"></a></p><h2>Return Value Policy</h2>
<p>For more information about <code>pybind11</code> return value policies, see <a href="https://pybind11.readthedocs.io/en/stable/advanced/functions.html#return-value-policies">the pybind11 documentation</a>.</p>
<p><code>pydrake</code> offers the <a class="el" href="namespacedrake_1_1pydrake.html#a6e587c4c8d044dd6eee74dad65c203ed">py_rvp</a> alias to help with shortened usage of <code>py::return_value_policy</code>. The most used (non-default) policies in <code>pydrake</code> are <code>reference</code> and <code>reference_internal</code> due to the usage of raw pointers / references in the public C++ API (rather than <code>std::shared_ptr&lt;&gt;</code>).</p>
<dl class="section note"><dt>Note</dt><dd>While <code>py_rvp::reference_internal</code> effectively implies <code>py_rvp::reference</code> and <code>py::keep_alive&lt;0, 1&gt;()</code>, we choose to only use it when <code>self</code> is the intended patient (i.e. the bound item is a class method). For static / free functions, we instead explicitly spell out <code>py_rvp::reference</code> and <code>py::keep_alive&lt;0, 1&gt;()</code>.</dd></dl>
<p><a class="anchor" id="PydrakeOverloads"></a></p><h2>Function Overloads</h2>
<p>To bind function overloads, please try the following (in order):</p><ul>
<li><code>py::overload_cast&lt;Args&gt;(func)</code>: See <a href="http://pybind11.readthedocs.io/en/stable/classes.html#overloaded-methods">the pybind11 documentation</a>. This works about 80% of the time.</li>
<li><code>pydrake::overload_cast_explicit&lt;Return, Args...&gt;(func)</code>: When <code>py::overload_cast</code> does not work (not always guaranteed to work).</li>
<li><code>static_cast</code>, as mentioned in the pybind11 documentation.</li>
<li>Lambdas, e.g. <code>[](Args... args) -&gt; auto&amp;&amp; { return func(args...); }</code> (using perfect forwarding when appropriate).</li>
</ul>
<h3>Public C++ API Considerations for Function and Method Templates</h3>
<p>The motivation behind this section can be found under the "C++ Function and Method Template Instantiations in Python" section in <code>doc/python_bindings.rst</code>.</p>
<p>In general, Drake uses techniques like parameter packs and type erasure to create sugar functions. These functions map their inputs to parameters of some concrete, under-the-hood method that actually does the work, and is devoid of such tricks. To facilitate python bindings, this underlying function should also be exposed in the public API.</p>
<p>As an example for parameter packs, <code>MultibodyPlant&lt;T&gt;::AddJoint&lt;JointType, Args...&gt;(...)</code> (<a href="https://git.io/JfqhI">code permalink</a>) is a C++ sugar method that uses parameter packs and ultimately passes the result to <code>MultibodyPlant&lt;T&gt;::AddJoint&lt;JointType&gt;(unique_ptr&lt;JointType&gt;)</code> (<a href="https://git.io/JfqhU">code permalink</a>), and only the <code>unique_ptr</code> function is bound (<a href="https://git.io/Jfqie">code permalink</a>):</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Class = MultibodyPlant&lt;T&gt;;</div><div class="line">...</div><div class="line">    .def(<span class="stringliteral">&quot;AddJoint&quot;</span>,</div><div class="line">        [](Class* <span class="keyword">self</span>, std::unique_ptr&lt;Joint&lt;T&gt;&gt; joint) -&gt; <span class="keyword">auto</span>&amp; {</div><div class="line">          <span class="keywordflow">return</span> <span class="keyword">self</span>-&gt;AddJoint(std::move(joint));</div><div class="line">        },</div><div class="line">        py::arg(<span class="stringliteral">&quot;joint&quot;</span>), py_rvp::reference_internal, cls_doc.AddJoint.doc_1args)</div><div class="line">...</div></div><!-- fragment --><p>As an example for parameter packs, <code>GeometryProperties::AddProperty&lt;ValueType&gt;</code> (<a href="https://git.io/JfqhL">code permalink</a>) is a C++ sugar method that uses type erasure and ultimately passes the result to <code>GeometryProperties::AddPropertyAbstract</code> (<a href="https://git.io/Jfqhm">code permalink</a>), and only the <code>AddPropertyAbstract</code> flavor is used in the bindings, but in such a way that it is similar to the C++ API for <code>AddProperty</code> (<a href="https://git.io/JfqiT">code permalink</a>):</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Class = GeometryProperties;</div><div class="line">py::handle abstract_value_cls =</div><div class="line">    py::module::import(<span class="stringliteral">&quot;pydrake.systems.framework&quot;</span>).attr(<span class="stringliteral">&quot;AbstractValue&quot;</span>);</div><div class="line">...</div><div class="line">    .def(<span class="stringliteral">&quot;AddProperty&quot;</span>,</div><div class="line">        [abstract_value_cls](Class* <span class="keyword">self</span>, <span class="keyword">const</span> std::string&amp; group_name,</div><div class="line">            <span class="keyword">const</span> std::string&amp; name, py::object value) {</div><div class="line">          py::object <span class="keyword">abstract</span> = abstract_value_cls.attr(<span class="stringliteral">&quot;Make&quot;</span>)(value);</div><div class="line">          <span class="keyword">self</span>-&gt;AddPropertyAbstract(</div><div class="line">              group_name, name, <span class="keyword">abstract</span>.cast&lt;const AbstractValue&amp;&gt;());</div><div class="line">        },</div><div class="line">        py::arg(<span class="stringliteral">&quot;group_name&quot;</span>), py::arg(<span class="stringliteral">&quot;name&quot;</span>), py::arg(<span class="stringliteral">&quot;value&quot;</span>),</div><div class="line">        cls_doc.AddProperty.doc)</div><div class="line">...</div></div><!-- fragment --><h3>Matrix-multiplication-like Methods</h3>
<p>For objects that may be represented by matrices or vectors (e.g. RigidTransform, RotationMatrix), the <code>*</code> operator (via <code>__mul__</code>) should <em>not</em> be bound because the <code>*</code> operator in NumPy implies elemnt-wise multiplication for arrays.</p>
<p>For simplicity, we instead bind the explicitly named <code>.multiply()</code> method, and alias the <code>__matmul__</code> operator <code>@</code> to this function.</p>
<p><a class="anchor" id="PydrakeReturnVectorsOrMatrices"></a></p><h4>Returning Vectors or Matrices</h4>
<p>Certain bound methods, like <code>RigidTransform.multiply()</code>, will have overloads that can multiply and return (a) other <code>RigidTransform</code> instances, (b) vectors, or (c) matrices (representing a list of vectors).</p>
<p>In the cases of (a) and (c), <code>pybind11</code> provides sufficient mechanisms to provide an unambiguous output return type. However, for (b), <code>pybind11</code> will return <code>ndarray</code> with shape <code>(3,)</code>. This can cause an issue when users pass a vector of shape <code>(3, 1)</code> as input. Nominally, pybind11 will return a <code>(3,)</code> array, but the user may expect <code>(3, 1)</code> as an output. To accommodate this, you should use the <a class="el" href="namespacedrake_1_1pydrake.html#af5f81d7315477aaa1694d9aa02a1346b" title="Wraps a overload instance method to reshape the output to be the same as a given input argument.">drake::pydrake::WrapToMatchInputShape</a> function.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/RobotLocomotion/drake/issues/13885">https://github.com/RobotLocomotion/drake/issues/13885</a></dd></dl>
<h2>Python Subclassing of C++ Classes</h2>
<p>In general, minimize the amount in which users may subclass C++ classes in Python. When you do wish to do this, ensure that you use a trampoline class in <code>pybind</code>, and ensure that the trampoline class inherits from the <code>py::wrapper&lt;&gt;</code> class specific to our fork of <code>pybind</code>. This ensures that no slicing happens with the subclassed instances.</p>
<p><a class="anchor" id="PydrakeBazelDebug"></a></p><h1>Interactive Debugging with Bazel</h1>
<p>If you are debugging a unitest, first try running the test with <code>--trace=user</code> to see where the code is failing. This should cover most cases where you need to debug C++ bits. Example: </p><pre class="fragment">bazel run //bindings/pydrake/systems:py/lifetime_test -- --trace=user
</pre><p>If you need to debug further while using Bazel, it is suggested to use <code>gdbserver</code> for simplicity. Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Terminal 1 - Host process.</span></div><div class="line">cd <a class="code" href="namespacedrake.html">drake</a></div><div class="line">bazel run -c dbg \</div><div class="line">    --run_under=<span class="stringliteral">&#39;gdbserver localhost:9999&#39;</span> \</div><div class="line">    <span class="comment">//bindings/pydrake/systems:py/lifetime_test -- \</span></div><div class="line"><span class="comment">    --trace=user</span></div><div class="line"></div><div class="line"><span class="preprocessor"># Terminal 2 - Client debugger.</span></div><div class="line">cd <a class="code" href="namespacedrake.html">drake</a></div><div class="line">gdb -ex <span class="stringliteral">&quot;dir ${PWD}/bazel-drake&quot;</span> \</div><div class="line">    -ex <span class="stringliteral">&quot;target remote localhost:9999&quot;</span> \</div><div class="line">    -ex <span class="stringliteral">&quot;set sysroot&quot;</span> \</div><div class="line">    -ex <span class="stringliteral">&quot;set breakpoint pending on&quot;</span></div><div class="line"><span class="preprocessor"># In the GDB terminal:</span></div><div class="line">(gdb) <span class="keywordflow">break</span> <a class="code" href="classdrake_1_1systems_1_1_simulator.html">drake::systems::Simulator&lt;double&gt;::Simulator</a></div><div class="line">(gdb) <span class="keywordflow">continue</span></div></div><!-- fragment --><p><code>set sysroot</code> is important for using <code>gdbserver</code>, <code>set breakpoint pending on</code> allows you set the breakpoints before loading <code>libdrake.so</code>, and <code>dir ...</code> adds source directories. It is also suggested that you <a href="https://stackoverflow.com/a/3176802">enable readline history</a> in <code>~/.gdbinit</code> for ease of use.</p>
<p>If using CLion, you can still connect to the <code>gdbserver</code> instance.</p>
<p>There are analogs for <code>lldb</code> / <code>lldbserver</code> but for brevity, only GDB is covered. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
