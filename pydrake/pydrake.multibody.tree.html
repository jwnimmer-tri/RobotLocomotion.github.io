

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydrake.multibody.tree &mdash; pydrake  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="pydrake  documentation" href="index.html"/>
        <link rel="up" title="pydrake.multibody" href="pydrake.multibody.html"/>
        <link rel="next" title="pydrake.perception" href="pydrake.perception.html"/>
        <link rel="prev" title="pydrake.multibody.plant" href="pydrake.multibody.plant.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> pydrake
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.all.html">pydrake.multibody.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.benchmarks.html">pydrake.multibody.benchmarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.inverse_kinematics.html">pydrake.multibody.inverse_kinematics</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.math.html">pydrake.multibody.math</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.parsing.html">pydrake.multibody.parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.plant.html">pydrake.multibody.plant</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.multibody.tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="pydrake.multibody.html">pydrake.multibody</a> &raquo;</li>
        
      <li>pydrake.multibody.tree</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pydrake.multibody.tree">
<span id="pydrake-multibody-tree"></span><h1>pydrake.multibody.tree<a class="headerlink" href="#module-pydrake.multibody.tree" title="Permalink to this headline">¶</a></h1>
<p>Bindings for MultibodyTree and related components.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.BallRpyJoint">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BallRpyJoint</code><a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.BallRpyJoint_[float]" title="pydrake.multibody.tree.BallRpyJoint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.BallRpyJoint_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.BallRpyJoint_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BallRpyJoint_</code><a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.BallRpyJoint_[float]" title="pydrake.multibody.tree.BallRpyJoint_[float]"><code class="xref py py-class docutils literal"><span class="pre">BallRpyJoint_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]" title="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">BallRpyJoint_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.BallRpyJoint_[Expression]" title="pydrake.multibody.tree.BallRpyJoint_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">BallRpyJoint_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float]">
<em class="property">class </em><code class="descname">BallRpyJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint allows two bodies to rotate freely relative to one another.
That is, given a frame F attached to the parent body P and a frame M
attached to the child body B (see the Joint class’s documentation),
this Joint allows frame M to rotate freely with respect to F, while
the origins, Mo and Fo, of frames M and F respectively remain
coincident. The orientation of M relative to F is parameterized with
space <code class="docutils literal"><span class="pre">x-y-z</span></code> Euler angles.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a ball rpy joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate freely relative to one another. See this class’s
documentation for further details on the definition of these frames,
get_angles() for an explanation of the angles defining orientation,
and get_angular_velocity() for an explanation of the generalized
velocities. This constructor signature creates a joint with no joint
limits, i.e. the joint position, velocity and acceleration limits are
the pair <code class="docutils literal"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<p>The orientation <code class="docutils literal"><span class="pre">R_FM</span></code> of the child frame M in parent frame F is
parameterized with space <code class="docutils literal"><span class="pre">x-y-z</span></code> Euler angles (also known as
extrinsic angles). That is, the angles θr, θp, θy, correspond to a
sequence of rotations about the x̂, ŷ, ẑ axes of parent frame F,
respectively. Mathematically, rotation <code class="docutils literal"><span class="pre">R_FM</span></code> is given in terms of
angles θr, θp, θy by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rz</span><span class="p">(</span><span class="n">θy</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ry</span><span class="p">(</span><span class="n">θp</span><span class="p">)</span> <span class="o">*</span> <span class="n">Rx</span><span class="p">(</span><span class="n">θr</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">Rx(θ)</span></code>, <cite>Ry(θ)</cite> and <code class="docutils literal"><span class="pre">Rz(θ)</span></code> correspond to the elemental
rotations in amount of θ about the x, y and z axes respectively. Zero
θr, θp, θy angles corresponds to frames F and M being coincident.
Angles θr, θp, θy are defined to be positive according to the
right-hand-rule with the thumb aligned in the direction of their
respective axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Space <code class="docutils literal"><span class="pre">x-y-z</span></code> angles (extrinsic) are equivalent to Body
<code class="docutils literal"><span class="pre">z-y-x</span></code> angles (intrinsic).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This particular choice of angles θr, θp, θy for this joint are
many times referred to as the roll, pitch and yaw angles by many
dynamicists. They are also known as the Tait-Bryan angles or
Cardan angles.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal"><span class="pre">this</span></code> joint stored in the <code class="docutils literal"><span class="pre">context</span></code>
ordered as θr, θp, θy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves from <code class="docutils literal"><span class="pre">context</span></code> the angular velocity <code class="docutils literal"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float], angles: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal"><span class="pre">context</span></code> ordered
as θr, θp, θy. See get_angles() for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float], w_FM: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets in <code class="docutils literal"><span class="pre">context</span></code> the state for <code class="docutils literal"><span class="pre">this</span></code> joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal"><span class="pre">w_FM</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], angles: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See get_angles() for details on the angle
representation.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BallRpyJoint_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="pydrake.multibody.tree.Joint_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></a></p>
<p>This Joint allows two bodies to rotate freely relative to one another.
That is, given a frame F attached to the parent body P and a frame M
attached to the child body B (see the Joint class’s documentation),
this Joint allows frame M to rotate freely with respect to F, while
the origins, Mo and Fo, of frames M and F respectively remain
coincident. The orientation of M relative to F is parameterized with
space <code class="docutils literal"><span class="pre">x-y-z</span></code> Euler angles.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a ball rpy joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate freely relative to one another. See this class’s
documentation for further details on the definition of these frames,
get_angles() for an explanation of the angles defining orientation,
and get_angular_velocity() for an explanation of the generalized
velocities. This constructor signature creates a joint with no joint
limits, i.e. the joint position, velocity and acceleration limits are
the pair <code class="docutils literal"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<p>The orientation <code class="docutils literal"><span class="pre">R_FM</span></code> of the child frame M in parent frame F is
parameterized with space <code class="docutils literal"><span class="pre">x-y-z</span></code> Euler angles (also known as
extrinsic angles). That is, the angles θr, θp, θy, correspond to a
sequence of rotations about the x̂, ŷ, ẑ axes of parent frame F,
respectively. Mathematically, rotation <code class="docutils literal"><span class="pre">R_FM</span></code> is given in terms of
angles θr, θp, θy by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rz</span><span class="p">(</span><span class="n">θy</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ry</span><span class="p">(</span><span class="n">θp</span><span class="p">)</span> <span class="o">*</span> <span class="n">Rx</span><span class="p">(</span><span class="n">θr</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">Rx(θ)</span></code>, <cite>Ry(θ)</cite> and <code class="docutils literal"><span class="pre">Rz(θ)</span></code> correspond to the elemental
rotations in amount of θ about the x, y and z axes respectively. Zero
θr, θp, θy angles corresponds to frames F and M being coincident.
Angles θr, θp, θy are defined to be positive according to the
right-hand-rule with the thumb aligned in the direction of their
respective axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Space <code class="docutils literal"><span class="pre">x-y-z</span></code> angles (extrinsic) are equivalent to Body
<code class="docutils literal"><span class="pre">z-y-x</span></code> angles (intrinsic).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This particular choice of angles θr, θp, θy for this joint are
many times referred to as the roll, pitch and yaw angles by many
dynamicists. They are also known as the Tait-Bryan angles or
Cardan angles.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal"><span class="pre">this</span></code> joint stored in the <code class="docutils literal"><span class="pre">context</span></code>
ordered as θr, θp, θy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves from <code class="docutils literal"><span class="pre">context</span></code> the angular velocity <code class="docutils literal"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], angles: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal"><span class="pre">context</span></code> ordered
as θr, θp, θy. See get_angles() for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], w_FM: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets in <code class="docutils literal"><span class="pre">context</span></code> the state for <code class="docutils literal"><span class="pre">this</span></code> joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal"><span class="pre">w_FM</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd], angles: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See get_angles() for details on the angle
representation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BallRpyJoint_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[Expression]" title="pydrake.multibody.tree.Joint_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></a></p>
<p>This Joint allows two bodies to rotate freely relative to one another.
That is, given a frame F attached to the parent body P and a frame M
attached to the child body B (see the Joint class’s documentation),
this Joint allows frame M to rotate freely with respect to F, while
the origins, Mo and Fo, of frames M and F respectively remain
coincident. The orientation of M relative to F is parameterized with
space <code class="docutils literal"><span class="pre">x-y-z</span></code> Euler angles.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a ball rpy joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate freely relative to one another. See this class’s
documentation for further details on the definition of these frames,
get_angles() for an explanation of the angles defining orientation,
and get_angular_velocity() for an explanation of the generalized
velocities. This constructor signature creates a joint with no joint
limits, i.e. the joint position, velocity and acceleration limits are
the pair <code class="docutils literal"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<p>The orientation <code class="docutils literal"><span class="pre">R_FM</span></code> of the child frame M in parent frame F is
parameterized with space <code class="docutils literal"><span class="pre">x-y-z</span></code> Euler angles (also known as
extrinsic angles). That is, the angles θr, θp, θy, correspond to a
sequence of rotations about the x̂, ŷ, ẑ axes of parent frame F,
respectively. Mathematically, rotation <code class="docutils literal"><span class="pre">R_FM</span></code> is given in terms of
angles θr, θp, θy by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rz</span><span class="p">(</span><span class="n">θy</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ry</span><span class="p">(</span><span class="n">θp</span><span class="p">)</span> <span class="o">*</span> <span class="n">Rx</span><span class="p">(</span><span class="n">θr</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">Rx(θ)</span></code>, <cite>Ry(θ)</cite> and <code class="docutils literal"><span class="pre">Rz(θ)</span></code> correspond to the elemental
rotations in amount of θ about the x, y and z axes respectively. Zero
θr, θp, θy angles corresponds to frames F and M being coincident.
Angles θr, θp, θy are defined to be positive according to the
right-hand-rule with the thumb aligned in the direction of their
respective axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Space <code class="docutils literal"><span class="pre">x-y-z</span></code> angles (extrinsic) are equivalent to Body
<code class="docutils literal"><span class="pre">z-y-x</span></code> angles (intrinsic).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This particular choice of angles θr, θp, θy for this joint are
many times referred to as the roll, pitch and yaw angles by many
dynamicists. They are also known as the Tait-Bryan angles or
Cardan angles.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal"><span class="pre">this</span></code> joint stored in the <code class="docutils literal"><span class="pre">context</span></code>
ordered as θr, θp, θy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves from <code class="docutils literal"><span class="pre">context</span></code> the angular velocity <code class="docutils literal"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], angles: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal"><span class="pre">context</span></code> ordered
as θr, θp, θy. See get_angles() for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], w_FM: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets in <code class="docutils literal"><span class="pre">context</span></code> the state for <code class="docutils literal"><span class="pre">this</span></code> joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal"><span class="pre">w_FM</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[Expression], angles: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See get_angles() for details on the angle
representation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BallRpyJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint allows two bodies to rotate freely relative to one another.
That is, given a frame F attached to the parent body P and a frame M
attached to the child body B (see the Joint class’s documentation),
this Joint allows frame M to rotate freely with respect to F, while
the origins, Mo and Fo, of frames M and F respectively remain
coincident. The orientation of M relative to F is parameterized with
space <code class="docutils literal"><span class="pre">x-y-z</span></code> Euler angles.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a ball rpy joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate freely relative to one another. See this class’s
documentation for further details on the definition of these frames,
get_angles() for an explanation of the angles defining orientation,
and get_angular_velocity() for an explanation of the generalized
velocities. This constructor signature creates a joint with no joint
limits, i.e. the joint position, velocity and acceleration limits are
the pair <code class="docutils literal"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<p>The orientation <code class="docutils literal"><span class="pre">R_FM</span></code> of the child frame M in parent frame F is
parameterized with space <code class="docutils literal"><span class="pre">x-y-z</span></code> Euler angles (also known as
extrinsic angles). That is, the angles θr, θp, θy, correspond to a
sequence of rotations about the x̂, ŷ, ẑ axes of parent frame F,
respectively. Mathematically, rotation <code class="docutils literal"><span class="pre">R_FM</span></code> is given in terms of
angles θr, θp, θy by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rz</span><span class="p">(</span><span class="n">θy</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ry</span><span class="p">(</span><span class="n">θp</span><span class="p">)</span> <span class="o">*</span> <span class="n">Rx</span><span class="p">(</span><span class="n">θr</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">Rx(θ)</span></code>, <cite>Ry(θ)</cite> and <code class="docutils literal"><span class="pre">Rz(θ)</span></code> correspond to the elemental
rotations in amount of θ about the x, y and z axes respectively. Zero
θr, θp, θy angles corresponds to frames F and M being coincident.
Angles θr, θp, θy are defined to be positive according to the
right-hand-rule with the thumb aligned in the direction of their
respective axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Space <code class="docutils literal"><span class="pre">x-y-z</span></code> angles (extrinsic) are equivalent to Body
<code class="docutils literal"><span class="pre">z-y-x</span></code> angles (intrinsic).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This particular choice of angles θr, θp, θy for this joint are
many times referred to as the roll, pitch and yaw angles by many
dynamicists. They are also known as the Tait-Bryan angles or
Cardan angles.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal"><span class="pre">this</span></code> joint stored in the <code class="docutils literal"><span class="pre">context</span></code>
ordered as θr, θp, θy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves from <code class="docutils literal"><span class="pre">context</span></code> the angular velocity <code class="docutils literal"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float], angles: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal"><span class="pre">context</span></code> ordered
as θr, θp, θy. See get_angles() for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float], w_FM: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets in <code class="docutils literal"><span class="pre">context</span></code> the state for <code class="docutils literal"><span class="pre">this</span></code> joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal"><span class="pre">w_FM</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], angles: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See get_angles() for details on the angle
representation.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.Body">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Body</code><a class="headerlink" href="#pydrake.multibody.tree.Body" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.Body_[float]" title="pydrake.multibody.tree.Body_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Body_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.Body_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Body_</code><a class="headerlink" href="#pydrake.multibody.tree.Body_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.Body_[float]" title="pydrake.multibody.tree.Body_[float]"><code class="xref py py-class docutils literal"><span class="pre">Body_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.Body_[AutoDiffXd]" title="pydrake.multibody.tree.Body_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">Body_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.Body_[Expression]" title="pydrake.multibody.tree.Body_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">Body_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.Body_.Body_[float]">
<em class="property">class </em><code class="descname">Body_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Body provides the general abstraction of a body with an API that
makes no assumption about whether a body is rigid or deformable and
neither does it make any assumptions about the underlying physical
model or approximation. As an element or component of a MultibodyTree,
a body is a MultibodyElement, and therefore it has a unique index of
type BodyIndex within the multibody tree it belongs to.</p>
<p>A Body contains a unique BodyFrame; see BodyFrame class documentation
for more information.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Body_.Body_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].AddInForce">
<code class="descname">AddInForce</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float], p_BP_E: numpy.ndarray[numpy.float64[3, 1]], F_Bp_E: pydrake.multibody.math.SpatialForce_[float], frame_E: pydrake.multibody.tree.Frame_[float], forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].AddInForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal"><span class="pre">this</span></code> body B, applied at point P and
expressed in a frame E into <code class="docutils literal"><span class="pre">forces</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the current state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BP_E</span></code>:</dt>
<dd>The position of point P in B, expressed in a frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">F_Bp_E</span></code>:</dt>
<dd>The spatial force to be applied on body B at point P, expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The expressed-in frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">forces</span></code>:</dt>
<dd>A multibody forces objects that on output will have <code class="docutils literal"><span class="pre">F_Bp_E</span></code>
added.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">forces</span></code> is nullptr or if it is not consistent</li>
<li>with the model to which <code class="docutils literal"><span class="pre">this</span></code> body belongs.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].AddInForceInWorld">
<code class="descname">AddInForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float], F_Bo_W: pydrake.multibody.math.SpatialForce_[float], forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].AddInForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal"><span class="pre">this</span></code> body B, applied at body B’s origin
Bo and expressed in the world frame W into <code class="docutils literal"><span class="pre">forces</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].body_frame">
<code class="descname">body_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyFrame_[float]<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].body_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the associated BodyFrame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].GetForceInWorld">
<code class="descname">GetForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float], forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].GetForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the sptatial force on <code class="docutils literal"><span class="pre">this</span></code> body B from <code class="docutils literal"><span class="pre">forces</span></code> as F_BBo_W:
applied at body B’s origin Bo and expressed in world world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].is_floating">
<code class="descname">is_floating</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].is_floating" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> body is granted 6-dofs by a
Mobilizer.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A floating body is not necessarily modeled with a quaternion
mobilizer, see has_quaternion_dofs(). Alternative options include
a space XYZ parametrization of rotations, see SpaceXYZMobilizer.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the <code class="docutils literal"><span class="pre">name</span></code> associated with <code class="docutils literal"><span class="pre">this</span></code> body.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Body_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Body provides the general abstraction of a body with an API that
makes no assumption about whether a body is rigid or deformable and
neither does it make any assumptions about the underlying physical
model or approximation. As an element or component of a MultibodyTree,
a body is a MultibodyElement, and therefore it has a unique index of
type BodyIndex within the multibody tree it belongs to.</p>
<p>A Body contains a unique BodyFrame; see BodyFrame class documentation
for more information.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].AddInForce">
<code class="descname">AddInForce</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], p_BP_E: numpy.ndarray[object[3, 1]], F_Bp_E: pydrake.multibody.math.SpatialForce_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd], forces: drake::multibody::MultibodyForces&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].AddInForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal"><span class="pre">this</span></code> body B, applied at point P and
expressed in a frame E into <code class="docutils literal"><span class="pre">forces</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the current state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BP_E</span></code>:</dt>
<dd>The position of point P in B, expressed in a frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">F_Bp_E</span></code>:</dt>
<dd>The spatial force to be applied on body B at point P, expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The expressed-in frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">forces</span></code>:</dt>
<dd>A multibody forces objects that on output will have <code class="docutils literal"><span class="pre">F_Bp_E</span></code>
added.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">forces</span></code> is nullptr or if it is not consistent</li>
<li>with the model to which <code class="docutils literal"><span class="pre">this</span></code> body belongs.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].AddInForceInWorld">
<code class="descname">AddInForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], F_Bo_W: pydrake.multibody.math.SpatialForce_[AutoDiffXd], forces: drake::multibody::MultibodyForces&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].AddInForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal"><span class="pre">this</span></code> body B, applied at body B’s origin
Bo and expressed in the world frame W into <code class="docutils literal"><span class="pre">forces</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].body_frame">
<code class="descname">body_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyFrame_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].body_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the associated BodyFrame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].GetForceInWorld">
<code class="descname">GetForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], forces: drake::multibody::MultibodyForces&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].GetForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the sptatial force on <code class="docutils literal"><span class="pre">this</span></code> body B from <code class="docutils literal"><span class="pre">forces</span></code> as F_BBo_W:
applied at body B’s origin Bo and expressed in world world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].is_floating">
<code class="descname">is_floating</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].is_floating" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> body is granted 6-dofs by a
Mobilizer.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A floating body is not necessarily modeled with a quaternion
mobilizer, see has_quaternion_dofs(). Alternative options include
a space XYZ parametrization of rotations, see SpaceXYZMobilizer.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the <code class="docutils literal"><span class="pre">name</span></code> associated with <code class="docutils literal"><span class="pre">this</span></code> body.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Body_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Body_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Body provides the general abstraction of a body with an API that
makes no assumption about whether a body is rigid or deformable and
neither does it make any assumptions about the underlying physical
model or approximation. As an element or component of a MultibodyTree,
a body is a MultibodyElement, and therefore it has a unique index of
type BodyIndex within the multibody tree it belongs to.</p>
<p>A Body contains a unique BodyFrame; see BodyFrame class documentation
for more information.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Body_[Expression].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].AddInForce">
<code class="descname">AddInForce</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], context: pydrake.systems.framework.Context_[Expression], p_BP_E: numpy.ndarray[object[3, 1]], F_Bp_E: pydrake.multibody.math.SpatialForce_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression], forces: drake::multibody::MultibodyForces&lt;drake::symbolic::Expression&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].AddInForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal"><span class="pre">this</span></code> body B, applied at point P and
expressed in a frame E into <code class="docutils literal"><span class="pre">forces</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the current state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BP_E</span></code>:</dt>
<dd>The position of point P in B, expressed in a frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">F_Bp_E</span></code>:</dt>
<dd>The spatial force to be applied on body B at point P, expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The expressed-in frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">forces</span></code>:</dt>
<dd>A multibody forces objects that on output will have <code class="docutils literal"><span class="pre">F_Bp_E</span></code>
added.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">forces</span></code> is nullptr or if it is not consistent</li>
<li>with the model to which <code class="docutils literal"><span class="pre">this</span></code> body belongs.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].AddInForceInWorld">
<code class="descname">AddInForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], context: pydrake.systems.framework.Context_[Expression], F_Bo_W: pydrake.multibody.math.SpatialForce_[Expression], forces: drake::multibody::MultibodyForces&lt;drake::symbolic::Expression&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].AddInForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal"><span class="pre">this</span></code> body B, applied at body B’s origin
Bo and expressed in the world frame W into <code class="docutils literal"><span class="pre">forces</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].body_frame">
<code class="descname">body_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyFrame_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].body_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the associated BodyFrame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].GetForceInWorld">
<code class="descname">GetForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], context: pydrake.systems.framework.Context_[Expression], forces: drake::multibody::MultibodyForces&lt;drake::symbolic::Expression&gt;</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].GetForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the sptatial force on <code class="docutils literal"><span class="pre">this</span></code> body B from <code class="docutils literal"><span class="pre">forces</span></code> as F_BBo_W:
applied at body B’s origin Bo and expressed in world world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].is_floating">
<code class="descname">is_floating</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].is_floating" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> body is granted 6-dofs by a
Mobilizer.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A floating body is not necessarily modeled with a quaternion
mobilizer, see has_quaternion_dofs(). Alternative options include
a space XYZ parametrization of rotations, see SpaceXYZMobilizer.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the <code class="docutils literal"><span class="pre">name</span></code> associated with <code class="docutils literal"><span class="pre">this</span></code> body.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Body_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Body_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.Body_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Body provides the general abstraction of a body with an API that
makes no assumption about whether a body is rigid or deformable and
neither does it make any assumptions about the underlying physical
model or approximation. As an element or component of a MultibodyTree,
a body is a MultibodyElement, and therefore it has a unique index of
type BodyIndex within the multibody tree it belongs to.</p>
<p>A Body contains a unique BodyFrame; see BodyFrame class documentation
for more information.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Body_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Body_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].AddInForce">
<code class="descname">AddInForce</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float], p_BP_E: numpy.ndarray[numpy.float64[3, 1]], F_Bp_E: pydrake.multibody.math.SpatialForce_[float], frame_E: pydrake.multibody.tree.Frame_[float], forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].AddInForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal"><span class="pre">this</span></code> body B, applied at point P and
expressed in a frame E into <code class="docutils literal"><span class="pre">forces</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the current state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BP_E</span></code>:</dt>
<dd>The position of point P in B, expressed in a frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">F_Bp_E</span></code>:</dt>
<dd>The spatial force to be applied on body B at point P, expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The expressed-in frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">forces</span></code>:</dt>
<dd>A multibody forces objects that on output will have <code class="docutils literal"><span class="pre">F_Bp_E</span></code>
added.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">forces</span></code> is nullptr or if it is not consistent</li>
<li>with the model to which <code class="docutils literal"><span class="pre">this</span></code> body belongs.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].AddInForceInWorld">
<code class="descname">AddInForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float], F_Bo_W: pydrake.multibody.math.SpatialForce_[float], forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].AddInForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal"><span class="pre">this</span></code> body B, applied at body B’s origin
Bo and expressed in the world frame W into <code class="docutils literal"><span class="pre">forces</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].body_frame">
<code class="descname">body_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyFrame_[float]<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].body_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the associated BodyFrame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].GetForceInWorld">
<code class="descname">GetForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float], forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].GetForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the sptatial force on <code class="docutils literal"><span class="pre">this</span></code> body B from <code class="docutils literal"><span class="pre">forces</span></code> as F_BBo_W:
applied at body B’s origin Bo and expressed in world world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].is_floating">
<code class="descname">is_floating</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].is_floating" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> body is granted 6-dofs by a
Mobilizer.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A floating body is not necessarily modeled with a quaternion
mobilizer, see has_quaternion_dofs(). Alternative options include
a space XYZ parametrization of rotations, see SpaceXYZMobilizer.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the <code class="docutils literal"><span class="pre">name</span></code> associated with <code class="docutils literal"><span class="pre">this</span></code> body.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.BodyFrame">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BodyFrame</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.BodyFrame_[float]" title="pydrake.multibody.tree.BodyFrame_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.BodyFrame_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.BodyFrame_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BodyFrame_</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.BodyFrame_[float]" title="pydrake.multibody.tree.BodyFrame_[float]"><code class="xref py py-class docutils literal"><span class="pre">BodyFrame_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.BodyFrame_[AutoDiffXd]" title="pydrake.multibody.tree.BodyFrame_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">BodyFrame_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.BodyFrame_[Expression]" title="pydrake.multibody.tree.BodyFrame_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">BodyFrame_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.BodyFrame_.BodyFrame_[float]">
<em class="property">class </em><code class="descname">BodyFrame_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_.BodyFrame_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[float]" title="pydrake.multibody.tree.Frame_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Frame_[float]</span></code></a></p>
<p>A BodyFrame is a material Frame that serves as the unique reference
frame for a Body.</p>
<p>Each Body B, regardless of whether it represents a rigid body or a
flexible body, has a unique body frame for which we use the same
symbol B (with meaning clear from context). The body frame is also
referred to as a <em>reference frame</em> in the literature for flexible body
mechanics modeling using the Finite Element Method. All properties of
a body are defined with respect to its body frame, including its mass
properties and attachment locations for joints, constraints,
actuators, geometry and so on. Run time motion of the body is defined
with respect to the motion of its body frame. We represent a body
frame by a BodyFrame object that is created whenever a Body is
constructed and is owned by the Body.</p>
<p>Note that the BodyFrame associated with a body does not necessarily
need to be located at its center of mass nor does it need to be
aligned with the body’s principal axes, although, in practice, it
frequently is. For flexible bodies, BodyFrame provides a
representation for the body’s reference frame. The flexible degrees of
freedom associated with a flexible body describe the body’s
deformation in this frame. Therefore, the motion of a flexible body is
defined by the motion of its BodyFrame, or reference frame, plus the
motion of the material points on the body with respect to its
BodyFrame.</p>
<p>A BodyFrame and Body are tightly coupled concepts; neither makes sense
without the other. Therefore, a BodyFrame instance is constructed in
conjunction with its Body and cannot be constructed anywhere else.
However, you can still access the frame associated with a body, see
Body::body_frame(). This access is more than a convenience; you can
use the BodyFrame to define other frames on the body and to attach
other multibody elements to it.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.BodyFrame_.BodyFrame_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_.BodyFrame_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.BodyFrame_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BodyFrame_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[AutoDiffXd]" title="pydrake.multibody.tree.Frame_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd]</span></code></a></p>
<p>A BodyFrame is a material Frame that serves as the unique reference
frame for a Body.</p>
<p>Each Body B, regardless of whether it represents a rigid body or a
flexible body, has a unique body frame for which we use the same
symbol B (with meaning clear from context). The body frame is also
referred to as a <em>reference frame</em> in the literature for flexible body
mechanics modeling using the Finite Element Method. All properties of
a body are defined with respect to its body frame, including its mass
properties and attachment locations for joints, constraints,
actuators, geometry and so on. Run time motion of the body is defined
with respect to the motion of its body frame. We represent a body
frame by a BodyFrame object that is created whenever a Body is
constructed and is owned by the Body.</p>
<p>Note that the BodyFrame associated with a body does not necessarily
need to be located at its center of mass nor does it need to be
aligned with the body’s principal axes, although, in practice, it
frequently is. For flexible bodies, BodyFrame provides a
representation for the body’s reference frame. The flexible degrees of
freedom associated with a flexible body describe the body’s
deformation in this frame. Therefore, the motion of a flexible body is
defined by the motion of its BodyFrame, or reference frame, plus the
motion of the material points on the body with respect to its
BodyFrame.</p>
<p>A BodyFrame and Body are tightly coupled concepts; neither makes sense
without the other. Therefore, a BodyFrame instance is constructed in
conjunction with its Body and cannot be constructed anywhere else.
However, you can still access the frame associated with a body, see
Body::body_frame(). This access is more than a convenience; you can
use the BodyFrame to define other frames on the body and to attach
other multibody elements to it.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.BodyFrame_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.BodyFrame_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BodyFrame_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[Expression]" title="pydrake.multibody.tree.Frame_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Frame_[Expression]</span></code></a></p>
<p>A BodyFrame is a material Frame that serves as the unique reference
frame for a Body.</p>
<p>Each Body B, regardless of whether it represents a rigid body or a
flexible body, has a unique body frame for which we use the same
symbol B (with meaning clear from context). The body frame is also
referred to as a <em>reference frame</em> in the literature for flexible body
mechanics modeling using the Finite Element Method. All properties of
a body are defined with respect to its body frame, including its mass
properties and attachment locations for joints, constraints,
actuators, geometry and so on. Run time motion of the body is defined
with respect to the motion of its body frame. We represent a body
frame by a BodyFrame object that is created whenever a Body is
constructed and is owned by the Body.</p>
<p>Note that the BodyFrame associated with a body does not necessarily
need to be located at its center of mass nor does it need to be
aligned with the body’s principal axes, although, in practice, it
frequently is. For flexible bodies, BodyFrame provides a
representation for the body’s reference frame. The flexible degrees of
freedom associated with a flexible body describe the body’s
deformation in this frame. Therefore, the motion of a flexible body is
defined by the motion of its BodyFrame, or reference frame, plus the
motion of the material points on the body with respect to its
BodyFrame.</p>
<p>A BodyFrame and Body are tightly coupled concepts; neither makes sense
without the other. Therefore, a BodyFrame instance is constructed in
conjunction with its Body and cannot be constructed anywhere else.
However, you can still access the frame associated with a body, see
Body::body_frame(). This access is more than a convenience; you can
use the BodyFrame to define other frames on the body and to attach
other multibody elements to it.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.BodyFrame_[Expression].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.BodyFrame_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BodyFrame_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[float]" title="pydrake.multibody.tree.Frame_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Frame_[float]</span></code></a></p>
<p>A BodyFrame is a material Frame that serves as the unique reference
frame for a Body.</p>
<p>Each Body B, regardless of whether it represents a rigid body or a
flexible body, has a unique body frame for which we use the same
symbol B (with meaning clear from context). The body frame is also
referred to as a <em>reference frame</em> in the literature for flexible body
mechanics modeling using the Finite Element Method. All properties of
a body are defined with respect to its body frame, including its mass
properties and attachment locations for joints, constraints,
actuators, geometry and so on. Run time motion of the body is defined
with respect to the motion of its body frame. We represent a body
frame by a BodyFrame object that is created whenever a Body is
constructed and is owned by the Body.</p>
<p>Note that the BodyFrame associated with a body does not necessarily
need to be located at its center of mass nor does it need to be
aligned with the body’s principal axes, although, in practice, it
frequently is. For flexible bodies, BodyFrame provides a
representation for the body’s reference frame. The flexible degrees of
freedom associated with a flexible body describe the body’s
deformation in this frame. Therefore, the motion of a flexible body is
defined by the motion of its BodyFrame, or reference frame, plus the
motion of the material points on the body with respect to its
BodyFrame.</p>
<p>A BodyFrame and Body are tightly coupled concepts; neither makes sense
without the other. Therefore, a BodyFrame instance is constructed in
conjunction with its Body and cannot be constructed anywhere else.
However, you can still access the frame associated with a body, see
Body::body_frame(). This access is more than a convenience; you can
use the BodyFrame to define other frames on the body and to attach
other multibody elements to it.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.BodyFrame_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.BodyIndex">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BodyIndex</code><a class="headerlink" href="#pydrake.multibody.tree.BodyIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify bodies by index in a multibody tree system.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.BodyIndex.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BodyIndex</em>, <em>arg0: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BodyIndex.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BodyIndex.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BodyIndex</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.BodyIndex.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.multibody.tree.default_model_instance">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">default_model_instance</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.default_model_instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the model instance which contains all tree elements with no
explicit model instance specified.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHinge">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">DoorHinge</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHinge" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.DoorHinge_[float]" title="pydrake.multibody.tree.DoorHinge_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.DoorHinge_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.DoorHinge_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">DoorHinge_</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.DoorHinge_[float]" title="pydrake.multibody.tree.DoorHinge_[float]"><code class="xref py py-class docutils literal"><span class="pre">DoorHinge_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd]" title="pydrake.multibody.tree.DoorHinge_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">DoorHinge_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.DoorHinge_[Expression]" title="pydrake.multibody.tree.DoorHinge_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">DoorHinge_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.DoorHinge_.DoorHinge_[float]">
<em class="property">class </em><code class="descname">DoorHinge_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_.DoorHinge_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement models a revolute DoorHinge joint that could exhibit
different force/torque characteristics at different states due to the
existence of different type of torques on the joint. This class
implements a “christmas tree” accumulation of these different torques
in an empirical and unprincipled way. Specifically, different curves
are assigned to different torques to mimic their evolution based on
the joint state and some prespecified parameters.</p>
<p>Torques considered in this implementation include: * torsional spring
torque (τ_ts) – position dependent * catch torque (τ_c) – position
dependent * dynamic friction torque (τ_df) – velocity dependent *
static friction torque (τ_sf) – velocity dependent * viscous friction
torque (τ_vf) – velocity dependent</p>
<p>We then implement two curves to approximate the progression of
different torques. A curve <code class="docutils literal"><span class="pre">s(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">tanh(x/t)</span></code> uses the <code class="docutils literal"><span class="pre">tanh</span></code>
function to approximate a step curve ({<cite>x&lt;0</cite>: -1 ; <code class="docutils literal"><span class="pre">x&gt;0</span></code>: 1})
outside of <code class="docutils literal"><span class="pre">-t</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">t</span></code>. The curve <code class="docutils literal"><span class="pre">doublet(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">s</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">−</span>
<span class="pre">s²)</span></code> is the second derivative of <code class="docutils literal"><span class="pre">s</span></code> scaled by <code class="docutils literal"><span class="pre">-t²</span></code>, which
yields a lump at negative <code class="docutils literal"><span class="pre">x</span></code> that integrates to -1 and a lump at
positive <code class="docutils literal"><span class="pre">x</span></code> that integrates to 1. Finally, the total external
torque on the hinge joint would be:</p>
<p><code class="docutils literal"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">τ_ts</span> <span class="pre">+</span> <span class="pre">τ_c</span> <span class="pre">+</span> <span class="pre">τ_df</span> <span class="pre">+</span> <span class="pre">τ_sf</span> <span class="pre">+</span> <span class="pre">τ_vf</span></code>.</p>
<p>where <code class="docutils literal"><span class="pre">τ_ts</span> <span class="pre">=</span> <span class="pre">-k_ts</span> <span class="pre">*</span> <span class="pre">(q</span> <span class="pre">−</span> <span class="pre">qs₀)</span></code>, <cite>τ_c = k_c * doublet(qc₀/2, q −
qc₀/2)`</cite>, <cite>τ_df = -k_df * s(k_q̇₀, q̇)`</cite>, <cite>τ_sf = -k_sf *
doublet(k_q̇₀, q̇)</cite> and <code class="docutils literal"><span class="pre">τ_vf</span> <span class="pre">=</span> <span class="pre">-k_vf</span> <span class="pre">*</span> <span class="pre">q̇</span></code>. The door is assumed to
be closed at <code class="docutils literal"><span class="pre">q=0</span></code>, opening in the positive-q direction. Note that,
the sign of the torques depends on two elements: one is the sign of
the torque related constants and another one is the sign of the
assigned curves. For example, as defined above, the static friction
torque <code class="docutils literal"><span class="pre">τ_sf</span></code> should be opposite to the direction of the velocity
q̇. The catch torque <code class="docutils literal"><span class="pre">τ_c</span></code> should be negative when <code class="docutils literal"><span class="pre">q</span> <span class="pre">&lt;</span> <span class="pre">qc₀/2</span></code> and
positive otherwise. This class applies all hinge-originating forces,
so it can be used instead of the SDF viscous damping. The users could
change the values of these different elements to obtain different
characteristics for the DoorHinge joint that the users want to model.
A jupyter notebook tool is also provided to help the users visualize
the curves and design parameters. Run <code class="docutils literal"><span class="pre">bazel</span> <span class="pre">run</span>
<span class="pre">//bindings/pydrake/multibody:examples/door_hinge_inspector</span></code> to bring
up the notebook.</p>
<p><strong>To give an example</strong>, a common dishwasher door has a frictional
torque sufficient for it to rest motionless at any angle, a catch at
the top to hold it in place, a dashpot (viscous friction source) to
prevent it from swinging too fast, and a spring to counteract some of
its mass. Two figures are provided to illustrate the dishwasher
DoorHinge torque with the given default parameters. Figure 1 shows the
static characteristic of the dishwasher door. At q = 0, there exists a
negative catch torque to prevent the door from moving. After that, the
torsional spring torque will dominate to compensate part of the door
gravity. Figure 2 shows the dynamic feature of the dishwasher door at
q = 30 deg. It shows the door can be closed easily since the torque is
small when the velocity is negative. However, whenever the door
intends to open further, there will be a counter torque to prevent
that movement, which therefore keeps the door at rest. Note that, due
to the gravity, the dishwasher door will be fully open eventually.
This process can be really slow because of the default
<code class="docutils literal"><span class="pre">motion_threshold</span></code> is set to be very small. You can change the
<code class="docutils literal"><span class="pre">motion_threshold</span></code> parameter to adjust the time. &#64;image html
multibody/tree/images/torque_vs_angle.svg “Figure 1” &#64;image html
multibody/tree/images/torque_vs_velocity.svg “Figure 2”</p>
<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], joint: pydrake.multibody.tree.RevoluteJoint_[float], config: pydrake.multibody.tree.DoorHingeConfig</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a hinge force element with parameters <code class="docutils literal"><span class="pre">config</span></code> applied to
the specified <code class="docutils literal"><span class="pre">joint</span></code>. It will throw an exception if the
DoorHingeConfig is invalid.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].CalcHingeFrictionalTorque">
<code class="descname">CalcHingeFrictionalTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], angular_rate: float</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].CalcHingeFrictionalTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the total frictional torque with the given <code class="docutils literal"><span class="pre">angular_rate</span></code>
and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].CalcHingeSpringTorque">
<code class="descname">CalcHingeSpringTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], angle: float</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].CalcHingeSpringTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total spring related torque with the given <code class="docutils literal"><span class="pre">angle</span></code> and
the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].CalcHingeTorque">
<code class="descname">CalcHingeTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], angle: float, angular_rate: float</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].CalcHingeTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total torque with the given <code class="docutils literal"><span class="pre">angle</span></code> and
<code class="docutils literal"><span class="pre">angular_rate</span></code> and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].config">
<code class="descname">config</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.DoorHingeConfig<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.DoorHinge_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">DoorHinge_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd]" title="pydrake.multibody.tree.ForceElement_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd]</span></code></a></p>
<p>This ForceElement models a revolute DoorHinge joint that could exhibit
different force/torque characteristics at different states due to the
existence of different type of torques on the joint. This class
implements a “christmas tree” accumulation of these different torques
in an empirical and unprincipled way. Specifically, different curves
are assigned to different torques to mimic their evolution based on
the joint state and some prespecified parameters.</p>
<p>Torques considered in this implementation include: * torsional spring
torque (τ_ts) – position dependent * catch torque (τ_c) – position
dependent * dynamic friction torque (τ_df) – velocity dependent *
static friction torque (τ_sf) – velocity dependent * viscous friction
torque (τ_vf) – velocity dependent</p>
<p>We then implement two curves to approximate the progression of
different torques. A curve <code class="docutils literal"><span class="pre">s(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">tanh(x/t)</span></code> uses the <code class="docutils literal"><span class="pre">tanh</span></code>
function to approximate a step curve ({<cite>x&lt;0</cite>: -1 ; <code class="docutils literal"><span class="pre">x&gt;0</span></code>: 1})
outside of <code class="docutils literal"><span class="pre">-t</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">t</span></code>. The curve <code class="docutils literal"><span class="pre">doublet(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">s</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">−</span>
<span class="pre">s²)</span></code> is the second derivative of <code class="docutils literal"><span class="pre">s</span></code> scaled by <code class="docutils literal"><span class="pre">-t²</span></code>, which
yields a lump at negative <code class="docutils literal"><span class="pre">x</span></code> that integrates to -1 and a lump at
positive <code class="docutils literal"><span class="pre">x</span></code> that integrates to 1. Finally, the total external
torque on the hinge joint would be:</p>
<p><code class="docutils literal"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">τ_ts</span> <span class="pre">+</span> <span class="pre">τ_c</span> <span class="pre">+</span> <span class="pre">τ_df</span> <span class="pre">+</span> <span class="pre">τ_sf</span> <span class="pre">+</span> <span class="pre">τ_vf</span></code>.</p>
<p>where <code class="docutils literal"><span class="pre">τ_ts</span> <span class="pre">=</span> <span class="pre">-k_ts</span> <span class="pre">*</span> <span class="pre">(q</span> <span class="pre">−</span> <span class="pre">qs₀)</span></code>, <cite>τ_c = k_c * doublet(qc₀/2, q −
qc₀/2)`</cite>, <cite>τ_df = -k_df * s(k_q̇₀, q̇)`</cite>, <cite>τ_sf = -k_sf *
doublet(k_q̇₀, q̇)</cite> and <code class="docutils literal"><span class="pre">τ_vf</span> <span class="pre">=</span> <span class="pre">-k_vf</span> <span class="pre">*</span> <span class="pre">q̇</span></code>. The door is assumed to
be closed at <code class="docutils literal"><span class="pre">q=0</span></code>, opening in the positive-q direction. Note that,
the sign of the torques depends on two elements: one is the sign of
the torque related constants and another one is the sign of the
assigned curves. For example, as defined above, the static friction
torque <code class="docutils literal"><span class="pre">τ_sf</span></code> should be opposite to the direction of the velocity
q̇. The catch torque <code class="docutils literal"><span class="pre">τ_c</span></code> should be negative when <code class="docutils literal"><span class="pre">q</span> <span class="pre">&lt;</span> <span class="pre">qc₀/2</span></code> and
positive otherwise. This class applies all hinge-originating forces,
so it can be used instead of the SDF viscous damping. The users could
change the values of these different elements to obtain different
characteristics for the DoorHinge joint that the users want to model.
A jupyter notebook tool is also provided to help the users visualize
the curves and design parameters. Run <code class="docutils literal"><span class="pre">bazel</span> <span class="pre">run</span>
<span class="pre">//bindings/pydrake/multibody:examples/door_hinge_inspector</span></code> to bring
up the notebook.</p>
<p><strong>To give an example</strong>, a common dishwasher door has a frictional
torque sufficient for it to rest motionless at any angle, a catch at
the top to hold it in place, a dashpot (viscous friction source) to
prevent it from swinging too fast, and a spring to counteract some of
its mass. Two figures are provided to illustrate the dishwasher
DoorHinge torque with the given default parameters. Figure 1 shows the
static characteristic of the dishwasher door. At q = 0, there exists a
negative catch torque to prevent the door from moving. After that, the
torsional spring torque will dominate to compensate part of the door
gravity. Figure 2 shows the dynamic feature of the dishwasher door at
q = 30 deg. It shows the door can be closed easily since the torque is
small when the velocity is negative. However, whenever the door
intends to open further, there will be a counter torque to prevent
that movement, which therefore keeps the door at rest. Note that, due
to the gravity, the dishwasher door will be fully open eventually.
This process can be really slow because of the default
<code class="docutils literal"><span class="pre">motion_threshold</span></code> is set to be very small. You can change the
<code class="docutils literal"><span class="pre">motion_threshold</span></code> parameter to adjust the time. &#64;image html
multibody/tree/images/torque_vs_angle.svg “Figure 1” &#64;image html
multibody/tree/images/torque_vs_velocity.svg “Figure 2”</p>
<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[AutoDiffXd], joint: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], config: pydrake.multibody.tree.DoorHingeConfig</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a hinge force element with parameters <code class="docutils literal"><span class="pre">config</span></code> applied to
the specified <code class="docutils literal"><span class="pre">joint</span></code>. It will throw an exception if the
DoorHingeConfig is invalid.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[AutoDiffXd].CalcHingeFrictionalTorque">
<code class="descname">CalcHingeFrictionalTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[AutoDiffXd], angular_rate: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd].CalcHingeFrictionalTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the total frictional torque with the given <code class="docutils literal"><span class="pre">angular_rate</span></code>
and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[AutoDiffXd].CalcHingeSpringTorque">
<code class="descname">CalcHingeSpringTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[AutoDiffXd], angle: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd].CalcHingeSpringTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total spring related torque with the given <code class="docutils literal"><span class="pre">angle</span></code> and
the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[AutoDiffXd].CalcHingeTorque">
<code class="descname">CalcHingeTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[AutoDiffXd], angle: pydrake.autodiffutils.AutoDiffXd, angular_rate: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd].CalcHingeTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total torque with the given <code class="docutils literal"><span class="pre">angle</span></code> and
<code class="docutils literal"><span class="pre">angular_rate</span></code> and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[AutoDiffXd].config">
<code class="descname">config</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.DoorHingeConfig<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd].config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[AutoDiffXd].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.DoorHinge_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">DoorHinge_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[Expression]" title="pydrake.multibody.tree.ForceElement_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[Expression]</span></code></a></p>
<p>This ForceElement models a revolute DoorHinge joint that could exhibit
different force/torque characteristics at different states due to the
existence of different type of torques on the joint. This class
implements a “christmas tree” accumulation of these different torques
in an empirical and unprincipled way. Specifically, different curves
are assigned to different torques to mimic their evolution based on
the joint state and some prespecified parameters.</p>
<p>Torques considered in this implementation include: * torsional spring
torque (τ_ts) – position dependent * catch torque (τ_c) – position
dependent * dynamic friction torque (τ_df) – velocity dependent *
static friction torque (τ_sf) – velocity dependent * viscous friction
torque (τ_vf) – velocity dependent</p>
<p>We then implement two curves to approximate the progression of
different torques. A curve <code class="docutils literal"><span class="pre">s(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">tanh(x/t)</span></code> uses the <code class="docutils literal"><span class="pre">tanh</span></code>
function to approximate a step curve ({<cite>x&lt;0</cite>: -1 ; <code class="docutils literal"><span class="pre">x&gt;0</span></code>: 1})
outside of <code class="docutils literal"><span class="pre">-t</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">t</span></code>. The curve <code class="docutils literal"><span class="pre">doublet(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">s</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">−</span>
<span class="pre">s²)</span></code> is the second derivative of <code class="docutils literal"><span class="pre">s</span></code> scaled by <code class="docutils literal"><span class="pre">-t²</span></code>, which
yields a lump at negative <code class="docutils literal"><span class="pre">x</span></code> that integrates to -1 and a lump at
positive <code class="docutils literal"><span class="pre">x</span></code> that integrates to 1. Finally, the total external
torque on the hinge joint would be:</p>
<p><code class="docutils literal"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">τ_ts</span> <span class="pre">+</span> <span class="pre">τ_c</span> <span class="pre">+</span> <span class="pre">τ_df</span> <span class="pre">+</span> <span class="pre">τ_sf</span> <span class="pre">+</span> <span class="pre">τ_vf</span></code>.</p>
<p>where <code class="docutils literal"><span class="pre">τ_ts</span> <span class="pre">=</span> <span class="pre">-k_ts</span> <span class="pre">*</span> <span class="pre">(q</span> <span class="pre">−</span> <span class="pre">qs₀)</span></code>, <cite>τ_c = k_c * doublet(qc₀/2, q −
qc₀/2)`</cite>, <cite>τ_df = -k_df * s(k_q̇₀, q̇)`</cite>, <cite>τ_sf = -k_sf *
doublet(k_q̇₀, q̇)</cite> and <code class="docutils literal"><span class="pre">τ_vf</span> <span class="pre">=</span> <span class="pre">-k_vf</span> <span class="pre">*</span> <span class="pre">q̇</span></code>. The door is assumed to
be closed at <code class="docutils literal"><span class="pre">q=0</span></code>, opening in the positive-q direction. Note that,
the sign of the torques depends on two elements: one is the sign of
the torque related constants and another one is the sign of the
assigned curves. For example, as defined above, the static friction
torque <code class="docutils literal"><span class="pre">τ_sf</span></code> should be opposite to the direction of the velocity
q̇. The catch torque <code class="docutils literal"><span class="pre">τ_c</span></code> should be negative when <code class="docutils literal"><span class="pre">q</span> <span class="pre">&lt;</span> <span class="pre">qc₀/2</span></code> and
positive otherwise. This class applies all hinge-originating forces,
so it can be used instead of the SDF viscous damping. The users could
change the values of these different elements to obtain different
characteristics for the DoorHinge joint that the users want to model.
A jupyter notebook tool is also provided to help the users visualize
the curves and design parameters. Run <code class="docutils literal"><span class="pre">bazel</span> <span class="pre">run</span>
<span class="pre">//bindings/pydrake/multibody:examples/door_hinge_inspector</span></code> to bring
up the notebook.</p>
<p><strong>To give an example</strong>, a common dishwasher door has a frictional
torque sufficient for it to rest motionless at any angle, a catch at
the top to hold it in place, a dashpot (viscous friction source) to
prevent it from swinging too fast, and a spring to counteract some of
its mass. Two figures are provided to illustrate the dishwasher
DoorHinge torque with the given default parameters. Figure 1 shows the
static characteristic of the dishwasher door. At q = 0, there exists a
negative catch torque to prevent the door from moving. After that, the
torsional spring torque will dominate to compensate part of the door
gravity. Figure 2 shows the dynamic feature of the dishwasher door at
q = 30 deg. It shows the door can be closed easily since the torque is
small when the velocity is negative. However, whenever the door
intends to open further, there will be a counter torque to prevent
that movement, which therefore keeps the door at rest. Note that, due
to the gravity, the dishwasher door will be fully open eventually.
This process can be really slow because of the default
<code class="docutils literal"><span class="pre">motion_threshold</span></code> is set to be very small. You can change the
<code class="docutils literal"><span class="pre">motion_threshold</span></code> parameter to adjust the time. &#64;image html
multibody/tree/images/torque_vs_angle.svg “Figure 1” &#64;image html
multibody/tree/images/torque_vs_velocity.svg “Figure 2”</p>
<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[Expression], joint: pydrake.multibody.tree.RevoluteJoint_[Expression], config: pydrake.multibody.tree.DoorHingeConfig</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a hinge force element with parameters <code class="docutils literal"><span class="pre">config</span></code> applied to
the specified <code class="docutils literal"><span class="pre">joint</span></code>. It will throw an exception if the
DoorHingeConfig is invalid.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[Expression].CalcHingeFrictionalTorque">
<code class="descname">CalcHingeFrictionalTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[Expression], angular_rate: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[Expression].CalcHingeFrictionalTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the total frictional torque with the given <code class="docutils literal"><span class="pre">angular_rate</span></code>
and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[Expression].CalcHingeSpringTorque">
<code class="descname">CalcHingeSpringTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[Expression], angle: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[Expression].CalcHingeSpringTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total spring related torque with the given <code class="docutils literal"><span class="pre">angle</span></code> and
the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[Expression].CalcHingeTorque">
<code class="descname">CalcHingeTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[Expression], angle: pydrake.symbolic.Expression, angular_rate: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[Expression].CalcHingeTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total torque with the given <code class="docutils literal"><span class="pre">angle</span></code> and
<code class="docutils literal"><span class="pre">angular_rate</span></code> and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[Expression].config">
<code class="descname">config</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.DoorHingeConfig<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[Expression].config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[Expression].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[Expression].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.DoorHinge_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">DoorHinge_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement models a revolute DoorHinge joint that could exhibit
different force/torque characteristics at different states due to the
existence of different type of torques on the joint. This class
implements a “christmas tree” accumulation of these different torques
in an empirical and unprincipled way. Specifically, different curves
are assigned to different torques to mimic their evolution based on
the joint state and some prespecified parameters.</p>
<p>Torques considered in this implementation include: * torsional spring
torque (τ_ts) – position dependent * catch torque (τ_c) – position
dependent * dynamic friction torque (τ_df) – velocity dependent *
static friction torque (τ_sf) – velocity dependent * viscous friction
torque (τ_vf) – velocity dependent</p>
<p>We then implement two curves to approximate the progression of
different torques. A curve <code class="docutils literal"><span class="pre">s(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">tanh(x/t)</span></code> uses the <code class="docutils literal"><span class="pre">tanh</span></code>
function to approximate a step curve ({<cite>x&lt;0</cite>: -1 ; <code class="docutils literal"><span class="pre">x&gt;0</span></code>: 1})
outside of <code class="docutils literal"><span class="pre">-t</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">t</span></code>. The curve <code class="docutils literal"><span class="pre">doublet(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">s</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">−</span>
<span class="pre">s²)</span></code> is the second derivative of <code class="docutils literal"><span class="pre">s</span></code> scaled by <code class="docutils literal"><span class="pre">-t²</span></code>, which
yields a lump at negative <code class="docutils literal"><span class="pre">x</span></code> that integrates to -1 and a lump at
positive <code class="docutils literal"><span class="pre">x</span></code> that integrates to 1. Finally, the total external
torque on the hinge joint would be:</p>
<p><code class="docutils literal"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">τ_ts</span> <span class="pre">+</span> <span class="pre">τ_c</span> <span class="pre">+</span> <span class="pre">τ_df</span> <span class="pre">+</span> <span class="pre">τ_sf</span> <span class="pre">+</span> <span class="pre">τ_vf</span></code>.</p>
<p>where <code class="docutils literal"><span class="pre">τ_ts</span> <span class="pre">=</span> <span class="pre">-k_ts</span> <span class="pre">*</span> <span class="pre">(q</span> <span class="pre">−</span> <span class="pre">qs₀)</span></code>, <cite>τ_c = k_c * doublet(qc₀/2, q −
qc₀/2)`</cite>, <cite>τ_df = -k_df * s(k_q̇₀, q̇)`</cite>, <cite>τ_sf = -k_sf *
doublet(k_q̇₀, q̇)</cite> and <code class="docutils literal"><span class="pre">τ_vf</span> <span class="pre">=</span> <span class="pre">-k_vf</span> <span class="pre">*</span> <span class="pre">q̇</span></code>. The door is assumed to
be closed at <code class="docutils literal"><span class="pre">q=0</span></code>, opening in the positive-q direction. Note that,
the sign of the torques depends on two elements: one is the sign of
the torque related constants and another one is the sign of the
assigned curves. For example, as defined above, the static friction
torque <code class="docutils literal"><span class="pre">τ_sf</span></code> should be opposite to the direction of the velocity
q̇. The catch torque <code class="docutils literal"><span class="pre">τ_c</span></code> should be negative when <code class="docutils literal"><span class="pre">q</span> <span class="pre">&lt;</span> <span class="pre">qc₀/2</span></code> and
positive otherwise. This class applies all hinge-originating forces,
so it can be used instead of the SDF viscous damping. The users could
change the values of these different elements to obtain different
characteristics for the DoorHinge joint that the users want to model.
A jupyter notebook tool is also provided to help the users visualize
the curves and design parameters. Run <code class="docutils literal"><span class="pre">bazel</span> <span class="pre">run</span>
<span class="pre">//bindings/pydrake/multibody:examples/door_hinge_inspector</span></code> to bring
up the notebook.</p>
<p><strong>To give an example</strong>, a common dishwasher door has a frictional
torque sufficient for it to rest motionless at any angle, a catch at
the top to hold it in place, a dashpot (viscous friction source) to
prevent it from swinging too fast, and a spring to counteract some of
its mass. Two figures are provided to illustrate the dishwasher
DoorHinge torque with the given default parameters. Figure 1 shows the
static characteristic of the dishwasher door. At q = 0, there exists a
negative catch torque to prevent the door from moving. After that, the
torsional spring torque will dominate to compensate part of the door
gravity. Figure 2 shows the dynamic feature of the dishwasher door at
q = 30 deg. It shows the door can be closed easily since the torque is
small when the velocity is negative. However, whenever the door
intends to open further, there will be a counter torque to prevent
that movement, which therefore keeps the door at rest. Note that, due
to the gravity, the dishwasher door will be fully open eventually.
This process can be really slow because of the default
<code class="docutils literal"><span class="pre">motion_threshold</span></code> is set to be very small. You can change the
<code class="docutils literal"><span class="pre">motion_threshold</span></code> parameter to adjust the time. &#64;image html
multibody/tree/images/torque_vs_angle.svg “Figure 1” &#64;image html
multibody/tree/images/torque_vs_velocity.svg “Figure 2”</p>
<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], joint: pydrake.multibody.tree.RevoluteJoint_[float], config: pydrake.multibody.tree.DoorHingeConfig</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a hinge force element with parameters <code class="docutils literal"><span class="pre">config</span></code> applied to
the specified <code class="docutils literal"><span class="pre">joint</span></code>. It will throw an exception if the
DoorHingeConfig is invalid.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[float].CalcHingeFrictionalTorque">
<code class="descname">CalcHingeFrictionalTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], angular_rate: float</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[float].CalcHingeFrictionalTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the total frictional torque with the given <code class="docutils literal"><span class="pre">angular_rate</span></code>
and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[float].CalcHingeSpringTorque">
<code class="descname">CalcHingeSpringTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], angle: float</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[float].CalcHingeSpringTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total spring related torque with the given <code class="docutils literal"><span class="pre">angle</span></code> and
the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[float].CalcHingeTorque">
<code class="descname">CalcHingeTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], angle: float, angular_rate: float</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[float].CalcHingeTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total torque with the given <code class="docutils literal"><span class="pre">angle</span></code> and
<code class="docutils literal"><span class="pre">angular_rate</span></code> and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[float].config">
<code class="descname">config</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.DoorHingeConfig<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[float].config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[float].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[float].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.DoorHingeConfig">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">DoorHingeConfig</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration structure for the DoorHinge.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.DoorHingeConfig.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHingeConfig</em>, <em>**kwargs</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize to empirically reasonable values measured approximately by
banging on the door of a dishwasher with a force gauge.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.catch_torque">
<code class="descname">catch_torque</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.catch_torque" title="Permalink to this definition">¶</a></dt>
<dd><p>k_c maximum catch torque applied over <code class="docutils literal"><span class="pre">catch_width</span></code> [Nm]. It should
be non-negative.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.catch_width">
<code class="descname">catch_width</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.catch_width" title="Permalink to this definition">¶</a></dt>
<dd><p>qc₀ measured from closed (q=0) position [radian]. It should be
non-negative.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.dynamic_friction_torque">
<code class="descname">dynamic_friction_torque</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.dynamic_friction_torque" title="Permalink to this definition">¶</a></dt>
<dd><p>k_df maximum dynamic friction torque measured opposite direction of
motion [Nm]. It should be non-negative.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.motion_threshold">
<code class="descname">motion_threshold</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.motion_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>k_q̇₀ motion threshold to start to apply friction torques [rad/s]. It
should be non-negative. Realistic frictional force is very stiff,
reversing entirely over zero change in position or velocity, which
kills integrators. We approximate it with a continuous function. This
constant [rad/s] is the scaling factor on that function – very
approximately the rad/s at which half of the full frictional force is
applied. This number is nonphysical; make it small but not so small
that the simulation vibrates or explodes.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.spring_constant">
<code class="descname">spring_constant</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.spring_constant" title="Permalink to this definition">¶</a></dt>
<dd><p>k_ts torsional spring constant measured toward the spring zero angle
[Nm/rad]. It should be non-negative.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.spring_zero_angle_rad">
<code class="descname">spring_zero_angle_rad</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.spring_zero_angle_rad" title="Permalink to this definition">¶</a></dt>
<dd><p>qs₀ measured outward from the closed position [radian].</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.static_friction_torque">
<code class="descname">static_friction_torque</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.static_friction_torque" title="Permalink to this definition">¶</a></dt>
<dd><p>k_sf maximum static friction measured opposite direction of motion
[Nm]. It should be non-negative.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.viscous_friction">
<code class="descname">viscous_friction</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.viscous_friction" title="Permalink to this definition">¶</a></dt>
<dd><p>k_vf viscous friction measured opposite direction of motion [Nm]. It
should be non-negative.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.FixedOffsetFrame">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">FixedOffsetFrame</code><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.FixedOffsetFrame_[float]" title="pydrake.multibody.tree.FixedOffsetFrame_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.FixedOffsetFrame_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">FixedOffsetFrame_</code><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.FixedOffsetFrame_[float]" title="pydrake.multibody.tree.FixedOffsetFrame_[float]"><code class="xref py py-class docutils literal"><span class="pre">FixedOffsetFrame_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd]" title="pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">FixedOffsetFrame_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.FixedOffsetFrame_[Expression]" title="pydrake.multibody.tree.FixedOffsetFrame_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">FixedOffsetFrame_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_.FixedOffsetFrame_[float]">
<em class="property">class </em><code class="descname">FixedOffsetFrame_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_.FixedOffsetFrame_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[float]" title="pydrake.multibody.tree.Frame_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Frame_[float]</span></code></a></p>
<p>%FixedOffsetFrame represents a material frame F whose pose is fixed
with respect to a <em>parent</em> material frame P. The pose offset is given
by a spatial transform <code class="docutils literal"><span class="pre">X_PF</span></code>, which is constant after construction.
For instance, we could rigidly attach a frame F to move with a rigid
body B at a fixed pose <code class="docutils literal"><span class="pre">X_BF</span></code>, where B is the BodyFrame associated
with body B. Thus, the World frame pose <code class="docutils literal"><span class="pre">X_WF</span></code> of a FixedOffsetFrame
F depends only on the World frame pose <code class="docutils literal"><span class="pre">X_WP</span></code> of its parent P, and
the constant pose <code class="docutils literal"><span class="pre">X_PF</span></code>, with <code class="docutils literal"><span class="pre">X_WF=X_WP*X_PF</span></code>.</p>
<p>For more information about spatial transforms, see
multibody_spatial_pose.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_.FixedOffsetFrame_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_.FixedOffsetFrame_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[float], name: str, P: pydrake.multibody.tree.Frame_[float], X_PF: pydrake.math.RigidTransform_[float], model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None) -&gt; None</li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to its
parent material Frame P. The pose is given by a spatial transform
<code class="docutils literal"><span class="pre">X_PF</span></code>; see class documentation for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The name of this frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">P</span></code>:</dt>
<dd>The frame to which this frame is attached with a fixed pose.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_PF</span></code>:</dt>
<dd>The <em>default</em> transform giving the pose of F in P, therefore only
the value (as a RigidTransform&lt;double&gt;) is provided.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">model_instance</span></code>:</dt>
<dd>The model instance to which this frame belongs to. If unspecified,
will use P.body().model_instance().</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[float], name: str, P: pydrake.multibody.tree.Frame_[float], X_PF: pydrake.common.eigen_geometry.Isometry3_[float], model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None) -&gt; None</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">FixedOffsetFrame_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[AutoDiffXd]" title="pydrake.multibody.tree.Frame_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd]</span></code></a></p>
<p>%FixedOffsetFrame represents a material frame F whose pose is fixed
with respect to a <em>parent</em> material frame P. The pose offset is given
by a spatial transform <code class="docutils literal"><span class="pre">X_PF</span></code>, which is constant after construction.
For instance, we could rigidly attach a frame F to move with a rigid
body B at a fixed pose <code class="docutils literal"><span class="pre">X_BF</span></code>, where B is the BodyFrame associated
with body B. Thus, the World frame pose <code class="docutils literal"><span class="pre">X_WF</span></code> of a FixedOffsetFrame
F depends only on the World frame pose <code class="docutils literal"><span class="pre">X_WP</span></code> of its parent P, and
the constant pose <code class="docutils literal"><span class="pre">X_PF</span></code>, with <code class="docutils literal"><span class="pre">X_WF=X_WP*X_PF</span></code>.</p>
<p>For more information about spatial transforms, see
multibody_spatial_pose.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd], name: str, P: pydrake.multibody.tree.Frame_[AutoDiffXd], X_PF: pydrake.math.RigidTransform_[float], model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None) -&gt; None</li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to its
parent material Frame P. The pose is given by a spatial transform
<code class="docutils literal"><span class="pre">X_PF</span></code>; see class documentation for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The name of this frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">P</span></code>:</dt>
<dd>The frame to which this frame is attached with a fixed pose.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_PF</span></code>:</dt>
<dd>The <em>default</em> transform giving the pose of F in P, therefore only
the value (as a RigidTransform&lt;double&gt;) is provided.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">model_instance</span></code>:</dt>
<dd>The model instance to which this frame belongs to. If unspecified,
will use P.body().model_instance().</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd], name: str, P: pydrake.multibody.tree.Frame_[AutoDiffXd], X_PF: pydrake.common.eigen_geometry.Isometry3_[float], model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None) -&gt; None</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">FixedOffsetFrame_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[Expression]" title="pydrake.multibody.tree.Frame_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Frame_[Expression]</span></code></a></p>
<p>%FixedOffsetFrame represents a material frame F whose pose is fixed
with respect to a <em>parent</em> material frame P. The pose offset is given
by a spatial transform <code class="docutils literal"><span class="pre">X_PF</span></code>, which is constant after construction.
For instance, we could rigidly attach a frame F to move with a rigid
body B at a fixed pose <code class="docutils literal"><span class="pre">X_BF</span></code>, where B is the BodyFrame associated
with body B. Thus, the World frame pose <code class="docutils literal"><span class="pre">X_WF</span></code> of a FixedOffsetFrame
F depends only on the World frame pose <code class="docutils literal"><span class="pre">X_WP</span></code> of its parent P, and
the constant pose <code class="docutils literal"><span class="pre">X_PF</span></code>, with <code class="docutils literal"><span class="pre">X_WF=X_WP*X_PF</span></code>.</p>
<p>For more information about spatial transforms, see
multibody_spatial_pose.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[Expression], name: str, P: pydrake.multibody.tree.Frame_[Expression], X_PF: pydrake.math.RigidTransform_[float], model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None) -&gt; None</li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to its
parent material Frame P. The pose is given by a spatial transform
<code class="docutils literal"><span class="pre">X_PF</span></code>; see class documentation for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The name of this frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">P</span></code>:</dt>
<dd>The frame to which this frame is attached with a fixed pose.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_PF</span></code>:</dt>
<dd>The <em>default</em> transform giving the pose of F in P, therefore only
the value (as a RigidTransform&lt;double&gt;) is provided.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">model_instance</span></code>:</dt>
<dd>The model instance to which this frame belongs to. If unspecified,
will use P.body().model_instance().</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[Expression], name: str, P: pydrake.multibody.tree.Frame_[Expression], X_PF: pydrake.common.eigen_geometry.Isometry3_[float], model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None) -&gt; None</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">FixedOffsetFrame_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[float]" title="pydrake.multibody.tree.Frame_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Frame_[float]</span></code></a></p>
<p>%FixedOffsetFrame represents a material frame F whose pose is fixed
with respect to a <em>parent</em> material frame P. The pose offset is given
by a spatial transform <code class="docutils literal"><span class="pre">X_PF</span></code>, which is constant after construction.
For instance, we could rigidly attach a frame F to move with a rigid
body B at a fixed pose <code class="docutils literal"><span class="pre">X_BF</span></code>, where B is the BodyFrame associated
with body B. Thus, the World frame pose <code class="docutils literal"><span class="pre">X_WF</span></code> of a FixedOffsetFrame
F depends only on the World frame pose <code class="docutils literal"><span class="pre">X_WP</span></code> of its parent P, and
the constant pose <code class="docutils literal"><span class="pre">X_PF</span></code>, with <code class="docutils literal"><span class="pre">X_WF=X_WP*X_PF</span></code>.</p>
<p>For more information about spatial transforms, see
multibody_spatial_pose.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[float], name: str, P: pydrake.multibody.tree.Frame_[float], X_PF: pydrake.math.RigidTransform_[float], model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None) -&gt; None</li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to its
parent material Frame P. The pose is given by a spatial transform
<code class="docutils literal"><span class="pre">X_PF</span></code>; see class documentation for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The name of this frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">P</span></code>:</dt>
<dd>The frame to which this frame is attached with a fixed pose.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_PF</span></code>:</dt>
<dd>The <em>default</em> transform giving the pose of F in P, therefore only
the value (as a RigidTransform&lt;double&gt;) is provided.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">model_instance</span></code>:</dt>
<dd>The model instance to which this frame belongs to. If unspecified,
will use P.body().model_instance().</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[float], name: str, P: pydrake.multibody.tree.Frame_[float], X_PF: pydrake.common.eigen_geometry.Isometry3_[float], model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None) -&gt; None</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.ForceElement">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ForceElement</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.ForceElement_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ForceElement_</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal"><span class="pre">ForceElement_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd]" title="pydrake.multibody.tree.ForceElement_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">ForceElement_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[Expression]" title="pydrake.multibody.tree.ForceElement_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">ForceElement_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.ForceElement_.ForceElement_[float]">
<em class="property">class </em><code class="descname">ForceElement_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_.ForceElement_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A ForceElement allows modeling state and time dependent forces in a
MultibodyTree model. Examples of such forces are springs, dampers,
drag and gravity. Forces that depend on accelerations such as virtual
mass cannot be modeled with a ForceElement. This abstract class
provides an API that all force elements subclasses must implement in
order to be fully defined. These are:</p>
<ul class="simple">
<li>CalcAndAddForceContribution(): computes the force contribution of a force
element in a MultibodyTree model.</li>
<li>CalcPotentialEnergy(): computes a force element potential energy
contribution.</li>
<li>CalcConservativePower(): computes the power generated by conservative
forces.</li>
<li>CalcNonConservativePower(): computes the power dissipated by
non-conservative forces.</li>
</ul>
<dl class="attribute">
<dt id="pydrake.multibody.tree.ForceElement_.ForceElement_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_.ForceElement_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_.ForceElement_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ForceElementIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_.ForceElement_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_.ForceElement_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_.ForceElement_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.ForceElement_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ForceElement_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>A ForceElement allows modeling state and time dependent forces in a
MultibodyTree model. Examples of such forces are springs, dampers,
drag and gravity. Forces that depend on accelerations such as virtual
mass cannot be modeled with a ForceElement. This abstract class
provides an API that all force elements subclasses must implement in
order to be fully defined. These are:</p>
<ul class="simple">
<li>CalcAndAddForceContribution(): computes the force contribution of a force
element in a MultibodyTree model.</li>
<li>CalcPotentialEnergy(): computes a force element potential energy
contribution.</li>
<li>CalcConservativePower(): computes the power generated by conservative
forces.</li>
<li>CalcNonConservativePower(): computes the power dissipated by
non-conservative forces.</li>
</ul>
<dl class="attribute">
<dt id="pydrake.multibody.tree.ForceElement_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_[AutoDiffXd].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ForceElementIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_[AutoDiffXd].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.ForceElement_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ForceElement_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>A ForceElement allows modeling state and time dependent forces in a
MultibodyTree model. Examples of such forces are springs, dampers,
drag and gravity. Forces that depend on accelerations such as virtual
mass cannot be modeled with a ForceElement. This abstract class
provides an API that all force elements subclasses must implement in
order to be fully defined. These are:</p>
<ul class="simple">
<li>CalcAndAddForceContribution(): computes the force contribution of a force
element in a MultibodyTree model.</li>
<li>CalcPotentialEnergy(): computes a force element potential energy
contribution.</li>
<li>CalcConservativePower(): computes the power generated by conservative
forces.</li>
<li>CalcNonConservativePower(): computes the power dissipated by
non-conservative forces.</li>
</ul>
<dl class="attribute">
<dt id="pydrake.multibody.tree.ForceElement_[Expression].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_[Expression].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ForceElementIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[Expression].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_[Expression].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[Expression].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.ForceElement_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ForceElement_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A ForceElement allows modeling state and time dependent forces in a
MultibodyTree model. Examples of such forces are springs, dampers,
drag and gravity. Forces that depend on accelerations such as virtual
mass cannot be modeled with a ForceElement. This abstract class
provides an API that all force elements subclasses must implement in
order to be fully defined. These are:</p>
<ul class="simple">
<li>CalcAndAddForceContribution(): computes the force contribution of a force
element in a MultibodyTree model.</li>
<li>CalcPotentialEnergy(): computes a force element potential energy
contribution.</li>
<li>CalcConservativePower(): computes the power generated by conservative
forces.</li>
<li>CalcNonConservativePower(): computes the power dissipated by
non-conservative forces.</li>
</ul>
<dl class="attribute">
<dt id="pydrake.multibody.tree.ForceElement_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ForceElementIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.ForceElementIndex">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ForceElementIndex</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElementIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify force elements by index within a multibody tree
system.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.ForceElementIndex.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElementIndex</em>, <em>arg0: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.ForceElementIndex.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElementIndex.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElementIndex</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.ForceElementIndex.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.Frame">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Frame</code><a class="headerlink" href="#pydrake.multibody.tree.Frame" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.Frame_[float]" title="pydrake.multibody.tree.Frame_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Frame_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.Frame_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Frame_</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[float]" title="pydrake.multibody.tree.Frame_[float]"><code class="xref py py-class docutils literal"><span class="pre">Frame_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.Frame_[AutoDiffXd]" title="pydrake.multibody.tree.Frame_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">Frame_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.Frame_[Expression]" title="pydrake.multibody.tree.Frame_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">Frame_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float]">
<em class="property">class </em><code class="descname">Frame_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Frame is an abstract class representing a <em>material frame</em> (also
called a <em>physical frame</em>), meaning that it is associated with a
material point of a Body. A material frame can be used to apply forces
and torques to a multibody system, and can be used as an attachment
point for force-producing elements like joints, actuators, and
constraints. Despite its name, Frame is not the most general frame
representation in Drake; see FrameBase for a more-general discussion.</p>
<p>The pose and motion of a Frame object is always calculated relative to
the BodyFrame of the body with which it is associated, and every Frame
object can report which Body object that is. Concrete classes derived
from Frame differ only in how those kinematic properties are
calculated. For soft bodies that calculation may depend on the body’s
deformation state variables. A Frame on a rigid body will usually have
a fixed offset from its BodyFrame, but that is not required – a frame
that moves with respect to its BodyFrame can still be a material frame
on that rigid body.</p>
<p>As always in Drake, runtime numerical quantities are stored in a
Context. A Frame object does not store runtime values, but provides
methods for extracting frame-associated values (such as the Frame
object’s kinematics) from a given Context.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].body">
<code class="descname">body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::Body&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the body associated to this Frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].GetFixedPoseInBodyFrame">
<code class="descname">GetFixedPoseInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].GetFixedPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal"><span class="pre">X_BF</span></code>
of <code class="docutils literal"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.FrameIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this frame. It may be empty if unnamed.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Frame_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Frame is an abstract class representing a <em>material frame</em> (also
called a <em>physical frame</em>), meaning that it is associated with a
material point of a Body. A material frame can be used to apply forces
and torques to a multibody system, and can be used as an attachment
point for force-producing elements like joints, actuators, and
constraints. Despite its name, Frame is not the most general frame
representation in Drake; see FrameBase for a more-general discussion.</p>
<p>The pose and motion of a Frame object is always calculated relative to
the BodyFrame of the body with which it is associated, and every Frame
object can report which Body object that is. Concrete classes derived
from Frame differ only in how those kinematic properties are
calculated. For soft bodies that calculation may depend on the body’s
deformation state variables. A Frame on a rigid body will usually have
a fixed offset from its BodyFrame, but that is not required – a frame
that moves with respect to its BodyFrame can still be a material frame
on that rigid body.</p>
<p>As always in Drake, runtime numerical quantities are stored in a
Context. A Frame object does not store runtime values, but provides
methods for extracting frame-associated values (such as the Frame
object’s kinematics) from a given Context.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].body">
<code class="descname">body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::Body&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the body associated to this Frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].GetFixedPoseInBodyFrame">
<code class="descname">GetFixedPoseInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].GetFixedPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal"><span class="pre">X_BF</span></code>
of <code class="docutils literal"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.FrameIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this frame. It may be empty if unnamed.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Frame_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Frame_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Frame is an abstract class representing a <em>material frame</em> (also
called a <em>physical frame</em>), meaning that it is associated with a
material point of a Body. A material frame can be used to apply forces
and torques to a multibody system, and can be used as an attachment
point for force-producing elements like joints, actuators, and
constraints. Despite its name, Frame is not the most general frame
representation in Drake; see FrameBase for a more-general discussion.</p>
<p>The pose and motion of a Frame object is always calculated relative to
the BodyFrame of the body with which it is associated, and every Frame
object can report which Body object that is. Concrete classes derived
from Frame differ only in how those kinematic properties are
calculated. For soft bodies that calculation may depend on the body’s
deformation state variables. A Frame on a rigid body will usually have
a fixed offset from its BodyFrame, but that is not required – a frame
that moves with respect to its BodyFrame can still be a material frame
on that rigid body.</p>
<p>As always in Drake, runtime numerical quantities are stored in a
Context. A Frame object does not store runtime values, but provides
methods for extracting frame-associated values (such as the Frame
object’s kinematics) from a given Context.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Frame_[Expression].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].body">
<code class="descname">body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::Body&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the body associated to this Frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].GetFixedPoseInBodyFrame">
<code class="descname">GetFixedPoseInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].GetFixedPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal"><span class="pre">X_BF</span></code>
of <code class="docutils literal"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.FrameIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this frame. It may be empty if unnamed.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Frame_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Frame_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Frame is an abstract class representing a <em>material frame</em> (also
called a <em>physical frame</em>), meaning that it is associated with a
material point of a Body. A material frame can be used to apply forces
and torques to a multibody system, and can be used as an attachment
point for force-producing elements like joints, actuators, and
constraints. Despite its name, Frame is not the most general frame
representation in Drake; see FrameBase for a more-general discussion.</p>
<p>The pose and motion of a Frame object is always calculated relative to
the BodyFrame of the body with which it is associated, and every Frame
object can report which Body object that is. Concrete classes derived
from Frame differ only in how those kinematic properties are
calculated. For soft bodies that calculation may depend on the body’s
deformation state variables. A Frame on a rigid body will usually have
a fixed offset from its BodyFrame, but that is not required – a frame
that moves with respect to its BodyFrame can still be a material frame
on that rigid body.</p>
<p>As always in Drake, runtime numerical quantities are stored in a
Context. A Frame object does not store runtime values, but provides
methods for extracting frame-associated values (such as the Frame
object’s kinematics) from a given Context.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Frame_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].body">
<code class="descname">body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::Body&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the body associated to this Frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].GetFixedPoseInBodyFrame">
<code class="descname">GetFixedPoseInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].GetFixedPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal"><span class="pre">X_BF</span></code>
of <code class="docutils literal"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.FrameIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this frame. It may be empty if unnamed.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.FrameIndex">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">FrameIndex</code><a class="headerlink" href="#pydrake.multibody.tree.FrameIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify frames by index in a multibody tree system.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.FrameIndex.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.FrameIndex</em>, <em>arg0: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.FrameIndex.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.FrameIndex.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.FrameIndex</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.FrameIndex.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.JacobianWrtVariable">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JacobianWrtVariable</code><a class="headerlink" href="#pydrake.multibody.tree.JacobianWrtVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Enumeration that indicates whether the Jacobian is partial
differentiation with respect to q̇ (time-derivatives of generalized
positions) or with respect to v (generalized velocities).</p>
<p>Members:</p>
<blockquote>
<div><p>kQDot : J = ∂V/∂q̇</p>
<p>kV : J = ∂V/∂v</p>
</div></blockquote>
<dl class="method">
<dt id="pydrake.multibody.tree.JacobianWrtVariable.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JacobianWrtVariable</em>, <em>arg0: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.JacobianWrtVariable.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.JacobianWrtVariable.kQDot">
<code class="descname">kQDot</code><em class="property"> = JacobianWrtVariable.kQDot</em><a class="headerlink" href="#pydrake.multibody.tree.JacobianWrtVariable.kQDot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.JacobianWrtVariable.kV">
<code class="descname">kV</code><em class="property"> = JacobianWrtVariable.kV</em><a class="headerlink" href="#pydrake.multibody.tree.JacobianWrtVariable.kV" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.JacobianWrtVariable.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.multibody.tree.JacobianWrtVariable.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.Joint">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Joint</code><a class="headerlink" href="#pydrake.multibody.tree.Joint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.Joint_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Joint_</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal"><span class="pre">Joint_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="pydrake.multibody.tree.Joint_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">Joint_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.Joint_[Expression]" title="pydrake.multibody.tree.Joint_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">Joint_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float]">
<em class="property">class </em><code class="descname">Joint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A Joint models the kinematical relationship which characterizes the
possible relative motion between two bodies. The two bodies connected
by a Joint object are referred to as the <em>parent</em> and <em>child</em> bodies.
Although the terms <em>parent</em> and <em>child</em> are sometimes used
synonymously to describe the relationship between inboard and outboard
bodies in multibody <em>trees</em>, the parent/child relationship is more
general and remains meaningful for multibody systems with loops, such
as a four-bar linkage. However, whenever possible the parent body will
be made to be inboard and the child outboard in the tree. A Joint is a
model of a physical kinematic constraint between two bodies, a
constraint that in the real physical system does not specify a tree
ordering.</p>
<p>In Drake we define a frame F rigidly attached to the parent body P
with pose <code class="docutils literal"><span class="pre">X_PF</span></code> and a frame M rigidly attached to the child body B
with pose <code class="docutils literal"><span class="pre">X_BM</span></code>. A Joint object specifies a kinematic relation
between frames F and M, which in turn imposes a kinematic relation
between bodies P and B.</p>
<p>Typical joints include the ball joint, to allow unrestricted rotations
about a given point, the revolute joint, that constraints two bodies
to rotate about a given common axis, etc.</p>
<p>Consider the following example to build a simple pendulum system:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">here</span> <span class="n">to</span> <span class="n">setup</span> <span class="n">quantities</span> <span class="n">below</span> <span class="k">as</span> <span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">etc</span><span class="o">.</span> <span class="o">...</span>
<span class="n">const</span> <span class="n">Body</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">pendulum</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddBody</span><span class="o">&lt;</span><span class="n">RigidBody</span><span class="o">&gt;</span><span class="p">(</span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">unit_inertia</span><span class="p">));</span>
<span class="o">//</span> <span class="n">We</span> <span class="n">will</span> <span class="n">connect</span> <span class="n">the</span> <span class="n">pendulum</span> <span class="n">body</span> <span class="n">to</span> <span class="n">the</span> <span class="n">world</span> <span class="n">using</span> <span class="n">a</span> <span class="n">RevoluteJoint</span><span class="o">.</span>
<span class="o">//</span> <span class="n">In</span> <span class="n">this</span> <span class="n">simple</span> <span class="n">case</span> <span class="n">the</span> <span class="n">parent</span> <span class="n">body</span> <span class="n">P</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">model</span><span class="s1">&#39;s world body and frame</span>
<span class="o">//</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Additionally</span><span class="p">,</span> <span class="n">we</span> <span class="n">need</span> <span class="n">to</span> <span class="n">specify</span> <span class="n">the</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="n">on</span> <span class="n">the</span> <span class="n">pendulum</span><span class="s1">&#39;s</span>
<span class="o">//</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Say</span> <span class="n">we</span> <span class="n">declared</span> <span class="ow">and</span> <span class="n">initialized</span> <span class="n">X_BM</span><span class="o">...</span>
<span class="n">const</span> <span class="n">RevoluteJoint</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">elbow</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddJoint</span><span class="o">&lt;</span><span class="n">RevoluteJoint</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="s2">&quot;Elbow&quot;</span><span class="p">,</span>                <span class="o">/*</span> <span class="n">joint</span> <span class="n">name</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">world_body</span><span class="p">(),</span>     <span class="o">/*</span> <span class="n">parent</span> <span class="n">body</span>
    <span class="p">{},</span>                     <span class="o">/*</span> <span class="n">frame</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span> <span class="n">W</span>
    <span class="n">pendulum</span><span class="p">,</span>               <span class="o">/*</span> <span class="n">child</span> <span class="n">body</span><span class="p">,</span> <span class="n">the</span> <span class="n">pendulum</span>
    <span class="n">X_BM</span><span class="p">,</span>                   <span class="o">/*</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span>
    <span class="n">Vector3d</span><span class="p">::</span><span class="n">UnitZ</span><span class="p">());</span>     <span class="o">/*</span> <span class="n">revolute</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Do not ever attempt to instantiate and manipulate Joint objects on
the stack; it will fail. Add joints to your plant using the
provided API MultibodyPlant::AddJoint() as in the example above.</p>
</div>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].acceleration_lower_limits">
<code class="descname">acceleration_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].acceleration_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].acceleration_upper_limits">
<code class="descname">acceleration_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].acceleration_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].child_body">
<code class="descname">child_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].child_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].default_positions">
<code class="descname">default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default positions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].frame_on_child">
<code class="descname">frame_on_child</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].frame_on_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame M attached on the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].frame_on_parent">
<code class="descname">frame_on_parent</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].frame_on_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame F attached on the parent body
P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].num_positions">
<code class="descname">num_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].num_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized positions describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].parent_body">
<code class="descname">parent_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].parent_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the parent body P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].position_lower_limits">
<code class="descname">position_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].position_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;name Methods to get and set the limits of <code class="docutils literal"><span class="pre">this</span></code> joint. For
position limits, the layout is the same as the generalized position’s.
For velocity and acceleration limits, the layout is the same as the
generalized velocity’s. A limit with value +/- ∞ implies no upper or
lower limit. Returns the position lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].position_start">
<code class="descname">position_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].position_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized position for this joint
within the vector q of generalized positions for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].position_upper_limits">
<code class="descname">position_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].position_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].set_acceleration_limits">
<code class="descname">set_acceleration_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].set_acceleration_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration limits to <code class="docutils literal"><span class="pre">lower_limits</span></code> and <code class="docutils literal"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].set_default_positions">
<code class="descname">set_default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], default_positions: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].set_default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default positions to <code class="docutils literal"><span class="pre">default_positions</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">default_positions</span></code> does not</li>
<li>match num_positions().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The values in <code class="docutils literal"><span class="pre">default_positions</span></code> are NOT constrained to be
within <code class="docutils literal"><span class="pre">position_lower_limits()</span></code> and
<code class="docutils literal"><span class="pre">position_upper_limits()</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].set_position_limits">
<code class="descname">set_position_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].set_position_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the position limits to <code class="docutils literal"><span class="pre">lower_limits</span></code> and <code class="docutils literal"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal"><span class="pre">upper_limits</span></code> does not match num_positions().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Setting the position limits does not affect the
<code class="docutils literal"><span class="pre">default_positions()</span></code>, regardless of whether the current
<code class="docutils literal"><span class="pre">default_positions()</span></code> satisfy the new position limits.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].set_velocity_limits">
<code class="descname">set_velocity_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].set_velocity_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the velocity limits to <code class="docutils literal"><span class="pre">lower_limits</span></code> and <code class="docutils literal"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].velocity_lower_limits">
<code class="descname">velocity_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].velocity_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].velocity_start">
<code class="descname">velocity_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].velocity_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized velocity for this joint
within the vector v of generalized velocities for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].velocity_upper_limits">
<code class="descname">velocity_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].velocity_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limits.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Joint_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>A Joint models the kinematical relationship which characterizes the
possible relative motion between two bodies. The two bodies connected
by a Joint object are referred to as the <em>parent</em> and <em>child</em> bodies.
Although the terms <em>parent</em> and <em>child</em> are sometimes used
synonymously to describe the relationship between inboard and outboard
bodies in multibody <em>trees</em>, the parent/child relationship is more
general and remains meaningful for multibody systems with loops, such
as a four-bar linkage. However, whenever possible the parent body will
be made to be inboard and the child outboard in the tree. A Joint is a
model of a physical kinematic constraint between two bodies, a
constraint that in the real physical system does not specify a tree
ordering.</p>
<p>In Drake we define a frame F rigidly attached to the parent body P
with pose <code class="docutils literal"><span class="pre">X_PF</span></code> and a frame M rigidly attached to the child body B
with pose <code class="docutils literal"><span class="pre">X_BM</span></code>. A Joint object specifies a kinematic relation
between frames F and M, which in turn imposes a kinematic relation
between bodies P and B.</p>
<p>Typical joints include the ball joint, to allow unrestricted rotations
about a given point, the revolute joint, that constraints two bodies
to rotate about a given common axis, etc.</p>
<p>Consider the following example to build a simple pendulum system:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">here</span> <span class="n">to</span> <span class="n">setup</span> <span class="n">quantities</span> <span class="n">below</span> <span class="k">as</span> <span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">etc</span><span class="o">.</span> <span class="o">...</span>
<span class="n">const</span> <span class="n">Body</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">pendulum</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddBody</span><span class="o">&lt;</span><span class="n">RigidBody</span><span class="o">&gt;</span><span class="p">(</span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">unit_inertia</span><span class="p">));</span>
<span class="o">//</span> <span class="n">We</span> <span class="n">will</span> <span class="n">connect</span> <span class="n">the</span> <span class="n">pendulum</span> <span class="n">body</span> <span class="n">to</span> <span class="n">the</span> <span class="n">world</span> <span class="n">using</span> <span class="n">a</span> <span class="n">RevoluteJoint</span><span class="o">.</span>
<span class="o">//</span> <span class="n">In</span> <span class="n">this</span> <span class="n">simple</span> <span class="n">case</span> <span class="n">the</span> <span class="n">parent</span> <span class="n">body</span> <span class="n">P</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">model</span><span class="s1">&#39;s world body and frame</span>
<span class="o">//</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Additionally</span><span class="p">,</span> <span class="n">we</span> <span class="n">need</span> <span class="n">to</span> <span class="n">specify</span> <span class="n">the</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="n">on</span> <span class="n">the</span> <span class="n">pendulum</span><span class="s1">&#39;s</span>
<span class="o">//</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Say</span> <span class="n">we</span> <span class="n">declared</span> <span class="ow">and</span> <span class="n">initialized</span> <span class="n">X_BM</span><span class="o">...</span>
<span class="n">const</span> <span class="n">RevoluteJoint</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">elbow</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddJoint</span><span class="o">&lt;</span><span class="n">RevoluteJoint</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="s2">&quot;Elbow&quot;</span><span class="p">,</span>                <span class="o">/*</span> <span class="n">joint</span> <span class="n">name</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">world_body</span><span class="p">(),</span>     <span class="o">/*</span> <span class="n">parent</span> <span class="n">body</span>
    <span class="p">{},</span>                     <span class="o">/*</span> <span class="n">frame</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span> <span class="n">W</span>
    <span class="n">pendulum</span><span class="p">,</span>               <span class="o">/*</span> <span class="n">child</span> <span class="n">body</span><span class="p">,</span> <span class="n">the</span> <span class="n">pendulum</span>
    <span class="n">X_BM</span><span class="p">,</span>                   <span class="o">/*</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span>
    <span class="n">Vector3d</span><span class="p">::</span><span class="n">UnitZ</span><span class="p">());</span>     <span class="o">/*</span> <span class="n">revolute</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Do not ever attempt to instantiate and manipulate Joint objects on
the stack; it will fail. Add joints to your plant using the
provided API MultibodyPlant::AddJoint() as in the example above.</p>
</div>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].acceleration_lower_limits">
<code class="descname">acceleration_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].acceleration_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].acceleration_upper_limits">
<code class="descname">acceleration_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].acceleration_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].child_body">
<code class="descname">child_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].child_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].default_positions">
<code class="descname">default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default positions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].frame_on_child">
<code class="descname">frame_on_child</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].frame_on_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame M attached on the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].frame_on_parent">
<code class="descname">frame_on_parent</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].frame_on_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame F attached on the parent body
P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].num_positions">
<code class="descname">num_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].num_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized positions describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].parent_body">
<code class="descname">parent_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].parent_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the parent body P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].position_lower_limits">
<code class="descname">position_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].position_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;name Methods to get and set the limits of <code class="docutils literal"><span class="pre">this</span></code> joint. For
position limits, the layout is the same as the generalized position’s.
For velocity and acceleration limits, the layout is the same as the
generalized velocity’s. A limit with value +/- ∞ implies no upper or
lower limit. Returns the position lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].position_start">
<code class="descname">position_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].position_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized position for this joint
within the vector q of generalized positions for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].position_upper_limits">
<code class="descname">position_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].position_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].set_acceleration_limits">
<code class="descname">set_acceleration_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].set_acceleration_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration limits to <code class="docutils literal"><span class="pre">lower_limits</span></code> and <code class="docutils literal"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].set_default_positions">
<code class="descname">set_default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], default_positions: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].set_default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default positions to <code class="docutils literal"><span class="pre">default_positions</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">default_positions</span></code> does not</li>
<li>match num_positions().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The values in <code class="docutils literal"><span class="pre">default_positions</span></code> are NOT constrained to be
within <code class="docutils literal"><span class="pre">position_lower_limits()</span></code> and
<code class="docutils literal"><span class="pre">position_upper_limits()</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].set_position_limits">
<code class="descname">set_position_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].set_position_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the position limits to <code class="docutils literal"><span class="pre">lower_limits</span></code> and <code class="docutils literal"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal"><span class="pre">upper_limits</span></code> does not match num_positions().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Setting the position limits does not affect the
<code class="docutils literal"><span class="pre">default_positions()</span></code>, regardless of whether the current
<code class="docutils literal"><span class="pre">default_positions()</span></code> satisfy the new position limits.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].set_velocity_limits">
<code class="descname">set_velocity_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].set_velocity_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the velocity limits to <code class="docutils literal"><span class="pre">lower_limits</span></code> and <code class="docutils literal"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].velocity_lower_limits">
<code class="descname">velocity_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].velocity_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].velocity_start">
<code class="descname">velocity_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].velocity_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized velocity for this joint
within the vector v of generalized velocities for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].velocity_upper_limits">
<code class="descname">velocity_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].velocity_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limits.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Joint_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Joint_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>A Joint models the kinematical relationship which characterizes the
possible relative motion between two bodies. The two bodies connected
by a Joint object are referred to as the <em>parent</em> and <em>child</em> bodies.
Although the terms <em>parent</em> and <em>child</em> are sometimes used
synonymously to describe the relationship between inboard and outboard
bodies in multibody <em>trees</em>, the parent/child relationship is more
general and remains meaningful for multibody systems with loops, such
as a four-bar linkage. However, whenever possible the parent body will
be made to be inboard and the child outboard in the tree. A Joint is a
model of a physical kinematic constraint between two bodies, a
constraint that in the real physical system does not specify a tree
ordering.</p>
<p>In Drake we define a frame F rigidly attached to the parent body P
with pose <code class="docutils literal"><span class="pre">X_PF</span></code> and a frame M rigidly attached to the child body B
with pose <code class="docutils literal"><span class="pre">X_BM</span></code>. A Joint object specifies a kinematic relation
between frames F and M, which in turn imposes a kinematic relation
between bodies P and B.</p>
<p>Typical joints include the ball joint, to allow unrestricted rotations
about a given point, the revolute joint, that constraints two bodies
to rotate about a given common axis, etc.</p>
<p>Consider the following example to build a simple pendulum system:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">here</span> <span class="n">to</span> <span class="n">setup</span> <span class="n">quantities</span> <span class="n">below</span> <span class="k">as</span> <span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">etc</span><span class="o">.</span> <span class="o">...</span>
<span class="n">const</span> <span class="n">Body</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">pendulum</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddBody</span><span class="o">&lt;</span><span class="n">RigidBody</span><span class="o">&gt;</span><span class="p">(</span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">unit_inertia</span><span class="p">));</span>
<span class="o">//</span> <span class="n">We</span> <span class="n">will</span> <span class="n">connect</span> <span class="n">the</span> <span class="n">pendulum</span> <span class="n">body</span> <span class="n">to</span> <span class="n">the</span> <span class="n">world</span> <span class="n">using</span> <span class="n">a</span> <span class="n">RevoluteJoint</span><span class="o">.</span>
<span class="o">//</span> <span class="n">In</span> <span class="n">this</span> <span class="n">simple</span> <span class="n">case</span> <span class="n">the</span> <span class="n">parent</span> <span class="n">body</span> <span class="n">P</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">model</span><span class="s1">&#39;s world body and frame</span>
<span class="o">//</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Additionally</span><span class="p">,</span> <span class="n">we</span> <span class="n">need</span> <span class="n">to</span> <span class="n">specify</span> <span class="n">the</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="n">on</span> <span class="n">the</span> <span class="n">pendulum</span><span class="s1">&#39;s</span>
<span class="o">//</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Say</span> <span class="n">we</span> <span class="n">declared</span> <span class="ow">and</span> <span class="n">initialized</span> <span class="n">X_BM</span><span class="o">...</span>
<span class="n">const</span> <span class="n">RevoluteJoint</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">elbow</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddJoint</span><span class="o">&lt;</span><span class="n">RevoluteJoint</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="s2">&quot;Elbow&quot;</span><span class="p">,</span>                <span class="o">/*</span> <span class="n">joint</span> <span class="n">name</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">world_body</span><span class="p">(),</span>     <span class="o">/*</span> <span class="n">parent</span> <span class="n">body</span>
    <span class="p">{},</span>                     <span class="o">/*</span> <span class="n">frame</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span> <span class="n">W</span>
    <span class="n">pendulum</span><span class="p">,</span>               <span class="o">/*</span> <span class="n">child</span> <span class="n">body</span><span class="p">,</span> <span class="n">the</span> <span class="n">pendulum</span>
    <span class="n">X_BM</span><span class="p">,</span>                   <span class="o">/*</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span>
    <span class="n">Vector3d</span><span class="p">::</span><span class="n">UnitZ</span><span class="p">());</span>     <span class="o">/*</span> <span class="n">revolute</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Do not ever attempt to instantiate and manipulate Joint objects on
the stack; it will fail. Add joints to your plant using the
provided API MultibodyPlant::AddJoint() as in the example above.</p>
</div>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Joint_[Expression].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].acceleration_lower_limits">
<code class="descname">acceleration_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].acceleration_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].acceleration_upper_limits">
<code class="descname">acceleration_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].acceleration_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].child_body">
<code class="descname">child_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].child_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].default_positions">
<code class="descname">default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default positions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].frame_on_child">
<code class="descname">frame_on_child</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].frame_on_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame M attached on the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].frame_on_parent">
<code class="descname">frame_on_parent</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].frame_on_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame F attached on the parent body
P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].num_positions">
<code class="descname">num_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].num_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized positions describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].parent_body">
<code class="descname">parent_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].parent_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the parent body P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].position_lower_limits">
<code class="descname">position_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].position_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;name Methods to get and set the limits of <code class="docutils literal"><span class="pre">this</span></code> joint. For
position limits, the layout is the same as the generalized position’s.
For velocity and acceleration limits, the layout is the same as the
generalized velocity’s. A limit with value +/- ∞ implies no upper or
lower limit. Returns the position lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].position_start">
<code class="descname">position_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].position_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized position for this joint
within the vector q of generalized positions for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].position_upper_limits">
<code class="descname">position_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].position_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].set_acceleration_limits">
<code class="descname">set_acceleration_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].set_acceleration_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration limits to <code class="docutils literal"><span class="pre">lower_limits</span></code> and <code class="docutils literal"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].set_default_positions">
<code class="descname">set_default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], default_positions: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].set_default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default positions to <code class="docutils literal"><span class="pre">default_positions</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">default_positions</span></code> does not</li>
<li>match num_positions().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The values in <code class="docutils literal"><span class="pre">default_positions</span></code> are NOT constrained to be
within <code class="docutils literal"><span class="pre">position_lower_limits()</span></code> and
<code class="docutils literal"><span class="pre">position_upper_limits()</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].set_position_limits">
<code class="descname">set_position_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].set_position_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the position limits to <code class="docutils literal"><span class="pre">lower_limits</span></code> and <code class="docutils literal"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal"><span class="pre">upper_limits</span></code> does not match num_positions().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Setting the position limits does not affect the
<code class="docutils literal"><span class="pre">default_positions()</span></code>, regardless of whether the current
<code class="docutils literal"><span class="pre">default_positions()</span></code> satisfy the new position limits.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].set_velocity_limits">
<code class="descname">set_velocity_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].set_velocity_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the velocity limits to <code class="docutils literal"><span class="pre">lower_limits</span></code> and <code class="docutils literal"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].velocity_lower_limits">
<code class="descname">velocity_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].velocity_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].velocity_start">
<code class="descname">velocity_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].velocity_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized velocity for this joint
within the vector v of generalized velocities for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].velocity_upper_limits">
<code class="descname">velocity_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].velocity_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limits.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Joint_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Joint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A Joint models the kinematical relationship which characterizes the
possible relative motion between two bodies. The two bodies connected
by a Joint object are referred to as the <em>parent</em> and <em>child</em> bodies.
Although the terms <em>parent</em> and <em>child</em> are sometimes used
synonymously to describe the relationship between inboard and outboard
bodies in multibody <em>trees</em>, the parent/child relationship is more
general and remains meaningful for multibody systems with loops, such
as a four-bar linkage. However, whenever possible the parent body will
be made to be inboard and the child outboard in the tree. A Joint is a
model of a physical kinematic constraint between two bodies, a
constraint that in the real physical system does not specify a tree
ordering.</p>
<p>In Drake we define a frame F rigidly attached to the parent body P
with pose <code class="docutils literal"><span class="pre">X_PF</span></code> and a frame M rigidly attached to the child body B
with pose <code class="docutils literal"><span class="pre">X_BM</span></code>. A Joint object specifies a kinematic relation
between frames F and M, which in turn imposes a kinematic relation
between bodies P and B.</p>
<p>Typical joints include the ball joint, to allow unrestricted rotations
about a given point, the revolute joint, that constraints two bodies
to rotate about a given common axis, etc.</p>
<p>Consider the following example to build a simple pendulum system:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">here</span> <span class="n">to</span> <span class="n">setup</span> <span class="n">quantities</span> <span class="n">below</span> <span class="k">as</span> <span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">etc</span><span class="o">.</span> <span class="o">...</span>
<span class="n">const</span> <span class="n">Body</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">pendulum</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddBody</span><span class="o">&lt;</span><span class="n">RigidBody</span><span class="o">&gt;</span><span class="p">(</span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">unit_inertia</span><span class="p">));</span>
<span class="o">//</span> <span class="n">We</span> <span class="n">will</span> <span class="n">connect</span> <span class="n">the</span> <span class="n">pendulum</span> <span class="n">body</span> <span class="n">to</span> <span class="n">the</span> <span class="n">world</span> <span class="n">using</span> <span class="n">a</span> <span class="n">RevoluteJoint</span><span class="o">.</span>
<span class="o">//</span> <span class="n">In</span> <span class="n">this</span> <span class="n">simple</span> <span class="n">case</span> <span class="n">the</span> <span class="n">parent</span> <span class="n">body</span> <span class="n">P</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">model</span><span class="s1">&#39;s world body and frame</span>
<span class="o">//</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Additionally</span><span class="p">,</span> <span class="n">we</span> <span class="n">need</span> <span class="n">to</span> <span class="n">specify</span> <span class="n">the</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="n">on</span> <span class="n">the</span> <span class="n">pendulum</span><span class="s1">&#39;s</span>
<span class="o">//</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Say</span> <span class="n">we</span> <span class="n">declared</span> <span class="ow">and</span> <span class="n">initialized</span> <span class="n">X_BM</span><span class="o">...</span>
<span class="n">const</span> <span class="n">RevoluteJoint</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">elbow</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddJoint</span><span class="o">&lt;</span><span class="n">RevoluteJoint</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="s2">&quot;Elbow&quot;</span><span class="p">,</span>                <span class="o">/*</span> <span class="n">joint</span> <span class="n">name</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">world_body</span><span class="p">(),</span>     <span class="o">/*</span> <span class="n">parent</span> <span class="n">body</span>
    <span class="p">{},</span>                     <span class="o">/*</span> <span class="n">frame</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span> <span class="n">W</span>
    <span class="n">pendulum</span><span class="p">,</span>               <span class="o">/*</span> <span class="n">child</span> <span class="n">body</span><span class="p">,</span> <span class="n">the</span> <span class="n">pendulum</span>
    <span class="n">X_BM</span><span class="p">,</span>                   <span class="o">/*</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span>
    <span class="n">Vector3d</span><span class="p">::</span><span class="n">UnitZ</span><span class="p">());</span>     <span class="o">/*</span> <span class="n">revolute</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Do not ever attempt to instantiate and manipulate Joint objects on
the stack; it will fail. Add joints to your plant using the
provided API MultibodyPlant::AddJoint() as in the example above.</p>
</div>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Joint_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].acceleration_lower_limits">
<code class="descname">acceleration_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].acceleration_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].acceleration_upper_limits">
<code class="descname">acceleration_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].acceleration_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].child_body">
<code class="descname">child_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].child_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].default_positions">
<code class="descname">default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default positions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].frame_on_child">
<code class="descname">frame_on_child</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].frame_on_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame M attached on the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].frame_on_parent">
<code class="descname">frame_on_parent</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].frame_on_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame F attached on the parent body
P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].num_positions">
<code class="descname">num_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].num_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized positions describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].parent_body">
<code class="descname">parent_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].parent_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the parent body P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].position_lower_limits">
<code class="descname">position_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].position_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;name Methods to get and set the limits of <code class="docutils literal"><span class="pre">this</span></code> joint. For
position limits, the layout is the same as the generalized position’s.
For velocity and acceleration limits, the layout is the same as the
generalized velocity’s. A limit with value +/- ∞ implies no upper or
lower limit. Returns the position lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].position_start">
<code class="descname">position_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].position_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized position for this joint
within the vector q of generalized positions for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].position_upper_limits">
<code class="descname">position_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].position_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].set_acceleration_limits">
<code class="descname">set_acceleration_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].set_acceleration_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration limits to <code class="docutils literal"><span class="pre">lower_limits</span></code> and <code class="docutils literal"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].set_default_positions">
<code class="descname">set_default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], default_positions: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].set_default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default positions to <code class="docutils literal"><span class="pre">default_positions</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">default_positions</span></code> does not</li>
<li>match num_positions().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The values in <code class="docutils literal"><span class="pre">default_positions</span></code> are NOT constrained to be
within <code class="docutils literal"><span class="pre">position_lower_limits()</span></code> and
<code class="docutils literal"><span class="pre">position_upper_limits()</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].set_position_limits">
<code class="descname">set_position_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].set_position_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the position limits to <code class="docutils literal"><span class="pre">lower_limits</span></code> and <code class="docutils literal"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal"><span class="pre">upper_limits</span></code> does not match num_positions().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Setting the position limits does not affect the
<code class="docutils literal"><span class="pre">default_positions()</span></code>, regardless of whether the current
<code class="docutils literal"><span class="pre">default_positions()</span></code> satisfy the new position limits.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].set_velocity_limits">
<code class="descname">set_velocity_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].set_velocity_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the velocity limits to <code class="docutils literal"><span class="pre">lower_limits</span></code> and <code class="docutils literal"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].velocity_lower_limits">
<code class="descname">velocity_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].velocity_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].velocity_start">
<code class="descname">velocity_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].velocity_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized velocity for this joint
within the vector v of generalized velocities for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].velocity_upper_limits">
<code class="descname">velocity_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].velocity_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limits.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.JointActuator">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JointActuator</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.JointActuator_[float]" title="pydrake.multibody.tree.JointActuator_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.JointActuator_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.JointActuator_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JointActuator_</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.JointActuator_[float]" title="pydrake.multibody.tree.JointActuator_[float]"><code class="xref py py-class docutils literal"><span class="pre">JointActuator_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd]" title="pydrake.multibody.tree.JointActuator_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">JointActuator_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.JointActuator_[Expression]" title="pydrake.multibody.tree.JointActuator_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">JointActuator_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float]">
<em class="property">class </em><code class="descname">JointActuator_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>The JointActuator class is mostly a simple bookkeeping structure to
represent an actuator acting on a given Joint. It helps to flag
whether a given Joint is actuated or not so that MultibodyTree clients
can apply forces on actuated joints through their actuators, see
AddInOneForce().</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].effort_limit">
<code class="descname">effort_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].effort_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the actuator effort limit.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuatorIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[float]<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the joint actuated by this JointActuator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the actuator.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JointActuator_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>The JointActuator class is mostly a simple bookkeeping structure to
represent an actuator acting on a given Joint. It helps to flag
whether a given Joint is actuated or not so that MultibodyTree clients
can apply forces on actuated joints through their actuators, see
AddInOneForce().</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].effort_limit">
<code class="descname">effort_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].effort_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the actuator effort limit.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuatorIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the joint actuated by this JointActuator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the actuator.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.JointActuator_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JointActuator_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>The JointActuator class is mostly a simple bookkeeping structure to
represent an actuator acting on a given Joint. It helps to flag
whether a given Joint is actuated or not so that MultibodyTree clients
can apply forces on actuated joints through their actuators, see
AddInOneForce().</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].effort_limit">
<code class="descname">effort_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].effort_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the actuator effort limit.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuatorIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the joint actuated by this JointActuator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[Expression]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the actuator.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.JointActuator_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JointActuator_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>The JointActuator class is mostly a simple bookkeeping structure to
represent an actuator acting on a given Joint. It helps to flag
whether a given Joint is actuated or not so that MultibodyTree clients
can apply forces on actuated joints through their actuators, see
AddInOneForce().</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.JointActuator_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[float].effort_limit">
<code class="descname">effort_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].effort_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the actuator effort limit.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuatorIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[float].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[float]<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the joint actuated by this JointActuator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the actuator.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.JointActuatorIndex">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JointActuatorIndex</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuatorIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify actuators by index within a multibody tree
system.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.JointActuatorIndex.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuatorIndex</em>, <em>arg0: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.JointActuatorIndex.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuatorIndex.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuatorIndex</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.JointActuatorIndex.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.JointIndex">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JointIndex</code><a class="headerlink" href="#pydrake.multibody.tree.JointIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify joints by index within a multibody tree system.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.JointIndex.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointIndex</em>, <em>arg0: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.JointIndex.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointIndex.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointIndex</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.JointIndex.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.LinearSpringDamper">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">LinearSpringDamper</code><a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.LinearSpringDamper_[float]" title="pydrake.multibody.tree.LinearSpringDamper_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.LinearSpringDamper_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.LinearSpringDamper_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">LinearSpringDamper_</code><a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.LinearSpringDamper_[float]" title="pydrake.multibody.tree.LinearSpringDamper_[float]"><code class="xref py py-class docutils literal"><span class="pre">LinearSpringDamper_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]" title="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">LinearSpringDamper_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression]" title="pydrake.multibody.tree.LinearSpringDamper_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">LinearSpringDamper_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float]">
<em class="property">class </em><code class="descname">LinearSpringDamper_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement models a spring-damper attached between two points
on two different bodies. Given a point P on a body A and a point Q on
a body B with positions p_AP and p_BQ, respectively, this
spring-damper applies equal and opposite forces on bodies A and B
according to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>f_AP = (k⋅(ℓ - ℓ₀) + c⋅dℓ/dt)⋅r̂
  f_BQ = -f_AP
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">ℓ</span> <span class="pre">=</span> <span class="pre">‖p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP‖</span></code> is the current length of the spring, dℓ/dt
its rate of change, <code class="docutils literal"><span class="pre">r̂</span> <span class="pre">=</span> <span class="pre">(p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP)</span> <span class="pre">/</span> <span class="pre">ℓ</span></code> is the normalized
vector from P to Q, ℓ₀ is the free length of the spring and k and c
are the stiffness and damping of the spring-damper, respectively. This
ForceElement is meant to model finite free length springs attached
between two points. In this typical arrangement springs are usually
pre-loaded, meaning they apply a non-zero spring force in the static
configuration of the system. Thus, neither the free length ℓ₀ nor the
current length ℓ of the spring can ever be zero. The length of the
spring approaching zero would incur in a non-physical configuration
and therefore this element throws a RuntimeError exception in that
case. Note that:</p>
<ul class="simple">
<li>The applied force is always along the line connecting points P and</li>
</ul>
<p>Q. - Damping always dissipates energy. - Forces on bodies A and B are
equal and opposite according to Newton’s third law.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float], bodyA: pydrake.multibody.tree.Body_[float], p_AP: numpy.ndarray[numpy.float64[3, 1]], bodyB: pydrake.multibody.tree.Body_[float], p_BQ: numpy.ndarray[numpy.float64[3, 1]], free_length: float, stiffness: float, damping: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring-damper between a point P on <code class="docutils literal"><span class="pre">bodyA</span></code> and a
point Q on <code class="docutils literal"><span class="pre">bodyB</span></code>. Point P is defined by its position <code class="docutils literal"><span class="pre">p_AP</span></code> as
measured and expressed in the body frame A and similarly, point Q is
defined by its position p_BQ as measured and expressed in body frame
B. The remaining parameters define:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">free_length</span></code>:</dt>
<dd>The free length of the spring ℓ₀, in meters, at which the spring
applies no forces. Since this force element is meant to model
finite length springs, ℓ₀ must be strictly positive.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N/m. It must be non-negative.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>The damping c of the damper in N⋅s/m. It must be non-negative.
Refer to this class’s documentation for further details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">free_length</span></code> is negative or zero.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">damping</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].bodyA">
<code class="descname">bodyA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].bodyA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].bodyB">
<code class="descname">bodyB</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].bodyB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].free_length">
<code class="descname">free_length</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].free_length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].p_AP">
<code class="descname">p_AP</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].p_AP" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_AP of point P on body A as measured and expressed in
body frame A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].p_BQ">
<code class="descname">p_BQ</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].p_BQ" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_BQ of point Q on body B as measured and expressed in
body frame B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">LinearSpringDamper_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd]" title="pydrake.multibody.tree.ForceElement_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd]</span></code></a></p>
<p>This ForceElement models a spring-damper attached between two points
on two different bodies. Given a point P on a body A and a point Q on
a body B with positions p_AP and p_BQ, respectively, this
spring-damper applies equal and opposite forces on bodies A and B
according to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>f_AP = (k⋅(ℓ - ℓ₀) + c⋅dℓ/dt)⋅r̂
  f_BQ = -f_AP
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">ℓ</span> <span class="pre">=</span> <span class="pre">‖p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP‖</span></code> is the current length of the spring, dℓ/dt
its rate of change, <code class="docutils literal"><span class="pre">r̂</span> <span class="pre">=</span> <span class="pre">(p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP)</span> <span class="pre">/</span> <span class="pre">ℓ</span></code> is the normalized
vector from P to Q, ℓ₀ is the free length of the spring and k and c
are the stiffness and damping of the spring-damper, respectively. This
ForceElement is meant to model finite free length springs attached
between two points. In this typical arrangement springs are usually
pre-loaded, meaning they apply a non-zero spring force in the static
configuration of the system. Thus, neither the free length ℓ₀ nor the
current length ℓ of the spring can ever be zero. The length of the
spring approaching zero would incur in a non-physical configuration
and therefore this element throws a RuntimeError exception in that
case. Note that:</p>
<ul class="simple">
<li>The applied force is always along the line connecting points P and</li>
</ul>
<p>Q. - Damping always dissipates energy. - Forces on bodies A and B are
equal and opposite according to Newton’s third law.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd], bodyA: pydrake.multibody.tree.Body_[AutoDiffXd], p_AP: numpy.ndarray[numpy.float64[3, 1]], bodyB: pydrake.multibody.tree.Body_[AutoDiffXd], p_BQ: numpy.ndarray[numpy.float64[3, 1]], free_length: float, stiffness: float, damping: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring-damper between a point P on <code class="docutils literal"><span class="pre">bodyA</span></code> and a
point Q on <code class="docutils literal"><span class="pre">bodyB</span></code>. Point P is defined by its position <code class="docutils literal"><span class="pre">p_AP</span></code> as
measured and expressed in the body frame A and similarly, point Q is
defined by its position p_BQ as measured and expressed in body frame
B. The remaining parameters define:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">free_length</span></code>:</dt>
<dd>The free length of the spring ℓ₀, in meters, at which the spring
applies no forces. Since this force element is meant to model
finite length springs, ℓ₀ must be strictly positive.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N/m. It must be non-negative.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>The damping c of the damper in N⋅s/m. It must be non-negative.
Refer to this class’s documentation for further details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">free_length</span></code> is negative or zero.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">damping</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].bodyA">
<code class="descname">bodyA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].bodyA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].bodyB">
<code class="descname">bodyB</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].bodyB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].damping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].free_length">
<code class="descname">free_length</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].free_length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].p_AP">
<code class="descname">p_AP</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].p_AP" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_AP of point P on body A as measured and expressed in
body frame A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].p_BQ">
<code class="descname">p_BQ</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].p_BQ" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_BQ of point Q on body B as measured and expressed in
body frame B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">LinearSpringDamper_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[Expression]" title="pydrake.multibody.tree.ForceElement_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[Expression]</span></code></a></p>
<p>This ForceElement models a spring-damper attached between two points
on two different bodies. Given a point P on a body A and a point Q on
a body B with positions p_AP and p_BQ, respectively, this
spring-damper applies equal and opposite forces on bodies A and B
according to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>f_AP = (k⋅(ℓ - ℓ₀) + c⋅dℓ/dt)⋅r̂
  f_BQ = -f_AP
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">ℓ</span> <span class="pre">=</span> <span class="pre">‖p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP‖</span></code> is the current length of the spring, dℓ/dt
its rate of change, <code class="docutils literal"><span class="pre">r̂</span> <span class="pre">=</span> <span class="pre">(p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP)</span> <span class="pre">/</span> <span class="pre">ℓ</span></code> is the normalized
vector from P to Q, ℓ₀ is the free length of the spring and k and c
are the stiffness and damping of the spring-damper, respectively. This
ForceElement is meant to model finite free length springs attached
between two points. In this typical arrangement springs are usually
pre-loaded, meaning they apply a non-zero spring force in the static
configuration of the system. Thus, neither the free length ℓ₀ nor the
current length ℓ of the spring can ever be zero. The length of the
spring approaching zero would incur in a non-physical configuration
and therefore this element throws a RuntimeError exception in that
case. Note that:</p>
<ul class="simple">
<li>The applied force is always along the line connecting points P and</li>
</ul>
<p>Q. - Damping always dissipates energy. - Forces on bodies A and B are
equal and opposite according to Newton’s third law.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression], bodyA: pydrake.multibody.tree.Body_[Expression], p_AP: numpy.ndarray[numpy.float64[3, 1]], bodyB: pydrake.multibody.tree.Body_[Expression], p_BQ: numpy.ndarray[numpy.float64[3, 1]], free_length: float, stiffness: float, damping: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring-damper between a point P on <code class="docutils literal"><span class="pre">bodyA</span></code> and a
point Q on <code class="docutils literal"><span class="pre">bodyB</span></code>. Point P is defined by its position <code class="docutils literal"><span class="pre">p_AP</span></code> as
measured and expressed in the body frame A and similarly, point Q is
defined by its position p_BQ as measured and expressed in body frame
B. The remaining parameters define:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">free_length</span></code>:</dt>
<dd>The free length of the spring ℓ₀, in meters, at which the spring
applies no forces. Since this force element is meant to model
finite length springs, ℓ₀ must be strictly positive.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N/m. It must be non-negative.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>The damping c of the damper in N⋅s/m. It must be non-negative.
Refer to this class’s documentation for further details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">free_length</span></code> is negative or zero.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">damping</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].bodyA">
<code class="descname">bodyA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].bodyA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].bodyB">
<code class="descname">bodyB</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].bodyB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].damping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].free_length">
<code class="descname">free_length</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].free_length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].p_AP">
<code class="descname">p_AP</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].p_AP" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_AP of point P on body A as measured and expressed in
body frame A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].p_BQ">
<code class="descname">p_BQ</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].p_BQ" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_BQ of point Q on body B as measured and expressed in
body frame B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">LinearSpringDamper_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement models a spring-damper attached between two points
on two different bodies. Given a point P on a body A and a point Q on
a body B with positions p_AP and p_BQ, respectively, this
spring-damper applies equal and opposite forces on bodies A and B
according to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>f_AP = (k⋅(ℓ - ℓ₀) + c⋅dℓ/dt)⋅r̂
  f_BQ = -f_AP
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">ℓ</span> <span class="pre">=</span> <span class="pre">‖p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP‖</span></code> is the current length of the spring, dℓ/dt
its rate of change, <code class="docutils literal"><span class="pre">r̂</span> <span class="pre">=</span> <span class="pre">(p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP)</span> <span class="pre">/</span> <span class="pre">ℓ</span></code> is the normalized
vector from P to Q, ℓ₀ is the free length of the spring and k and c
are the stiffness and damping of the spring-damper, respectively. This
ForceElement is meant to model finite free length springs attached
between two points. In this typical arrangement springs are usually
pre-loaded, meaning they apply a non-zero spring force in the static
configuration of the system. Thus, neither the free length ℓ₀ nor the
current length ℓ of the spring can ever be zero. The length of the
spring approaching zero would incur in a non-physical configuration
and therefore this element throws a RuntimeError exception in that
case. Note that:</p>
<ul class="simple">
<li>The applied force is always along the line connecting points P and</li>
</ul>
<p>Q. - Damping always dissipates energy. - Forces on bodies A and B are
equal and opposite according to Newton’s third law.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float], bodyA: pydrake.multibody.tree.Body_[float], p_AP: numpy.ndarray[numpy.float64[3, 1]], bodyB: pydrake.multibody.tree.Body_[float], p_BQ: numpy.ndarray[numpy.float64[3, 1]], free_length: float, stiffness: float, damping: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring-damper between a point P on <code class="docutils literal"><span class="pre">bodyA</span></code> and a
point Q on <code class="docutils literal"><span class="pre">bodyB</span></code>. Point P is defined by its position <code class="docutils literal"><span class="pre">p_AP</span></code> as
measured and expressed in the body frame A and similarly, point Q is
defined by its position p_BQ as measured and expressed in body frame
B. The remaining parameters define:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">free_length</span></code>:</dt>
<dd>The free length of the spring ℓ₀, in meters, at which the spring
applies no forces. Since this force element is meant to model
finite length springs, ℓ₀ must be strictly positive.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N/m. It must be non-negative.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>The damping c of the damper in N⋅s/m. It must be non-negative.
Refer to this class’s documentation for further details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">free_length</span></code> is negative or zero.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">damping</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].bodyA">
<code class="descname">bodyA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].bodyA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].bodyB">
<code class="descname">bodyB</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].bodyB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].free_length">
<code class="descname">free_length</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].free_length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].p_AP">
<code class="descname">p_AP</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].p_AP" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_AP of point P on body A as measured and expressed in
body frame A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].p_BQ">
<code class="descname">p_BQ</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].p_BQ" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_BQ of point Q on body B as measured and expressed in
body frame B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.ModelInstanceIndex">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ModelInstanceIndex</code><a class="headerlink" href="#pydrake.multibody.tree.ModelInstanceIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify model instances by index within a multibody tree
system.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.ModelInstanceIndex.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ModelInstanceIndex</em>, <em>arg0: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.ModelInstanceIndex.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ModelInstanceIndex.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ModelInstanceIndex</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.ModelInstanceIndex.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.MultibodyForces">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">MultibodyForces</code><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.MultibodyForces_[float]" title="pydrake.multibody.tree.MultibodyForces_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.MultibodyForces_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.MultibodyForces_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">MultibodyForces_</code><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.MultibodyForces_[float]" title="pydrake.multibody.tree.MultibodyForces_[float]"><code class="xref py py-class docutils literal"><span class="pre">MultibodyForces_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]" title="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">MultibodyForces_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.MultibodyForces_[Expression]" title="pydrake.multibody.tree.MultibodyForces_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">MultibodyForces_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float]">
<em class="property">class </em><code class="descname">MultibodyForces_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to hold a set of forces applied to a MultibodyTree system.
Forces can include generalized forces as well as body spatial forces.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float], plant: drake::multibody::MultibodyPlant&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a force object to store a set of forces to be applied to
the multibody model for <code class="docutils literal"><span class="pre">plant</span></code>. Forces are initialized to zero,
meaning no forces are applied. <code class="docutils literal"><span class="pre">plant</span></code> must have been already
finalized with MultibodyPlant::Finalize() or this constructor will
abort.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].AddInForces">
<code class="descname">AddInForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float], addend: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].AddInForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal"><span class="pre">this</span></code> the force contribution stored in <code class="docutils literal"><span class="pre">addend</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].generalized_forces">
<code class="descname">generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a constant reference to the vector of generalized
forces stored by <code class="docutils literal"><span class="pre">this</span></code> forces object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].mutable_generalized_forces">
<code class="descname">mutable_generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].mutable_generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Mutable version of generalized_forces().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.MultibodyForces_[float]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> to store zero forces (no applied forces).</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">MultibodyForces_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to hold a set of forces applied to a MultibodyTree system.
Forces can include generalized forces as well as body spatial forces.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd], plant: drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a force object to store a set of forces to be applied to
the multibody model for <code class="docutils literal"><span class="pre">plant</span></code>. Forces are initialized to zero,
meaning no forces are applied. <code class="docutils literal"><span class="pre">plant</span></code> must have been already
finalized with MultibodyPlant::Finalize() or this constructor will
abort.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].AddInForces">
<code class="descname">AddInForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd], addend: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].AddInForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal"><span class="pre">this</span></code> the force contribution stored in <code class="docutils literal"><span class="pre">addend</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].generalized_forces">
<code class="descname">generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a constant reference to the vector of generalized
forces stored by <code class="docutils literal"><span class="pre">this</span></code> forces object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].mutable_generalized_forces">
<code class="descname">mutable_generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].mutable_generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Mutable version of generalized_forces().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> to store zero forces (no applied forces).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.MultibodyForces_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">MultibodyForces_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to hold a set of forces applied to a MultibodyTree system.
Forces can include generalized forces as well as body spatial forces.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[Expression], plant: drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a force object to store a set of forces to be applied to
the multibody model for <code class="docutils literal"><span class="pre">plant</span></code>. Forces are initialized to zero,
meaning no forces are applied. <code class="docutils literal"><span class="pre">plant</span></code> must have been already
finalized with MultibodyPlant::Finalize() or this constructor will
abort.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[Expression].AddInForces">
<code class="descname">AddInForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[Expression], addend: pydrake.multibody.tree.MultibodyForces_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[Expression].AddInForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal"><span class="pre">this</span></code> the force contribution stored in <code class="docutils literal"><span class="pre">addend</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[Expression].generalized_forces">
<code class="descname">generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[Expression].generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a constant reference to the vector of generalized
forces stored by <code class="docutils literal"><span class="pre">this</span></code> forces object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[Expression].mutable_generalized_forces">
<code class="descname">mutable_generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[Expression].mutable_generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Mutable version of generalized_forces().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[Expression].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.MultibodyForces_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[Expression].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> to store zero forces (no applied forces).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.MultibodyForces_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">MultibodyForces_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to hold a set of forces applied to a MultibodyTree system.
Forces can include generalized forces as well as body spatial forces.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float], plant: drake::multibody::MultibodyPlant&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a force object to store a set of forces to be applied to
the multibody model for <code class="docutils literal"><span class="pre">plant</span></code>. Forces are initialized to zero,
meaning no forces are applied. <code class="docutils literal"><span class="pre">plant</span></code> must have been already
finalized with MultibodyPlant::Finalize() or this constructor will
abort.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[float].AddInForces">
<code class="descname">AddInForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float], addend: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[float].AddInForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal"><span class="pre">this</span></code> the force contribution stored in <code class="docutils literal"><span class="pre">addend</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[float].generalized_forces">
<code class="descname">generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[float].generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a constant reference to the vector of generalized
forces stored by <code class="docutils literal"><span class="pre">this</span></code> forces object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[float].mutable_generalized_forces">
<code class="descname">mutable_generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[float].mutable_generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Mutable version of generalized_forces().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.MultibodyForces_[float]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> to store zero forces (no applied forces).</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.PrismaticJoint">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">PrismaticJoint</code><a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.PrismaticJoint_[float]" title="pydrake.multibody.tree.PrismaticJoint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.PrismaticJoint_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.PrismaticJoint_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">PrismaticJoint_</code><a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.PrismaticJoint_[float]" title="pydrake.multibody.tree.PrismaticJoint_[float]"><code class="xref py py-class docutils literal"><span class="pre">PrismaticJoint_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]" title="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">PrismaticJoint_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.PrismaticJoint_[Expression]" title="pydrake.multibody.tree.PrismaticJoint_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">PrismaticJoint_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float]">
<em class="property">class </em><code class="descname">PrismaticJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint allows two bodies to translate relative to one another
along a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to translate
with respect to each other along an axis â. The translation distance
is defined positive when child body B translates along the direction
of â. Axis â is constant and has the same measures in both frames F
and M, that is, <code class="docutils literal"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], axis: numpy.ndarray[numpy.float64[3, 1]], pos_lower_limit: float = -inf, pos_upper_limit: float = inf, damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a prismatic joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, translate relatively to one another along a common axis.
See this class’s documentation for further details on the definition
of these frames and translation distance. The first three arguments to
this constructor are those of the Joint class constructor. See the
Joint class’s documentation for details. The additional parameter
<code class="docutils literal"><span class="pre">axis</span></code> is:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the translation axis for this joint.
Given that frame M only translates with respect to F and there is
no relative rotation, the measures of <code class="docutils literal"><span class="pre">axis</span></code> in either frame F
or M are exactly the same, that is, <code class="docutils literal"><span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>. This
vector can have any length, only the direction is used.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">pos_lower_limit</span></code>:</dt>
<dd>Lower position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">pos_upper_limit</span></code>:</dt>
<dd>Upper position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅s/m, used to model losses within
the joint. The damping force (in N) is modeled as <code class="docutils literal"><span class="pre">f</span> <span class="pre">=</span>
<span class="pre">-damping⋅v</span></code>, i.e. opposing motion, with v the translational speed
for <code class="docutils literal"><span class="pre">this</span></code> joint (see get_translation_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if damping is negative.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if pos_lower_limit &gt; pos_upper_limit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> joint’s damping constant in N⋅s/m.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translation distance of <code class="docutils literal"><span class="pre">this</span></code> mobilizer from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The translation coordinate of <code class="docutils literal"><span class="pre">this</span></code> joint read from
<code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].get_translation_rate">
<code class="descname">get_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].get_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in meters per second, of <code class="docutils literal"><span class="pre">this</span></code> joint’s
translation distance (see get_translation()) from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rate of change of <code class="docutils literal"><span class="pre">this</span></code> joint’s translation read from
<code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].set_random_translation_distribution">
<code class="descname">set_random_translation_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], translation: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].set_random_translation_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float], translation: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinate corresponding to
the translation distance of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">translation</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">translation</span></code>:</dt>
<dd>The desired translation in meters to be stored in <code class="docutils literal"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].set_translation_rate">
<code class="descname">set_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float], translation_dot: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].set_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in meters per second, of <code class="docutils literal"><span class="pre">this</span></code> joint’s
translation distance to <code class="docutils literal"><span class="pre">translation_dot</span></code>. The new rate of change
<code class="docutils literal"><span class="pre">translation_dot</span></code> gets stored in <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">translation_dot</span></code>:</dt>
<dd>The desired rate of change of <code class="docutils literal"><span class="pre">this</span></code> joints’s translation in
meters per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].translation_axis">
<code class="descname">translation_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].translation_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of translation for <code class="docutils literal"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frames’s definitions) then, <code class="docutils literal"><span class="pre">axis</span>
<span class="pre">=</span> <span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">PrismaticJoint_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="pydrake.multibody.tree.Joint_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></a></p>
<p>This Joint allows two bodies to translate relative to one another
along a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to translate
with respect to each other along an axis â. The translation distance
is defined positive when child body B translates along the direction
of â. Axis â is constant and has the same measures in both frames F
and M, that is, <code class="docutils literal"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3, 1]], pos_lower_limit: float = -inf, pos_upper_limit: float = inf, damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a prismatic joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, translate relatively to one another along a common axis.
See this class’s documentation for further details on the definition
of these frames and translation distance. The first three arguments to
this constructor are those of the Joint class constructor. See the
Joint class’s documentation for details. The additional parameter
<code class="docutils literal"><span class="pre">axis</span></code> is:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the translation axis for this joint.
Given that frame M only translates with respect to F and there is
no relative rotation, the measures of <code class="docutils literal"><span class="pre">axis</span></code> in either frame F
or M are exactly the same, that is, <code class="docutils literal"><span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>. This
vector can have any length, only the direction is used.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">pos_lower_limit</span></code>:</dt>
<dd>Lower position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">pos_upper_limit</span></code>:</dt>
<dd>Upper position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅s/m, used to model losses within
the joint. The damping force (in N) is modeled as <code class="docutils literal"><span class="pre">f</span> <span class="pre">=</span>
<span class="pre">-damping⋅v</span></code>, i.e. opposing motion, with v the translational speed
for <code class="docutils literal"><span class="pre">this</span></code> joint (see get_translation_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if damping is negative.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if pos_lower_limit &gt; pos_upper_limit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> joint’s damping constant in N⋅s/m.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translation distance of <code class="docutils literal"><span class="pre">this</span></code> mobilizer from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The translation coordinate of <code class="docutils literal"><span class="pre">this</span></code> joint read from
<code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].get_translation_rate">
<code class="descname">get_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].get_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in meters per second, of <code class="docutils literal"><span class="pre">this</span></code> joint’s
translation distance (see get_translation()) from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rate of change of <code class="docutils literal"><span class="pre">this</span></code> joint’s translation read from
<code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].set_random_translation_distribution">
<code class="descname">set_random_translation_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd], translation: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].set_random_translation_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], translation: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinate corresponding to
the translation distance of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">translation</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">translation</span></code>:</dt>
<dd>The desired translation in meters to be stored in <code class="docutils literal"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].set_translation_rate">
<code class="descname">set_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], translation_dot: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].set_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in meters per second, of <code class="docutils literal"><span class="pre">this</span></code> joint’s
translation distance to <code class="docutils literal"><span class="pre">translation_dot</span></code>. The new rate of change
<code class="docutils literal"><span class="pre">translation_dot</span></code> gets stored in <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">translation_dot</span></code>:</dt>
<dd>The desired rate of change of <code class="docutils literal"><span class="pre">this</span></code> joints’s translation in
meters per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].translation_axis">
<code class="descname">translation_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].translation_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of translation for <code class="docutils literal"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frames’s definitions) then, <code class="docutils literal"><span class="pre">axis</span>
<span class="pre">=</span> <span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">PrismaticJoint_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[Expression]" title="pydrake.multibody.tree.Joint_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></a></p>
<p>This Joint allows two bodies to translate relative to one another
along a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to translate
with respect to each other along an axis â. The translation distance
is defined positive when child body B translates along the direction
of â. Axis â is constant and has the same measures in both frames F
and M, that is, <code class="docutils literal"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], axis: numpy.ndarray[numpy.float64[3, 1]], pos_lower_limit: float = -inf, pos_upper_limit: float = inf, damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a prismatic joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, translate relatively to one another along a common axis.
See this class’s documentation for further details on the definition
of these frames and translation distance. The first three arguments to
this constructor are those of the Joint class constructor. See the
Joint class’s documentation for details. The additional parameter
<code class="docutils literal"><span class="pre">axis</span></code> is:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the translation axis for this joint.
Given that frame M only translates with respect to F and there is
no relative rotation, the measures of <code class="docutils literal"><span class="pre">axis</span></code> in either frame F
or M are exactly the same, that is, <code class="docutils literal"><span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>. This
vector can have any length, only the direction is used.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">pos_lower_limit</span></code>:</dt>
<dd>Lower position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">pos_upper_limit</span></code>:</dt>
<dd>Upper position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅s/m, used to model losses within
the joint. The damping force (in N) is modeled as <code class="docutils literal"><span class="pre">f</span> <span class="pre">=</span>
<span class="pre">-damping⋅v</span></code>, i.e. opposing motion, with v the translational speed
for <code class="docutils literal"><span class="pre">this</span></code> joint (see get_translation_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if damping is negative.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if pos_lower_limit &gt; pos_upper_limit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> joint’s damping constant in N⋅s/m.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translation distance of <code class="docutils literal"><span class="pre">this</span></code> mobilizer from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The translation coordinate of <code class="docutils literal"><span class="pre">this</span></code> joint read from
<code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].get_translation_rate">
<code class="descname">get_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].get_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in meters per second, of <code class="docutils literal"><span class="pre">this</span></code> joint’s
translation distance (see get_translation()) from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rate of change of <code class="docutils literal"><span class="pre">this</span></code> joint’s translation read from
<code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].set_random_translation_distribution">
<code class="descname">set_random_translation_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression], translation: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].set_random_translation_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], translation: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinate corresponding to
the translation distance of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">translation</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">translation</span></code>:</dt>
<dd>The desired translation in meters to be stored in <code class="docutils literal"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].set_translation_rate">
<code class="descname">set_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], translation_dot: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].set_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in meters per second, of <code class="docutils literal"><span class="pre">this</span></code> joint’s
translation distance to <code class="docutils literal"><span class="pre">translation_dot</span></code>. The new rate of change
<code class="docutils literal"><span class="pre">translation_dot</span></code> gets stored in <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">translation_dot</span></code>:</dt>
<dd>The desired rate of change of <code class="docutils literal"><span class="pre">this</span></code> joints’s translation in
meters per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].translation_axis">
<code class="descname">translation_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].translation_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of translation for <code class="docutils literal"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frames’s definitions) then, <code class="docutils literal"><span class="pre">axis</span>
<span class="pre">=</span> <span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">PrismaticJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint allows two bodies to translate relative to one another
along a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to translate
with respect to each other along an axis â. The translation distance
is defined positive when child body B translates along the direction
of â. Axis â is constant and has the same measures in both frames F
and M, that is, <code class="docutils literal"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], axis: numpy.ndarray[numpy.float64[3, 1]], pos_lower_limit: float = -inf, pos_upper_limit: float = inf, damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a prismatic joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, translate relatively to one another along a common axis.
See this class’s documentation for further details on the definition
of these frames and translation distance. The first three arguments to
this constructor are those of the Joint class constructor. See the
Joint class’s documentation for details. The additional parameter
<code class="docutils literal"><span class="pre">axis</span></code> is:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the translation axis for this joint.
Given that frame M only translates with respect to F and there is
no relative rotation, the measures of <code class="docutils literal"><span class="pre">axis</span></code> in either frame F
or M are exactly the same, that is, <code class="docutils literal"><span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>. This
vector can have any length, only the direction is used.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">pos_lower_limit</span></code>:</dt>
<dd>Lower position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">pos_upper_limit</span></code>:</dt>
<dd>Upper position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅s/m, used to model losses within
the joint. The damping force (in N) is modeled as <code class="docutils literal"><span class="pre">f</span> <span class="pre">=</span>
<span class="pre">-damping⋅v</span></code>, i.e. opposing motion, with v the translational speed
for <code class="docutils literal"><span class="pre">this</span></code> joint (see get_translation_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if damping is negative.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if pos_lower_limit &gt; pos_upper_limit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> joint’s damping constant in N⋅s/m.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translation distance of <code class="docutils literal"><span class="pre">this</span></code> mobilizer from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The translation coordinate of <code class="docutils literal"><span class="pre">this</span></code> joint read from
<code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].get_translation_rate">
<code class="descname">get_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].get_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in meters per second, of <code class="docutils literal"><span class="pre">this</span></code> joint’s
translation distance (see get_translation()) from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rate of change of <code class="docutils literal"><span class="pre">this</span></code> joint’s translation read from
<code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].set_random_translation_distribution">
<code class="descname">set_random_translation_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], translation: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].set_random_translation_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float], translation: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinate corresponding to
the translation distance of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">translation</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">translation</span></code>:</dt>
<dd>The desired translation in meters to be stored in <code class="docutils literal"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].set_translation_rate">
<code class="descname">set_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float], translation_dot: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].set_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in meters per second, of <code class="docutils literal"><span class="pre">this</span></code> joint’s
translation distance to <code class="docutils literal"><span class="pre">translation_dot</span></code>. The new rate of change
<code class="docutils literal"><span class="pre">translation_dot</span></code> gets stored in <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">translation_dot</span></code>:</dt>
<dd>The desired rate of change of <code class="docutils literal"><span class="pre">this</span></code> joints’s translation in
meters per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].translation_axis">
<code class="descname">translation_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].translation_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of translation for <code class="docutils literal"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frames’s definitions) then, <code class="docutils literal"><span class="pre">axis</span>
<span class="pre">=</span> <span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.RevoluteJoint">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteJoint</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.RevoluteJoint_[float]" title="pydrake.multibody.tree.RevoluteJoint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.RevoluteJoint_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.RevoluteJoint_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteJoint_</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.RevoluteJoint_[float]" title="pydrake.multibody.tree.RevoluteJoint_[float]"><code class="xref py py-class docutils literal"><span class="pre">RevoluteJoint_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]" title="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">RevoluteJoint_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RevoluteJoint_[Expression]" title="pydrake.multibody.tree.RevoluteJoint_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">RevoluteJoint_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float]">
<em class="property">class </em><code class="descname">RevoluteJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint allows two bodies to rotate relatively to one another
around a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to rotate
with respect to each other about an axis â. The rotation angle’s sign
is defined such that child body B rotates about axis â according to
the right hand rule, with thumb aligned in the axis direction. Axis â
is constant and has the same measures in both frames F and M, that is,
<code class="docutils literal"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], axis: numpy.ndarray[numpy.float64[3, 1]], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. This constructor signature creates
a joint with no joint limits, i.e. the joint position, velocity and
acceleration limits are the pair <code class="docutils literal"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame M only rotates with respect to F and their
origins are coincident at all times, the measures of <code class="docutils literal"><span class="pre">axis</span></code> in
either frame F or M are exactly the same, that is, <code class="docutils literal"><span class="pre">axis_F</span> <span class="pre">=</span>
<span class="pre">axis_M</span></code>. In other words, <code class="docutils literal"><span class="pre">axis_F</span></code> (or <code class="docutils literal"><span class="pre">axis_M</span></code>) is the
eigenvector of <code class="docutils literal"><span class="pre">R_FM</span></code> with eigenvalue equal to one. This vector
can have any length, only the direction is used. This method
aborts if <code class="docutils literal"><span class="pre">axis</span></code> is the zero vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal"><span class="pre">this</span></code> joint (see get_angular_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].get_angle">
<code class="descname">get_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].get_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angle of <code class="docutils literal"><span class="pre">this</span></code> mobilizer from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinate of <code class="docutils literal"><span class="pre">this</span></code> joint stored in the <code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].revolute_axis">
<code class="descname">revolute_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].revolute_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of revolution of <code class="docutils literal"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frames’s definitions) then, <code class="docutils literal"><span class="pre">axis</span>
<span class="pre">=</span> <span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].set_angle">
<code class="descname">set_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], context: pydrake.systems.framework.Context_[float], angle: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].set_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinate corresponding
to the rotation angle of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">angle</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">angle</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].set_random_angle_distribution">
<code class="descname">set_random_angle_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], angle: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].set_random_angle_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteJoint_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="pydrake.multibody.tree.Joint_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></a></p>
<p>This Joint allows two bodies to rotate relatively to one another
around a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to rotate
with respect to each other about an axis â. The rotation angle’s sign
is defined such that child body B rotates about axis â according to
the right hand rule, with thumb aligned in the axis direction. Axis â
is constant and has the same measures in both frames F and M, that is,
<code class="docutils literal"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3, 1]], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. This constructor signature creates
a joint with no joint limits, i.e. the joint position, velocity and
acceleration limits are the pair <code class="docutils literal"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame M only rotates with respect to F and their
origins are coincident at all times, the measures of <code class="docutils literal"><span class="pre">axis</span></code> in
either frame F or M are exactly the same, that is, <code class="docutils literal"><span class="pre">axis_F</span> <span class="pre">=</span>
<span class="pre">axis_M</span></code>. In other words, <code class="docutils literal"><span class="pre">axis_F</span></code> (or <code class="docutils literal"><span class="pre">axis_M</span></code>) is the
eigenvector of <code class="docutils literal"><span class="pre">R_FM</span></code> with eigenvalue equal to one. This vector
can have any length, only the direction is used. This method
aborts if <code class="docutils literal"><span class="pre">axis</span></code> is the zero vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal"><span class="pre">this</span></code> joint (see get_angular_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].get_angle">
<code class="descname">get_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].get_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angle of <code class="docutils literal"><span class="pre">this</span></code> mobilizer from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinate of <code class="docutils literal"><span class="pre">this</span></code> joint stored in the <code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].revolute_axis">
<code class="descname">revolute_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].revolute_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of revolution of <code class="docutils literal"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frames’s definitions) then, <code class="docutils literal"><span class="pre">axis</span>
<span class="pre">=</span> <span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].set_angle">
<code class="descname">set_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], angle: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].set_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinate corresponding
to the rotation angle of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">angle</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">angle</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].set_random_angle_distribution">
<code class="descname">set_random_angle_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], angle: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].set_random_angle_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteJoint_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[Expression]" title="pydrake.multibody.tree.Joint_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></a></p>
<p>This Joint allows two bodies to rotate relatively to one another
around a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to rotate
with respect to each other about an axis â. The rotation angle’s sign
is defined such that child body B rotates about axis â according to
the right hand rule, with thumb aligned in the axis direction. Axis â
is constant and has the same measures in both frames F and M, that is,
<code class="docutils literal"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], axis: numpy.ndarray[numpy.float64[3, 1]], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. This constructor signature creates
a joint with no joint limits, i.e. the joint position, velocity and
acceleration limits are the pair <code class="docutils literal"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame M only rotates with respect to F and their
origins are coincident at all times, the measures of <code class="docutils literal"><span class="pre">axis</span></code> in
either frame F or M are exactly the same, that is, <code class="docutils literal"><span class="pre">axis_F</span> <span class="pre">=</span>
<span class="pre">axis_M</span></code>. In other words, <code class="docutils literal"><span class="pre">axis_F</span></code> (or <code class="docutils literal"><span class="pre">axis_M</span></code>) is the
eigenvector of <code class="docutils literal"><span class="pre">R_FM</span></code> with eigenvalue equal to one. This vector
can have any length, only the direction is used. This method
aborts if <code class="docutils literal"><span class="pre">axis</span></code> is the zero vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal"><span class="pre">this</span></code> joint (see get_angular_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].get_angle">
<code class="descname">get_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].get_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angle of <code class="docutils literal"><span class="pre">this</span></code> mobilizer from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinate of <code class="docutils literal"><span class="pre">this</span></code> joint stored in the <code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].revolute_axis">
<code class="descname">revolute_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].revolute_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of revolution of <code class="docutils literal"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frames’s definitions) then, <code class="docutils literal"><span class="pre">axis</span>
<span class="pre">=</span> <span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].set_angle">
<code class="descname">set_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], angle: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].set_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinate corresponding
to the rotation angle of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">angle</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">angle</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].set_random_angle_distribution">
<code class="descname">set_random_angle_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression], angle: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].set_random_angle_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint allows two bodies to rotate relatively to one another
around a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to rotate
with respect to each other about an axis â. The rotation angle’s sign
is defined such that child body B rotates about axis â according to
the right hand rule, with thumb aligned in the axis direction. Axis â
is constant and has the same measures in both frames F and M, that is,
<code class="docutils literal"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], axis: numpy.ndarray[numpy.float64[3, 1]], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. This constructor signature creates
a joint with no joint limits, i.e. the joint position, velocity and
acceleration limits are the pair <code class="docutils literal"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame M only rotates with respect to F and their
origins are coincident at all times, the measures of <code class="docutils literal"><span class="pre">axis</span></code> in
either frame F or M are exactly the same, that is, <code class="docutils literal"><span class="pre">axis_F</span> <span class="pre">=</span>
<span class="pre">axis_M</span></code>. In other words, <code class="docutils literal"><span class="pre">axis_F</span></code> (or <code class="docutils literal"><span class="pre">axis_M</span></code>) is the
eigenvector of <code class="docutils literal"><span class="pre">R_FM</span></code> with eigenvalue equal to one. This vector
can have any length, only the direction is used. This method
aborts if <code class="docutils literal"><span class="pre">axis</span></code> is the zero vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal"><span class="pre">this</span></code> joint (see get_angular_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].get_angle">
<code class="descname">get_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].get_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angle of <code class="docutils literal"><span class="pre">this</span></code> mobilizer from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinate of <code class="docutils literal"><span class="pre">this</span></code> joint stored in the <code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].revolute_axis">
<code class="descname">revolute_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].revolute_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of revolution of <code class="docutils literal"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frames’s definitions) then, <code class="docutils literal"><span class="pre">axis</span>
<span class="pre">=</span> <span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].set_angle">
<code class="descname">set_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], context: pydrake.systems.framework.Context_[float], angle: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].set_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinate corresponding
to the rotation angle of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">angle</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">angle</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].set_random_angle_distribution">
<code class="descname">set_random_angle_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], angle: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].set_random_angle_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.RevoluteSpring">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteSpring</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.RevoluteSpring_[float]" title="pydrake.multibody.tree.RevoluteSpring_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.RevoluteSpring_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.RevoluteSpring_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteSpring_</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.RevoluteSpring_[float]" title="pydrake.multibody.tree.RevoluteSpring_[float]"><code class="xref py py-class docutils literal"><span class="pre">RevoluteSpring_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd]" title="pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">RevoluteSpring_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RevoluteSpring_[Expression]" title="pydrake.multibody.tree.RevoluteSpring_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">RevoluteSpring_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float]">
<em class="property">class </em><code class="descname">RevoluteSpring_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement models a torsional spring attached to a
RevoluteJoint and applies a torque to that joint</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>τ = -k⋅(θ - θ₀)
</pre></div>
</div>
<p>where θ₀ is the nominal joint position. Note that joint damping exists
within the RevoluteJoint itself, and so is not included here.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float], joint: pydrake.multibody.tree.RevoluteJoint_[float], nominal_angle: float, stiffness: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring attached to the given joint</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">nominal_angle</span></code>:</dt>
<dd>The nominal angle of the spring θ₀, in radians, at which the
spring applies no moment.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N⋅m/rad.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].nominal_angle">
<code class="descname">nominal_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].nominal_angle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteSpring_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd]" title="pydrake.multibody.tree.ForceElement_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd]</span></code></a></p>
<p>This ForceElement models a torsional spring attached to a
RevoluteJoint and applies a torque to that joint</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>τ = -k⋅(θ - θ₀)
</pre></div>
</div>
<p>where θ₀ is the nominal joint position. Note that joint damping exists
within the RevoluteJoint itself, and so is not included here.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd], joint: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], nominal_angle: float, stiffness: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring attached to the given joint</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">nominal_angle</span></code>:</dt>
<dd>The nominal angle of the spring θ₀, in radians, at which the
spring applies no moment.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N⋅m/rad.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].nominal_angle">
<code class="descname">nominal_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].nominal_angle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteSpring_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteSpring_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[Expression]" title="pydrake.multibody.tree.ForceElement_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[Expression]</span></code></a></p>
<p>This ForceElement models a torsional spring attached to a
RevoluteJoint and applies a torque to that joint</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>τ = -k⋅(θ - θ₀)
</pre></div>
</div>
<p>where θ₀ is the nominal joint position. Note that joint damping exists
within the RevoluteJoint itself, and so is not included here.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[Expression], joint: pydrake.multibody.tree.RevoluteJoint_[Expression], nominal_angle: float, stiffness: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring attached to the given joint</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">nominal_angle</span></code>:</dt>
<dd>The nominal angle of the spring θ₀, in radians, at which the
spring applies no moment.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N⋅m/rad.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[Expression].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[Expression].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[Expression].nominal_angle">
<code class="descname">nominal_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[Expression].nominal_angle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[Expression].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[Expression].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteSpring_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteSpring_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement models a torsional spring attached to a
RevoluteJoint and applies a torque to that joint</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>τ = -k⋅(θ - θ₀)
</pre></div>
</div>
<p>where θ₀ is the nominal joint position. Note that joint damping exists
within the RevoluteJoint itself, and so is not included here.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float], joint: pydrake.multibody.tree.RevoluteJoint_[float], nominal_angle: float, stiffness: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring attached to the given joint</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">nominal_angle</span></code>:</dt>
<dd>The nominal angle of the spring θ₀, in radians, at which the
spring applies no moment.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N⋅m/rad.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[float].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[float].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[float].nominal_angle">
<code class="descname">nominal_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[float].nominal_angle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[float].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[float].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.RigidBody">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RigidBody</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.RigidBody_[float]" title="pydrake.multibody.tree.RigidBody_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.RigidBody_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.RigidBody_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RigidBody_</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.RigidBody_[float]" title="pydrake.multibody.tree.RigidBody_[float]"><code class="xref py py-class docutils literal"><span class="pre">RigidBody_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd]" title="pydrake.multibody.tree.RigidBody_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">RigidBody_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RigidBody_[Expression]" title="pydrake.multibody.tree.RigidBody_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">RigidBody_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float]">
<em class="property">class </em><code class="descname">RigidBody_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Body_[float]" title="pydrake.multibody.tree.Body_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Body_[float]</span></code></a></p>
<p>The term <strong>rigid body</strong> implies that the deformations of the body
under consideration are so small that they have no significant effect
on the overall motions of the body and therefore deformations can be
neglected. If deformations are neglected, the distance between any two
points on the rigid body remains constant at all times. This
invariance of the distance between two arbitrary points is often taken
as the definition of a rigid body in classical treatments of multibody
mechanics [Goldstein 2001]. It can be demonstrated that the
unconstrained three-dimensional motions of a rigid body can be
described by six coordinates and thus it is often said that a free
body in space has six <strong>degrees of freedom</strong>. These degrees of freedom
obey the Newton-Euler equations of motion. However, within a
MultibodyTree, a RigidBody is <em>not</em> free in space; instead, it is
assigned a limited number of degrees of freedom (0-6) with respect to
its parent body in the multibody tree by its Mobilizer (also called a
“tree joint” or “inboard joint”). Additional constraints on
permissible motion can be added using Constraint objects to remove
more degrees of freedom.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Goldstein 2001] H Goldstein, CP Poole, JL Safko, Classical Mechanics</dt>
<dd>(3rd Edition), Addison-Wesley, 2001.</dd>
</dl>
</li>
</ul>
<dl class="attribute">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_com">
<code class="descname">default_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this rigid body’s center of mass as
measured and expressed in this body’s frame. This value is initially
supplied at construction when specifying this body’s SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">p_BoBcm_B</span></code>:</dt>
<dd>The position of this rigid body B’s center of mass <code class="docutils literal"><span class="pre">Bcm</span></code>
measured from Bo (B’s frame origin) and expressed in B (body B’s
frame).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_mass">
<code class="descname">default_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this body’s mass. This value is initially
supplied at construction when specifying this body’s SpatialInertia.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">This body’s default mass.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_spatial_inertia">
<code class="descname">default_spatial_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::SpatialInertia&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_spatial_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default value of this body B’s spatial inertia about Bo (B’s
origin) and expressed in B (this body’s frame).</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>body B’s spatial inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_unit_inertia">
<code class="descname">default_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::UnitInertia&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this body B’s unit inertia about Bo (body
B’s origin), expressed in B (this body’s frame). This value is
initially supplied at construction when specifying this body’s
SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">G_BBo_B</span></code>:</dt>
<dd>rigid body B’s unit inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RigidBody_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Body_[AutoDiffXd]" title="pydrake.multibody.tree.Body_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Body_[AutoDiffXd]</span></code></a></p>
<p>The term <strong>rigid body</strong> implies that the deformations of the body
under consideration are so small that they have no significant effect
on the overall motions of the body and therefore deformations can be
neglected. If deformations are neglected, the distance between any two
points on the rigid body remains constant at all times. This
invariance of the distance between two arbitrary points is often taken
as the definition of a rigid body in classical treatments of multibody
mechanics [Goldstein 2001]. It can be demonstrated that the
unconstrained three-dimensional motions of a rigid body can be
described by six coordinates and thus it is often said that a free
body in space has six <strong>degrees of freedom</strong>. These degrees of freedom
obey the Newton-Euler equations of motion. However, within a
MultibodyTree, a RigidBody is <em>not</em> free in space; instead, it is
assigned a limited number of degrees of freedom (0-6) with respect to
its parent body in the multibody tree by its Mobilizer (also called a
“tree joint” or “inboard joint”). Additional constraints on
permissible motion can be added using Constraint objects to remove
more degrees of freedom.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Goldstein 2001] H Goldstein, CP Poole, JL Safko, Classical Mechanics</dt>
<dd>(3rd Edition), Addison-Wesley, 2001.</dd>
</dl>
</li>
</ul>
<dl class="attribute">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_com">
<code class="descname">default_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this rigid body’s center of mass as
measured and expressed in this body’s frame. This value is initially
supplied at construction when specifying this body’s SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">p_BoBcm_B</span></code>:</dt>
<dd>The position of this rigid body B’s center of mass <code class="docutils literal"><span class="pre">Bcm</span></code>
measured from Bo (B’s frame origin) and expressed in B (body B’s
frame).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_mass">
<code class="descname">default_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this body’s mass. This value is initially
supplied at construction when specifying this body’s SpatialInertia.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">This body’s default mass.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_spatial_inertia">
<code class="descname">default_spatial_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_spatial_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default value of this body B’s spatial inertia about Bo (B’s
origin) and expressed in B (this body’s frame).</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>body B’s spatial inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_unit_inertia">
<code class="descname">default_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this body B’s unit inertia about Bo (body
B’s origin), expressed in B (this body’s frame). This value is
initially supplied at construction when specifying this body’s
SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">G_BBo_B</span></code>:</dt>
<dd>rigid body B’s unit inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RigidBody_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RigidBody_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Body_[Expression]" title="pydrake.multibody.tree.Body_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Body_[Expression]</span></code></a></p>
<p>The term <strong>rigid body</strong> implies that the deformations of the body
under consideration are so small that they have no significant effect
on the overall motions of the body and therefore deformations can be
neglected. If deformations are neglected, the distance between any two
points on the rigid body remains constant at all times. This
invariance of the distance between two arbitrary points is often taken
as the definition of a rigid body in classical treatments of multibody
mechanics [Goldstein 2001]. It can be demonstrated that the
unconstrained three-dimensional motions of a rigid body can be
described by six coordinates and thus it is often said that a free
body in space has six <strong>degrees of freedom</strong>. These degrees of freedom
obey the Newton-Euler equations of motion. However, within a
MultibodyTree, a RigidBody is <em>not</em> free in space; instead, it is
assigned a limited number of degrees of freedom (0-6) with respect to
its parent body in the multibody tree by its Mobilizer (also called a
“tree joint” or “inboard joint”). Additional constraints on
permissible motion can be added using Constraint objects to remove
more degrees of freedom.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Goldstein 2001] H Goldstein, CP Poole, JL Safko, Classical Mechanics</dt>
<dd>(3rd Edition), Addison-Wesley, 2001.</dd>
</dl>
</li>
</ul>
<dl class="attribute">
<dt id="pydrake.multibody.tree.RigidBody_[Expression].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[Expression].default_com">
<code class="descname">default_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression].default_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this rigid body’s center of mass as
measured and expressed in this body’s frame. This value is initially
supplied at construction when specifying this body’s SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">p_BoBcm_B</span></code>:</dt>
<dd>The position of this rigid body B’s center of mass <code class="docutils literal"><span class="pre">Bcm</span></code>
measured from Bo (B’s frame origin) and expressed in B (body B’s
frame).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[Expression].default_mass">
<code class="descname">default_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression].default_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this body’s mass. This value is initially
supplied at construction when specifying this body’s SpatialInertia.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">This body’s default mass.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[Expression].default_spatial_inertia">
<code class="descname">default_spatial_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression].default_spatial_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default value of this body B’s spatial inertia about Bo (B’s
origin) and expressed in B (this body’s frame).</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>body B’s spatial inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[Expression].default_unit_inertia">
<code class="descname">default_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression].default_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this body B’s unit inertia about Bo (body
B’s origin), expressed in B (this body’s frame). This value is
initially supplied at construction when specifying this body’s
SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">G_BBo_B</span></code>:</dt>
<dd>rigid body B’s unit inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RigidBody_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RigidBody_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Body_[float]" title="pydrake.multibody.tree.Body_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Body_[float]</span></code></a></p>
<p>The term <strong>rigid body</strong> implies that the deformations of the body
under consideration are so small that they have no significant effect
on the overall motions of the body and therefore deformations can be
neglected. If deformations are neglected, the distance between any two
points on the rigid body remains constant at all times. This
invariance of the distance between two arbitrary points is often taken
as the definition of a rigid body in classical treatments of multibody
mechanics [Goldstein 2001]. It can be demonstrated that the
unconstrained three-dimensional motions of a rigid body can be
described by six coordinates and thus it is often said that a free
body in space has six <strong>degrees of freedom</strong>. These degrees of freedom
obey the Newton-Euler equations of motion. However, within a
MultibodyTree, a RigidBody is <em>not</em> free in space; instead, it is
assigned a limited number of degrees of freedom (0-6) with respect to
its parent body in the multibody tree by its Mobilizer (also called a
“tree joint” or “inboard joint”). Additional constraints on
permissible motion can be added using Constraint objects to remove
more degrees of freedom.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Goldstein 2001] H Goldstein, CP Poole, JL Safko, Classical Mechanics</dt>
<dd>(3rd Edition), Addison-Wesley, 2001.</dd>
</dl>
</li>
</ul>
<dl class="attribute">
<dt id="pydrake.multibody.tree.RigidBody_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[float].default_com">
<code class="descname">default_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float].default_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this rigid body’s center of mass as
measured and expressed in this body’s frame. This value is initially
supplied at construction when specifying this body’s SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">p_BoBcm_B</span></code>:</dt>
<dd>The position of this rigid body B’s center of mass <code class="docutils literal"><span class="pre">Bcm</span></code>
measured from Bo (B’s frame origin) and expressed in B (body B’s
frame).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[float].default_mass">
<code class="descname">default_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float].default_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this body’s mass. This value is initially
supplied at construction when specifying this body’s SpatialInertia.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">This body’s default mass.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[float].default_spatial_inertia">
<code class="descname">default_spatial_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::SpatialInertia&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float].default_spatial_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default value of this body B’s spatial inertia about Bo (B’s
origin) and expressed in B (this body’s frame).</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>body B’s spatial inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[float].default_unit_inertia">
<code class="descname">default_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::UnitInertia&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float].default_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this body B’s unit inertia about Bo (body
B’s origin), expressed in B (this body’s frame). This value is
initially supplied at construction when specifying this body’s
SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">G_BBo_B</span></code>:</dt>
<dd>rigid body B’s unit inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.RotationalInertia">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RotationalInertia</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[float]" title="pydrake.multibody.tree.RotationalInertia_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.RotationalInertia_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.RotationalInertia_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RotationalInertia_</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[float]" title="pydrake.multibody.tree.RotationalInertia_[float]"><code class="xref py py-class docutils literal"><span class="pre">RotationalInertia_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]" title="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">RotationalInertia_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[Expression]" title="pydrake.multibody.tree.RotationalInertia_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">RotationalInertia_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float]">
<em class="property">class </em><code class="descname">RotationalInertia_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class describes the mass distribution (inertia properties) of a
body or composite body about a particular point. Herein, “composite
body” means one body or a collection of bodies that are welded
together. In this documentation, “body” and “composite body” are used
interchangeably.</p>
<p>A <strong>rigid</strong> body’s mass distribution is described by three quantities:
the body’s mass; the body’s center of mass; and the body’s rotational
inertia about a particular point. The term <strong>rotational inertia</strong> is
used here and by [Jain 2010] to distinguish from a body’s <strong>spatial
inertia</strong>. In this class, a 3x3 <strong>inertia matrix</strong> I represents a
body’s rotational inertia about a point and expressed in a frame. More
specifically, <code class="docutils literal"><span class="pre">I_BP_E</span></code> is the inertia matrix of a body B about-point
P and expressed-in frame E (herein frame E’s orthogonal unit vectors
Ex, Ey, Ez are denoted 𝐱̂, 𝐲̂, 𝐳̂).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span> <span class="n">Ixx</span> <span class="n">Ixy</span> <span class="n">Ixz</span> <span class="o">|</span>
<span class="n">I</span> <span class="o">=</span> <span class="o">|</span> <span class="n">Ixy</span> <span class="n">Iyy</span> <span class="n">Iyz</span> <span class="o">|</span>
    <span class="o">|</span> <span class="n">Ixz</span> <span class="n">Iyz</span> <span class="n">Izz</span> <span class="o">|</span>
</pre></div>
</div>
<p>The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz,
Iyz are defined in terms of the mass dm of a differential volume of
the body. The position of dm from about-point P is xx̂ + yŷ + zẑ =
[x, y, z]_E.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Ixx = ∫ (y² + z²) dm
Iyy = ∫ (x² + z²) dm
Izz = ∫ (x² + y²) dm
Ixy = - ∫ x y dm
Ixz = - ∫ x z dm
Iyz = - ∫ y z dm
</pre></div>
</div>
<p>We use the negated convention for products of inertia, so that I
serves to relate angular velocity ω and angular momentum h via <code class="docutils literal"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">I</span>
<span class="pre">⋅</span> <span class="pre">ω</span></code>. Ensure your products of inertia follow this negative sign
convention.</p>
<p>The 3x3 inertia matrix is symmetric and its diagonal elements (moments
of inertia) and off-diagonal elements (products of inertia) are
associated with a body (or composite body) S, an about-point P, and an
expressed-in frame E (𝐱̂, 𝐲̂, 𝐳̂̂). A rotational inertia is
ill-defined unless there is a body S, about-point P, and expressed-in
frame E. The user of this class is responsible for tracking the body
S, about-point P and expressed-in frame E (none of these are stored in
this class).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the about-point nor the expressed-in
frame, nor does this class help enforce consistency of the
about-point or expressed-in frame. To help users of this class
track the about-point and expressed-in frame, we strongly
recommend the following notation.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In typeset material, use the symbol <span class="math">\([I^{S/P}]_E\)</span> to
represent the rotational inertia (inertia matrix) of a body (or
composite body) S about-point P, expressed in frame E. In code and
comments, use the monogram notation <code class="docutils literal"><span class="pre">I_SP_E</span></code> (e.g., as described
in multibody_spatial_inertia). If the about-point P is fixed to a
body B, the point is named <span class="math">\(B_P\)</span> and this appears in
code/comments as <code class="docutils literal"><span class="pre">Bp</span></code>. Examples: <code class="docutils literal"><span class="pre">I_BBp_E</span></code> is rigid body B’s
rotational inertia about-point Bp expressed-in frame E; I_BBo_E is
B’s rotational inertia about-point <code class="docutils literal"><span class="pre">Bo</span></code> (body B’s origin)
expressed-in frame E; and I_BBcm_E is B’s inertia matrix
about-point <code class="docutils literal"><span class="pre">Bcm</span></code> (B’s center of mass) expressed-in frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The rotational inertia (inertia matrix) can be re-expressed in
terms of a special frame whose orthogonal unit vectors are
parallel to <strong>principal axes of inertia</strong> so that the inertia
matrix is diagonalized with elements called <strong>principal moments of
inertia</strong>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The formal definition of the inertia matrix <span class="math">\(I^{S/P}\)</span> of a
system S about a point P follows the definition of the inertia
dyadic 𝐈 of S about P, which begins by modeling S with n particles
S₁ … Sₙ (e.g., 12 grams of carbon can be modeled with n = 6.02 *
10²³ molecules/particles). The inertia dyadic 𝐈₁ of one particle
S₁ about point P is defined [Kane, 1985] in terms of m₁ (mass of
S₁), ᴾ𝐩ˢ¹ (position vector from P to S₁), and the unit dyadic 𝐔
which is defined by the property 𝐔 ⋅ 𝐯 = 𝐯 where 𝐯 is is any
vector (this definition of 𝐔 is analogous to defining the identity
matrix by the property 𝑰𝒅𝒆𝒏𝒕𝒊𝒕𝒚𝑴𝒂𝒕𝒓𝒊𝒙 * 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙 = 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙).</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐈₁ = m₁ * [𝐔 * (ᴾ𝐩ˢ¹ ⋅ ᴾ𝐩ˢ¹)  -  ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹]
</pre></div>
</div>
<p>Note: The vector dot-product (⋅) above produces a scalar whereas the
vector multiply (*) produces a dyadic which is a 2nd-order tensor
(ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹ is similar to the matrix outer-product of a 3x1 matrix
multiplied by a 1x3 matrix). An example inertia dyadic for a single
particle is shown further below. The inertia dyadic 𝐈 of the entire
system S is defined by summing the inertia dyadic of each particle Sᵢ
about P (i = 1, … n), i.e.,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐈 = 𝐈₁ + 𝐈₂ + ... 𝐈ₙ
</pre></div>
</div>
<p>The elements of the inertia matrix <span class="math">\([I^{S/P}]_E\)</span> expressed in
frame E (in terms of orthogonal unit vectors 𝐱̂, 𝐲̂, 𝐳̂̂) are found by
pre-dot multiplying and post-dot multiplying 𝐈 with appropriate unit
vectors.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Ixx = 𝐱̂ ⋅ 𝐈 ⋅ 𝐱̂     Ixy = 𝐱̂ ⋅ 𝐈 ⋅ 𝐲̂      Ixz = 𝐱̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Iyx = 𝐲̂ ⋅ 𝐈 ⋅ 𝐱̂     Iyy = 𝐲̂ ⋅ 𝐈 ⋅ 𝐲̂      Iyz = 𝐲̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Izx = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐱̂     Izy = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐲̂      Izz = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐳̂̂
</pre></div>
</div>
<p>The inertia dyadic 𝐈ᴮ of a rigid body B about Bcm (B’s center of mass)
is related to various dynamic quantities. For example, B’s angular
momentum 𝐇 about Bcm in a frame N and B’s kinetic energy KE in N
relate to 𝐈ᴮ by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐇 = 𝐈ᴮ ⋅ 𝛚
   KE = 1/2 𝛚 ⋅ 𝐈ᴮ ⋅ 𝛚  +  1/2 mᴮ 𝐯 ⋅ 𝐯
</pre></div>
</div>
<p>where 𝛚 is B’s angular velocity in N, 𝐯 is Bcm’s translational
velocity in N, and mᴮ is B’s mass. When frame N happens to be a
Newtonian frame (also called an inertial frame or
non-rotating/non-accelerating frame), the moment 𝐓 of all forces on B
about Bcm relates to 𝐈ᴮ and 𝛂 (B’s angular acceleration in N) by
Euler’s rigid body equation as</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐓 = 𝐈ᴮ ⋅ 𝛂  +  𝛚 × 𝐈ᴮ ⋅ 𝛚
</pre></div>
</div>
<p>Example: For a particle Q of mass m whose position vector from a point
O is written in terms of right-handed orthogonal unit vectors 𝐱̂, 𝐲̂,
𝐳̂ (below), the inertia dyadic 𝐈 of particle Q about point O is
defined and calculated</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐩 = x 𝐱̂  +  y 𝐲̂                               (given)
    𝐈 = m * [𝐔 * (𝐩 ⋅ 𝐩)  -  𝐩 * 𝐩]              (definition)
      = m * [𝐔 * (x² + y²)  -  (x𝐱̂ + y𝐲̂̂) * (x𝐱̂ + y𝐲̂)
      = m * [(𝐱̂𝐱̂ + 𝐲̂𝐲̂ + 𝐳̂𝐳̂) * (x² + y²) - (x²𝐱̂𝐱̂ + xy𝐱̂𝐲̂̂ + xy𝐲̂̂𝐱̂ + y²𝐲̂̂𝐲̂̂)]
      = m * [y²𝐱̂𝐱̂ + x²𝐲̂𝐲̂ + (x² + y²)𝐳̂𝐳̂ - xy𝐱̂𝐲̂̂ - xy𝐲̂̂𝐱̂]
</pre></div>
</div>
<p>which means the inertia matrix for particle Q about point O for 𝐱̂,
𝐲̂, 𝐳̂ is</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>|  m y²     -m x y         0     |
I = | -m x y     m x²          0     |
    |    0         0     m (x² + y²) |
</pre></div>
</div>
<p>[Kane, 1985] pg. 68. “Dynamics: Theory and Applications,” McGraw-Hill
Co., New York, 1985 (with D. A. Levinson). Available for free .pdf
download: <a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<p>Various methods in this class require numerical (not symbolic) data
types.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].CopyToFullMatrix3">
<code class="descname">CopyToFullMatrix3</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 3]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].CopyToFullMatrix3" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a full 3x3 matrix copy of this rotational inertia. The returned
copy is symmetric and includes both lower and upper parts of the
matrix.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RotationalInertia_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class describes the mass distribution (inertia properties) of a
body or composite body about a particular point. Herein, “composite
body” means one body or a collection of bodies that are welded
together. In this documentation, “body” and “composite body” are used
interchangeably.</p>
<p>A <strong>rigid</strong> body’s mass distribution is described by three quantities:
the body’s mass; the body’s center of mass; and the body’s rotational
inertia about a particular point. The term <strong>rotational inertia</strong> is
used here and by [Jain 2010] to distinguish from a body’s <strong>spatial
inertia</strong>. In this class, a 3x3 <strong>inertia matrix</strong> I represents a
body’s rotational inertia about a point and expressed in a frame. More
specifically, <code class="docutils literal"><span class="pre">I_BP_E</span></code> is the inertia matrix of a body B about-point
P and expressed-in frame E (herein frame E’s orthogonal unit vectors
Ex, Ey, Ez are denoted 𝐱̂, 𝐲̂, 𝐳̂).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span> <span class="n">Ixx</span> <span class="n">Ixy</span> <span class="n">Ixz</span> <span class="o">|</span>
<span class="n">I</span> <span class="o">=</span> <span class="o">|</span> <span class="n">Ixy</span> <span class="n">Iyy</span> <span class="n">Iyz</span> <span class="o">|</span>
    <span class="o">|</span> <span class="n">Ixz</span> <span class="n">Iyz</span> <span class="n">Izz</span> <span class="o">|</span>
</pre></div>
</div>
<p>The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz,
Iyz are defined in terms of the mass dm of a differential volume of
the body. The position of dm from about-point P is xx̂ + yŷ + zẑ =
[x, y, z]_E.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Ixx = ∫ (y² + z²) dm
Iyy = ∫ (x² + z²) dm
Izz = ∫ (x² + y²) dm
Ixy = - ∫ x y dm
Ixz = - ∫ x z dm
Iyz = - ∫ y z dm
</pre></div>
</div>
<p>We use the negated convention for products of inertia, so that I
serves to relate angular velocity ω and angular momentum h via <code class="docutils literal"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">I</span>
<span class="pre">⋅</span> <span class="pre">ω</span></code>. Ensure your products of inertia follow this negative sign
convention.</p>
<p>The 3x3 inertia matrix is symmetric and its diagonal elements (moments
of inertia) and off-diagonal elements (products of inertia) are
associated with a body (or composite body) S, an about-point P, and an
expressed-in frame E (𝐱̂, 𝐲̂, 𝐳̂̂). A rotational inertia is
ill-defined unless there is a body S, about-point P, and expressed-in
frame E. The user of this class is responsible for tracking the body
S, about-point P and expressed-in frame E (none of these are stored in
this class).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the about-point nor the expressed-in
frame, nor does this class help enforce consistency of the
about-point or expressed-in frame. To help users of this class
track the about-point and expressed-in frame, we strongly
recommend the following notation.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In typeset material, use the symbol <span class="math">\([I^{S/P}]_E\)</span> to
represent the rotational inertia (inertia matrix) of a body (or
composite body) S about-point P, expressed in frame E. In code and
comments, use the monogram notation <code class="docutils literal"><span class="pre">I_SP_E</span></code> (e.g., as described
in multibody_spatial_inertia). If the about-point P is fixed to a
body B, the point is named <span class="math">\(B_P\)</span> and this appears in
code/comments as <code class="docutils literal"><span class="pre">Bp</span></code>. Examples: <code class="docutils literal"><span class="pre">I_BBp_E</span></code> is rigid body B’s
rotational inertia about-point Bp expressed-in frame E; I_BBo_E is
B’s rotational inertia about-point <code class="docutils literal"><span class="pre">Bo</span></code> (body B’s origin)
expressed-in frame E; and I_BBcm_E is B’s inertia matrix
about-point <code class="docutils literal"><span class="pre">Bcm</span></code> (B’s center of mass) expressed-in frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The rotational inertia (inertia matrix) can be re-expressed in
terms of a special frame whose orthogonal unit vectors are
parallel to <strong>principal axes of inertia</strong> so that the inertia
matrix is diagonalized with elements called <strong>principal moments of
inertia</strong>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The formal definition of the inertia matrix <span class="math">\(I^{S/P}\)</span> of a
system S about a point P follows the definition of the inertia
dyadic 𝐈 of S about P, which begins by modeling S with n particles
S₁ … Sₙ (e.g., 12 grams of carbon can be modeled with n = 6.02 *
10²³ molecules/particles). The inertia dyadic 𝐈₁ of one particle
S₁ about point P is defined [Kane, 1985] in terms of m₁ (mass of
S₁), ᴾ𝐩ˢ¹ (position vector from P to S₁), and the unit dyadic 𝐔
which is defined by the property 𝐔 ⋅ 𝐯 = 𝐯 where 𝐯 is is any
vector (this definition of 𝐔 is analogous to defining the identity
matrix by the property 𝑰𝒅𝒆𝒏𝒕𝒊𝒕𝒚𝑴𝒂𝒕𝒓𝒊𝒙 * 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙 = 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙).</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐈₁ = m₁ * [𝐔 * (ᴾ𝐩ˢ¹ ⋅ ᴾ𝐩ˢ¹)  -  ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹]
</pre></div>
</div>
<p>Note: The vector dot-product (⋅) above produces a scalar whereas the
vector multiply (*) produces a dyadic which is a 2nd-order tensor
(ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹ is similar to the matrix outer-product of a 3x1 matrix
multiplied by a 1x3 matrix). An example inertia dyadic for a single
particle is shown further below. The inertia dyadic 𝐈 of the entire
system S is defined by summing the inertia dyadic of each particle Sᵢ
about P (i = 1, … n), i.e.,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐈 = 𝐈₁ + 𝐈₂ + ... 𝐈ₙ
</pre></div>
</div>
<p>The elements of the inertia matrix <span class="math">\([I^{S/P}]_E\)</span> expressed in
frame E (in terms of orthogonal unit vectors 𝐱̂, 𝐲̂, 𝐳̂̂) are found by
pre-dot multiplying and post-dot multiplying 𝐈 with appropriate unit
vectors.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Ixx = 𝐱̂ ⋅ 𝐈 ⋅ 𝐱̂     Ixy = 𝐱̂ ⋅ 𝐈 ⋅ 𝐲̂      Ixz = 𝐱̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Iyx = 𝐲̂ ⋅ 𝐈 ⋅ 𝐱̂     Iyy = 𝐲̂ ⋅ 𝐈 ⋅ 𝐲̂      Iyz = 𝐲̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Izx = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐱̂     Izy = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐲̂      Izz = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐳̂̂
</pre></div>
</div>
<p>The inertia dyadic 𝐈ᴮ of a rigid body B about Bcm (B’s center of mass)
is related to various dynamic quantities. For example, B’s angular
momentum 𝐇 about Bcm in a frame N and B’s kinetic energy KE in N
relate to 𝐈ᴮ by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐇 = 𝐈ᴮ ⋅ 𝛚
   KE = 1/2 𝛚 ⋅ 𝐈ᴮ ⋅ 𝛚  +  1/2 mᴮ 𝐯 ⋅ 𝐯
</pre></div>
</div>
<p>where 𝛚 is B’s angular velocity in N, 𝐯 is Bcm’s translational
velocity in N, and mᴮ is B’s mass. When frame N happens to be a
Newtonian frame (also called an inertial frame or
non-rotating/non-accelerating frame), the moment 𝐓 of all forces on B
about Bcm relates to 𝐈ᴮ and 𝛂 (B’s angular acceleration in N) by
Euler’s rigid body equation as</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐓 = 𝐈ᴮ ⋅ 𝛂  +  𝛚 × 𝐈ᴮ ⋅ 𝛚
</pre></div>
</div>
<p>Example: For a particle Q of mass m whose position vector from a point
O is written in terms of right-handed orthogonal unit vectors 𝐱̂, 𝐲̂,
𝐳̂ (below), the inertia dyadic 𝐈 of particle Q about point O is
defined and calculated</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐩 = x 𝐱̂  +  y 𝐲̂                               (given)
    𝐈 = m * [𝐔 * (𝐩 ⋅ 𝐩)  -  𝐩 * 𝐩]              (definition)
      = m * [𝐔 * (x² + y²)  -  (x𝐱̂ + y𝐲̂̂) * (x𝐱̂ + y𝐲̂)
      = m * [(𝐱̂𝐱̂ + 𝐲̂𝐲̂ + 𝐳̂𝐳̂) * (x² + y²) - (x²𝐱̂𝐱̂ + xy𝐱̂𝐲̂̂ + xy𝐲̂̂𝐱̂ + y²𝐲̂̂𝐲̂̂)]
      = m * [y²𝐱̂𝐱̂ + x²𝐲̂𝐲̂ + (x² + y²)𝐳̂𝐳̂ - xy𝐱̂𝐲̂̂ - xy𝐲̂̂𝐱̂]
</pre></div>
</div>
<p>which means the inertia matrix for particle Q about point O for 𝐱̂,
𝐲̂, 𝐳̂ is</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>|  m y²     -m x y         0     |
I = | -m x y     m x²          0     |
    |    0         0     m (x² + y²) |
</pre></div>
</div>
<p>[Kane, 1985] pg. 68. “Dynamics: Theory and Applications,” McGraw-Hill
Co., New York, 1985 (with D. A. Levinson). Available for free .pdf
download: <a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<p>Various methods in this class require numerical (not symbolic) data
types.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].CopyToFullMatrix3">
<code class="descname">CopyToFullMatrix3</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 3]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].CopyToFullMatrix3" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a full 3x3 matrix copy of this rotational inertia. The returned
copy is symmetric and includes both lower and upper parts of the
matrix.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RotationalInertia_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class describes the mass distribution (inertia properties) of a
body or composite body about a particular point. Herein, “composite
body” means one body or a collection of bodies that are welded
together. In this documentation, “body” and “composite body” are used
interchangeably.</p>
<p>A <strong>rigid</strong> body’s mass distribution is described by three quantities:
the body’s mass; the body’s center of mass; and the body’s rotational
inertia about a particular point. The term <strong>rotational inertia</strong> is
used here and by [Jain 2010] to distinguish from a body’s <strong>spatial
inertia</strong>. In this class, a 3x3 <strong>inertia matrix</strong> I represents a
body’s rotational inertia about a point and expressed in a frame. More
specifically, <code class="docutils literal"><span class="pre">I_BP_E</span></code> is the inertia matrix of a body B about-point
P and expressed-in frame E (herein frame E’s orthogonal unit vectors
Ex, Ey, Ez are denoted 𝐱̂, 𝐲̂, 𝐳̂).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span> <span class="n">Ixx</span> <span class="n">Ixy</span> <span class="n">Ixz</span> <span class="o">|</span>
<span class="n">I</span> <span class="o">=</span> <span class="o">|</span> <span class="n">Ixy</span> <span class="n">Iyy</span> <span class="n">Iyz</span> <span class="o">|</span>
    <span class="o">|</span> <span class="n">Ixz</span> <span class="n">Iyz</span> <span class="n">Izz</span> <span class="o">|</span>
</pre></div>
</div>
<p>The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz,
Iyz are defined in terms of the mass dm of a differential volume of
the body. The position of dm from about-point P is xx̂ + yŷ + zẑ =
[x, y, z]_E.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Ixx = ∫ (y² + z²) dm
Iyy = ∫ (x² + z²) dm
Izz = ∫ (x² + y²) dm
Ixy = - ∫ x y dm
Ixz = - ∫ x z dm
Iyz = - ∫ y z dm
</pre></div>
</div>
<p>We use the negated convention for products of inertia, so that I
serves to relate angular velocity ω and angular momentum h via <code class="docutils literal"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">I</span>
<span class="pre">⋅</span> <span class="pre">ω</span></code>. Ensure your products of inertia follow this negative sign
convention.</p>
<p>The 3x3 inertia matrix is symmetric and its diagonal elements (moments
of inertia) and off-diagonal elements (products of inertia) are
associated with a body (or composite body) S, an about-point P, and an
expressed-in frame E (𝐱̂, 𝐲̂, 𝐳̂̂). A rotational inertia is
ill-defined unless there is a body S, about-point P, and expressed-in
frame E. The user of this class is responsible for tracking the body
S, about-point P and expressed-in frame E (none of these are stored in
this class).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the about-point nor the expressed-in
frame, nor does this class help enforce consistency of the
about-point or expressed-in frame. To help users of this class
track the about-point and expressed-in frame, we strongly
recommend the following notation.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In typeset material, use the symbol <span class="math">\([I^{S/P}]_E\)</span> to
represent the rotational inertia (inertia matrix) of a body (or
composite body) S about-point P, expressed in frame E. In code and
comments, use the monogram notation <code class="docutils literal"><span class="pre">I_SP_E</span></code> (e.g., as described
in multibody_spatial_inertia). If the about-point P is fixed to a
body B, the point is named <span class="math">\(B_P\)</span> and this appears in
code/comments as <code class="docutils literal"><span class="pre">Bp</span></code>. Examples: <code class="docutils literal"><span class="pre">I_BBp_E</span></code> is rigid body B’s
rotational inertia about-point Bp expressed-in frame E; I_BBo_E is
B’s rotational inertia about-point <code class="docutils literal"><span class="pre">Bo</span></code> (body B’s origin)
expressed-in frame E; and I_BBcm_E is B’s inertia matrix
about-point <code class="docutils literal"><span class="pre">Bcm</span></code> (B’s center of mass) expressed-in frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The rotational inertia (inertia matrix) can be re-expressed in
terms of a special frame whose orthogonal unit vectors are
parallel to <strong>principal axes of inertia</strong> so that the inertia
matrix is diagonalized with elements called <strong>principal moments of
inertia</strong>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The formal definition of the inertia matrix <span class="math">\(I^{S/P}\)</span> of a
system S about a point P follows the definition of the inertia
dyadic 𝐈 of S about P, which begins by modeling S with n particles
S₁ … Sₙ (e.g., 12 grams of carbon can be modeled with n = 6.02 *
10²³ molecules/particles). The inertia dyadic 𝐈₁ of one particle
S₁ about point P is defined [Kane, 1985] in terms of m₁ (mass of
S₁), ᴾ𝐩ˢ¹ (position vector from P to S₁), and the unit dyadic 𝐔
which is defined by the property 𝐔 ⋅ 𝐯 = 𝐯 where 𝐯 is is any
vector (this definition of 𝐔 is analogous to defining the identity
matrix by the property 𝑰𝒅𝒆𝒏𝒕𝒊𝒕𝒚𝑴𝒂𝒕𝒓𝒊𝒙 * 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙 = 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙).</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐈₁ = m₁ * [𝐔 * (ᴾ𝐩ˢ¹ ⋅ ᴾ𝐩ˢ¹)  -  ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹]
</pre></div>
</div>
<p>Note: The vector dot-product (⋅) above produces a scalar whereas the
vector multiply (*) produces a dyadic which is a 2nd-order tensor
(ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹ is similar to the matrix outer-product of a 3x1 matrix
multiplied by a 1x3 matrix). An example inertia dyadic for a single
particle is shown further below. The inertia dyadic 𝐈 of the entire
system S is defined by summing the inertia dyadic of each particle Sᵢ
about P (i = 1, … n), i.e.,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐈 = 𝐈₁ + 𝐈₂ + ... 𝐈ₙ
</pre></div>
</div>
<p>The elements of the inertia matrix <span class="math">\([I^{S/P}]_E\)</span> expressed in
frame E (in terms of orthogonal unit vectors 𝐱̂, 𝐲̂, 𝐳̂̂) are found by
pre-dot multiplying and post-dot multiplying 𝐈 with appropriate unit
vectors.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Ixx = 𝐱̂ ⋅ 𝐈 ⋅ 𝐱̂     Ixy = 𝐱̂ ⋅ 𝐈 ⋅ 𝐲̂      Ixz = 𝐱̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Iyx = 𝐲̂ ⋅ 𝐈 ⋅ 𝐱̂     Iyy = 𝐲̂ ⋅ 𝐈 ⋅ 𝐲̂      Iyz = 𝐲̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Izx = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐱̂     Izy = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐲̂      Izz = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐳̂̂
</pre></div>
</div>
<p>The inertia dyadic 𝐈ᴮ of a rigid body B about Bcm (B’s center of mass)
is related to various dynamic quantities. For example, B’s angular
momentum 𝐇 about Bcm in a frame N and B’s kinetic energy KE in N
relate to 𝐈ᴮ by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐇 = 𝐈ᴮ ⋅ 𝛚
   KE = 1/2 𝛚 ⋅ 𝐈ᴮ ⋅ 𝛚  +  1/2 mᴮ 𝐯 ⋅ 𝐯
</pre></div>
</div>
<p>where 𝛚 is B’s angular velocity in N, 𝐯 is Bcm’s translational
velocity in N, and mᴮ is B’s mass. When frame N happens to be a
Newtonian frame (also called an inertial frame or
non-rotating/non-accelerating frame), the moment 𝐓 of all forces on B
about Bcm relates to 𝐈ᴮ and 𝛂 (B’s angular acceleration in N) by
Euler’s rigid body equation as</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐓 = 𝐈ᴮ ⋅ 𝛂  +  𝛚 × 𝐈ᴮ ⋅ 𝛚
</pre></div>
</div>
<p>Example: For a particle Q of mass m whose position vector from a point
O is written in terms of right-handed orthogonal unit vectors 𝐱̂, 𝐲̂,
𝐳̂ (below), the inertia dyadic 𝐈 of particle Q about point O is
defined and calculated</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐩 = x 𝐱̂  +  y 𝐲̂                               (given)
    𝐈 = m * [𝐔 * (𝐩 ⋅ 𝐩)  -  𝐩 * 𝐩]              (definition)
      = m * [𝐔 * (x² + y²)  -  (x𝐱̂ + y𝐲̂̂) * (x𝐱̂ + y𝐲̂)
      = m * [(𝐱̂𝐱̂ + 𝐲̂𝐲̂ + 𝐳̂𝐳̂) * (x² + y²) - (x²𝐱̂𝐱̂ + xy𝐱̂𝐲̂̂ + xy𝐲̂̂𝐱̂ + y²𝐲̂̂𝐲̂̂)]
      = m * [y²𝐱̂𝐱̂ + x²𝐲̂𝐲̂ + (x² + y²)𝐳̂𝐳̂ - xy𝐱̂𝐲̂̂ - xy𝐲̂̂𝐱̂]
</pre></div>
</div>
<p>which means the inertia matrix for particle Q about point O for 𝐱̂,
𝐲̂, 𝐳̂ is</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>|  m y²     -m x y         0     |
I = | -m x y     m x²          0     |
    |    0         0     m (x² + y²) |
</pre></div>
</div>
<p>[Kane, 1985] pg. 68. “Dynamics: Theory and Applications,” McGraw-Hill
Co., New York, 1985 (with D. A. Levinson). Available for free .pdf
download: <a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<p>Various methods in this class require numerical (not symbolic) data
types.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].CopyToFullMatrix3">
<code class="descname">CopyToFullMatrix3</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 3]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].CopyToFullMatrix3" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a full 3x3 matrix copy of this rotational inertia. The returned
copy is symmetric and includes both lower and upper parts of the
matrix.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RotationalInertia_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RotationalInertia_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class describes the mass distribution (inertia properties) of a
body or composite body about a particular point. Herein, “composite
body” means one body or a collection of bodies that are welded
together. In this documentation, “body” and “composite body” are used
interchangeably.</p>
<p>A <strong>rigid</strong> body’s mass distribution is described by three quantities:
the body’s mass; the body’s center of mass; and the body’s rotational
inertia about a particular point. The term <strong>rotational inertia</strong> is
used here and by [Jain 2010] to distinguish from a body’s <strong>spatial
inertia</strong>. In this class, a 3x3 <strong>inertia matrix</strong> I represents a
body’s rotational inertia about a point and expressed in a frame. More
specifically, <code class="docutils literal"><span class="pre">I_BP_E</span></code> is the inertia matrix of a body B about-point
P and expressed-in frame E (herein frame E’s orthogonal unit vectors
Ex, Ey, Ez are denoted 𝐱̂, 𝐲̂, 𝐳̂).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span> <span class="n">Ixx</span> <span class="n">Ixy</span> <span class="n">Ixz</span> <span class="o">|</span>
<span class="n">I</span> <span class="o">=</span> <span class="o">|</span> <span class="n">Ixy</span> <span class="n">Iyy</span> <span class="n">Iyz</span> <span class="o">|</span>
    <span class="o">|</span> <span class="n">Ixz</span> <span class="n">Iyz</span> <span class="n">Izz</span> <span class="o">|</span>
</pre></div>
</div>
<p>The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz,
Iyz are defined in terms of the mass dm of a differential volume of
the body. The position of dm from about-point P is xx̂ + yŷ + zẑ =
[x, y, z]_E.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Ixx = ∫ (y² + z²) dm
Iyy = ∫ (x² + z²) dm
Izz = ∫ (x² + y²) dm
Ixy = - ∫ x y dm
Ixz = - ∫ x z dm
Iyz = - ∫ y z dm
</pre></div>
</div>
<p>We use the negated convention for products of inertia, so that I
serves to relate angular velocity ω and angular momentum h via <code class="docutils literal"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">I</span>
<span class="pre">⋅</span> <span class="pre">ω</span></code>. Ensure your products of inertia follow this negative sign
convention.</p>
<p>The 3x3 inertia matrix is symmetric and its diagonal elements (moments
of inertia) and off-diagonal elements (products of inertia) are
associated with a body (or composite body) S, an about-point P, and an
expressed-in frame E (𝐱̂, 𝐲̂, 𝐳̂̂). A rotational inertia is
ill-defined unless there is a body S, about-point P, and expressed-in
frame E. The user of this class is responsible for tracking the body
S, about-point P and expressed-in frame E (none of these are stored in
this class).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the about-point nor the expressed-in
frame, nor does this class help enforce consistency of the
about-point or expressed-in frame. To help users of this class
track the about-point and expressed-in frame, we strongly
recommend the following notation.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In typeset material, use the symbol <span class="math">\([I^{S/P}]_E\)</span> to
represent the rotational inertia (inertia matrix) of a body (or
composite body) S about-point P, expressed in frame E. In code and
comments, use the monogram notation <code class="docutils literal"><span class="pre">I_SP_E</span></code> (e.g., as described
in multibody_spatial_inertia). If the about-point P is fixed to a
body B, the point is named <span class="math">\(B_P\)</span> and this appears in
code/comments as <code class="docutils literal"><span class="pre">Bp</span></code>. Examples: <code class="docutils literal"><span class="pre">I_BBp_E</span></code> is rigid body B’s
rotational inertia about-point Bp expressed-in frame E; I_BBo_E is
B’s rotational inertia about-point <code class="docutils literal"><span class="pre">Bo</span></code> (body B’s origin)
expressed-in frame E; and I_BBcm_E is B’s inertia matrix
about-point <code class="docutils literal"><span class="pre">Bcm</span></code> (B’s center of mass) expressed-in frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The rotational inertia (inertia matrix) can be re-expressed in
terms of a special frame whose orthogonal unit vectors are
parallel to <strong>principal axes of inertia</strong> so that the inertia
matrix is diagonalized with elements called <strong>principal moments of
inertia</strong>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The formal definition of the inertia matrix <span class="math">\(I^{S/P}\)</span> of a
system S about a point P follows the definition of the inertia
dyadic 𝐈 of S about P, which begins by modeling S with n particles
S₁ … Sₙ (e.g., 12 grams of carbon can be modeled with n = 6.02 *
10²³ molecules/particles). The inertia dyadic 𝐈₁ of one particle
S₁ about point P is defined [Kane, 1985] in terms of m₁ (mass of
S₁), ᴾ𝐩ˢ¹ (position vector from P to S₁), and the unit dyadic 𝐔
which is defined by the property 𝐔 ⋅ 𝐯 = 𝐯 where 𝐯 is is any
vector (this definition of 𝐔 is analogous to defining the identity
matrix by the property 𝑰𝒅𝒆𝒏𝒕𝒊𝒕𝒚𝑴𝒂𝒕𝒓𝒊𝒙 * 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙 = 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙).</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐈₁ = m₁ * [𝐔 * (ᴾ𝐩ˢ¹ ⋅ ᴾ𝐩ˢ¹)  -  ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹]
</pre></div>
</div>
<p>Note: The vector dot-product (⋅) above produces a scalar whereas the
vector multiply (*) produces a dyadic which is a 2nd-order tensor
(ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹ is similar to the matrix outer-product of a 3x1 matrix
multiplied by a 1x3 matrix). An example inertia dyadic for a single
particle is shown further below. The inertia dyadic 𝐈 of the entire
system S is defined by summing the inertia dyadic of each particle Sᵢ
about P (i = 1, … n), i.e.,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐈 = 𝐈₁ + 𝐈₂ + ... 𝐈ₙ
</pre></div>
</div>
<p>The elements of the inertia matrix <span class="math">\([I^{S/P}]_E\)</span> expressed in
frame E (in terms of orthogonal unit vectors 𝐱̂, 𝐲̂, 𝐳̂̂) are found by
pre-dot multiplying and post-dot multiplying 𝐈 with appropriate unit
vectors.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Ixx = 𝐱̂ ⋅ 𝐈 ⋅ 𝐱̂     Ixy = 𝐱̂ ⋅ 𝐈 ⋅ 𝐲̂      Ixz = 𝐱̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Iyx = 𝐲̂ ⋅ 𝐈 ⋅ 𝐱̂     Iyy = 𝐲̂ ⋅ 𝐈 ⋅ 𝐲̂      Iyz = 𝐲̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Izx = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐱̂     Izy = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐲̂      Izz = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐳̂̂
</pre></div>
</div>
<p>The inertia dyadic 𝐈ᴮ of a rigid body B about Bcm (B’s center of mass)
is related to various dynamic quantities. For example, B’s angular
momentum 𝐇 about Bcm in a frame N and B’s kinetic energy KE in N
relate to 𝐈ᴮ by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐇 = 𝐈ᴮ ⋅ 𝛚
   KE = 1/2 𝛚 ⋅ 𝐈ᴮ ⋅ 𝛚  +  1/2 mᴮ 𝐯 ⋅ 𝐯
</pre></div>
</div>
<p>where 𝛚 is B’s angular velocity in N, 𝐯 is Bcm’s translational
velocity in N, and mᴮ is B’s mass. When frame N happens to be a
Newtonian frame (also called an inertial frame or
non-rotating/non-accelerating frame), the moment 𝐓 of all forces on B
about Bcm relates to 𝐈ᴮ and 𝛂 (B’s angular acceleration in N) by
Euler’s rigid body equation as</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐓 = 𝐈ᴮ ⋅ 𝛂  +  𝛚 × 𝐈ᴮ ⋅ 𝛚
</pre></div>
</div>
<p>Example: For a particle Q of mass m whose position vector from a point
O is written in terms of right-handed orthogonal unit vectors 𝐱̂, 𝐲̂,
𝐳̂ (below), the inertia dyadic 𝐈 of particle Q about point O is
defined and calculated</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>𝐩 = x 𝐱̂  +  y 𝐲̂                               (given)
    𝐈 = m * [𝐔 * (𝐩 ⋅ 𝐩)  -  𝐩 * 𝐩]              (definition)
      = m * [𝐔 * (x² + y²)  -  (x𝐱̂ + y𝐲̂̂) * (x𝐱̂ + y𝐲̂)
      = m * [(𝐱̂𝐱̂ + 𝐲̂𝐲̂ + 𝐳̂𝐳̂) * (x² + y²) - (x²𝐱̂𝐱̂ + xy𝐱̂𝐲̂̂ + xy𝐲̂̂𝐱̂ + y²𝐲̂̂𝐲̂̂)]
      = m * [y²𝐱̂𝐱̂ + x²𝐲̂𝐲̂ + (x² + y²)𝐳̂𝐳̂ - xy𝐱̂𝐲̂̂ - xy𝐲̂̂𝐱̂]
</pre></div>
</div>
<p>which means the inertia matrix for particle Q about point O for 𝐱̂,
𝐲̂, 𝐳̂ is</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>|  m y²     -m x y         0     |
I = | -m x y     m x²          0     |
    |    0         0     m (x² + y²) |
</pre></div>
</div>
<p>[Kane, 1985] pg. 68. “Dynamics: Theory and Applications,” McGraw-Hill
Co., New York, 1985 (with D. A. Levinson). Available for free .pdf
download: <a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<p>Various methods in this class require numerical (not symbolic) data
types.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].CopyToFullMatrix3">
<code class="descname">CopyToFullMatrix3</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 3]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].CopyToFullMatrix3" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a full 3x3 matrix copy of this rotational inertia. The returned
copy is symmetric and includes both lower and upper parts of the
matrix.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.SpatialInertia">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">SpatialInertia</code><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.SpatialInertia_[float]" title="pydrake.multibody.tree.SpatialInertia_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.SpatialInertia_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.SpatialInertia_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">SpatialInertia_</code><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.SpatialInertia_[float]" title="pydrake.multibody.tree.SpatialInertia_[float]"><code class="xref py py-class docutils literal"><span class="pre">SpatialInertia_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]" title="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">SpatialInertia_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.SpatialInertia_[Expression]" title="pydrake.multibody.tree.SpatialInertia_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">SpatialInertia_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float]">
<em class="property">class </em><code class="descname">SpatialInertia_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents the physical concept of a <em>Spatial Inertia</em>. A
spatial inertia (or spatial mass matrix) encapsulates the mass, center
of mass, and rotational inertia of the mass distribution of a body or
composite body S, where with “composite body” we mean a collection of
bodies welded together containing at least one body (throughout this
documentation “body” is many times used instead of “composite body”
but the same concepts apply to a collection of bodies as well.) A
spatial inertia is an element of ℝ⁶ˣ⁶ that is symmetric, and positive
semi-definite. It logically consists of <code class="docutils literal"><span class="pre">3x3</span></code> sub-matrices arranged
like so, [Jain 2010]:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Spatial mass matrix
          ------------ ------------
       0 |            |            |
       1 |    I_SP    | m p_PScm×  |
       2 |            |            |
          ------------ ------------
       3 |            |            |
       4 | -m p_PScm× |     m Id   |
       5 |            |            |
          ------------ ------------
               Symbol: M
</pre></div>
</div>
<p>where, with the monogram notation described in
multibody_spatial_inertia, <code class="docutils literal"><span class="pre">I_SP</span></code> is the rotational inertia of body
or composite body S computed about a point P, m is the mass of this
composite body, <code class="docutils literal"><span class="pre">p_PScm</span></code> is the position vector from point P to the
center of mass <code class="docutils literal"><span class="pre">Scm</span></code> of the composite body S with <code class="docutils literal"><span class="pre">p_PScm×</span></code>
denoting its skew-symmetric cross product matrix (defined such that
<code class="docutils literal"><span class="pre">a×</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a.cross(b)</span></code>), and <code class="docutils literal"><span class="pre">Id</span></code> is the identity matrix in ℝ³ˣ³. See
Section 2.1, p. 17 of [Jain 2010]. The logical arrangement as shown
above is chosen to be consistent with our logical arrangement for
spatial vectors as documented in multibody_spatial_algebra for which
the rotational component comes first followed by the translational
component.</p>
<p>In typeset material we use the symbol <span class="math">\([M^{S/P}]_E\)</span> to represent
the spatial inertia of a body or composite body S about point P,
expressed in frame E. For this inertia, the monogram notation reads
<code class="docutils literal"><span class="pre">M_SP_E</span></code>. If the point P is fixed to a body B, we write that point
as <span class="math">\(B_P\)</span> which appears in code and comments as <code class="docutils literal"><span class="pre">Bp</span></code>. So if the
body or composite body is B and the about point is <code class="docutils literal"><span class="pre">Bp</span></code>, the
monogram notation reads <code class="docutils literal"><span class="pre">M_BBp_E</span></code>, which can be abbreviated to
<code class="docutils literal"><span class="pre">M_Bp_E</span></code> since the about point <code class="docutils literal"><span class="pre">Bp</span></code> also identifies the body.
Common cases are that the about point is the origin <code class="docutils literal"><span class="pre">Bo</span></code> of the
body, or it’s the center of mass <code class="docutils literal"><span class="pre">Bcm</span></code> for which the rotational
inertia in monogram notation would read as <code class="docutils literal"><span class="pre">I_Bo_E</span></code> and <code class="docutils literal"><span class="pre">I_Bcm_E</span></code>,
respectively. Given <code class="docutils literal"><span class="pre">M_BP_E</span></code> (<span class="math">\([M^{B/P}]_E\)</span>), the rotational
inertia of this spatial inertia is <code class="docutils literal"><span class="pre">I_BP_E</span></code> (<span class="math">\([I^{B/P}]_E\)</span>)
and the position vector of the center of mass measured from point P
and expressed in E is <code class="docutils literal"><span class="pre">p_PBcm_E</span></code> (<span class="math">\([^Pp^{B_{cm}}]_E\)</span>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not implement any mechanism to track the frame E
in which a spatial inertia is expressed or about what point is
computed. Methods and operators on this class have no means to
determine frame consistency through operations. It is therefore
the responsibility of users of this class to keep track of frames
in which operations are performed. We suggest doing that using
disciplined notation, as described above.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Jain 2010]  Jain, A., 2010. Robot and multibody dynamics: analysis and</dt>
<dd>algorithms. Springer Science &amp; Business Media.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; None</li>
</ol>
<p>Default SpatialInertia constructor initializes mass, center of mass
and rotational inertia to invalid NaN’s for a quick detection of
uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[float], mass: float, p_PScm_E: numpy.ndarray[numpy.float64[3, 1]], G_SP_E: pydrake.multibody.tree.UnitInertia_[float], skip_validity_check: bool = False) -&gt; None</li>
</ol>
<p>Constructs a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass and rotational
inertia. The center of mass is specified by the position vector
<code class="docutils literal"><span class="pre">p_PScm_E</span></code> from point P to the center of mass point <code class="docutils literal"><span class="pre">Scm</span></code>,
expressed in a frame E. The rotational inertia is provided as the
UnitInertia <code class="docutils literal"><span class="pre">G_SP_E</span></code> of the body or composite body S computed about
point P and expressed in frame E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The third argument of this constructor is unusual in that it is an
UnitInertia (not a traditional RotationalInertia) and its inertia
is about the arbitrary point P (not Scm – S’s center of mass).</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MakeFromCentralInertia a factory method with traditional utility.</p>
</div>
<p>This constructor checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to
non-physically viable spatial inertia. Since this check has
non-negligable runtime costs, it can be disabled by setting the
optional argument <code class="docutils literal"><span class="pre">skip_validity_check</span></code> to <code class="docutils literal"><span class="pre">True</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">mass</span></code>:</dt>
<dd>The mass of the body or composite body S.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_PScm_E</span></code>:</dt>
<dd>The position vector from point P to the center of mass of body or
composite body S expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">G_SP_E</span></code>:</dt>
<dd>UnitInertia of the body or composite body S computed about origin
point P and expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">skip_validity_check</span></code>:</dt>
<dd>If true, skips the validity check described above. Defaults to
false.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].CalcComMoment">
<code class="descname">CalcComMoment</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].CalcComMoment" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the center of mass moment vector <code class="docutils literal"><span class="pre">mass</span> <span class="pre">*</span> <span class="pre">p_PScm_E</span></code> given
the position vector <code class="docutils literal"><span class="pre">p_PScm_E</span></code> from the <em>about point</em> P to the
center of mass <code class="docutils literal"><span class="pre">Scm</span></code> of the body or composite body S, expressed in
frame E. See the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].CalcRotationalInertia">
<code class="descname">CalcRotationalInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].CalcRotationalInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the rotational inertia <code class="docutils literal"><span class="pre">I_SP_E</span> <span class="pre">=</span> <span class="pre">mass</span> <span class="pre">*</span> <span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].CopyToFullMatrix6">
<code class="descname">CopyToFullMatrix6</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 6]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].CopyToFullMatrix6" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy to a full 6x6 matrix representation.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].get_com">
<code class="descname">get_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].get_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the position vector <code class="docutils literal"><span class="pre">p_PScm_E</span></code> from the
<em>about point</em> P to the center of mass <code class="docutils literal"><span class="pre">Scm</span></code> of the body or composite
body S, expressed in frame E. See the documentation of this class for
details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].get_mass">
<code class="descname">get_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].get_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the mass of this spatial inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].get_unit_inertia">
<code class="descname">get_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].get_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the unit inertia <code class="docutils literal"><span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].IsNaN">
<code class="descname">IsNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].IsNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if any of the elements in this spatial inertia is NaN
and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].IsPhysicallyValid">
<code class="descname">IsPhysicallyValid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].IsPhysicallyValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a number of checks to verify that this is a physically valid
spatial inertia. The checks performed are:</p>
<ul class="simple">
<li>No NaN entries.</li>
<li>Non-negative mass.</li>
<li>Non-negative principal moments about the center of mass.</li>
<li>Principal moments about the center of mass must satisfy the triangle
inequality:
- <code class="docutils literal"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">&gt;=</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz &gt;= Iyy</cite>
- <code class="docutils literal"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">&gt;=</span> <span class="pre">Ixx</span></code></li>
</ul>
<p>These are the tests performed by
RotationalInertia::CouldBePhysicallyValid() which become a sufficient
condition when performed on a rotational inertia about a body’s center
of mass.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationalInertia::CouldBePhysicallyValid().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float], R_AE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal"><span class="pre">this</span></code> spatial inertia <code class="docutils literal"><span class="pre">M_SP_E</span></code> for some body or composite
body S, taken about a point P and expressed in frame E, this method
computes the same inertia re-expressed in another frame A.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">M_SP_A</span></code>:</dt>
<dd>The same spatial inertia of S about P but now re-expressed in
frame A.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ReExpressInPlace() for details.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].SetNaN">
<code class="descname">SetNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].SetNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> spatial inertia to have NaN entries. Typically used for
quick detection of uninitialized values.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float], p_PQ_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal"><span class="pre">this</span></code> spatial inertia <code class="docutils literal"><span class="pre">M_SP_E</span></code> for some body or composite
body S, computed about point P, and expressed in frame E, this method
uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the
same spatial inertia about a new point Q. The result still is
expressed in frame E.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more details.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Vector from the original about point P to the new about point Q,
expressed in the same frame E <code class="docutils literal"><span class="pre">this</span></code> spatial inertia is
expressed in.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">M_SQ_E</span></code>:</dt>
<dd>This same spatial inertia for body or composite body S but
computed about about a new point Q.</dd>
</dl>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">SpatialInertia_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents the physical concept of a <em>Spatial Inertia</em>. A
spatial inertia (or spatial mass matrix) encapsulates the mass, center
of mass, and rotational inertia of the mass distribution of a body or
composite body S, where with “composite body” we mean a collection of
bodies welded together containing at least one body (throughout this
documentation “body” is many times used instead of “composite body”
but the same concepts apply to a collection of bodies as well.) A
spatial inertia is an element of ℝ⁶ˣ⁶ that is symmetric, and positive
semi-definite. It logically consists of <code class="docutils literal"><span class="pre">3x3</span></code> sub-matrices arranged
like so, [Jain 2010]:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Spatial mass matrix
          ------------ ------------
       0 |            |            |
       1 |    I_SP    | m p_PScm×  |
       2 |            |            |
          ------------ ------------
       3 |            |            |
       4 | -m p_PScm× |     m Id   |
       5 |            |            |
          ------------ ------------
               Symbol: M
</pre></div>
</div>
<p>where, with the monogram notation described in
multibody_spatial_inertia, <code class="docutils literal"><span class="pre">I_SP</span></code> is the rotational inertia of body
or composite body S computed about a point P, m is the mass of this
composite body, <code class="docutils literal"><span class="pre">p_PScm</span></code> is the position vector from point P to the
center of mass <code class="docutils literal"><span class="pre">Scm</span></code> of the composite body S with <code class="docutils literal"><span class="pre">p_PScm×</span></code>
denoting its skew-symmetric cross product matrix (defined such that
<code class="docutils literal"><span class="pre">a×</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a.cross(b)</span></code>), and <code class="docutils literal"><span class="pre">Id</span></code> is the identity matrix in ℝ³ˣ³. See
Section 2.1, p. 17 of [Jain 2010]. The logical arrangement as shown
above is chosen to be consistent with our logical arrangement for
spatial vectors as documented in multibody_spatial_algebra for which
the rotational component comes first followed by the translational
component.</p>
<p>In typeset material we use the symbol <span class="math">\([M^{S/P}]_E\)</span> to represent
the spatial inertia of a body or composite body S about point P,
expressed in frame E. For this inertia, the monogram notation reads
<code class="docutils literal"><span class="pre">M_SP_E</span></code>. If the point P is fixed to a body B, we write that point
as <span class="math">\(B_P\)</span> which appears in code and comments as <code class="docutils literal"><span class="pre">Bp</span></code>. So if the
body or composite body is B and the about point is <code class="docutils literal"><span class="pre">Bp</span></code>, the
monogram notation reads <code class="docutils literal"><span class="pre">M_BBp_E</span></code>, which can be abbreviated to
<code class="docutils literal"><span class="pre">M_Bp_E</span></code> since the about point <code class="docutils literal"><span class="pre">Bp</span></code> also identifies the body.
Common cases are that the about point is the origin <code class="docutils literal"><span class="pre">Bo</span></code> of the
body, or it’s the center of mass <code class="docutils literal"><span class="pre">Bcm</span></code> for which the rotational
inertia in monogram notation would read as <code class="docutils literal"><span class="pre">I_Bo_E</span></code> and <code class="docutils literal"><span class="pre">I_Bcm_E</span></code>,
respectively. Given <code class="docutils literal"><span class="pre">M_BP_E</span></code> (<span class="math">\([M^{B/P}]_E\)</span>), the rotational
inertia of this spatial inertia is <code class="docutils literal"><span class="pre">I_BP_E</span></code> (<span class="math">\([I^{B/P}]_E\)</span>)
and the position vector of the center of mass measured from point P
and expressed in E is <code class="docutils literal"><span class="pre">p_PBcm_E</span></code> (<span class="math">\([^Pp^{B_{cm}}]_E\)</span>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not implement any mechanism to track the frame E
in which a spatial inertia is expressed or about what point is
computed. Methods and operators on this class have no means to
determine frame consistency through operations. It is therefore
the responsibility of users of this class to keep track of frames
in which operations are performed. We suggest doing that using
disciplined notation, as described above.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Jain 2010]  Jain, A., 2010. Robot and multibody dynamics: analysis and</dt>
<dd>algorithms. Springer Science &amp; Business Media.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Default SpatialInertia constructor initializes mass, center of mass
and rotational inertia to invalid NaN’s for a quick detection of
uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd], mass: pydrake.autodiffutils.AutoDiffXd, p_PScm_E: numpy.ndarray[object[3, 1]], G_SP_E: pydrake.multibody.tree.UnitInertia_[AutoDiffXd], skip_validity_check: bool = False) -&gt; None</li>
</ol>
<p>Constructs a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass and rotational
inertia. The center of mass is specified by the position vector
<code class="docutils literal"><span class="pre">p_PScm_E</span></code> from point P to the center of mass point <code class="docutils literal"><span class="pre">Scm</span></code>,
expressed in a frame E. The rotational inertia is provided as the
UnitInertia <code class="docutils literal"><span class="pre">G_SP_E</span></code> of the body or composite body S computed about
point P and expressed in frame E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The third argument of this constructor is unusual in that it is an
UnitInertia (not a traditional RotationalInertia) and its inertia
is about the arbitrary point P (not Scm – S’s center of mass).</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MakeFromCentralInertia a factory method with traditional utility.</p>
</div>
<p>This constructor checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to
non-physically viable spatial inertia. Since this check has
non-negligable runtime costs, it can be disabled by setting the
optional argument <code class="docutils literal"><span class="pre">skip_validity_check</span></code> to <code class="docutils literal"><span class="pre">True</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">mass</span></code>:</dt>
<dd>The mass of the body or composite body S.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_PScm_E</span></code>:</dt>
<dd>The position vector from point P to the center of mass of body or
composite body S expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">G_SP_E</span></code>:</dt>
<dd>UnitInertia of the body or composite body S computed about origin
point P and expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">skip_validity_check</span></code>:</dt>
<dd>If true, skips the validity check described above. Defaults to
false.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].CalcComMoment">
<code class="descname">CalcComMoment</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].CalcComMoment" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the center of mass moment vector <code class="docutils literal"><span class="pre">mass</span> <span class="pre">*</span> <span class="pre">p_PScm_E</span></code> given
the position vector <code class="docutils literal"><span class="pre">p_PScm_E</span></code> from the <em>about point</em> P to the
center of mass <code class="docutils literal"><span class="pre">Scm</span></code> of the body or composite body S, expressed in
frame E. See the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].CalcRotationalInertia">
<code class="descname">CalcRotationalInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].CalcRotationalInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the rotational inertia <code class="docutils literal"><span class="pre">I_SP_E</span> <span class="pre">=</span> <span class="pre">mass</span> <span class="pre">*</span> <span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].CopyToFullMatrix6">
<code class="descname">CopyToFullMatrix6</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 6]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].CopyToFullMatrix6" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy to a full 6x6 matrix representation.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].get_com">
<code class="descname">get_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].get_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the position vector <code class="docutils literal"><span class="pre">p_PScm_E</span></code> from the
<em>about point</em> P to the center of mass <code class="docutils literal"><span class="pre">Scm</span></code> of the body or composite
body S, expressed in frame E. See the documentation of this class for
details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].get_mass">
<code class="descname">get_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].get_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the mass of this spatial inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].get_unit_inertia">
<code class="descname">get_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].get_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the unit inertia <code class="docutils literal"><span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].IsNaN">
<code class="descname">IsNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].IsNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if any of the elements in this spatial inertia is NaN
and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].IsPhysicallyValid">
<code class="descname">IsPhysicallyValid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].IsPhysicallyValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a number of checks to verify that this is a physically valid
spatial inertia. The checks performed are:</p>
<ul class="simple">
<li>No NaN entries.</li>
<li>Non-negative mass.</li>
<li>Non-negative principal moments about the center of mass.</li>
<li>Principal moments about the center of mass must satisfy the triangle
inequality:
- <code class="docutils literal"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">&gt;=</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz &gt;= Iyy</cite>
- <code class="docutils literal"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">&gt;=</span> <span class="pre">Ixx</span></code></li>
</ul>
<p>These are the tests performed by
RotationalInertia::CouldBePhysicallyValid() which become a sufficient
condition when performed on a rotational inertia about a body’s center
of mass.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationalInertia::CouldBePhysicallyValid().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd], R_AE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal"><span class="pre">this</span></code> spatial inertia <code class="docutils literal"><span class="pre">M_SP_E</span></code> for some body or composite
body S, taken about a point P and expressed in frame E, this method
computes the same inertia re-expressed in another frame A.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">M_SP_A</span></code>:</dt>
<dd>The same spatial inertia of S about P but now re-expressed in
frame A.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ReExpressInPlace() for details.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].SetNaN">
<code class="descname">SetNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].SetNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> spatial inertia to have NaN entries. Typically used for
quick detection of uninitialized values.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd], p_PQ_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal"><span class="pre">this</span></code> spatial inertia <code class="docutils literal"><span class="pre">M_SP_E</span></code> for some body or composite
body S, computed about point P, and expressed in frame E, this method
uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the
same spatial inertia about a new point Q. The result still is
expressed in frame E.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more details.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Vector from the original about point P to the new about point Q,
expressed in the same frame E <code class="docutils literal"><span class="pre">this</span></code> spatial inertia is
expressed in.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">M_SQ_E</span></code>:</dt>
<dd>This same spatial inertia for body or composite body S but
computed about about a new point Q.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">SpatialInertia_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents the physical concept of a <em>Spatial Inertia</em>. A
spatial inertia (or spatial mass matrix) encapsulates the mass, center
of mass, and rotational inertia of the mass distribution of a body or
composite body S, where with “composite body” we mean a collection of
bodies welded together containing at least one body (throughout this
documentation “body” is many times used instead of “composite body”
but the same concepts apply to a collection of bodies as well.) A
spatial inertia is an element of ℝ⁶ˣ⁶ that is symmetric, and positive
semi-definite. It logically consists of <code class="docutils literal"><span class="pre">3x3</span></code> sub-matrices arranged
like so, [Jain 2010]:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Spatial mass matrix
          ------------ ------------
       0 |            |            |
       1 |    I_SP    | m p_PScm×  |
       2 |            |            |
          ------------ ------------
       3 |            |            |
       4 | -m p_PScm× |     m Id   |
       5 |            |            |
          ------------ ------------
               Symbol: M
</pre></div>
</div>
<p>where, with the monogram notation described in
multibody_spatial_inertia, <code class="docutils literal"><span class="pre">I_SP</span></code> is the rotational inertia of body
or composite body S computed about a point P, m is the mass of this
composite body, <code class="docutils literal"><span class="pre">p_PScm</span></code> is the position vector from point P to the
center of mass <code class="docutils literal"><span class="pre">Scm</span></code> of the composite body S with <code class="docutils literal"><span class="pre">p_PScm×</span></code>
denoting its skew-symmetric cross product matrix (defined such that
<code class="docutils literal"><span class="pre">a×</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a.cross(b)</span></code>), and <code class="docutils literal"><span class="pre">Id</span></code> is the identity matrix in ℝ³ˣ³. See
Section 2.1, p. 17 of [Jain 2010]. The logical arrangement as shown
above is chosen to be consistent with our logical arrangement for
spatial vectors as documented in multibody_spatial_algebra for which
the rotational component comes first followed by the translational
component.</p>
<p>In typeset material we use the symbol <span class="math">\([M^{S/P}]_E\)</span> to represent
the spatial inertia of a body or composite body S about point P,
expressed in frame E. For this inertia, the monogram notation reads
<code class="docutils literal"><span class="pre">M_SP_E</span></code>. If the point P is fixed to a body B, we write that point
as <span class="math">\(B_P\)</span> which appears in code and comments as <code class="docutils literal"><span class="pre">Bp</span></code>. So if the
body or composite body is B and the about point is <code class="docutils literal"><span class="pre">Bp</span></code>, the
monogram notation reads <code class="docutils literal"><span class="pre">M_BBp_E</span></code>, which can be abbreviated to
<code class="docutils literal"><span class="pre">M_Bp_E</span></code> since the about point <code class="docutils literal"><span class="pre">Bp</span></code> also identifies the body.
Common cases are that the about point is the origin <code class="docutils literal"><span class="pre">Bo</span></code> of the
body, or it’s the center of mass <code class="docutils literal"><span class="pre">Bcm</span></code> for which the rotational
inertia in monogram notation would read as <code class="docutils literal"><span class="pre">I_Bo_E</span></code> and <code class="docutils literal"><span class="pre">I_Bcm_E</span></code>,
respectively. Given <code class="docutils literal"><span class="pre">M_BP_E</span></code> (<span class="math">\([M^{B/P}]_E\)</span>), the rotational
inertia of this spatial inertia is <code class="docutils literal"><span class="pre">I_BP_E</span></code> (<span class="math">\([I^{B/P}]_E\)</span>)
and the position vector of the center of mass measured from point P
and expressed in E is <code class="docutils literal"><span class="pre">p_PBcm_E</span></code> (<span class="math">\([^Pp^{B_{cm}}]_E\)</span>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not implement any mechanism to track the frame E
in which a spatial inertia is expressed or about what point is
computed. Methods and operators on this class have no means to
determine frame consistency through operations. It is therefore
the responsibility of users of this class to keep track of frames
in which operations are performed. We suggest doing that using
disciplined notation, as described above.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Jain 2010]  Jain, A., 2010. Robot and multibody dynamics: analysis and</dt>
<dd>algorithms. Springer Science &amp; Business Media.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[Expression]) -&gt; None</li>
</ol>
<p>Default SpatialInertia constructor initializes mass, center of mass
and rotational inertia to invalid NaN’s for a quick detection of
uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[Expression], mass: pydrake.symbolic.Expression, p_PScm_E: numpy.ndarray[object[3, 1]], G_SP_E: pydrake.multibody.tree.UnitInertia_[Expression], skip_validity_check: bool = False) -&gt; None</li>
</ol>
<p>Constructs a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass and rotational
inertia. The center of mass is specified by the position vector
<code class="docutils literal"><span class="pre">p_PScm_E</span></code> from point P to the center of mass point <code class="docutils literal"><span class="pre">Scm</span></code>,
expressed in a frame E. The rotational inertia is provided as the
UnitInertia <code class="docutils literal"><span class="pre">G_SP_E</span></code> of the body or composite body S computed about
point P and expressed in frame E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The third argument of this constructor is unusual in that it is an
UnitInertia (not a traditional RotationalInertia) and its inertia
is about the arbitrary point P (not Scm – S’s center of mass).</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MakeFromCentralInertia a factory method with traditional utility.</p>
</div>
<p>This constructor checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to
non-physically viable spatial inertia. Since this check has
non-negligable runtime costs, it can be disabled by setting the
optional argument <code class="docutils literal"><span class="pre">skip_validity_check</span></code> to <code class="docutils literal"><span class="pre">True</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">mass</span></code>:</dt>
<dd>The mass of the body or composite body S.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_PScm_E</span></code>:</dt>
<dd>The position vector from point P to the center of mass of body or
composite body S expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">G_SP_E</span></code>:</dt>
<dd>UnitInertia of the body or composite body S computed about origin
point P and expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">skip_validity_check</span></code>:</dt>
<dd>If true, skips the validity check described above. Defaults to
false.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].CalcComMoment">
<code class="descname">CalcComMoment</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].CalcComMoment" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the center of mass moment vector <code class="docutils literal"><span class="pre">mass</span> <span class="pre">*</span> <span class="pre">p_PScm_E</span></code> given
the position vector <code class="docutils literal"><span class="pre">p_PScm_E</span></code> from the <em>about point</em> P to the
center of mass <code class="docutils literal"><span class="pre">Scm</span></code> of the body or composite body S, expressed in
frame E. See the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].CalcRotationalInertia">
<code class="descname">CalcRotationalInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].CalcRotationalInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the rotational inertia <code class="docutils literal"><span class="pre">I_SP_E</span> <span class="pre">=</span> <span class="pre">mass</span> <span class="pre">*</span> <span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].CopyToFullMatrix6">
<code class="descname">CopyToFullMatrix6</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 6]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].CopyToFullMatrix6" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy to a full 6x6 matrix representation.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].get_com">
<code class="descname">get_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].get_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the position vector <code class="docutils literal"><span class="pre">p_PScm_E</span></code> from the
<em>about point</em> P to the center of mass <code class="docutils literal"><span class="pre">Scm</span></code> of the body or composite
body S, expressed in frame E. See the documentation of this class for
details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].get_mass">
<code class="descname">get_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].get_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the mass of this spatial inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].get_unit_inertia">
<code class="descname">get_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].get_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the unit inertia <code class="docutils literal"><span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].IsNaN">
<code class="descname">IsNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].IsNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if any of the elements in this spatial inertia is NaN
and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].IsPhysicallyValid">
<code class="descname">IsPhysicallyValid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].IsPhysicallyValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a number of checks to verify that this is a physically valid
spatial inertia. The checks performed are:</p>
<ul class="simple">
<li>No NaN entries.</li>
<li>Non-negative mass.</li>
<li>Non-negative principal moments about the center of mass.</li>
<li>Principal moments about the center of mass must satisfy the triangle
inequality:
- <code class="docutils literal"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">&gt;=</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz &gt;= Iyy</cite>
- <code class="docutils literal"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">&gt;=</span> <span class="pre">Ixx</span></code></li>
</ul>
<p>These are the tests performed by
RotationalInertia::CouldBePhysicallyValid() which become a sufficient
condition when performed on a rotational inertia about a body’s center
of mass.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationalInertia::CouldBePhysicallyValid().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression], R_AE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal"><span class="pre">this</span></code> spatial inertia <code class="docutils literal"><span class="pre">M_SP_E</span></code> for some body or composite
body S, taken about a point P and expressed in frame E, this method
computes the same inertia re-expressed in another frame A.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">M_SP_A</span></code>:</dt>
<dd>The same spatial inertia of S about P but now re-expressed in
frame A.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ReExpressInPlace() for details.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].SetNaN">
<code class="descname">SetNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].SetNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> spatial inertia to have NaN entries. Typically used for
quick detection of uninitialized values.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression], p_PQ_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal"><span class="pre">this</span></code> spatial inertia <code class="docutils literal"><span class="pre">M_SP_E</span></code> for some body or composite
body S, computed about point P, and expressed in frame E, this method
uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the
same spatial inertia about a new point Q. The result still is
expressed in frame E.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more details.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Vector from the original about point P to the new about point Q,
expressed in the same frame E <code class="docutils literal"><span class="pre">this</span></code> spatial inertia is
expressed in.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">M_SQ_E</span></code>:</dt>
<dd>This same spatial inertia for body or composite body S but
computed about about a new point Q.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.SpatialInertia_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">SpatialInertia_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents the physical concept of a <em>Spatial Inertia</em>. A
spatial inertia (or spatial mass matrix) encapsulates the mass, center
of mass, and rotational inertia of the mass distribution of a body or
composite body S, where with “composite body” we mean a collection of
bodies welded together containing at least one body (throughout this
documentation “body” is many times used instead of “composite body”
but the same concepts apply to a collection of bodies as well.) A
spatial inertia is an element of ℝ⁶ˣ⁶ that is symmetric, and positive
semi-definite. It logically consists of <code class="docutils literal"><span class="pre">3x3</span></code> sub-matrices arranged
like so, [Jain 2010]:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>Spatial mass matrix
          ------------ ------------
       0 |            |            |
       1 |    I_SP    | m p_PScm×  |
       2 |            |            |
          ------------ ------------
       3 |            |            |
       4 | -m p_PScm× |     m Id   |
       5 |            |            |
          ------------ ------------
               Symbol: M
</pre></div>
</div>
<p>where, with the monogram notation described in
multibody_spatial_inertia, <code class="docutils literal"><span class="pre">I_SP</span></code> is the rotational inertia of body
or composite body S computed about a point P, m is the mass of this
composite body, <code class="docutils literal"><span class="pre">p_PScm</span></code> is the position vector from point P to the
center of mass <code class="docutils literal"><span class="pre">Scm</span></code> of the composite body S with <code class="docutils literal"><span class="pre">p_PScm×</span></code>
denoting its skew-symmetric cross product matrix (defined such that
<code class="docutils literal"><span class="pre">a×</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a.cross(b)</span></code>), and <code class="docutils literal"><span class="pre">Id</span></code> is the identity matrix in ℝ³ˣ³. See
Section 2.1, p. 17 of [Jain 2010]. The logical arrangement as shown
above is chosen to be consistent with our logical arrangement for
spatial vectors as documented in multibody_spatial_algebra for which
the rotational component comes first followed by the translational
component.</p>
<p>In typeset material we use the symbol <span class="math">\([M^{S/P}]_E\)</span> to represent
the spatial inertia of a body or composite body S about point P,
expressed in frame E. For this inertia, the monogram notation reads
<code class="docutils literal"><span class="pre">M_SP_E</span></code>. If the point P is fixed to a body B, we write that point
as <span class="math">\(B_P\)</span> which appears in code and comments as <code class="docutils literal"><span class="pre">Bp</span></code>. So if the
body or composite body is B and the about point is <code class="docutils literal"><span class="pre">Bp</span></code>, the
monogram notation reads <code class="docutils literal"><span class="pre">M_BBp_E</span></code>, which can be abbreviated to
<code class="docutils literal"><span class="pre">M_Bp_E</span></code> since the about point <code class="docutils literal"><span class="pre">Bp</span></code> also identifies the body.
Common cases are that the about point is the origin <code class="docutils literal"><span class="pre">Bo</span></code> of the
body, or it’s the center of mass <code class="docutils literal"><span class="pre">Bcm</span></code> for which the rotational
inertia in monogram notation would read as <code class="docutils literal"><span class="pre">I_Bo_E</span></code> and <code class="docutils literal"><span class="pre">I_Bcm_E</span></code>,
respectively. Given <code class="docutils literal"><span class="pre">M_BP_E</span></code> (<span class="math">\([M^{B/P}]_E\)</span>), the rotational
inertia of this spatial inertia is <code class="docutils literal"><span class="pre">I_BP_E</span></code> (<span class="math">\([I^{B/P}]_E\)</span>)
and the position vector of the center of mass measured from point P
and expressed in E is <code class="docutils literal"><span class="pre">p_PBcm_E</span></code> (<span class="math">\([^Pp^{B_{cm}}]_E\)</span>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not implement any mechanism to track the frame E
in which a spatial inertia is expressed or about what point is
computed. Methods and operators on this class have no means to
determine frame consistency through operations. It is therefore
the responsibility of users of this class to keep track of frames
in which operations are performed. We suggest doing that using
disciplined notation, as described above.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Jain 2010]  Jain, A., 2010. Robot and multibody dynamics: analysis and</dt>
<dd>algorithms. Springer Science &amp; Business Media.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; None</li>
</ol>
<p>Default SpatialInertia constructor initializes mass, center of mass
and rotational inertia to invalid NaN’s for a quick detection of
uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[float], mass: float, p_PScm_E: numpy.ndarray[numpy.float64[3, 1]], G_SP_E: pydrake.multibody.tree.UnitInertia_[float], skip_validity_check: bool = False) -&gt; None</li>
</ol>
<p>Constructs a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass and rotational
inertia. The center of mass is specified by the position vector
<code class="docutils literal"><span class="pre">p_PScm_E</span></code> from point P to the center of mass point <code class="docutils literal"><span class="pre">Scm</span></code>,
expressed in a frame E. The rotational inertia is provided as the
UnitInertia <code class="docutils literal"><span class="pre">G_SP_E</span></code> of the body or composite body S computed about
point P and expressed in frame E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The third argument of this constructor is unusual in that it is an
UnitInertia (not a traditional RotationalInertia) and its inertia
is about the arbitrary point P (not Scm – S’s center of mass).</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MakeFromCentralInertia a factory method with traditional utility.</p>
</div>
<p>This constructor checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to
non-physically viable spatial inertia. Since this check has
non-negligable runtime costs, it can be disabled by setting the
optional argument <code class="docutils literal"><span class="pre">skip_validity_check</span></code> to <code class="docutils literal"><span class="pre">True</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">mass</span></code>:</dt>
<dd>The mass of the body or composite body S.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_PScm_E</span></code>:</dt>
<dd>The position vector from point P to the center of mass of body or
composite body S expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">G_SP_E</span></code>:</dt>
<dd>UnitInertia of the body or composite body S computed about origin
point P and expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">skip_validity_check</span></code>:</dt>
<dd>If true, skips the validity check described above. Defaults to
false.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].CalcComMoment">
<code class="descname">CalcComMoment</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].CalcComMoment" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the center of mass moment vector <code class="docutils literal"><span class="pre">mass</span> <span class="pre">*</span> <span class="pre">p_PScm_E</span></code> given
the position vector <code class="docutils literal"><span class="pre">p_PScm_E</span></code> from the <em>about point</em> P to the
center of mass <code class="docutils literal"><span class="pre">Scm</span></code> of the body or composite body S, expressed in
frame E. See the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].CalcRotationalInertia">
<code class="descname">CalcRotationalInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].CalcRotationalInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the rotational inertia <code class="docutils literal"><span class="pre">I_SP_E</span> <span class="pre">=</span> <span class="pre">mass</span> <span class="pre">*</span> <span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].CopyToFullMatrix6">
<code class="descname">CopyToFullMatrix6</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 6]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].CopyToFullMatrix6" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy to a full 6x6 matrix representation.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].get_com">
<code class="descname">get_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].get_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the position vector <code class="docutils literal"><span class="pre">p_PScm_E</span></code> from the
<em>about point</em> P to the center of mass <code class="docutils literal"><span class="pre">Scm</span></code> of the body or composite
body S, expressed in frame E. See the documentation of this class for
details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].get_mass">
<code class="descname">get_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].get_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the mass of this spatial inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].get_unit_inertia">
<code class="descname">get_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].get_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the unit inertia <code class="docutils literal"><span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].IsNaN">
<code class="descname">IsNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].IsNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if any of the elements in this spatial inertia is NaN
and <code class="docutils literal"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].IsPhysicallyValid">
<code class="descname">IsPhysicallyValid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].IsPhysicallyValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a number of checks to verify that this is a physically valid
spatial inertia. The checks performed are:</p>
<ul class="simple">
<li>No NaN entries.</li>
<li>Non-negative mass.</li>
<li>Non-negative principal moments about the center of mass.</li>
<li>Principal moments about the center of mass must satisfy the triangle
inequality:
- <code class="docutils literal"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">&gt;=</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz &gt;= Iyy</cite>
- <code class="docutils literal"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">&gt;=</span> <span class="pre">Ixx</span></code></li>
</ul>
<p>These are the tests performed by
RotationalInertia::CouldBePhysicallyValid() which become a sufficient
condition when performed on a rotational inertia about a body’s center
of mass.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationalInertia::CouldBePhysicallyValid().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float], R_AE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal"><span class="pre">this</span></code> spatial inertia <code class="docutils literal"><span class="pre">M_SP_E</span></code> for some body or composite
body S, taken about a point P and expressed in frame E, this method
computes the same inertia re-expressed in another frame A.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">M_SP_A</span></code>:</dt>
<dd>The same spatial inertia of S about P but now re-expressed in
frame A.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ReExpressInPlace() for details.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].SetNaN">
<code class="descname">SetNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].SetNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> spatial inertia to have NaN entries. Typically used for
quick detection of uninitialized values.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float], p_PQ_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal"><span class="pre">this</span></code> spatial inertia <code class="docutils literal"><span class="pre">M_SP_E</span></code> for some body or composite
body S, computed about point P, and expressed in frame E, this method
uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the
same spatial inertia about a new point Q. The result still is
expressed in frame E.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more details.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Vector from the original about point P to the new about point Q,
expressed in the same frame E <code class="docutils literal"><span class="pre">this</span></code> spatial inertia is
expressed in.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">M_SQ_E</span></code>:</dt>
<dd>This same spatial inertia for body or composite body S but
computed about about a new point Q.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniformGravityFieldElement</code><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.UniformGravityFieldElement_[float]" title="pydrake.multibody.tree.UniformGravityFieldElement_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniformGravityFieldElement_</code><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.UniformGravityFieldElement_[float]" title="pydrake.multibody.tree.UniformGravityFieldElement_[float]"><code class="xref py py-class docutils literal"><span class="pre">UniformGravityFieldElement_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]" title="pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">UniformGravityFieldElement_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.UniformGravityFieldElement_[Expression]" title="pydrake.multibody.tree.UniformGravityFieldElement_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">UniformGravityFieldElement_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float]">
<em class="property">class </em><code class="descname">UniformGravityFieldElement_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement allows modeling the effect of a uniform gravity
field as felt by bodies on the surface of the Earth. This gravity
field acts on all bodies in the MultibodyTree model.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[float]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a default strength (on
the earth’s surface) and direction (-z).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[float], g_W: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a strength given by
the acceleration of gravity vector <code class="docutils literal"><span class="pre">g_W</span></code>, expressed in the world
frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].gravity_vector">
<code class="descname">gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration of the gravity vector in m/s², expressed in
the world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].set_gravity_vector">
<code class="descname">set_gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[float], arg0: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].set_gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration of gravity vector, expressed in the world frame
W in m/s².</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniformGravityFieldElement_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd]" title="pydrake.multibody.tree.ForceElement_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd]</span></code></a></p>
<p>This ForceElement allows modeling the effect of a uniform gravity
field as felt by bodies on the surface of the Earth. This gravity
field acts on all bodies in the MultibodyTree model.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a default strength (on
the earth’s surface) and direction (-z).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd], g_W: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a strength given by
the acceleration of gravity vector <code class="docutils literal"><span class="pre">g_W</span></code>, expressed in the world
frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].gravity_vector">
<code class="descname">gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration of the gravity vector in m/s², expressed in
the world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].set_gravity_vector">
<code class="descname">set_gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd], arg0: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].set_gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration of gravity vector, expressed in the world frame
W in m/s².</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniformGravityFieldElement_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[Expression]" title="pydrake.multibody.tree.ForceElement_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[Expression]</span></code></a></p>
<p>This ForceElement allows modeling the effect of a uniform gravity
field as felt by bodies on the surface of the Earth. This gravity
field acts on all bodies in the MultibodyTree model.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[Expression]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a default strength (on
the earth’s surface) and direction (-z).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[Expression], g_W: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a strength given by
the acceleration of gravity vector <code class="docutils literal"><span class="pre">g_W</span></code>, expressed in the world
frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[Expression].gravity_vector">
<code class="descname">gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[Expression].gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration of the gravity vector in m/s², expressed in
the world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[Expression].set_gravity_vector">
<code class="descname">set_gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[Expression], arg0: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[Expression].set_gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration of gravity vector, expressed in the world frame
W in m/s².</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniformGravityFieldElement_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement allows modeling the effect of a uniform gravity
field as felt by bodies on the surface of the Earth. This gravity
field acts on all bodies in the MultibodyTree model.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[float]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a default strength (on
the earth’s surface) and direction (-z).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[float], g_W: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a strength given by
the acceleration of gravity vector <code class="docutils literal"><span class="pre">g_W</span></code>, expressed in the world
frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[float].gravity_vector">
<code class="descname">gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[float].gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration of the gravity vector in m/s², expressed in
the world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[float].set_gravity_vector">
<code class="descname">set_gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[float], arg0: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[float].set_gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration of gravity vector, expressed in the world frame
W in m/s².</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.UnitInertia">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UnitInertia</code><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.UnitInertia_[float]" title="pydrake.multibody.tree.UnitInertia_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.UnitInertia_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.UnitInertia_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UnitInertia_</code><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.UnitInertia_[float]" title="pydrake.multibody.tree.UnitInertia_[float]"><code class="xref py py-class docutils literal"><span class="pre">UnitInertia_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd]" title="pydrake.multibody.tree.UnitInertia_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">UnitInertia_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.UnitInertia_[Expression]" title="pydrake.multibody.tree.UnitInertia_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">UnitInertia_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float]">
<em class="property">class </em><code class="descname">UnitInertia_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[float]" title="pydrake.multibody.tree.RotationalInertia_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.RotationalInertia_[float]</span></code></a></p>
<p>This class is used to represent rotational inertias for unit mass
bodies. Therefore, unlike RotationalInertia whose units are kg⋅m², the
units of a UnitInertia are those of length squared. A unit inertia is
a useful concept to represent the geometric distribution of mass in a
body regardless of the actual value of the body mass. The rotational
inertia of a body can therefore be obtained by multiplying its unit
inertia by its mass. Unit inertia matrices can also be called
<strong>gyration</strong> matrices and therefore we choose to represent them in
source code notation with the capital letter G. In contrast, the
capital letter I is used to represent non-unit mass rotational
inertias. This class restricts the set of allowed operations on a unit
inertia to ensure the unit-mass invariant. For instance,
multiplication by a scalar can only return a general RotationalInertia
but not a UnitInertia.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class has no means to check at construction from user
provided parameters whether it actually represents the unit
inertia or gyration matrix of a unit-mass body. However, as
previously noted, once a unit inertia is created, a number of
operations are disallowed to ensure the unit-mass invariant. Also
notice that once a unit inertia is created, it <em>is</em> the unit
inertia of <em>some</em> body, perhaps with scaled geometry from the
user’s intention.</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[float]) -&gt; None</li>
</ol>
<p>Default UnitInertia constructor sets all entries to NaN for quick
detection of uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[float], Ixx: float, Iyy: float, Izz: float) -&gt; None</li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal"><span class="pre">Izz</span></code>, and with each product of inertia set to zero. In debug
builds, throws RuntimeError if unit inertia constructed from these
arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UnitInertia_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]" title="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</span></code></a></p>
<p>This class is used to represent rotational inertias for unit mass
bodies. Therefore, unlike RotationalInertia whose units are kg⋅m², the
units of a UnitInertia are those of length squared. A unit inertia is
a useful concept to represent the geometric distribution of mass in a
body regardless of the actual value of the body mass. The rotational
inertia of a body can therefore be obtained by multiplying its unit
inertia by its mass. Unit inertia matrices can also be called
<strong>gyration</strong> matrices and therefore we choose to represent them in
source code notation with the capital letter G. In contrast, the
capital letter I is used to represent non-unit mass rotational
inertias. This class restricts the set of allowed operations on a unit
inertia to ensure the unit-mass invariant. For instance,
multiplication by a scalar can only return a general RotationalInertia
but not a UnitInertia.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class has no means to check at construction from user
provided parameters whether it actually represents the unit
inertia or gyration matrix of a unit-mass body. However, as
previously noted, once a unit inertia is created, a number of
operations are disallowed to ensure the unit-mass invariant. Also
notice that once a unit inertia is created, it <em>is</em> the unit
inertia of <em>some</em> body, perhaps with scaled geometry from the
user’s intention.</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Default UnitInertia constructor sets all entries to NaN for quick
detection of uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[AutoDiffXd], Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd) -&gt; None</li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal"><span class="pre">Izz</span></code>, and with each product of inertia set to zero. In debug
builds, throws RuntimeError if unit inertia constructed from these
arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UnitInertia_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[Expression]" title="pydrake.multibody.tree.RotationalInertia_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression]</span></code></a></p>
<p>This class is used to represent rotational inertias for unit mass
bodies. Therefore, unlike RotationalInertia whose units are kg⋅m², the
units of a UnitInertia are those of length squared. A unit inertia is
a useful concept to represent the geometric distribution of mass in a
body regardless of the actual value of the body mass. The rotational
inertia of a body can therefore be obtained by multiplying its unit
inertia by its mass. Unit inertia matrices can also be called
<strong>gyration</strong> matrices and therefore we choose to represent them in
source code notation with the capital letter G. In contrast, the
capital letter I is used to represent non-unit mass rotational
inertias. This class restricts the set of allowed operations on a unit
inertia to ensure the unit-mass invariant. For instance,
multiplication by a scalar can only return a general RotationalInertia
but not a UnitInertia.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class has no means to check at construction from user
provided parameters whether it actually represents the unit
inertia or gyration matrix of a unit-mass body. However, as
previously noted, once a unit inertia is created, a number of
operations are disallowed to ensure the unit-mass invariant. Also
notice that once a unit inertia is created, it <em>is</em> the unit
inertia of <em>some</em> body, perhaps with scaled geometry from the
user’s intention.</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[Expression]) -&gt; None</li>
</ol>
<p>Default UnitInertia constructor sets all entries to NaN for quick
detection of uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[Expression], Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression) -&gt; None</li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal"><span class="pre">Izz</span></code>, and with each product of inertia set to zero. In debug
builds, throws RuntimeError if unit inertia constructed from these
arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UnitInertia_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UnitInertia_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[float]" title="pydrake.multibody.tree.RotationalInertia_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.RotationalInertia_[float]</span></code></a></p>
<p>This class is used to represent rotational inertias for unit mass
bodies. Therefore, unlike RotationalInertia whose units are kg⋅m², the
units of a UnitInertia are those of length squared. A unit inertia is
a useful concept to represent the geometric distribution of mass in a
body regardless of the actual value of the body mass. The rotational
inertia of a body can therefore be obtained by multiplying its unit
inertia by its mass. Unit inertia matrices can also be called
<strong>gyration</strong> matrices and therefore we choose to represent them in
source code notation with the capital letter G. In contrast, the
capital letter I is used to represent non-unit mass rotational
inertias. This class restricts the set of allowed operations on a unit
inertia to ensure the unit-mass invariant. For instance,
multiplication by a scalar can only return a general RotationalInertia
but not a UnitInertia.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class has no means to check at construction from user
provided parameters whether it actually represents the unit
inertia or gyration matrix of a unit-mass body. However, as
previously noted, once a unit inertia is created, a number of
operations are disallowed to ensure the unit-mass invariant. Also
notice that once a unit inertia is created, it <em>is</em> the unit
inertia of <em>some</em> body, perhaps with scaled geometry from the
user’s intention.</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[float]) -&gt; None</li>
</ol>
<p>Default UnitInertia constructor sets all entries to NaN for quick
detection of uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[float], Ixx: float, Iyy: float, Izz: float) -&gt; None</li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal"><span class="pre">Izz</span></code>, and with each product of inertia set to zero. In debug
builds, throws RuntimeError if unit inertia constructed from these
arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.UniversalJoint">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniversalJoint</code><a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.UniversalJoint_[float]" title="pydrake.multibody.tree.UniversalJoint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.UniversalJoint_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.UniversalJoint_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniversalJoint_</code><a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.UniversalJoint_[float]" title="pydrake.multibody.tree.UniversalJoint_[float]"><code class="xref py py-class docutils literal"><span class="pre">UniversalJoint_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]" title="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">UniversalJoint_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.UniversalJoint_[Expression]" title="pydrake.multibody.tree.UniversalJoint_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">UniversalJoint_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float]">
<em class="property">class </em><code class="descname">UniversalJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This joint models a universal joint allowing two bodies to rotate
relative to one another with two degrees of freedom. A universal joint
can be thought of as a mechanism consisting of three bodies; the
parent body P, an intermediate cross-shaped body I, and the child body
B. In a physical universal joint, body I has a significantly smaller
mass than P or B. This universal joint model corresponds to the
mathematical limit of having a body I of negligible mass. Given a
frame F attached to the parent body P and a frame M attached to the
child body B (see the Joint class’s documentation), the orientation of
M in F can then naturally be defined as follows using a body fixed
rotation sequence. A first rotation of θ₁ about Fx defines the
orientation R_FI of the intermediate frame I attached to body I
(notice that by definition Ix = Fx at all times). A second rotation of
θ₂ about Iy defines the orientation R_IM of frame M (notice that by
definition My = Iy at all times). Mathematically, the orientation of
frame M in F is given by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>R_FM(q) = R_FI(θ₁) * R_IM(θ₂)
</pre></div>
</div>
<p>No translational motion of M in F is allowed and the origins, <code class="docutils literal"><span class="pre">Mo</span></code>
and <code class="docutils literal"><span class="pre">Fo</span></code>, of frames M and F respectively remain coincident. The
angles of rotation about F’s x-axis and M’s y-axis, along with their
rates, specify the state of the joint. Zero θ₁, θ₂ angles corresponds
to frames F, I, and M being coincident. Angles (θ₁, θ₂) are defined to
be positive according to the right-hand-rule with the thumb aligned in
the direction of their respective axes.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a universal joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate as described in the class’s documentation. See
class documentation for details on the angles defining orientation.
This constructor signature creates a joint with no joint limits, i.e.
the joint position, velocity and acceleration limits are the pair
<code class="docutils literal"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s. The damping torque
(in N⋅m) is modeled as <code class="docutils literal"><span class="pre">τᵢ</span> <span class="pre">=</span> <span class="pre">-damping⋅ωᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code> i.e. opposing
motion, with ωᵢ the angular rates about the i-th axis for <code class="docutils literal"><span class="pre">this</span></code>
joint (see get_angular_rates())and τᵢ the torque on child body B about
the same i-th axis.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint from <code class="docutils literal"><span class="pre">context</span></code>. See class
documentation for the definition of these angles.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal"><span class="pre">this</span></code> joint stored in the <code class="docutils literal"><span class="pre">context</span></code>
ordered as (θ₁, θ₂).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].get_angular_rates">
<code class="descname">get_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].get_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rates of change, in radians per second, of <code class="docutils literal"><span class="pre">this</span></code> joint’s
angles (see class documentation) from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rates of change of <code class="docutils literal"><span class="pre">this</span></code> joint’s angles as stored in the
<code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float], angles: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal"><span class="pre">context</span></code> ordered
as (θ₁, θ₂). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].set_angular_rates">
<code class="descname">set_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float], theta_dot: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].set_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rates of change, in radians per second, of this <code class="docutils literal"><span class="pre">this</span></code>
joint’s angles (see class documentation) to <code class="docutils literal"><span class="pre">theta_dot</span></code>. The new
rates of change get stored in <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal"><span class="pre">this</span></code> joints’s angles in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], angles: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See class documentation for details on the
definition of the angles.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniversalJoint_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="pydrake.multibody.tree.Joint_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></a></p>
<p>This joint models a universal joint allowing two bodies to rotate
relative to one another with two degrees of freedom. A universal joint
can be thought of as a mechanism consisting of three bodies; the
parent body P, an intermediate cross-shaped body I, and the child body
B. In a physical universal joint, body I has a significantly smaller
mass than P or B. This universal joint model corresponds to the
mathematical limit of having a body I of negligible mass. Given a
frame F attached to the parent body P and a frame M attached to the
child body B (see the Joint class’s documentation), the orientation of
M in F can then naturally be defined as follows using a body fixed
rotation sequence. A first rotation of θ₁ about Fx defines the
orientation R_FI of the intermediate frame I attached to body I
(notice that by definition Ix = Fx at all times). A second rotation of
θ₂ about Iy defines the orientation R_IM of frame M (notice that by
definition My = Iy at all times). Mathematically, the orientation of
frame M in F is given by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>R_FM(q) = R_FI(θ₁) * R_IM(θ₂)
</pre></div>
</div>
<p>No translational motion of M in F is allowed and the origins, <code class="docutils literal"><span class="pre">Mo</span></code>
and <code class="docutils literal"><span class="pre">Fo</span></code>, of frames M and F respectively remain coincident. The
angles of rotation about F’s x-axis and M’s y-axis, along with their
rates, specify the state of the joint. Zero θ₁, θ₂ angles corresponds
to frames F, I, and M being coincident. Angles (θ₁, θ₂) are defined to
be positive according to the right-hand-rule with the thumb aligned in
the direction of their respective axes.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a universal joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate as described in the class’s documentation. See
class documentation for details on the angles defining orientation.
This constructor signature creates a joint with no joint limits, i.e.
the joint position, velocity and acceleration limits are the pair
<code class="docutils literal"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s. The damping torque
(in N⋅m) is modeled as <code class="docutils literal"><span class="pre">τᵢ</span> <span class="pre">=</span> <span class="pre">-damping⋅ωᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code> i.e. opposing
motion, with ωᵢ the angular rates about the i-th axis for <code class="docutils literal"><span class="pre">this</span></code>
joint (see get_angular_rates())and τᵢ the torque on child body B about
the same i-th axis.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint from <code class="docutils literal"><span class="pre">context</span></code>. See class
documentation for the definition of these angles.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal"><span class="pre">this</span></code> joint stored in the <code class="docutils literal"><span class="pre">context</span></code>
ordered as (θ₁, θ₂).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].get_angular_rates">
<code class="descname">get_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].get_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rates of change, in radians per second, of <code class="docutils literal"><span class="pre">this</span></code> joint’s
angles (see class documentation) from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rates of change of <code class="docutils literal"><span class="pre">this</span></code> joint’s angles as stored in the
<code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], angles: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal"><span class="pre">context</span></code> ordered
as (θ₁, θ₂). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].set_angular_rates">
<code class="descname">set_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], theta_dot: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].set_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rates of change, in radians per second, of this <code class="docutils literal"><span class="pre">this</span></code>
joint’s angles (see class documentation) to <code class="docutils literal"><span class="pre">theta_dot</span></code>. The new
rates of change get stored in <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal"><span class="pre">this</span></code> joints’s angles in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd], angles: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See class documentation for details on the
definition of the angles.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniversalJoint_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[Expression]" title="pydrake.multibody.tree.Joint_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></a></p>
<p>This joint models a universal joint allowing two bodies to rotate
relative to one another with two degrees of freedom. A universal joint
can be thought of as a mechanism consisting of three bodies; the
parent body P, an intermediate cross-shaped body I, and the child body
B. In a physical universal joint, body I has a significantly smaller
mass than P or B. This universal joint model corresponds to the
mathematical limit of having a body I of negligible mass. Given a
frame F attached to the parent body P and a frame M attached to the
child body B (see the Joint class’s documentation), the orientation of
M in F can then naturally be defined as follows using a body fixed
rotation sequence. A first rotation of θ₁ about Fx defines the
orientation R_FI of the intermediate frame I attached to body I
(notice that by definition Ix = Fx at all times). A second rotation of
θ₂ about Iy defines the orientation R_IM of frame M (notice that by
definition My = Iy at all times). Mathematically, the orientation of
frame M in F is given by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>R_FM(q) = R_FI(θ₁) * R_IM(θ₂)
</pre></div>
</div>
<p>No translational motion of M in F is allowed and the origins, <code class="docutils literal"><span class="pre">Mo</span></code>
and <code class="docutils literal"><span class="pre">Fo</span></code>, of frames M and F respectively remain coincident. The
angles of rotation about F’s x-axis and M’s y-axis, along with their
rates, specify the state of the joint. Zero θ₁, θ₂ angles corresponds
to frames F, I, and M being coincident. Angles (θ₁, θ₂) are defined to
be positive according to the right-hand-rule with the thumb aligned in
the direction of their respective axes.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a universal joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate as described in the class’s documentation. See
class documentation for details on the angles defining orientation.
This constructor signature creates a joint with no joint limits, i.e.
the joint position, velocity and acceleration limits are the pair
<code class="docutils literal"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s. The damping torque
(in N⋅m) is modeled as <code class="docutils literal"><span class="pre">τᵢ</span> <span class="pre">=</span> <span class="pre">-damping⋅ωᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code> i.e. opposing
motion, with ωᵢ the angular rates about the i-th axis for <code class="docutils literal"><span class="pre">this</span></code>
joint (see get_angular_rates())and τᵢ the torque on child body B about
the same i-th axis.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint from <code class="docutils literal"><span class="pre">context</span></code>. See class
documentation for the definition of these angles.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal"><span class="pre">this</span></code> joint stored in the <code class="docutils literal"><span class="pre">context</span></code>
ordered as (θ₁, θ₂).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].get_angular_rates">
<code class="descname">get_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].get_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rates of change, in radians per second, of <code class="docutils literal"><span class="pre">this</span></code> joint’s
angles (see class documentation) from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rates of change of <code class="docutils literal"><span class="pre">this</span></code> joint’s angles as stored in the
<code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], angles: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal"><span class="pre">context</span></code> ordered
as (θ₁, θ₂). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].set_angular_rates">
<code class="descname">set_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], theta_dot: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].set_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rates of change, in radians per second, of this <code class="docutils literal"><span class="pre">this</span></code>
joint’s angles (see class documentation) to <code class="docutils literal"><span class="pre">theta_dot</span></code>. The new
rates of change get stored in <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal"><span class="pre">this</span></code> joints’s angles in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression], angles: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See class documentation for details on the
definition of the angles.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UniversalJoint_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniversalJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This joint models a universal joint allowing two bodies to rotate
relative to one another with two degrees of freedom. A universal joint
can be thought of as a mechanism consisting of three bodies; the
parent body P, an intermediate cross-shaped body I, and the child body
B. In a physical universal joint, body I has a significantly smaller
mass than P or B. This universal joint model corresponds to the
mathematical limit of having a body I of negligible mass. Given a
frame F attached to the parent body P and a frame M attached to the
child body B (see the Joint class’s documentation), the orientation of
M in F can then naturally be defined as follows using a body fixed
rotation sequence. A first rotation of θ₁ about Fx defines the
orientation R_FI of the intermediate frame I attached to body I
(notice that by definition Ix = Fx at all times). A second rotation of
θ₂ about Iy defines the orientation R_IM of frame M (notice that by
definition My = Iy at all times). Mathematically, the orientation of
frame M in F is given by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>R_FM(q) = R_FI(θ₁) * R_IM(θ₂)
</pre></div>
</div>
<p>No translational motion of M in F is allowed and the origins, <code class="docutils literal"><span class="pre">Mo</span></code>
and <code class="docutils literal"><span class="pre">Fo</span></code>, of frames M and F respectively remain coincident. The
angles of rotation about F’s x-axis and M’s y-axis, along with their
rates, specify the state of the joint. Zero θ₁, θ₂ angles corresponds
to frames F, I, and M being coincident. Angles (θ₁, θ₂) are defined to
be positive according to the right-hand-rule with the thumb aligned in
the direction of their respective axes.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a universal joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate as described in the class’s documentation. See
class documentation for details on the angles defining orientation.
This constructor signature creates a joint with no joint limits, i.e.
the joint position, velocity and acceleration limits are the pair
<code class="docutils literal"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s. The damping torque
(in N⋅m) is modeled as <code class="docutils literal"><span class="pre">τᵢ</span> <span class="pre">=</span> <span class="pre">-damping⋅ωᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code> i.e. opposing
motion, with ωᵢ the angular rates about the i-th axis for <code class="docutils literal"><span class="pre">this</span></code>
joint (see get_angular_rates())and τᵢ the torque on child body B about
the same i-th axis.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint from <code class="docutils literal"><span class="pre">context</span></code>. See class
documentation for the definition of these angles.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal"><span class="pre">this</span></code> joint stored in the <code class="docutils literal"><span class="pre">context</span></code>
ordered as (θ₁, θ₂).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].get_angular_rates">
<code class="descname">get_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].get_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rates of change, in radians per second, of <code class="docutils literal"><span class="pre">this</span></code> joint’s
angles (see class documentation) from <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rates of change of <code class="docutils literal"><span class="pre">this</span></code> joint’s angles as stored in the
<code class="docutils literal"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float], angles: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal"><span class="pre">this</span></code> joint equals <code class="docutils literal"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal"><span class="pre">context</span></code> ordered
as (θ₁, θ₂). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].set_angular_rates">
<code class="descname">set_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float], theta_dot: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].set_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rates of change, in radians per second, of this <code class="docutils literal"><span class="pre">this</span></code>
joint’s angles (see class documentation) to <code class="docutils literal"><span class="pre">theta_dot</span></code>. The new
rates of change get stored in <code class="docutils literal"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal"><span class="pre">this</span></code> joints’s angles in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], angles: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See class documentation for details on the
definition of the angles.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.WeldJoint">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">WeldJoint</code><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.WeldJoint_[float]" title="pydrake.multibody.tree.WeldJoint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.WeldJoint_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.WeldJoint_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">WeldJoint_</code><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.WeldJoint_[float]" title="pydrake.multibody.tree.WeldJoint_[float]"><code class="xref py py-class docutils literal"><span class="pre">WeldJoint_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.WeldJoint_[AutoDiffXd]" title="pydrake.multibody.tree.WeldJoint_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">WeldJoint_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.WeldJoint_[Expression]" title="pydrake.multibody.tree.WeldJoint_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">WeldJoint_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.WeldJoint_.WeldJoint_[float]">
<em class="property">class </em><code class="descname">WeldJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_.WeldJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint fixes the relative pose between two frames as if “welding”
them together.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_.WeldJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_.WeldJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[float], name: str, parent_frame_P: pydrake.multibody.tree.Frame_[float], child_frame_C: pydrake.multibody.tree.Frame_[float], X_PC: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Constructor for a WeldJoint between a <code class="docutils literal"><span class="pre">parent_frame_P</span></code> and a
<code class="docutils literal"><span class="pre">child_frame_C</span></code> so that their relative pose <code class="docutils literal"><span class="pre">X_PC</span></code> is fixed as if
they were “welded” together.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[float], name: str, parent_frame_P: pydrake.multibody.tree.Frame_[float], child_frame_C: pydrake.multibody.tree.Frame_[float], X_PC: pydrake.common.eigen_geometry.Isometry3_[float]) -&gt; None</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_.WeldJoint_[float].X_PC">
<code class="descname">X_PC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.WeldJoint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_.WeldJoint_[float].X_PC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose X_PC of frame C in P.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.WeldJoint_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">WeldJoint_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="pydrake.multibody.tree.Joint_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></a></p>
<p>This Joint fixes the relative pose between two frames as if “welding”
them together.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[AutoDiffXd], name: str, parent_frame_P: pydrake.multibody.tree.Frame_[AutoDiffXd], child_frame_C: pydrake.multibody.tree.Frame_[AutoDiffXd], X_PC: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Constructor for a WeldJoint between a <code class="docutils literal"><span class="pre">parent_frame_P</span></code> and a
<code class="docutils literal"><span class="pre">child_frame_C</span></code> so that their relative pose <code class="docutils literal"><span class="pre">X_PC</span></code> is fixed as if
they were “welded” together.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[AutoDiffXd], name: str, parent_frame_P: pydrake.multibody.tree.Frame_[AutoDiffXd], child_frame_C: pydrake.multibody.tree.Frame_[AutoDiffXd], X_PC: pydrake.common.eigen_geometry.Isometry3_[float]) -&gt; None</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_[AutoDiffXd].X_PC">
<code class="descname">X_PC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.WeldJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[AutoDiffXd].X_PC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose X_PC of frame C in P.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.WeldJoint_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">WeldJoint_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[Expression]" title="pydrake.multibody.tree.Joint_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></a></p>
<p>This Joint fixes the relative pose between two frames as if “welding”
them together.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[Expression], name: str, parent_frame_P: pydrake.multibody.tree.Frame_[Expression], child_frame_C: pydrake.multibody.tree.Frame_[Expression], X_PC: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Constructor for a WeldJoint between a <code class="docutils literal"><span class="pre">parent_frame_P</span></code> and a
<code class="docutils literal"><span class="pre">child_frame_C</span></code> so that their relative pose <code class="docutils literal"><span class="pre">X_PC</span></code> is fixed as if
they were “welded” together.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[Expression], name: str, parent_frame_P: pydrake.multibody.tree.Frame_[Expression], child_frame_C: pydrake.multibody.tree.Frame_[Expression], X_PC: pydrake.common.eigen_geometry.Isometry3_[float]) -&gt; None</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_[Expression].X_PC">
<code class="descname">X_PC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.WeldJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[Expression].X_PC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose X_PC of frame C in P.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.WeldJoint_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">WeldJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint fixes the relative pose between two frames as if “welding”
them together.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[float], name: str, parent_frame_P: pydrake.multibody.tree.Frame_[float], child_frame_C: pydrake.multibody.tree.Frame_[float], X_PC: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Constructor for a WeldJoint between a <code class="docutils literal"><span class="pre">parent_frame_P</span></code> and a
<code class="docutils literal"><span class="pre">child_frame_C</span></code> so that their relative pose <code class="docutils literal"><span class="pre">X_PC</span></code> is fixed as if
they were “welded” together.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[float], name: str, parent_frame_P: pydrake.multibody.tree.Frame_[float], child_frame_C: pydrake.multibody.tree.Frame_[float], X_PC: pydrake.common.eigen_geometry.Isometry3_[float]) -&gt; None</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_[float].X_PC">
<code class="descname">X_PC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.WeldJoint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[float].X_PC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose X_PC of frame C in P.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.multibody.tree.world_index">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">world_index</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.tree.world_index" title="Permalink to this definition">¶</a></dt>
<dd><p>For every MultibodyTree the <strong>world</strong> body <em>always</em> has this unique
index and it is always zero.</p>
</dd></dl>

<dl class="function">
<dt id="pydrake.multibody.tree.world_model_instance">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">world_model_instance</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.world_model_instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the model instance containing the <em>world</em> body. For every
MultibodyTree the <strong>world</strong> body <em>always</em> has this unique model
instance and it is always zero (as described in #3088).</p>
</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pydrake.perception.html" class="btn btn-neutral float-right" title="pydrake.perception" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pydrake.multibody.plant.html" class="btn btn-neutral" title="pydrake.multibody.plant" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>