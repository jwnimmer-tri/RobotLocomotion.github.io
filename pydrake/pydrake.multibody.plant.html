

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydrake.multibody.plant &mdash; pydrake  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="pydrake  documentation" href="index.html"/>
        <link rel="up" title="pydrake.multibody" href="pydrake.multibody.html"/>
        <link rel="next" title="pydrake.multibody.tree" href="pydrake.multibody.tree.html"/>
        <link rel="prev" title="pydrake.multibody.parsing" href="pydrake.multibody.parsing.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> pydrake
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.all.html">pydrake.multibody.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.benchmarks.html">pydrake.multibody.benchmarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.inverse_kinematics.html">pydrake.multibody.inverse_kinematics</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.math.html">pydrake.multibody.math</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.parsing.html">pydrake.multibody.parsing</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.multibody.plant</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.tree.html">pydrake.multibody.tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="pydrake.multibody.html">pydrake.multibody</a> &raquo;</li>
        
      <li>pydrake.multibody.plant</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pydrake.multibody.plant">
<span id="pydrake-multibody-plant"></span><h1>pydrake.multibody.plant<a class="headerlink" href="#module-pydrake.multibody.plant" title="Permalink to this headline">¶</a></h1>
<p>Bindings for MultibodyPlant and related classes.</p>
<dl class="function">
<dt id="pydrake.multibody.plant.AddMultibodyPlantSceneGraph">
<code class="descclassname">pydrake.multibody.plant.</code><code class="descname">AddMultibodyPlantSceneGraph</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.AddMultibodyPlantSceneGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[float], plant: pydrake.multibody.plant.MultibodyPlant_[float], scene_graph: pydrake.geometry.SceneGraph_[float] = None) -&gt; tuple</li>
</ol>
<p>Adds a MultibodyPlant and a SceneGraph instance to a diagram builder,
connecting the geometry ports.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">builder</span></code>:</dt>
<dd>Builder to add to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">plant</span></code>:</dt>
<dd>Plant to be added to the builder.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">scene_graph</span></code>:</dt>
<dd>(optional) Constructed scene graph. If none is provided, one will
be created and used.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Pair of the registered plant and scene graph.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">builder</span></code> and <code class="docutils literal"><span class="pre">plant</span></code> must be non-null.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[float], time_step: float, scene_graph: pydrake.geometry.SceneGraph_[float] = None) -&gt; tuple</li>
</ol>
<p>Makes a new MultibodyPlant with discrete update period <code class="docutils literal"><span class="pre">time_step</span></code>
and adds it to a diagram builder together with the provided SceneGraph
instance, connecting the geometry ports.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">builder</span></code>:</dt>
<dd>Builder to add to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">time_step</span></code>:</dt>
<dd>The discrete update period for the new MultibodyPlant to be added.
Please refer to the documentation provided in
MultibodyPlant::MultibodyPlant(double) for further details on the
parameter <code class="docutils literal"><span class="pre">time_step</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">scene_graph</span></code>:</dt>
<dd>(optional) Constructed scene graph. If none is provided, one will
be created and used.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Pair of the registered plant and scene graph.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">builder</span></code> must be non-null.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[AutoDiffXd], plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], scene_graph: pydrake.geometry.SceneGraph_[AutoDiffXd] = None) -&gt; tuple</li>
</ol>
<p>Adds a MultibodyPlant and a SceneGraph instance to a diagram builder,
connecting the geometry ports.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">builder</span></code>:</dt>
<dd>Builder to add to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">plant</span></code>:</dt>
<dd>Plant to be added to the builder.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">scene_graph</span></code>:</dt>
<dd>(optional) Constructed scene graph. If none is provided, one will
be created and used.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Pair of the registered plant and scene graph.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">builder</span></code> and <code class="docutils literal"><span class="pre">plant</span></code> must be non-null.</dd>
</dl>
<ol class="arabic simple" start="4">
<li>AddMultibodyPlantSceneGraph(builder: pydrake.systems.framework.DiagramBuilder_[AutoDiffXd], time_step: float, scene_graph: pydrake.geometry.SceneGraph_[AutoDiffXd] = None) -&gt; tuple</li>
</ol>
<p>Makes a new MultibodyPlant with discrete update period <code class="docutils literal"><span class="pre">time_step</span></code>
and adds it to a diagram builder together with the provided SceneGraph
instance, connecting the geometry ports.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Usage examples in add_multibody_plant_scene_graph
“AddMultibodyPlantSceneGraph”.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">builder</span></code>:</dt>
<dd>Builder to add to.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">time_step</span></code>:</dt>
<dd>The discrete update period for the new MultibodyPlant to be added.
Please refer to the documentation provided in
MultibodyPlant::MultibodyPlant(double) for further details on the
parameter <code class="docutils literal"><span class="pre">time_step</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">scene_graph</span></code>:</dt>
<dd>(optional) Constructed scene graph. If none is provided, one will
be created and used.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Pair of the registered plant and scene graph.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">builder</span></code> must be non-null.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.multibody.plant.CalcContactFrictionFromSurfaceProperties">
<code class="descclassname">pydrake.multibody.plant.</code><code class="descname">CalcContactFrictionFromSurfaceProperties</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.CalcContactFrictionFromSurfaceProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>CalcContactFrictionFromSurfaceProperties(surface_properties1: pydrake.multibody.plant.CoulombFriction_[float], surface_properties2: pydrake.multibody.plant.CoulombFriction_[float]) -&gt; pydrake.multibody.plant.CoulombFriction_[float]</li>
</ol>
<p>Given the surface properties of two different surfaces, this method
computes the Coulomb’s law coefficients of friction characterizing the
interaction by friction of the given surface pair. The surface
properties are specified by individual Coulomb’s law coefficients of
friction. As outlined in the class’s documentation for
CoulombFriction, friction coefficients characterize a surface pair and
not individual surfaces. However, we find it useful in practice to
associate the abstract <strong>idea</strong> of friction coefficients to a single
surface. Please refer to the documentation for CoulombFriction for
details on this topic.</p>
<p>More specifically, this method computes the contact coefficients for
the given surface pair as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">μ</span> <span class="o">=</span> <span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span> <span class="o">+</span> <span class="n">μₙ</span><span class="p">)</span>
</pre></div>
</div>
<p>where the operation above is performed separately on the static and
dynamic friction coefficients.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">surface_properties1</span></code>:</dt>
<dd>Surface properties for surface 1. Specified as an individual set
of Coulomb’s law coefficients of friction.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">surface_properties2</span></code>:</dt>
<dd>Surface properties for surface 2. Specified as an individual set
of Coulomb’s law coefficients of friction.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the combined friction coefficients for the interacting surfaces.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>CalcContactFrictionFromSurfaceProperties(surface_properties1: pydrake.multibody.plant.CoulombFriction_[AutoDiffXd], surface_properties2: pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]) -&gt; pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]</li>
</ol>
<p>Given the surface properties of two different surfaces, this method
computes the Coulomb’s law coefficients of friction characterizing the
interaction by friction of the given surface pair. The surface
properties are specified by individual Coulomb’s law coefficients of
friction. As outlined in the class’s documentation for
CoulombFriction, friction coefficients characterize a surface pair and
not individual surfaces. However, we find it useful in practice to
associate the abstract <strong>idea</strong> of friction coefficients to a single
surface. Please refer to the documentation for CoulombFriction for
details on this topic.</p>
<p>More specifically, this method computes the contact coefficients for
the given surface pair as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">μ</span> <span class="o">=</span> <span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span> <span class="o">+</span> <span class="n">μₙ</span><span class="p">)</span>
</pre></div>
</div>
<p>where the operation above is performed separately on the static and
dynamic friction coefficients.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">surface_properties1</span></code>:</dt>
<dd>Surface properties for surface 1. Specified as an individual set
of Coulomb’s law coefficients of friction.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">surface_properties2</span></code>:</dt>
<dd>Surface properties for surface 2. Specified as an individual set
of Coulomb’s law coefficients of friction.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the combined friction coefficients for the interacting surfaces.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>CalcContactFrictionFromSurfaceProperties(surface_properties1: pydrake.multibody.plant.CoulombFriction_[Expression], surface_properties2: pydrake.multibody.plant.CoulombFriction_[Expression]) -&gt; pydrake.multibody.plant.CoulombFriction_[Expression]</li>
</ol>
<p>Given the surface properties of two different surfaces, this method
computes the Coulomb’s law coefficients of friction characterizing the
interaction by friction of the given surface pair. The surface
properties are specified by individual Coulomb’s law coefficients of
friction. As outlined in the class’s documentation for
CoulombFriction, friction coefficients characterize a surface pair and
not individual surfaces. However, we find it useful in practice to
associate the abstract <strong>idea</strong> of friction coefficients to a single
surface. Please refer to the documentation for CoulombFriction for
details on this topic.</p>
<p>More specifically, this method computes the contact coefficients for
the given surface pair as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">μ</span> <span class="o">=</span> <span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span> <span class="o">+</span> <span class="n">μₙ</span><span class="p">)</span>
</pre></div>
</div>
<p>where the operation above is performed separately on the static and
dynamic friction coefficients.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">surface_properties1</span></code>:</dt>
<dd>Surface properties for surface 1. Specified as an individual set
of Coulomb’s law coefficients of friction.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">surface_properties2</span></code>:</dt>
<dd>Surface properties for surface 2. Specified as an individual set
of Coulomb’s law coefficients of friction.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the combined friction coefficients for the interacting surfaces.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pydrake.multibody.plant.ConnectContactResultsToDrakeVisualizer">
<code class="descclassname">pydrake.multibody.plant.</code><code class="descname">ConnectContactResultsToDrakeVisualizer</code><span class="sig-paren">(</span><em>builder: pydrake.systems.framework.DiagramBuilder_[float], plant: pydrake.multibody.plant.MultibodyPlant_[float], lcm: pydrake.lcm.DrakeLcmInterface = None</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.lcm.LcmPublisherSystem<a class="headerlink" href="#pydrake.multibody.plant.ConnectContactResultsToDrakeVisualizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Extends a Diagram with the required components to publish contact
results to drake_visualizer. This must be called <em>during</em> Diagram
building and uses the given <code class="docutils literal"><span class="pre">builder</span></code> to add relevant subsystems and
connections.</p>
<p>This is a convenience method to simplify some common boilerplate for
adding contact results visualization capability to a Diagram. What it
does is:</p>
<ul class="simple">
<li>adds systems ContactResultsToLcmSystem and LcmPublisherSystem to</li>
</ul>
<p>the Diagram and connects the draw message output to the publisher input,
- connects the <code class="docutils literal"><span class="pre">multibody_plant</span></code> contact results output to the
ContactResultsToLcmSystem system, and
- sets the publishing rate to 1/60 of a second (simulated time).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">builder</span></code>:</dt>
<dd>The diagram builder being used to construct the Diagram.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">multibody_plant</span></code>:</dt>
<dd>The System in <code class="docutils literal"><span class="pre">builder</span></code> containing the plant whose contact
results are to be visualized.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">lcm</span></code>:</dt>
<dd>An optional lcm interface through which lcm messages will be
dispatched. Will be allocated internally if none is supplied.</dd>
<dt>Precondition:</dt>
<dd>The given <code class="docutils literal"><span class="pre">multibody_plant</span></code> must be contained within the
supplied DiagramBuilder.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the LcmPublisherSystem (in case callers, e.g., need to change the
default publishing rate).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.ContactResults">
<code class="descclassname">pydrake.multibody.plant.</code><code class="descname">ContactResults</code><a class="headerlink" href="#pydrake.multibody.plant.ContactResults" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.plant.ContactResults_[float]" title="pydrake.multibody.plant.ContactResults_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.plant.ContactResults_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.plant.ContactResults_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">ContactResults_</code><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.plant.ContactResults_[float]" title="pydrake.multibody.plant.ContactResults_[float]"><code class="xref py py-class docutils literal"><span class="pre">ContactResults_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.ContactResults_[AutoDiffXd]" title="pydrake.multibody.plant.ContactResults_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">ContactResults_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.ContactResults_[Expression]" title="pydrake.multibody.plant.ContactResults_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">ContactResults_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.plant.ContactResults_.ContactResults_[float]">
<em class="property">class </em><code class="descname">ContactResults_[float]</code><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_.ContactResults_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A container class storing the contact results information for each
contact pair for a given state of the simulation. Note that copying
this data structure is expensive when <code class="docutils literal"><span class="pre">num_hydroelastic_contacts()</span> <span class="pre">&gt;</span>
<span class="pre">0</span></code> because a deep copy is performed.</p>
<dl class="method">
<dt id="pydrake.multibody.plant.ContactResults_.ContactResults_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ContactResults_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.ContactResults_.ContactResults_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.ContactResults_.ContactResults_[float].num_point_pair_contacts">
<code class="descname">num_point_pair_contacts</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ContactResults_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.ContactResults_.ContactResults_[float].num_point_pair_contacts" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of point pair contacts.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.ContactResults_.ContactResults_[float].point_pair_contact_info">
<code class="descname">point_pair_contact_info</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ContactResults_[float], i: int</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.plant.PointPairContactInfo_[float]<a class="headerlink" href="#pydrake.multibody.plant.ContactResults_.ContactResults_[float].point_pair_contact_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the ith PointPairContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal"><span class="pre">num_point_pair_contacts()</span></code> - 1] or this
method aborts.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.ContactResults_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">ContactResults_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>A container class storing the contact results information for each
contact pair for a given state of the simulation. Note that copying
this data structure is expensive when <code class="docutils literal"><span class="pre">num_hydroelastic_contacts()</span> <span class="pre">&gt;</span>
<span class="pre">0</span></code> because a deep copy is performed.</p>
<dl class="method">
<dt id="pydrake.multibody.plant.ContactResults_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ContactResults_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.ContactResults_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.ContactResults_[AutoDiffXd].num_point_pair_contacts">
<code class="descname">num_point_pair_contacts</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ContactResults_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.ContactResults_[AutoDiffXd].num_point_pair_contacts" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of point pair contacts.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.ContactResults_[AutoDiffXd].point_pair_contact_info">
<code class="descname">point_pair_contact_info</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ContactResults_[AutoDiffXd], i: int</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.ContactResults_[AutoDiffXd].point_pair_contact_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the ith PointPairContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal"><span class="pre">num_point_pair_contacts()</span></code> - 1] or this
method aborts.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.ContactResults_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">ContactResults_[Expression]</code><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>A container class storing the contact results information for each
contact pair for a given state of the simulation. Note that copying
this data structure is expensive when <code class="docutils literal"><span class="pre">num_hydroelastic_contacts()</span> <span class="pre">&gt;</span>
<span class="pre">0</span></code> because a deep copy is performed.</p>
<dl class="method">
<dt id="pydrake.multibody.plant.ContactResults_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ContactResults_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.ContactResults_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.ContactResults_[Expression].num_point_pair_contacts">
<code class="descname">num_point_pair_contacts</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ContactResults_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.ContactResults_[Expression].num_point_pair_contacts" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of point pair contacts.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.ContactResults_[Expression].point_pair_contact_info">
<code class="descname">point_pair_contact_info</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ContactResults_[Expression], i: int</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.plant.PointPairContactInfo_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.ContactResults_[Expression].point_pair_contact_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the ith PointPairContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal"><span class="pre">num_point_pair_contacts()</span></code> - 1] or this
method aborts.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.ContactResults_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">ContactResults_[float]</code><a class="headerlink" href="#pydrake.multibody.plant.ContactResults_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A container class storing the contact results information for each
contact pair for a given state of the simulation. Note that copying
this data structure is expensive when <code class="docutils literal"><span class="pre">num_hydroelastic_contacts()</span> <span class="pre">&gt;</span>
<span class="pre">0</span></code> because a deep copy is performed.</p>
<dl class="method">
<dt id="pydrake.multibody.plant.ContactResults_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ContactResults_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.ContactResults_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.ContactResults_[float].num_point_pair_contacts">
<code class="descname">num_point_pair_contacts</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ContactResults_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.ContactResults_[float].num_point_pair_contacts" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of point pair contacts.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.ContactResults_[float].point_pair_contact_info">
<code class="descname">point_pair_contact_info</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ContactResults_[float], i: int</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.plant.PointPairContactInfo_[float]<a class="headerlink" href="#pydrake.multibody.plant.ContactResults_[float].point_pair_contact_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the ith PointPairContactInfo instance. The input index i
must be in the range [0, <code class="docutils literal"><span class="pre">num_point_pair_contacts()</span></code> - 1] or this
method aborts.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.ContactResultsToLcmSystem">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">ContactResultsToLcmSystem</code><a class="headerlink" href="#pydrake.multibody.plant.ContactResultsToLcmSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_[float]" title="pydrake.systems.framework.LeafSystem_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.framework.LeafSystem_[float]</span></code></a></p>
<p>A System that encodes ContactResults into a
lcmt_contact_results_for_viz message. It has a single input port with
type ContactResults&lt;T&gt; and a single output port with
lcmt_contact_results_for_viz.</p>
<dl class="method">
<dt id="pydrake.multibody.plant.ContactResultsToLcmSystem.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ContactResultsToLcmSystem, plant: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.ContactResultsToLcmSystem.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a ContactResultsToLcmSystem.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">plant</span></code>:</dt>
<dd>The MultibodyPlant that the ContactResults are generated from.</dd>
<dt>Precondition:</dt>
<dd>The <code class="docutils literal"><span class="pre">plant</span></code> must be finalized already. The input port of this
system must be connected to the corresponding output port of
<code class="docutils literal"><span class="pre">plant</span></code> (either directly or from an exported port in a Diagram).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.ContactResultsToLcmSystem.get_contact_result_input_port">
<code class="descname">get_contact_result_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ContactResultsToLcmSystem</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.ContactResultsToLcmSystem.get_contact_result_input_port" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.ContactResultsToLcmSystem.get_lcm_message_output_port">
<code class="descname">get_lcm_message_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ContactResultsToLcmSystem</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.ContactResultsToLcmSystem.get_lcm_message_output_port" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.CoulombFriction">
<code class="descclassname">pydrake.multibody.plant.</code><code class="descname">CoulombFriction</code><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction_[float]" title="pydrake.multibody.plant.CoulombFriction_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.plant.CoulombFriction_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.plant.CoulombFriction_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">CoulombFriction_</code><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction_[float]" title="pydrake.multibody.plant.CoulombFriction_[float]"><code class="xref py py-class docutils literal"><span class="pre">CoulombFriction_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]" title="pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">CoulombFriction_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.CoulombFriction_[Expression]" title="pydrake.multibody.plant.CoulombFriction_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">CoulombFriction_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.plant.CoulombFriction_.CoulombFriction_[float]">
<em class="property">class </em><code class="descname">CoulombFriction_[float]</code><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_.CoulombFriction_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters for Coulomb’s Law of Friction, namely:</p>
<ul class="simple">
<li>Static friction coefficient, for a pair of surfaces at rest relative to
each other.</li>
<li>Dynamic (or kinematic) friction coefficient, for a pair of surfaces in
relative motion.</li>
</ul>
<p>These coefficients are an empirical property characterizing the
interaction by friction between a pair of contacting surfaces.
Friction coefficients depend upon the mechanical properties of the
surfaces’ materials and on the roughness of the surfaces. They are
determined experimentally.</p>
<p>Even though the Coulomb’s law coefficients of friction characterize a
pair of surfaces interacting by friction, we associate the abstract
<strong>idea</strong> of friction coefficients to a single surface by considering
the coefficients for contact between two identical surfaces. For this
case of two identical surfaces, the friction coefficients that
describe the surface pair are taken to equal those of one of the
identical surfaces. We extend this idea to the case of different
surfaces by defining a <strong>combination law</strong> that allow us to obtain the
Coulomb’s law coefficients of friction characterizing the pair of
surfaces, given the individual friction coefficients of each surface.
We would like this <strong>combination law</strong> to satisfy:</p>
<ul class="simple">
<li>The friction coefficient of two identical surfaces is the friction
coefficient of one of the surfaces.</li>
<li>The combination law is commutative. That is, surface A combined with
surface B gives the same results as surface B combined with surface A.</li>
<li>For two surfaces M and N with very different friction coefficients, say
<code class="docutils literal"><span class="pre">μₘ</span> <span class="pre">≪</span> <span class="pre">μₙ</span></code>, the combined friction coefficient should be in the order of
magnitude of the smallest friction coefficient (in the example μₘ). To
understand this requirement, consider rubber (high friction coefficient)
sliding on ice (low friction coefficient). We’d like the surface pair
to be defined by a friction coefficient close to that of ice, since rubber
will easily slide on ice.</li>
</ul>
<p>These requirements are met by the following ad-hoc combination law:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">μ</span> <span class="o">=</span> <span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span> <span class="o">+</span> <span class="n">μₙ</span><span class="p">)</span>
</pre></div>
</div>
<p>See CalcContactFrictionFromSurfaceProperties(), which implements this
law. More complex combination laws could also be a function of other
parameters such as the mechanical properties of the interacting
surfaces or even their roughnesses. For instance, if the the rubber
surface above has metal studs (somehow making the surface “rougher”),
it will definitely have a better grip on an ice surface. Therefore
this new variable should be taken into account in the combination law.
Notice that in this example, this new combination law model for tires,
will have a different set of requirements from the ones stated above.</p>
<dl class="method">
<dt id="pydrake.multibody.plant.CoulombFriction_.CoulombFriction_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.CoulombFriction_[float], static_friction: float, dynamic_friction: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_.CoulombFriction_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies both the static and dynamic friction coefficients for a
given surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of the friction coefficients are negative or</li>
<li>if <code class="docutils literal"><span class="pre">dynamic_friction</span> <span class="pre">&gt;</span> <span class="pre">static_friction</span></code> (they can be equal.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.CoulombFriction_.CoulombFriction_[float].dynamic_friction">
<code class="descname">dynamic_friction</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.CoulombFriction_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_.CoulombFriction_[float].dynamic_friction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coefficient of dynamic friction.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.CoulombFriction_.CoulombFriction_[float].static_friction">
<code class="descname">static_friction</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.CoulombFriction_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_.CoulombFriction_[float].static_friction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coefficient of static friction.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">CoulombFriction_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters for Coulomb’s Law of Friction, namely:</p>
<ul class="simple">
<li>Static friction coefficient, for a pair of surfaces at rest relative to
each other.</li>
<li>Dynamic (or kinematic) friction coefficient, for a pair of surfaces in
relative motion.</li>
</ul>
<p>These coefficients are an empirical property characterizing the
interaction by friction between a pair of contacting surfaces.
Friction coefficients depend upon the mechanical properties of the
surfaces’ materials and on the roughness of the surfaces. They are
determined experimentally.</p>
<p>Even though the Coulomb’s law coefficients of friction characterize a
pair of surfaces interacting by friction, we associate the abstract
<strong>idea</strong> of friction coefficients to a single surface by considering
the coefficients for contact between two identical surfaces. For this
case of two identical surfaces, the friction coefficients that
describe the surface pair are taken to equal those of one of the
identical surfaces. We extend this idea to the case of different
surfaces by defining a <strong>combination law</strong> that allow us to obtain the
Coulomb’s law coefficients of friction characterizing the pair of
surfaces, given the individual friction coefficients of each surface.
We would like this <strong>combination law</strong> to satisfy:</p>
<ul class="simple">
<li>The friction coefficient of two identical surfaces is the friction
coefficient of one of the surfaces.</li>
<li>The combination law is commutative. That is, surface A combined with
surface B gives the same results as surface B combined with surface A.</li>
<li>For two surfaces M and N with very different friction coefficients, say
<code class="docutils literal"><span class="pre">μₘ</span> <span class="pre">≪</span> <span class="pre">μₙ</span></code>, the combined friction coefficient should be in the order of
magnitude of the smallest friction coefficient (in the example μₘ). To
understand this requirement, consider rubber (high friction coefficient)
sliding on ice (low friction coefficient). We’d like the surface pair
to be defined by a friction coefficient close to that of ice, since rubber
will easily slide on ice.</li>
</ul>
<p>These requirements are met by the following ad-hoc combination law:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">μ</span> <span class="o">=</span> <span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span> <span class="o">+</span> <span class="n">μₙ</span><span class="p">)</span>
</pre></div>
</div>
<p>See CalcContactFrictionFromSurfaceProperties(), which implements this
law. More complex combination laws could also be a function of other
parameters such as the mechanical properties of the interacting
surfaces or even their roughnesses. For instance, if the the rubber
surface above has metal studs (somehow making the surface “rougher”),
it will definitely have a better grip on an ice surface. Therefore
this new variable should be taken into account in the combination law.
Notice that in this example, this new combination law model for tires,
will have a different set of requirements from the ones stated above.</p>
<dl class="method">
<dt id="pydrake.multibody.plant.CoulombFriction_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.CoulombFriction_[AutoDiffXd], static_friction: pydrake.autodiffutils.AutoDiffXd, dynamic_friction: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies both the static and dynamic friction coefficients for a
given surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of the friction coefficients are negative or</li>
<li>if <code class="docutils literal"><span class="pre">dynamic_friction</span> <span class="pre">&gt;</span> <span class="pre">static_friction</span></code> (they can be equal.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.CoulombFriction_[AutoDiffXd].dynamic_friction">
<code class="descname">dynamic_friction</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_[AutoDiffXd].dynamic_friction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coefficient of dynamic friction.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.CoulombFriction_[AutoDiffXd].static_friction">
<code class="descname">static_friction</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.CoulombFriction_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_[AutoDiffXd].static_friction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coefficient of static friction.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.CoulombFriction_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">CoulombFriction_[Expression]</code><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters for Coulomb’s Law of Friction, namely:</p>
<ul class="simple">
<li>Static friction coefficient, for a pair of surfaces at rest relative to
each other.</li>
<li>Dynamic (or kinematic) friction coefficient, for a pair of surfaces in
relative motion.</li>
</ul>
<p>These coefficients are an empirical property characterizing the
interaction by friction between a pair of contacting surfaces.
Friction coefficients depend upon the mechanical properties of the
surfaces’ materials and on the roughness of the surfaces. They are
determined experimentally.</p>
<p>Even though the Coulomb’s law coefficients of friction characterize a
pair of surfaces interacting by friction, we associate the abstract
<strong>idea</strong> of friction coefficients to a single surface by considering
the coefficients for contact between two identical surfaces. For this
case of two identical surfaces, the friction coefficients that
describe the surface pair are taken to equal those of one of the
identical surfaces. We extend this idea to the case of different
surfaces by defining a <strong>combination law</strong> that allow us to obtain the
Coulomb’s law coefficients of friction characterizing the pair of
surfaces, given the individual friction coefficients of each surface.
We would like this <strong>combination law</strong> to satisfy:</p>
<ul class="simple">
<li>The friction coefficient of two identical surfaces is the friction
coefficient of one of the surfaces.</li>
<li>The combination law is commutative. That is, surface A combined with
surface B gives the same results as surface B combined with surface A.</li>
<li>For two surfaces M and N with very different friction coefficients, say
<code class="docutils literal"><span class="pre">μₘ</span> <span class="pre">≪</span> <span class="pre">μₙ</span></code>, the combined friction coefficient should be in the order of
magnitude of the smallest friction coefficient (in the example μₘ). To
understand this requirement, consider rubber (high friction coefficient)
sliding on ice (low friction coefficient). We’d like the surface pair
to be defined by a friction coefficient close to that of ice, since rubber
will easily slide on ice.</li>
</ul>
<p>These requirements are met by the following ad-hoc combination law:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">μ</span> <span class="o">=</span> <span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span> <span class="o">+</span> <span class="n">μₙ</span><span class="p">)</span>
</pre></div>
</div>
<p>See CalcContactFrictionFromSurfaceProperties(), which implements this
law. More complex combination laws could also be a function of other
parameters such as the mechanical properties of the interacting
surfaces or even their roughnesses. For instance, if the the rubber
surface above has metal studs (somehow making the surface “rougher”),
it will definitely have a better grip on an ice surface. Therefore
this new variable should be taken into account in the combination law.
Notice that in this example, this new combination law model for tires,
will have a different set of requirements from the ones stated above.</p>
<dl class="method">
<dt id="pydrake.multibody.plant.CoulombFriction_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.CoulombFriction_[Expression], static_friction: pydrake.symbolic.Expression, dynamic_friction: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies both the static and dynamic friction coefficients for a
given surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of the friction coefficients are negative or</li>
<li>if <code class="docutils literal"><span class="pre">dynamic_friction</span> <span class="pre">&gt;</span> <span class="pre">static_friction</span></code> (they can be equal.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.CoulombFriction_[Expression].dynamic_friction">
<code class="descname">dynamic_friction</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.CoulombFriction_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_[Expression].dynamic_friction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coefficient of dynamic friction.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.CoulombFriction_[Expression].static_friction">
<code class="descname">static_friction</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.CoulombFriction_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_[Expression].static_friction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coefficient of static friction.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.CoulombFriction_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">CoulombFriction_[float]</code><a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters for Coulomb’s Law of Friction, namely:</p>
<ul class="simple">
<li>Static friction coefficient, for a pair of surfaces at rest relative to
each other.</li>
<li>Dynamic (or kinematic) friction coefficient, for a pair of surfaces in
relative motion.</li>
</ul>
<p>These coefficients are an empirical property characterizing the
interaction by friction between a pair of contacting surfaces.
Friction coefficients depend upon the mechanical properties of the
surfaces’ materials and on the roughness of the surfaces. They are
determined experimentally.</p>
<p>Even though the Coulomb’s law coefficients of friction characterize a
pair of surfaces interacting by friction, we associate the abstract
<strong>idea</strong> of friction coefficients to a single surface by considering
the coefficients for contact between two identical surfaces. For this
case of two identical surfaces, the friction coefficients that
describe the surface pair are taken to equal those of one of the
identical surfaces. We extend this idea to the case of different
surfaces by defining a <strong>combination law</strong> that allow us to obtain the
Coulomb’s law coefficients of friction characterizing the pair of
surfaces, given the individual friction coefficients of each surface.
We would like this <strong>combination law</strong> to satisfy:</p>
<ul class="simple">
<li>The friction coefficient of two identical surfaces is the friction
coefficient of one of the surfaces.</li>
<li>The combination law is commutative. That is, surface A combined with
surface B gives the same results as surface B combined with surface A.</li>
<li>For two surfaces M and N with very different friction coefficients, say
<code class="docutils literal"><span class="pre">μₘ</span> <span class="pre">≪</span> <span class="pre">μₙ</span></code>, the combined friction coefficient should be in the order of
magnitude of the smallest friction coefficient (in the example μₘ). To
understand this requirement, consider rubber (high friction coefficient)
sliding on ice (low friction coefficient). We’d like the surface pair
to be defined by a friction coefficient close to that of ice, since rubber
will easily slide on ice.</li>
</ul>
<p>These requirements are met by the following ad-hoc combination law:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">μ</span> <span class="o">=</span> <span class="mi">2</span><span class="n">μₘμₙ</span><span class="o">/</span><span class="p">(</span><span class="n">μₘ</span> <span class="o">+</span> <span class="n">μₙ</span><span class="p">)</span>
</pre></div>
</div>
<p>See CalcContactFrictionFromSurfaceProperties(), which implements this
law. More complex combination laws could also be a function of other
parameters such as the mechanical properties of the interacting
surfaces or even their roughnesses. For instance, if the the rubber
surface above has metal studs (somehow making the surface “rougher”),
it will definitely have a better grip on an ice surface. Therefore
this new variable should be taken into account in the combination law.
Notice that in this example, this new combination law model for tires,
will have a different set of requirements from the ones stated above.</p>
<dl class="method">
<dt id="pydrake.multibody.plant.CoulombFriction_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.CoulombFriction_[float], static_friction: float, dynamic_friction: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies both the static and dynamic friction coefficients for a
given surface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of the friction coefficients are negative or</li>
<li>if <code class="docutils literal"><span class="pre">dynamic_friction</span> <span class="pre">&gt;</span> <span class="pre">static_friction</span></code> (they can be equal.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.CoulombFriction_[float].dynamic_friction">
<code class="descname">dynamic_friction</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.CoulombFriction_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_[float].dynamic_friction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coefficient of dynamic friction.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.CoulombFriction_[float].static_friction">
<code class="descname">static_friction</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.CoulombFriction_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.CoulombFriction_[float].static_friction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coefficient of static friction.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce">
<code class="descclassname">pydrake.multibody.plant.</code><code class="descname">ExternallyAppliedSpatialForce</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float]" title="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">ExternallyAppliedSpatialForce_</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float]" title="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float]"><code class="xref py py-class docutils literal"><span class="pre">ExternallyAppliedSpatialForce_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd]" title="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">ExternallyAppliedSpatialForce_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression]" title="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">ExternallyAppliedSpatialForce_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_.ExternallyAppliedSpatialForce_[float]">
<em class="property">class </em><code class="descname">ExternallyAppliedSpatialForce_[float]</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_.ExternallyAppliedSpatialForce_[float]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_.ExternallyAppliedSpatialForce_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_.ExternallyAppliedSpatialForce_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_.ExternallyAppliedSpatialForce_[float].body_index">
<code class="descname">body_index</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_.ExternallyAppliedSpatialForce_[float].body_index" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the body that the force is to be applied to.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_.ExternallyAppliedSpatialForce_[float].F_Bq_W">
<code class="descname">F_Bq_W</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_.ExternallyAppliedSpatialForce_[float].F_Bq_W" title="Permalink to this definition">¶</a></dt>
<dd><p>A spatial force applied to Body B at point Bq, expressed in the world
frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_.ExternallyAppliedSpatialForce_[float].p_BoBq_B">
<code class="descname">p_BoBq_B</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_.ExternallyAppliedSpatialForce_[float].p_BoBq_B" title="Permalink to this definition">¶</a></dt>
<dd><p>A position vector from Body B’s origin (Bo) to a point Bq (a point of
B), expressed in B’s frame.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">ExternallyAppliedSpatialForce_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd].body_index">
<code class="descname">body_index</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd].body_index" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the body that the force is to be applied to.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd].F_Bq_W">
<code class="descname">F_Bq_W</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd].F_Bq_W" title="Permalink to this definition">¶</a></dt>
<dd><p>A spatial force applied to Body B at point Bq, expressed in the world
frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd].p_BoBq_B">
<code class="descname">p_BoBq_B</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[AutoDiffXd].p_BoBq_B" title="Permalink to this definition">¶</a></dt>
<dd><p>A position vector from Body B’s origin (Bo) to a point Bq (a point of
B), expressed in B’s frame.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">ExternallyAppliedSpatialForce_[Expression]</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression].body_index">
<code class="descname">body_index</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression].body_index" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the body that the force is to be applied to.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression].F_Bq_W">
<code class="descname">F_Bq_W</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression].F_Bq_W" title="Permalink to this definition">¶</a></dt>
<dd><p>A spatial force applied to Body B at point Bq, expressed in the world
frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression].p_BoBq_B">
<code class="descname">p_BoBq_B</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[Expression].p_BoBq_B" title="Permalink to this definition">¶</a></dt>
<dd><p>A position vector from Body B’s origin (Bo) to a point Bq (a point of
B), expressed in B’s frame.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">ExternallyAppliedSpatialForce_[float]</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float].body_index">
<code class="descname">body_index</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float].body_index" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the body that the force is to be applied to.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float].F_Bq_W">
<code class="descname">F_Bq_W</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float].F_Bq_W" title="Permalink to this definition">¶</a></dt>
<dd><p>A spatial force applied to Body B at point Bq, expressed in the world
frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float].p_BoBq_B">
<code class="descname">p_BoBq_B</code><a class="headerlink" href="#pydrake.multibody.plant.ExternallyAppliedSpatialForce_[float].p_BoBq_B" title="Permalink to this definition">¶</a></dt>
<dd><p>A position vector from Body B’s origin (Bo) to a point Bq (a point of
B), expressed in B’s frame.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.MultibodyPlant">
<code class="descclassname">pydrake.multibody.plant.</code><code class="descname">MultibodyPlant</code><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_[float]" title="pydrake.multibody.plant.MultibodyPlant_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.plant.MultibodyPlant_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.plant.MultibodyPlant_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">MultibodyPlant_</code><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_[float]" title="pydrake.multibody.plant.MultibodyPlant_[float]"><code class="xref py py-class docutils literal"><span class="pre">MultibodyPlant_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]" title="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">MultibodyPlant_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.MultibodyPlant_[Expression]" title="pydrake.multibody.plant.MultibodyPlant_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">MultibodyPlant_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float]">
<em class="property">class </em><code class="descname">MultibodyPlant_[float]</code><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_[float]" title="pydrake.systems.framework.LeafSystem_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.framework.LeafSystem_[float]</span></code></a></p>
<p>MultibodyPlant is a Drake system framework representation (see
systems::System) for the model of a physical system consisting of a
collection of interconnected bodies. See multibody for an overview of
concepts/notation.</p>
<p>&lt;table align=center cellpadding=0 cellspacing=0&gt;&lt;tr align=center&gt;&lt;td
style=”vertical-align:middle”&gt;&lt;table cellspacing=0
cellpadding=0&gt;&lt;tr&gt;&lt;td align=right style=”padding:5px 0px 5px
0px”&gt;applied_generalized_force&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=right
style=”padding:5px 0px 5px
0px”&gt;applied_spatial_force&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=right
style=”padding:5px 0px 5px 0px”&gt;&lt;em
style=”color:gray”&gt;model_instance_name[i]&lt;/em&gt;_actuation&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=right style=”padding:5px 0px 5px 0px”&gt;&lt;span
style=”color:green”&gt;geometry_query&lt;/span&gt;&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;td
align=center
style=”border:solid;padding-left:20px;padding-right:20px;vertical-align:middle”
bgcolor=#F0F0F0&gt;MultibodyPlant&lt;/td&gt;&lt;td
style=”vertical-align:middle”&gt;&lt;table cellspacing=0
cellpadding=0&gt;&lt;tr&gt;&lt;td align=left style=”padding:5px 0px 5px
0px”&gt;&amp;rarr; continuous_state&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left
style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; body_poses&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr;
body_spatial_velocities&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left style=”padding:5px
0px 5px 0px”&gt;&amp;rarr; body_spatial_accelerations&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr;
generalized_acceleration&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left
style=”padding:5px 0px 5px 0px”&gt;&amp;rarr;
reaction_forces&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left style=”padding:5px 0px 5px
0px”&gt;&amp;rarr; contact_results&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left
style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;em
style=”color:gray”&gt;model_instance_name[i]&lt;/em&gt;_continuous_state&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;em
style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt;_generalized_acceleration&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;em
style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt;_generalized_contact_forces&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;span
style=”color:green”&gt;geometry_pose&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</p>
<p>The ports whose names begin with &lt;em style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt; represent groups of ports, one for each of
the model_instances “model instances”, with i ∈ {0, …, N-1} for the
N model instances. If a model instance does not contain any data of
the indicated type the port will still be present but its value will
be a zero-length vector. (Model instances <code class="docutils literal"><span class="pre">world_model_instance()</span></code>
and <code class="docutils literal"><span class="pre">default_model_instance()</span></code> always exist.)</p>
<p>The ports shown in &lt;span style=”color:green”&gt; green&lt;/span&gt; are for
communication with Drake’s geometry::SceneGraph “SceneGraph” system
for dealing with geometry.</p>
<p>MultibodyPlant provides a user-facing API for:</p>
<ul class="simple">
<li>mbp_input_and_output_ports “Ports”: Access input and output ports. -</li>
</ul>
<p>mbp_construction “Construction”: Add bodies, joints, frames, force
elements, and actuators. - mbp_geometry “Geometry”: Register
geometries to a provided SceneGraph instance. - mbp_contact_modeling
“Contact modeling”: Select and parameterize contact models. -
mbp_state_accessors_and_mutators “State access and modification”:
Obtain and manipulate position and velocity state variables. -
mbp_working_with_free_bodies “Free bodies”: Work conveniently with
free (floating) bodies. - mbp_kinematic_and_dynamic_computations
“Kinematics and dynamics”: Perform systems::Context
“Context”-dependent kinematic and dynamic queries. -
mbp_system_matrix_computations “System matrices”: Explicitly form
matrices that appear in the equations of motion. - mbp_introspection
“Introspection”: Perform introspection to find out what’s in the
MultibodyPlant.</p>
<p><a href="#id1"><span class="problematic" id="id2">**</span></a>** Model Instances</p>
<p>A MultiBodyPlant may contain multiple model instances. Each model
instance corresponds to a set of bodies and their connections
(joints). Model instances provide methods to get or set the state of
the set of bodies (e.g., through GetPositionsAndVelocities() and
SetPositionsAndVelocities()), connecting controllers (through
get_state_output_port() and get_actuation_input_port()), and
organizing duplicate models (read through a parser). In fact, many
MultibodyPlant methods are overloaded to allow operating on the entire
plant or just the subset corresponding to the model instance; for
example, one GetPositions() method obtains the generalized positions
for the entire plant while another GetPositions() method obtains the
generalized positions for model instance.</p>
<p>Model instances are frequently defined through SDF files (using the
<code class="docutils literal"><span class="pre">model</span></code> tag) and are automatically created when SDF files are parsed
(by Parser). There are two special multibody::ModelInstanceIndex
values. The world body is always multibody::ModelInstanceIndex 0.
multibody::ModelInstanceIndex 1 is reserved for all elements with no
explicit model instance and is generally only relevant for elements
created programmatically (and only when a model instance is not
explicitly specified). Note that Parser creates model instances
(resulting in a multibody::ModelInstanceIndex ≥ 2) as needed.</p>
<p>See num_model_instances(), num_positions(), num_velocities(),
num_actuated_dofs(), AddModelInstance() GetPositionsAndVelocities(),
GetPositions(), GetVelocities(), SetPositionsAndVelocities(),
SetPositions(), SetVelocities(), GetPositionsFromArray(),
GetVelocitiesFromArray(), SetPositionsInArray(),
SetVelocitiesInArray(), SetActuationInArray(),
HasModelInstanceNamed(), GetModelInstanceName(),
get_state_output_port(), get_actuation_input_port().</p>
<p><a href="#id3"><span class="problematic" id="id4">**</span></a>** System dynamics</p>
<p>The state of a multibody system <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">[q;</span> <span class="pre">v]</span></code> is given by its
generalized positions vector q, of size <code class="docutils literal"><span class="pre">nq</span></code> (see num_positions()),
and by its generalized velocities vector v, of size <code class="docutils literal"><span class="pre">nv</span></code> (see
num_velocities()). As a Drake systems::System “System”, MultibodyPlant
implements the governing equations for a multibody dynamical system in
the form <code class="docutils literal"><span class="pre">ẋ</span> <span class="pre">=</span> <span class="pre">f(t,</span> <span class="pre">x,</span> <span class="pre">u)</span></code> with t being time and u the actuation
forces. The governing equations for the dynamics of a multibody system
modeled with MultibodyPlant are [Featherstone 2008, Jain 2010]:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">q̇</span> <span class="o">=</span> <span class="n">N</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span>
   <span class="p">(</span><span class="mi">1</span><span class="p">)</span>    <span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v̇</span> <span class="o">+</span> <span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="n">v</span> <span class="o">=</span> <span class="n">τ</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">M(q)</span></code> is the mass matrix of the multibody system, <code class="docutils literal"><span class="pre">C(q,</span>
<span class="pre">v)v</span></code> contains Coriolis, centripetal, and gyroscopic terms and
<code class="docutils literal"><span class="pre">N(q)</span></code> is the kinematic coupling matrix describing the relationship
between q̇ (the time derivatives of the generalized positions) and the
generalized velocities v, [Seth 2010]. <code class="docutils literal"><span class="pre">N(q)</span></code> is an <code class="docutils literal"><span class="pre">nq</span> <span class="pre">x</span> <span class="pre">nv</span></code>
matrix. The vector <code class="docutils literal"><span class="pre">τ</span> <span class="pre">∈</span> <span class="pre">ℝⁿᵛ</span></code> on the right hand side of Eq. (1) is
the system’s generalized forces. These incorporate gravity, springs,
externally applied body forces, constraint forces, and contact forces.</p>
<p><a href="#id5"><span class="problematic" id="id6">**</span></a>** Loading models from SDF files</p>
<p>Drake has the capability to load multibody models from SDF and URDF
files. Consider the example below which loads an acrobot model:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">acrobot</span><span class="p">;</span>
   <span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">scene_graph</span><span class="p">;</span>
   <span class="n">Parser</span> <span class="n">parser</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acrobot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scene_graph</span><span class="p">);</span>
   <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">relative_name</span> <span class="o">=</span>
     <span class="s2">&quot;drake/multibody/benchmarks/acrobot/acrobot.sdf&quot;</span><span class="p">;</span>
   <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">full_name</span> <span class="o">=</span> <span class="n">FindResourceOrThrow</span><span class="p">(</span><span class="n">relative_name</span><span class="p">);</span>
   <span class="n">parser</span><span class="o">.</span><span class="n">AddModelFromFile</span><span class="p">(</span><span class="n">full_name</span><span class="p">);</span>
</pre></div>
</div>
<p>As in the example above, for models including visual geometry,
collision geometry or both, the user must specify a SceneGraph for
geometry handling. You can find a full example of the LQR controlled
acrobot in examples/multibody/acrobot/run_lqr.cc.</p>
<p>AddModelFromFile() can be invoked multiple times on the same plant in
order to load multiple model instances. Other methods are available on
Parser such as AddAllModelsFromFile() which allows creating model
instances per each <code class="docutils literal"><span class="pre">&lt;model&gt;</span></code> tag found in the file. Please refer to
each of these methods’ documentation for further details.</p>
<p><a href="#id7"><span class="problematic" id="id8">**</span></a>** Working with SceneGraph</p>
<p>** Adding a MultibodyPlant connected to a SceneGraph to your Diagram</p>
<p>Probably the simplest way to add and wire up a MultibodyPlant with a
SceneGraph in your Diagram is using AddMultibodyPlantSceneGraph().</p>
<p>Recommended usages:</p>
<p>Assign to a MultibodyPlant reference (ignoring the SceneGraph):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">plant</span> <span class="o">=</span>
       <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">/*</span> <span class="n">time_step</span> <span class="o">*/</span><span class="p">);</span>
   <span class="n">plant</span><span class="o">.</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>This flavor is the simplest, when the SceneGraph is not explicitly
needed. (It can always be retrieved later via
GetSubsystemByName(“scene_graph”).)</p>
<p>Assign to auto, and use the named public fields:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">items</span> <span class="o">=</span> <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">/*</span> <span class="n">time_step</span> <span class="o">*/</span><span class="p">);</span>
   <span class="n">items</span><span class="o">.</span><span class="n">plant</span><span class="o">.</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
   <span class="n">items</span><span class="o">.</span><span class="n">scene_graph</span><span class="o">.</span><span class="n">DoBar</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>or taking advantage of C++17’s structured binding</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="p">[</span><span class="n">plant</span><span class="p">,</span> <span class="n">scene_graph</span><span class="p">]</span> <span class="o">=</span> <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
   <span class="o">...</span>
   <span class="n">plant</span><span class="o">.</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
   <span class="n">scene_graph</span><span class="o">.</span><span class="n">DoBar</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>This is the easiest way to use both the plant and scene_graph.</p>
<p>Assign to already-declared pointer variables:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;*</span> <span class="n">plant</span><span class="p">{};</span>
   <span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;*</span> <span class="n">scene_graph</span><span class="p">{};</span>
   <span class="n">std</span><span class="p">::</span><span class="n">tie</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span> <span class="n">scene_graph</span><span class="p">)</span> <span class="o">=</span>
       <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">/*</span> <span class="n">time_step</span> <span class="o">*/</span><span class="p">);</span>
   <span class="n">plant</span><span class="o">-&gt;</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
   <span class="n">scene_graph</span><span class="o">-&gt;</span><span class="n">DoBar</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>This flavor is most useful when the pointers are class member fields
(and so perhaps cannot be references).</p>
<p>** Registering geometry with a SceneGraph</p>
<p>MultibodyPlant users can register geometry with a SceneGraph for
essentially two purposes; a) visualization and, b) contact modeling.</p>
<p>Before any geometry registration takes place, a user <strong>must</strong> first
make a call to RegisterAsSourceForSceneGraph() in order to register
the MultibodyPlant as a client of a SceneGraph instance, point at
which the plant will have assigned a valid geometry::SourceId. At
Finalize(), MultibodyPlant will declare input/output ports as
appropriate to communicate with the SceneGraph instance on which
registrations took place. All geometry registration <strong>must</strong> be
performed pre-finalize.</p>
<p>Multibodyplant declares an input port for geometric queries, see
get_geometry_query_input_port(). If MultibodyPlant registers geometry
with a SceneGraph via calls to RegisterCollisionGeometry(), users may
use this port for geometric queries. Users must connect this input
port to the output port for geometric queries of the SceneGraph used
for registration, which can be obtained with
SceneGraph::get_query_output_port(). In summary, if MultibodyPlant
registers collision geometry, the setup process will include:</p>
<p>1. Call to RegisterAsSourceForSceneGraph(). 2. Calls to
RegisterCollisionGeometry(), as many as needed. 3. Call to Finalize(),
user is done specifying the model. 4. Connect
SceneGraph::get_query_output_port() to
get_geometry_query_input_port().</p>
<p>Refer to the documentation provided in each of the methods above for
further details.</p>
<p>** Accessing point contact parameters MultibodyPlant’s point contact
model looks for model parameters stored as
geometry::ProximityProperties by geometry::SceneGraph. These
properties can be obtained before or after context creation through
geometry::SceneGraphInspector APIs as outlined below. MultibodyPlant
expects the following properties for point contact modeling:</p>
<div class="line-block">
<div class="line">Group name | Property Name | Required | Property Type | Property</div>
</div>
<p>Description | | :——–: | :————–: | :——: |
:—————-: | :——————- | | material |
coulomb_friction | yes¹ | CoulombFriction&lt;T&gt; | Static and Dynamic
friction. | | material | point_contact_stiffness | no² | T | Penalty
method stiffness. | | material | hunt_crossley_dissipation | no² | T |
Penalty method dissipation. |</p>
<p>¹ Collision geometry is required to be registered with a
geometry::ProximityProperties object that contains the (“material”,
“coulomb_friction”) property. If the property is missing,
MultibodyPlant will throw an exeception.</p>
<p>² If the property is missing, MultibodyPlant will use a heuristic
value as the default. Refer to the section mbp_penalty_method “Penalty
method point contact” for further details.</p>
<p>Accessing and modifying contact properties requires interfacing with
geometry::SceneGraph’s model inspector. Interfacing with a model
inspector obtained from geometry::SceneGraph will provide the default
registered values for a given parameter. These are the values that
will initially appear in a systems::Context created by
CreateDefaultContext(). Subsequently, true system paramters can be
accessed and changed through a systems::Context once available. For
both of the above cases, proximity properties are accessed through
geometry::SceneGraphInspector APIs.</p>
<p>Before context creation an inspector can be retrieved directly from
SceneGraph as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">For</span> <span class="n">a</span> <span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">instance</span> <span class="n">called</span> <span class="n">scene_graph</span><span class="o">.</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">inspector</span> <span class="o">=</span>
<span class="n">scene_graph</span><span class="o">.</span><span class="n">model_inspector</span><span class="p">();</span>
</pre></div>
</div>
<p>After context creation, an inspector can be retrieved from the state
stored in the context by the plant’s geometry query input port:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">For</span> <span class="n">a</span> <span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">instance</span> <span class="n">called</span> <span class="n">mbp</span> <span class="ow">and</span> <span class="n">a</span>
<span class="o">//</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">called</span> <span class="n">context</span><span class="o">.</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">QueryObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">query_object</span> <span class="o">=</span>
<span class="n">mbp</span><span class="o">.</span><span class="n">get_geometry_query_input_port</span><span class="p">()</span>
<span class="o">.</span><span class="n">template</span> <span class="n">Eval</span><span class="o">&lt;</span><span class="n">geometry</span><span class="p">::</span><span class="n">QueryObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">inspector</span> <span class="o">=</span>
<span class="n">query_object</span><span class="o">.</span><span class="n">inspector</span><span class="p">();</span>
</pre></div>
</div>
<p>Once an inspector is available, proximity properties can be retrieved
as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">For</span> <span class="n">a</span> <span class="n">body</span> <span class="k">with</span> <span class="n">GeometryId</span> <span class="n">called</span> <span class="n">geometry_id</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">ProximityProperties</span><span class="o">*</span> <span class="n">props</span> <span class="o">=</span>
<span class="n">inspector</span><span class="o">.</span><span class="n">GetProximityProperties</span><span class="p">(</span><span class="n">geometry_id</span><span class="p">);</span>
<span class="n">const</span> <span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">geometry_friction</span> <span class="o">=</span>
<span class="n">props</span><span class="o">-&gt;</span><span class="n">GetProperty</span><span class="o">&lt;</span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s2">&quot;material&quot;</span><span class="p">,</span>
<span class="s2">&quot;coulomb_friction&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p><a href="#id9"><span class="problematic" id="id10">**</span></a>** Adding modeling elements</p>
<p>Add multibody elements to a MultibodyPlant with methods like:</p>
<ul class="simple">
<li>Bodies: AddRigidBody() - Joints: AddJoint() - see mbp_construction</li>
</ul>
<p>“Construction” for more.</p>
<p>All modeling elements <strong>must</strong> be added before Finalize() is called.
See mbp_finalize_stage “Finalize stage” for a discussion.</p>
<p><a href="#id11"><span class="problematic" id="id12">**</span></a>** Modeling contact</p>
<p>Please refer to drake_contacts “Contact Modeling in Drake” for details
on the available approximations, setup, and considerations for a
multibody simulation with frictional contact.</p>
<p><a href="#id13"><span class="problematic" id="id14">**</span></a>** Energy and Power</p>
<p>MultibodyPlant implements the System energy and power methods, with
some limitations. - Kinetic energy: fully implemented. - Potential
energy and conservative power: currently include only gravity and
contributions from ForceElement objects; potential energy from
compliant contact and joint limits are not included. - Nonconservative
power: currently includes only contributions from ForceElement
objects; actuation and input port forces, joint damping, and
dissipation from joint limits, friction, and contact dissipation are
not included.</p>
<p>See Drake issue #12942 for more discussion.</p>
<p><a href="#id15"><span class="problematic" id="id16">**</span></a>** Finalize() stage</p>
<p>Once the user is done adding modeling elements and registering
geometry, a call to Finalize() must be performed. This call will: -
Build the underlying MultibodyTree topology, see
MultibodyTree::Finalize() for details, - declare the plant’s state, -
declare the plant’s input and output ports, - declare input and output
ports for communication with a SceneGraph.</p>
<p><a href="#id17"><span class="problematic" id="id18">**</span></a>** References</p>
<ul class="simple">
<li>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics</li>
</ul>
<p>algorithms. Springer. - [Jain 2010] Jain, A., 2010. Robot and
multibody dynamics: analysis and algorithms. Springer Science &amp;
Business Media. - [Seth 2010] Seth, A., Sherman, M., Eastman, P. and
Delp, S., 2010. Minimal formulation of joint motion for biomechanisms.
Nonlinear dynamics, 62(1), pp.291-303.</p>
<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], time_step: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>This constructor creates a plant with a single “world” body.
Therefore, right after creation, num_bodies() returns one.</p>
<p>MultibodyPlant offers two different modalities to model mechanical
systems in time. These are: 1. As a discrete system with periodic
updates, <code class="docutils literal"><span class="pre">time_step</span></code> is strictly greater than zero. 2. As a
continuous system, <code class="docutils literal"><span class="pre">time_step</span></code> equals exactly zero.</p>
<p>Currently the discrete model is preferred for simulation given its
robustness and speed in problems with frictional contact. However this
might change as we work towards developing better strategies to model
contact. See time_advancement_strategy “Choice of Time Advancement
Strategy” for further details.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Users should be aware of current limitations in either modeling
modality. While the discrete model is often the preferred option
for problems with frictional contact given its robustness and
speed, it might become unstable when using large feedback gains,
high damping or large external forcing. MultibodyPlant will throw
an exception whenever the discrete solver is detected to fail.
Conversely, the continuous modality has the potential to leverage
the robustness and accuracy control provide by Drake’s
integrators. However thus far this has proved difficult in
practice and especially due to poor performance.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">time_step</span></code>:</dt>
<dd>Indicates whether <code class="docutils literal"><span class="pre">this</span></code> plant is modeled as a continuous system
(<code class="docutils literal"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code>) or as a discrete system with periodic updates
of period <code class="docutils literal"><span class="pre">time_step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. See time_advancement_strategy “Choice
of Time Advancement Strategy” for further details.</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Currently the continuous modality with <code class="docutils literal"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code> does not
support joint limits for simulation, these are ignored.
MultibodyPlant prints a warning to console if joint limits are
provided. If your simulation requires joint limits currently you
must use a discrete MultibodyPlant model.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">time_step</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].AddForceElement">
<code class="descname">AddForceElement</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], force_element: pydrake.multibody.tree.ForceElement_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ForceElement_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].AddForceElement" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a new force element model of type <code class="docutils literal"><span class="pre">ForceElementType</span></code> to
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. The arguments to this method <code class="docutils literal"><span class="pre">args</span></code> are
forwarded to <a href="#id19"><span class="problematic" id="id20">``</span></a>ForceElementType`’s constructor.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">args</span></code>:</dt>
<dd>Zero or more parameters provided to the constructor of the new
force element. It must be the case that
<cite>ForceElementType&lt;T&gt;(args)`</cite> is a valid constructor.</dd>
<dt>Template parameter <code class="docutils literal"><span class="pre">ForceElementType</span></code>:</dt>
<dd>The type of the ForceElement to add. As there is always a
UniformGravityFieldElement present (accessible through
gravity_field()), an exception will be thrown if this function is
called to add another UniformGravityFieldElement.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A constant reference to the new ForceElement just added, of type
<code class="docutils literal"><span class="pre">ForceElementType&lt;T&gt;</span></code> specialized on the scalar type T of
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. It will remain valid for the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The ForceElement class’s documentation for further details on how
a force element is defined.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].AddFrame">
<code class="descname">AddFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], frame: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].AddFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>This method adds a Frame of type <code class="docutils literal"><span class="pre">FrameType&lt;T&gt;</span></code>. For more
information, please see the corresponding constructor of
<code class="docutils literal"><span class="pre">FrameType</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">FrameType</span></code>:</dt>
<dd>Template which will be instantiated on <code class="docutils literal"><span class="pre">T</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame</span></code>:</dt>
<dd>Unique pointer frame instance.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A constant reference to the new Frame just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].AddJoint">
<code class="descname">AddJoint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], joint: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].AddJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>This method adds a Joint of type <code class="docutils literal"><span class="pre">JointType</span></code> between two bodies. For
more information, see the below overload of <code class="docutils literal"><span class="pre">AddJoint&lt;&gt;</span></code>, and the
related <code class="docutils literal"><span class="pre">MultibodyTree::AddJoint&lt;&gt;</span></code> method.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].AddJointActuator">
<code class="descname">AddJointActuator</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, joint: pydrake.multibody.tree.Joint_[float], effort_limit: float = inf</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuator_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].AddJointActuator" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and adds a JointActuator model for an actuator acting on a
given <code class="docutils literal"><span class="pre">joint</span></code>. This method returns a constant reference to the
actuator just added, which will remain valid for the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> plant.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that uniquely identifies the new actuator to be added to
<code class="docutils literal"><span class="pre">this</span></code> model. A RuntimeError is thrown if an actuator with the
same name already exists in the model. See
HasJointActuatorNamed().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">joint</span></code>:</dt>
<dd>The Joint to be actuated by the new JointActuator.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">effort_limit</span></code>:</dt>
<dd>The maximum effort for the actuator. It must be strictly positive,
otherwise an RuntimeError is thrown. If +∞, the actuator has no
limit, which is the default. The effort limit has physical units
in accordance to the joint type it actuates. For instance, it will
have units of N⋅m (torque) for revolute joints while it will have
units of N (force) for prismatic joints.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A constant reference to the new JointActuator just added, which
will remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> plant.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">joint.num_velocities()</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> since for now we</li>
<li>only support actuators for single dof joints.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].AddModelInstance">
<code class="descname">AddModelInstance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], name: str</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].AddModelInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new model instance. Returns the index for the model
instance.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that uniquely identifies the new instance to be added to
<code class="docutils literal"><span class="pre">this</span></code> model. An exception is thrown if an instance with the
same name already exists in the model. See
HasModelInstanceNamed().</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].AddRigidBody">
<code class="descname">AddRigidBody</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].AddRigidBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; pydrake.multibody.tree.RigidBody_[float]</li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. The body
will use the default model instance (model_instance “more on model
instances”).</p>
<p>Example of usage:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">;</span>
  <span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">to</span> <span class="n">define</span> <span class="n">spatial_inertia</span><span class="p">,</span> <span class="n">a</span> <span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">object</span> <span class="o">...</span>
  <span class="n">const</span> <span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">body</span> <span class="o">=</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s2">&quot;BodyName&quot;</span><span class="p">,</span> <span class="n">spatial_inertia</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that identifies the new body to be added to <code class="docutils literal"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal"><span class="pre">name</span></code> already
is part of the model in the default model instance. See
HasBodyNamed(), Body::name().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>The SpatialInertia of the new rigid body to be added to <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal"><span class="pre">Bo</span></code> and
expressed in the body frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if additional model instances have been created</li>
<li>beyond the world and default instances.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; pydrake.multibody.tree.RigidBody_[float]</li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<p>Example of usage:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">;</span>
  <span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">to</span> <span class="n">define</span> <span class="n">spatial_inertia</span><span class="p">,</span> <span class="n">a</span> <span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">object</span> <span class="o">...</span>
  <span class="n">ModelInstanceIndex</span> <span class="n">model_instance</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">AddModelInstance</span><span class="p">(</span><span class="s2">&quot;instance&quot;</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">body</span> <span class="o">=</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s2">&quot;BodyName&quot;</span><span class="p">,</span> <span class="n">model_instance</span><span class="p">,</span> <span class="n">spatial_inertia</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that identifies the new body to be added to <code class="docutils literal"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal"><span class="pre">name</span></code> already
is part of <code class="docutils literal"><span class="pre">model_instance</span></code>. See HasBodyNamed(), Body::name().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">model_instance</span></code>:</dt>
<dd>A model instance index which this body is part of.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>The SpatialInertia of the new rigid body to be added to <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal"><span class="pre">Bo</span></code> and
expressed in the body frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcBiasSpatialAcceleration">
<code class="descname">CalcBiasSpatialAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BoBp_B: numpy.ndarray[numpy.float64[3, 1]], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcBiasSpatialAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>For one point Bp affixed/welded to a frame B, calculates A𝑠Bias_ABp,
Bp’s spatial acceleration bias in frame A with respect to “speeds” 𝑠,
where 𝑠 is either q̇ (time-derivatives of generalized positions) or v
(generalized velocities). A𝑠Bias_ABp is the term in A_ABp (Bp’s
spatial acceleration in A) that does not include 𝑠̇, i.e., A𝑠Bias_ABp
is Bi’s translational acceleration in A when 𝑠̇ = 0.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   (𝑠 = q̇ or 𝑠 = v), hence
  A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠
</pre></div>
</div>
<p>where J𝑠_V_ABp is Bp’s spatial velocity Jacobian in frame A for speeds
s (see CalcJacobianSpatialVelocity() for details on J𝑠_V_ABp).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the spatial
accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which point Bp is affixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBp_B</span></code>:</dt>
<dd>Position vector from Bo (frame_B’s origin) to point Bp (regarded
as affixed/welded to B), expressed in frame_B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures A𝑠Bias_ABp. Currently, an exception is
thrown if frame_A is not the World frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which A𝑠Bias_ABp is expressed on output.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A𝑠Bias_ABp_E Point Bp’s spatial acceleration bias in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shown below, A𝑠Bias_ABp_E = J̇𝑠_V_ABp ⋅ 𝑠 is quadratic in 𝑠.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>V_ABp =  J𝑠_V_ABp ⋅ 𝑠        which upon vector differentiation in A gives
 A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   Since J̇𝑠_V_ABp is linear in 𝑠,
 A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠                             is quadratic in 𝑠.
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcJacobianSpatialVelocity() to compute J𝑠_V_ABp, point Bp’s
translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if with_respect_to is not JacobianWrtVariable::kV</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if frame_A is not the world frame.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcBiasTerm">
<code class="descname">CalcBiasTerm</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcBiasTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the bias term <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> containing Coriolis, centripetal,
and gyroscopic effects in the multibody equations of motion:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>M(q) v̇ + C(q, v) v = tau_app + ∑ (Jv_V_WBᵀ(q) ⋅ Fapp_Bo_W)
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">M(q)</span></code> is the multibody model’s mass matrix and <code class="docutils literal"><span class="pre">tau_app</span></code> is
a vector of generalized forces. The last term is a summation over all
bodies of the dot-product of <code class="docutils literal"><span class="pre">Fapp_Bo_W</span></code> (applied spatial force on
body B at Bo) with <code class="docutils literal"><span class="pre">Jv_V_WB(q)</span></code> (B’s spatial Jacobian in world W
with respect to generalized velocities v). Note: B’s spatial velocity
in W can be written <code class="docutils literal"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model. It stores the
generalized positions q and the generalized velocities v.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">Cv</span></code>:</dt>
<dd>On output, <code class="docutils literal"><span class="pre">Cv</span></code> will contain the product <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>. It must
be a valid (non-null) pointer to a column vector in <code class="docutils literal"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities (num_velocities()) of the
model. This method aborts if Cv is nullptr or if it does not have
the proper size.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcBiasTranslationalAcceleration">
<code class="descname">CalcBiasTranslationalAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BoBi_B: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcBiasTranslationalAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi,
Bi’s translational acceleration bias in frame A with respect to
“speeds” 𝑠, where 𝑠 is either q̇ (time-derivatives of generalized
positions) or v (generalized velocities). a𝑠Bias_ABi is the term in
a_ABi (Bi’s translational acceleration in A) that does not include 𝑠̇,
i.e., a𝑠Bias_ABi is Bi’s translational acceleration in A when 𝑠̇ = 0.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇  +  J̇𝑠_v_ABi ⋅ 𝑠  (𝑠 = q̇ or 𝑠 = v), hence
  a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠
</pre></div>
</div>
<p>where J𝑠_v_ABi is Bi’s translational velocity Jacobian in frame A for
s (see CalcJacobianTranslationalVelocity() for details on J𝑠_v_ABi).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the translational
accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which points Bi are affixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBi_B</span></code>:</dt>
<dd>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B. Each column in the <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span>
<span class="pre">p</span></code> matrix p_BoBi_B corresponds to a position vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures a𝑠Bias_ABi. Currently, an exception is
thrown if frame_A is not the World frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which a𝑠Bias_ABi is expressed on output.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a𝑠Bias_ABi_E Point Bi’s translational acceleration bias in frame A
with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
a𝑠Bias_ABi_E is a <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">p</span></code> matrix, where p is the number of
points Bi.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shown below, a𝑠Bias_ABi_E = J̇𝑠_v_ABp ⋅ 𝑠 is quadratic in 𝑠.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>v_ABi =  J𝑠_v_ABi ⋅ 𝑠        which upon vector differentiation in A gives
 a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇ + J̇𝑠_v_ABi ⋅ 𝑠     Since J̇𝑠_v_ABi is linear in 𝑠,
 a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠                             is quadratic in 𝑠.
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcJacobianTranslationalVelocity() to compute J𝑠_v_ABi, point
Bi’s translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>p_BoBi_B must have 3 rows.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if with_respect_to is not JacobianWrtVariable::kV</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if frame_A is not the world frame.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcCenterOfMassPosition">
<code class="descname">CalcCenterOfMassPosition</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcCenterOfMassPosition" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the center of mass position p_WCcm of all bodies
in <code class="docutils literal"><span class="pre">MultibodyPlant</span></code> measured and expressed in world frame W. The
bodies are considered as a single composite body C, whose center of
mass <code class="docutils literal"><span class="pre">composite_mass</span></code> is located at Ccm. The world_body() is
ignored.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model. It stores the
generalized positions q of the model.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">p_WCcm</span></code>:</dt>
<dd>The output position of center of mass in the world frame W.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">MultibodyPlant</span></code> has no body except</li>
<li><code class="docutils literal"><span class="pre">world_body()</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError unless <code class="docutils literal"><span class="pre">composite_mass</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcForceElementsContribution">
<code class="descname">CalcForceElementsContribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], forces: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcForceElementsContribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the combined force contribution of ForceElement objects in
the model. A ForceElement can apply forces as a spatial force per body
or as generalized forces, depending on the ForceElement model.
ForceElement contributions are a function of the state and time only.
The output from this method can immediately be used as input to
CalcInverseDynamics() to include the effect of applied forces by force
elements.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of this model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">forces</span></code>:</dt>
<dd>A pointer to a valid, non nullptr, multibody forces object. On
output <code class="docutils literal"><span class="pre">forces</span></code> will store the forces exerted by all the
ForceElement objects in the model.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">forces</span></code> is null or not compatible with this</li>
<li>model, per MultibodyForces::CheckInvariants().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcGravityGeneralizedForces">
<code class="descname">CalcGravityGeneralizedForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcGravityGeneralizedForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the generalized forces <code class="docutils literal"><span class="pre">tau_g(q)</span></code> due to gravity as a
function of the generalized positions <code class="docutils literal"><span class="pre">q</span></code> stored in the input
<code class="docutils literal"><span class="pre">context</span></code>. The vector of generalized forces due to gravity
<code class="docutils literal"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the right hand side of
the equations of motion together with any other generalized forces,
like so:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Mv̇</span> <span class="o">+</span> <span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="n">v</span> <span class="o">=</span> <span class="n">tau_g</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau_app</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the model.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tau_g A vector containing the generalized forces due to gravity.
The generalized forces are consistent with the vector of
generalized velocities <code class="docutils literal"><span class="pre">v</span></code> for <code class="docutils literal"><span class="pre">this</span></code> so that the inner
product <code class="docutils literal"><span class="pre">v⋅tau_g</span></code> corresponds to the power applied by the
gravity forces on the mechanical system. That is, <code class="docutils literal"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>
corresponds to potential energy going into the system, as either
mechanical kinetic energy, some other potential energy, or heat,
and therefore to a decrease of the gravitational potential energy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcInverseDynamics">
<code class="descname">CalcInverseDynamics</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], known_vdot: numpy.ndarray[numpy.float64[m, 1]], external_forces: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcInverseDynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the state of this model in <code class="docutils literal"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal"><span class="pre">vdot</span></code>, this method computes the set of
generalized forces <code class="docutils literal"><span class="pre">tau</span></code> that would need to be applied in order to
attain the specified generalized accelerations. Mathematically, this
method computes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>tau = M(q)v̇ + C(q, v)v - tau_app - ∑ J_WBᵀ(q) Fapp_Bo_W
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">M(q)</span></code> is the model’s mass matrix, <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> is the bias
term containing Coriolis and gyroscopic effects and <code class="docutils literal"><span class="pre">tau_app</span></code>
consists of a vector applied generalized forces. The last term is a
summation over all bodies in the model where <code class="docutils literal"><span class="pre">Fapp_Bo_W</span></code> is an
applied spatial force on body B at <code class="docutils literal"><span class="pre">Bo</span></code> which gets projected into
the space of generalized forces with the transpose of <code class="docutils literal"><span class="pre">Jv_V_WB(q)</span></code>
(where <code class="docutils literal"><span class="pre">Jv_V_WB</span></code> is B’s spatial velocity Jacobian in W with respect
to generalized velocities v). Note: B’s spatial velocity in W can be
written as <code class="docutils literal"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>. This method does not compute
explicit expressions for the mass matrix nor for the bias term, which
would be of at least <code class="docutils literal"><span class="pre">O(n²)</span></code> complexity, but it implements an
<code class="docutils literal"><span class="pre">O(n)</span></code> Newton-Euler recursive algorithm, where n is the number of
bodies in the model. The explicit formation of the mass matrix
<code class="docutils literal"><span class="pre">M(q)</span></code> would require the calculation of <code class="docutils literal"><span class="pre">O(n²)</span></code> entries while
explicitly forming the product <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)</span> <span class="pre">*</span> <span class="pre">v</span></code> could require up to
<code class="docutils literal"><span class="pre">O(n³)</span></code> operations (see [Featherstone 1987, §4]), depending on the
implementation. The recursive Newton-Euler algorithm is the most
efficient currently known general method for solving inverse dynamics
[Featherstone 2008].</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">known_vdot</span></code>:</dt>
<dd>A vector with the known generalized accelerations <code class="docutils literal"><span class="pre">vdot</span></code> for the
full model. Use the provided Joint APIs in order to access entries
into this array.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">external_forces</span></code>:</dt>
<dd>A set of forces to be applied to the system either as body spatial
forces <code class="docutils literal"><span class="pre">Fapp_Bo_W</span></code> or generalized forces <code class="docutils literal"><span class="pre">tau_app</span></code>, see
MultibodyForces for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the vector of generalized forces that would need to be applied to
the mechanical system in order to achieve the desired acceleration
given by <code class="docutils literal"><span class="pre">known_vdot</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcJacobianAngularVelocity">
<code class="descname">CalcJacobianAngularVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcJacobianAngularVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates J𝑠_w_AB, a frame B’s angular velocity Jacobian in a frame A
with respect to “speeds” 𝑠.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>J𝑠_w_AB ≜ [ ∂(w_AB)/∂𝑠₁,  ...  ∂(w_AB)/∂𝑠ₙ ]    (n is j or k)
     w_AB = J𝑠_w_AB ⋅ 𝑠          w_AB is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">w_AB</span></code> is B’s angular velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal"><span class="pre">J𝑠_w_AB</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame B in <code class="docutils literal"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame A in <code class="docutils literal"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which <code class="docutils literal"><span class="pre">w_AB</span></code> is expressed on input and the frame in
which the Jacobian <code class="docutils literal"><span class="pre">J𝑠_w_AB</span></code> is expressed on output.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">J𝑠_w_AB_E</span></code>:</dt>
<dd>Frame B’s angular velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E. The
Jacobian is a function of only generalized positions q (which are
pulled from the context). The previous definition shows
<code class="docutils literal"><span class="pre">J𝑠_w_AB_E</span></code> is a matrix of size <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code>, where n is the number
of elements in 𝑠.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">J𝑠_w_AB_E</span></code> is nullptr or not of size <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcJacobianSpatialVelocity">
<code class="descname">CalcJacobianSpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BP: numpy.ndarray[numpy.float64[3, 1]], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcJacobianSpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp’s
spatial velocity Jacobian in frame A with respect to “speeds” 𝑠.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>J𝑠_V_ABp ≜ [ ∂(V_ABp)/∂𝑠₁,  ...  ∂(V_ABp)/∂𝑠ₙ ]    (n is j or k)
     V_ABp = J𝑠_V_ABp ⋅ 𝑠          V_ABp is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">V_ABp</span></code> is Bp’s spatial velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal"><span class="pre">J𝑠_V_ABp</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which point Bp is fixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBp_B</span></code>:</dt>
<dd>A position vector from Bo (frame_B’s origin) to point Bp (regarded
as fixed/welded to B), expressed in frame_B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures <code class="docutils literal"><span class="pre">v_ABp</span></code> (Bp’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAp_A (similar
to the parameter p_BoBp_B for frame_B). There is no need for
p_AoAp_A because Bp’s velocity in A is defined as the derivative
in frame A of Bp’s position vector from <em>any</em> point fixed to A.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which <code class="docutils literal"><span class="pre">v_ABp</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal"><span class="pre">J𝑠_V_ABp</span></code> is expressed on output.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">J𝑠_V_ABp_E</span></code>:</dt>
<dd>Point Bp’s spatial velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E.
<code class="docutils literal"><span class="pre">J𝑠_V_ABp_E</span></code> is a <code class="docutils literal"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where n is the number of
elements in 𝑠. The Jacobian is a function of only generalized
positions q (which are pulled from the context). Note: The
returned <code class="docutils literal"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix stores frame B’s angular velocity
Jacobian in A in rows 1-3 and stores point Bp’s translational
velocity Jacobian in A in rows 4-6, i.e.,</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">J𝑠_w_AB_E</span> <span class="o">=</span> <span class="n">J𝑠_V_ABp_E</span><span class="o">.</span><span class="n">topRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">J𝑠_v_ABp_E</span> <span class="o">=</span> <span class="n">J𝑠_V_ABp_E</span><span class="o">.</span><span class="n">bottomRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>Note: Consider CalcJacobianTranslationalVelocity() for multiple points
fixed to frame B and consider CalcJacobianAngularVelocity() to
calculate frame B’s angular velocity Jacobian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">J𝑠_V_ABp_E</span></code> is nullptr or not sized <code class="docutils literal"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcJacobianTranslationalVelocity">
<code class="descname">CalcJacobianTranslationalVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BoBi_B: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcJacobianTranslationalVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi,
Bi’s translational velocity Jacobian in frame A with respect to
“speeds” 𝑠.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>J𝑠_v_ABi ≜ [ ∂(v_ABi)/∂𝑠₁,  ...  ∂(v_ABi)/∂𝑠ₙ ]    (n is j or k)
     v_ABi = J𝑠_v_ABi ⋅ 𝑠          v_ABi is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">v_ABi</span></code> is Bi’s translational velocity in frame A and “speeds” 𝑠 is
either q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized
positions) or v ≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal"><span class="pre">J𝑠_v_ABi</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which point Bi is affixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBi_B</span></code>:</dt>
<dd>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures <code class="docutils literal"><span class="pre">v_ABi</span></code> (Bi’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAi_A (similar
to the parameter p_BoBi_B for frame_B). There is no need for
p_AoAi_A because Bi’s velocity in A is defined as the derivative
in frame A of Bi’s position vector from <em>any</em> point affixed to A.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which <code class="docutils literal"><span class="pre">v_ABi</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal"><span class="pre">J𝑠_v_ABi</span></code> is expressed on output.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">J𝑠_v_ABi_E</span></code>:</dt>
<dd>Point Bi’s velocity Jacobian in frame A with respect to speeds 𝑠
(which is either q̇ or v), expressed in frame E. <code class="docutils literal"><span class="pre">J𝑠_v_ABi_E</span></code> is
a <code class="docutils literal"><span class="pre">3*p</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where p is the number of points Bi and n is
the number of elements in 𝑠. The Jacobian is a function of only
generalized positions q (which are pulled from the context).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">J𝑠_v_ABi_E</span></code> is nullptr or not sized <a href="#id21"><span class="problematic" id="id22">``</span></a>3*p x</li>
<li>n``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When 𝑠 = q̇, <code class="docutils literal"><span class="pre">Jq̇_v_ABi</span> <span class="pre">=</span> <span class="pre">Jq_p_AoBi</span></code>. In other words, point Bi’s
velocity Jacobian in frame A with respect to q̇ is equal to point
Bi’s position Jacobian from Ao (A’s origin) in frame A with
respect to q.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>[∂(v_ABi)/∂q̇₁,  ...  ∂(v_ABi)/∂q̇ⱼ] = [∂(p_AoBi)/∂q₁,  ...  ∂(p_AoBi)/∂qⱼ]
</pre></div>
</div>
<p>Note: Each partial derivative of p_AoBi is taken in frame A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcMassMatrixViaInverseDynamics">
<code class="descname">CalcMassMatrixViaInverseDynamics</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcMassMatrixViaInverseDynamics" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcPointsPositions">
<code class="descname">CalcPointsPositions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], frame_B: pydrake.multibody.tree.Frame_[float], p_BQi: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcPointsPositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the positions <code class="docutils literal"><span class="pre">p_BQi</span></code> for a set of points <code class="docutils literal"><span class="pre">Qi</span></code> measured and
expressed in a frame B, this method computes the positions
<code class="docutils literal"><span class="pre">p_AQi(q)</span></code> of each point <code class="docutils literal"><span class="pre">Qi</span></code> in the set as measured and expressed
in another frame A, as a function of the generalized positions q of
the model.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model. It stores the
generalized positions q of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame B in which the positions <code class="docutils literal"><span class="pre">p_BQi</span></code> of a set of points
<code class="docutils literal"><span class="pre">Qi</span></code> are given.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BQi</span></code>:</dt>
<dd>The input positions of each point <code class="docutils literal"><span class="pre">Qi</span></code> in frame B. <code class="docutils literal"><span class="pre">p_BQi</span> <span class="pre">∈</span>
<span class="pre">ℝ³ˣⁿᵖ</span></code> with <code class="docutils literal"><span class="pre">np</span></code> the number of points in the set. Each column
of <code class="docutils literal"><span class="pre">p_BQi</span></code> corresponds to a vector in ℝ³ holding the position of
one of the points in the set as measured and expressed in frame B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame A in which it is desired to compute the positions
<code class="docutils literal"><span class="pre">p_AQi</span></code> of each point <code class="docutils literal"><span class="pre">Qi</span></code> in the set.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_AQi</span></code>:</dt>
<dd>The output positions of each point <code class="docutils literal"><span class="pre">Qi</span></code> now computed as measured
and expressed in frame A. The output <code class="docutils literal"><span class="pre">p_AQi</span></code> <strong>must</strong> have the
same size as the input <code class="docutils literal"><span class="pre">p_BQi</span></code> or otherwise this method aborts.
That is <code class="docutils literal"><span class="pre">p_AQi</span></code> <strong>must</strong> be in <code class="docutils literal"><span class="pre">ℝ³ˣⁿᵖ</span></code>.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Both <code class="docutils literal"><span class="pre">p_BQi</span></code> and <code class="docutils literal"><span class="pre">p_AQi</span></code> must have three rows. Otherwise this
method will throw a RuntimeError exception. This method also
throws a RuntimeError exception if <code class="docutils literal"><span class="pre">p_BQi</span></code> and <code class="docutils literal"><span class="pre">p_AQi</span></code> differ
in the number of columns.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcRelativeTransform">
<code class="descname">CalcRelativeTransform</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], frame_A: pydrake.multibody.tree.Frame_[float], frame_B: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcRelativeTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rigid transform (pose) <code class="docutils literal"><span class="pre">X_FG</span></code> relating frame F and
frame G.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal"><span class="pre">X_FG</span></code> is a function of q.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_F</span></code>:</dt>
<dd>The frame F designated in the rigid transform <code class="docutils literal"><span class="pre">X_FG</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_G</span></code>:</dt>
<dd>The frame G designated in the rigid transform <code class="docutils literal"><span class="pre">X_FG</span></code>.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">X_FG</span></code>:</dt>
<dd>The RigidTransform relating frame F and frame G.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcSpatialAccelerationsFromVdot">
<code class="descname">CalcSpatialAccelerationsFromVdot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], known_vdot: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.multibody.math.SpatialAcceleration_[float]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CalcSpatialAccelerationsFromVdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the state of this model in <code class="docutils literal"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal"><span class="pre">known_vdot</span></code>, this method computes the
spatial acceleration <code class="docutils literal"><span class="pre">A_WB</span></code> for each body as measured and expressed
in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of this model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">known_vdot</span></code>:</dt>
<dd>A vector with the generalized accelerations for the full model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">A_WB_array</span></code>:</dt>
<dd>A pointer to a valid, non nullptr, vector of spatial accelerations
containing the spatial acceleration <code class="docutils literal"><span class="pre">A_WB</span></code> for each body. It
must be of size equal to the number of bodies in the model. On
output, entries will be ordered by BodyIndex.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if A_WB_array is not of size <code class="docutils literal"><span class="pre">num_bodies()</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CollectRegisteredGeometries">
<code class="descname">CollectRegisteredGeometries</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], bodies: List[pydrake.multibody.tree.Body_[float]]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.GeometrySet<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].CollectRegisteredGeometries" title="Permalink to this definition">¶</a></dt>
<dd><p>For each of the provided <code class="docutils literal"><span class="pre">bodies</span></code>, collects up all geometries that
have been registered to that body. Intended to be used in conjunction
with SceneGraph::ExcludeCollisionsWithin() and
SceneGraph::ExcludeCollisionsBetween() to filter collisions between
the geometries registered to the bodies.</p>
<p>For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Don&#39;t report on collisions between geometries affixed to ``body1``,
// ``body2``, or ``body3``.
std::vector&lt;const RigidBody&lt;T&gt;*&gt; bodies{&amp;body1, &amp;body2, &amp;body3};
geometry::GeometrySet set = plant.CollectRegisteredGeometries(bodies);
scene_graph.ExcludeCollisionsWithin(set);
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is a <em>very</em> specific order of operations:</p>
</div>
<ol class="arabic simple">
<li>Bodies and geometries must be added to the MultibodyPlant.</li>
<li>The MultibodyPlant must be finalized (via Finalize()).</li>
<li>Create GeometrySet instances from bodies (via this method).</li>
<li>Invoke SceneGraph::ExcludeCollisions*() to filter collisions.</li>
<li>Allocate context.</li>
</ol>
<p>Changing the order will cause exceptions to be thrown.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].default_coulomb_friction">
<code class="descname">default_coulomb_friction</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.plant.CoulombFriction_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].default_coulomb_friction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the friction coefficients provided during geometry
registration for the given geometry <code class="docutils literal"><span class="pre">id</span></code>. We call these the
“default” coefficients but note that we mean user-supplied
per-geometry default, not something more global.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not correspond to a geometry in</li>
<li><code class="docutils literal"><span class="pre">this</span></code> model registered for contact modeling.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RegisterCollisionGeometry() for details on geometry registration.
(Deprecated.)</p>
</div>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>default_coulomb_friction() will be removed. Please use SceneGraph
which now stores friction properties in ProximityProperties. See
the section “Accessing point contact parameters” in the
documentation for MultibodyPlant. This will be removed from Drake
on or after 2020-09-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].EvalBodyPoseInWorld">
<code class="descname">EvalBodyPoseInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].EvalBodyPoseInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the pose <code class="docutils literal"><span class="pre">X_WB</span></code> of a body B in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">body_B</span></code>:</dt>
<dd>The body B for which the pose is requested.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">X_WB</span></code>:</dt>
<dd>The pose of body frame B in the world frame W.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if Finalize() was not called on <code class="docutils literal"><span class="pre">this</span></code> model or if</li>
<li><code class="docutils literal"><span class="pre">body_B</span></code> does not belong to this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].EvalBodySpatialVelocityInWorld">
<code class="descname">EvalBodySpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].EvalBodySpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the spatial velocity <code class="docutils literal"><span class="pre">V_WB</span></code> of a body B in the world frame
W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">body_B</span></code>:</dt>
<dd>The body B for which the spatial velocity is requested.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">V_WB The spatial velocity of body frame B in the world frame W.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if Finalize() was not called on <code class="docutils literal"><span class="pre">this</span></code> model or if</li>
<li><code class="docutils literal"><span class="pre">body_B</span></code> does not belong to this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].Finalize">
<code class="descname">Finalize</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].Finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>This method must be called after all elements in the model (joints,
bodies, force elements, constraints, etc.) are added and before any
computations are performed. It essentially compiles all the necessary
“topological information”, i.e. how bodies, joints and, any other
elements connect with each other, and performs all the required
pre-processing to enable computations at a later stage.</p>
<p>If the finalize stage is successful, the topology of this
MultibodyPlant is valid, meaning that the topology is up-to-date after
this call. No more multibody elements can be added after a call to
Finalize().</p>
<p>At Finalize(), state and input/output ports for <code class="docutils literal"><span class="pre">this</span></code> plant are
declared. If <code class="docutils literal"><span class="pre">this</span></code> plant registered geometry with a SceneGraph,
input and output ports to enable communication with that SceneGraph
are declared as well.</p>
<p>If geometry has been registered on a SceneGraph instance, that
instance must be provided to the Finalize() method so that any
geometric implications of the finalization process can be
appropriately handled.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">is_finalized().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the MultibodyPlant has already been finalized.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].geometry_source_is_registered">
<code class="descname">geometry_source_is_registered</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].geometry_source_is_registered" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant was registered with a
SceneGraph. This method can be called at any time during the lifetime
of <code class="docutils literal"><span class="pre">this</span></code> plant to query if <code class="docutils literal"><span class="pre">this</span></code> plant has been registered with
a SceneGraph, either pre- or post-finalize, see Finalize().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_actuation_input_port">
<code class="descname">get_actuation_input_port</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_actuation_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[float]) -&gt; pydrake.systems.framework.InputPort_[float]</li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for the case where only one model instance has actuated dofs. This
input port is a vector valued port, which can be set with
JointActuator::set_actuation_vector().</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called before Finalize(), if the model does not</li>
<li>contain any actuators, or if multiple model instances have</li>
<li>actuated dofs.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.InputPort_[float]</li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for a specific model instance. This input port is a vector valued
port, which can be set with JointActuator::set_actuation_vector().</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_applied_generalized_force_input_port">
<code class="descname">get_applied_generalized_force_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_applied_generalized_force_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the vector-valued input port for
applied generalized forces, and the vector will be added directly into
<code class="docutils literal"><span class="pre">tau</span></code> (see mbp_equations_of_motion “System dynamics”). This vector
is ordered using the same convention as the plant velocities: you can
set the generalized forces that will be applied to model instance i
using, e.g., <code class="docutils literal"><span class="pre">SetVelocitiesInArray(i,</span> <span class="pre">model_forces,</span> <span class="pre">&amp;force_array)</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_applied_spatial_force_input_port">
<code class="descname">get_applied_spatial_force_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_applied_spatial_force_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the input port for applying spatial
forces to bodies in the plant. The data type for the port is an
std::vector of ExternallyAppliedSpatialForce; any number of spatial
forces can be applied to any number of bodies in the plant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_body">
<code class="descname">get_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], body_index: pydrake.multibody.tree.BodyIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the body with unique index
<code class="docutils literal"><span class="pre">body_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">body_index</span></code> does not correspond to a body in</li>
<li>this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_body_poses_output_port">
<code class="descname">get_body_poses_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_body_poses_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of all body poses in the world frame. You can
obtain the pose <code class="docutils literal"><span class="pre">X_WB</span></code> of a body B in the world frame W with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">X_WB_all</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">get_body_poses_output_port</span><span class="p">()</span><span class="o">.</span>
      <span class="o">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">math</span><span class="p">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">BodyIndex</span> <span class="n">arm_body_index</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s2">&quot;arm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">math</span><span class="p">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">X_WArm</span> <span class="o">=</span> <span class="n">X_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
<p>As shown in the example above, the resulting <code class="docutils literal"><span class="pre">std::vector</span></code> of body
poses is indexed by BodyIndex, and it has size num_bodies(). BodyIndex
“zero” (0) always corresponds to the world body, with pose equal to
the identity at all times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_body_spatial_accelerations_output_port">
<code class="descname">get_body_spatial_accelerations_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_body_spatial_accelerations_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of all body spatial accelerations in the world
frame. You can obtain the spatial acceleration <code class="docutils literal"><span class="pre">A_WB</span></code> of a body B in
the world frame W with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">A_WB_all</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">get_body_spatial_accelerations_output_port</span><span class="p">()</span><span class="o">.</span>
      <span class="o">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialAcceleration</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">BodyIndex</span> <span class="n">arm_body_index</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s2">&quot;arm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">A_WArm</span> <span class="o">=</span> <span class="n">A_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
<p>As shown in the example above, the resulting <code class="docutils literal"><span class="pre">std::vector</span></code> of body
spatial accelerations is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial acceleration at all times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_body_spatial_velocities_output_port">
<code class="descname">get_body_spatial_velocities_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_body_spatial_velocities_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of all body spatial velocities in the world
frame. You can obtain the spatial velocity <code class="docutils literal"><span class="pre">V_WB</span></code> of a body B in the
world frame W with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">V_WB_all</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">get_body_spatial_velocities_output_port</span><span class="p">()</span><span class="o">.</span>
      <span class="o">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">BodyIndex</span> <span class="n">arm_body_index</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s2">&quot;arm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">V_WArm</span> <span class="o">=</span> <span class="n">V_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
<p>As shown in the example above, the resulting <code class="docutils literal"><span class="pre">std::vector</span></code> of body
spatial velocities is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial velocity at all times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_contact_penalty_method_time_scale">
<code class="descname">get_contact_penalty_method_time_scale</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_contact_penalty_method_time_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a time-scale estimate <code class="docutils literal"><span class="pre">tc</span></code> based on the requested
penetration allowance δ set with set_penetration_allowance(). For the
penalty method in use to enforce non-penetration, this time scale
relates to the time it takes the relative normal velocity between two
bodies to go to zero. This time scale <code class="docutils literal"><span class="pre">tc</span></code> is artificially
introduced by the penalty method and goes to zero in the limit to
ideal rigid contact. Since numerical integration methods for continuum
systems must be able to resolve a system’s dynamics, the time step
used by an integrator must in general be much smaller than the time
scale <code class="docutils literal"><span class="pre">tc</span></code>. How much smaller will depend on the details of the
problem and the convergence characteristics of the integrator and
should be tuned appropriately. Another factor to take into account for
setting up the simulation’s time step is the speed of the objects in
your simulation. If <code class="docutils literal"><span class="pre">vn</span></code> represents a reference velocity scale for
the normal relative velocity between bodies, the new time scale <code class="docutils literal"><span class="pre">tn</span> <span class="pre">=</span>
<span class="pre">δ</span> <span class="pre">/</span> <span class="pre">vn</span></code> represents the time it would take for the distance between
two bodies approaching with relative normal velocity <code class="docutils literal"><span class="pre">vn</span></code> to
decrease by the penetration_allowance δ. In this case a user should
choose a time step for simulation that can resolve the smallest of the
two time scales <code class="docutils literal"><span class="pre">tc</span></code> and <code class="docutils literal"><span class="pre">tn</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_contact_results_output_port">
<code class="descname">get_contact_results_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_contact_results_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the port that outputs ContactResults.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize, see Finalize().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_frame">
<code class="descname">get_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], frame_index: pydrake.multibody.tree.FrameIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the frame with unique index
<code class="docutils literal"><span class="pre">frame_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">frame_index</span></code> does not correspond to a frame in</li>
<li>this plant.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_generalized_acceleration_output_port">
<code class="descname">get_generalized_acceleration_output_port</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_generalized_acceleration_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[float]) -&gt; pydrake.systems.framework.OutputPort_[float]</li>
</ol>
<p>Returns a constant reference to the output port for generalized
accelerations v̇ of the model.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[float]</li>
</ol>
<p>Returns a constant reference to the output port for the generalized
accelerations v̇ᵢ ⊆ v̇ for model instance i.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_generalized_contact_forces_output_port">
<code class="descname">get_generalized_contact_forces_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_generalized_contact_forces_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the output port of generalized contact
forces for a specific model instance.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_geometry_poses_output_port">
<code class="descname">get_geometry_poses_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_geometry_poses_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of frames’ poses to communicate with a
SceneGraph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_geometry_query_input_port">
<code class="descname">get_geometry_query_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_geometry_query_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the input port used to perform
geometric queries on a SceneGraph. See
SceneGraph::get_query_output_port(). Refer to section mbp_geometry
“Geometry” of this class’s documentation for further details on
collision geometry registration and connection with a SceneGraph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_joint">
<code class="descname">get_joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], joint_index: pydrake.multibody.tree.JointIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the joint with unique index
<code class="docutils literal"><span class="pre">joint_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError when <code class="docutils literal"><span class="pre">joint_index</span></code> does not correspond to a joint</li>
<li>in this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_joint_actuator">
<code class="descname">get_joint_actuator</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], actuator_index: pydrake.multibody.tree.JointActuatorIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuator_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_joint_actuator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the joint actuator with unique index
<code class="docutils literal"><span class="pre">actuator_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">actuator_index</span></code> does not correspond to a joint</li>
<li>actuator in this tree.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_reaction_forces_output_port">
<code class="descname">get_reaction_forces_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_reaction_forces_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the port for joint reaction forces. A Joint models the
kinematical relationship which characterizes the possible relative
motion between two bodies. In Drake, a joint connects a frame <code class="docutils literal"><span class="pre">Jp</span></code>
on <em>parent</em> body P with a frame <code class="docutils literal"><span class="pre">Jc</span></code> on a <em>child</em> body C. This usage
of the terms <em>parent</em> and <em>child</em> is just a convention and implies
nothing about the inboard-outboard relationship between the bodies.
Since a Joint imposes a kinematical relationship which characterizes
the possible relative motion between frames Jp and Jc, reaction forces
on each body are established. That is, we could cut the model at the
joint and replace it with equivalent forces equal to these reaction
forces in order to attain the same motions of the mechanical system.</p>
<p>This output port allows to evaluate the reaction force <code class="docutils literal"><span class="pre">F_CJc_Jc</span></code> on
the <em>child</em> body C, at <code class="docutils literal"><span class="pre">Jc</span></code>, and expressed in Jc for all joints in
the model. This port evaluates to a vector of type
std::vector&lt;SpatialForce&lt;T&gt;&gt; and size num_joints() indexed by
JointIndex, see Joint::index(). Each entry corresponds to the spatial
force <code class="docutils literal"><span class="pre">F_CJc_Jc</span></code> applied on the joint’s child body C
(Joint::child_body()), at the joint’s child frame <code class="docutils literal"><span class="pre">Jc</span></code>
(Joint::frame_on_child()) and expressed in frame <code class="docutils literal"><span class="pre">Jc</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_source_id">
<code class="descname">get_source_id</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; Optional[pydrake.geometry.SourceId]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_source_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unique id identifying <code class="docutils literal"><span class="pre">this</span></code> plant as a source for a
SceneGraph. Returns <code class="docutils literal"><span class="pre">nullopt</span></code> if <code class="docutils literal"><span class="pre">this</span></code> plant did not register any
geometry. This method can be called at any time during the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> plant to query if <code class="docutils literal"><span class="pre">this</span></code> plant has been registered with a
SceneGraph, either pre- or post-finalize, see Finalize(). However, a
geometry::SourceId is only assigned once at the first call of any of
this plant’s geometry registration methods, and it does not change
after that. Post-finalize calls will always return the same value.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_state_output_port">
<code class="descname">get_state_output_port</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].get_state_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[float]) -&gt; pydrake.systems.framework.OutputPort_[float]</li>
</ol>
<p>Returns a constant reference to the output port for the multibody
state x = [q, v] of the model.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[float]</li>
</ol>
<p>Returns a constant reference to the output port for the state xᵢ = [qᵢ
vᵢ] of model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.)</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetAccelerationLowerLimits">
<code class="descname">GetAccelerationLowerLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetAccelerationLowerLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of size <code class="docutils literal"><span class="pre">num_velocities()</span></code> containing the lower
acceleration limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetAccelerationUpperLimits">
<code class="descname">GetAccelerationUpperLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetAccelerationUpperLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit analog of GetAccelerationsLowerLimits(), where any
unbounded or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetAccelerationLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetBodyByName">
<code class="descname">GetBodyByName</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetBodyByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str) -&gt; pydrake.multibody.tree.Body_[float]</li>
</ol>
<p>Returns a constant reference to a body that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no body with the requested name.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the body name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasBodyNamed() to query if there exists a body in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.Body_[float]</li>
</ol>
<p>Returns a constant reference to the body that is uniquely identified
by the string <code class="docutils literal"><span class="pre">name</span></code> and <code class="docutils literal"><span class="pre">model_instance</span></code> in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no body with the requested name.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasBodyNamed() to query if there exists a body in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetBodyFrameIdIfExists">
<code class="descname">GetBodyFrameIdIfExists</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], body_index: pydrake.multibody.tree.BodyIndex</em><span class="sig-paren">)</span> &#x2192; Optional[pydrake.geometry.FrameId]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetBodyFrameIdIfExists" title="Permalink to this definition">¶</a></dt>
<dd><p>If the body with <code class="docutils literal"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise, it
returns nullopt.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetBodyFrameIdOrThrow">
<code class="descname">GetBodyFrameIdOrThrow</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], body_index: pydrake.multibody.tree.BodyIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.FrameId<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetBodyFrameIdOrThrow" title="Permalink to this definition">¶</a></dt>
<dd><p>If the body with <code class="docutils literal"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise this
method throws an exception.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the called plant does not have the body indicated</li>
<li>by <code class="docutils literal"><span class="pre">body_index</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetBodyFromFrameId">
<code class="descname">GetBodyFromFrameId</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], arg0: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetBodyFromFrameId" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a geometry frame identifier, returns a pointer to the body
associated with that id (nullptr if there is no such body).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetBodyIndices">
<code class="descname">GetBodyIndices</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex</em><span class="sig-paren">)</span> &#x2192; List[pydrake.multibody.tree.BodyIndex]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetBodyIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of body indices associated with <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetCollisionGeometriesForBody">
<code class="descname">GetCollisionGeometriesForBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.GeometryId]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetCollisionGeometriesForBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different contact
geometries for <code class="docutils literal"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method can be called at any time during the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RegisterCollisionGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetDefaultFreeBodyPose">
<code class="descname">GetDefaultFreeBodyPose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetDefaultFreeBodyPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default pose of <code class="docutils literal"><span class="pre">body</span></code> as set by SetDefaultFreeBodyPose().</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">body</span></code>:</dt>
<dd>Body whose default pose will be retrieved.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetFrameByName">
<code class="descname">GetFrameByName</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetFrameByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str) -&gt; pydrake.multibody.tree.Frame_[float]</li>
</ol>
<p>Returns a constant reference to a frame that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no frame with the requested name.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the frame name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasFrameNamed() to query if there exists a frame in <code class="docutils literal"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.Frame_[float]</li>
</ol>
<p>Returns a constant reference to the frame that is uniquely identified
by the string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no frame with the requested name.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasFrameNamed() to query if there exists a frame in <code class="docutils literal"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetJointActuatorByName">
<code class="descname">GetJointActuatorByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], name: str</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuator_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetJointActuatorByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to an actuator that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if there is no actuator with the requested name.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the actuator name occurs in multiple model</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">instances.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetJointByName">
<code class="descname">GetJointByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetJointByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal"><span class="pre">JointType</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">JointType</span></code>:</dt>
<dd>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the named joint is not of type <code class="docutils literal"><span class="pre">JointType</span></code> or if</li>
<li>there is no Joint with that name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasJointNamed() to query if there exists a joint in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetModelInstanceByName">
<code class="descname">GetModelInstanceByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], name: str</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetModelInstanceByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the model instance that is uniquely identified by
the string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no instance with the requested name.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasModelInstanceNamed() to query if there exists an instance in
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetModelInstanceName">
<code class="descname">GetModelInstanceName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetModelInstanceName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of a <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError when <code class="docutils literal"><span class="pre">model_instance</span></code> does not correspond to a</li>
<li>model in this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetMutableJointByName">
<code class="descname">GetMutableJointByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetMutableJointByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal"><span class="pre">JointType</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">JointType</span></code>:</dt>
<dd>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the named joint is not of type <code class="docutils literal"><span class="pre">JointType</span></code> or if</li>
<li>there is no Joint with that name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasJointNamed() to query if there exists a joint in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetMutablePositions">
<code class="descname">GetMutablePositions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1], flags.writeable]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetMutablePositions" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a mutable vector reference containing the vector of
generalized positions (<strong>see warning</strong>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You should use SetPositions() instead of this method unless you
are fully aware of the possible interactions with the caching
mechanism (see dangerous_get_mutable).</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr or if it does not</li>
<li>correspond to the context for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetMutablePositionsAndVelocities">
<code class="descname">GetMutablePositionsAndVelocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1], flags.writeable]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetMutablePositionsAndVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a mutable vector containing the vector <code class="docutils literal"><span class="pre">[q;</span> <span class="pre">v]</span></code>
of the model with <code class="docutils literal"><span class="pre">q</span></code> the vector of generalized positions and <code class="docutils literal"><span class="pre">v</span></code>
the vector of generalized velocities (<strong>see warning</strong>).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You should use SetPositionsAndVelocities() instead of this method
unless you are fully aware of the interactions with the caching
mechanism (see dangerous_get_mutable).</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr or if it does not</li>
<li>correspond to the context for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetMutableVelocities">
<code class="descname">GetMutableVelocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1], flags.writeable]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetMutableVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>See GetMutableVelocities() method above.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetPositionLowerLimits">
<code class="descname">GetPositionLowerLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetPositionLowerLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of size <code class="docutils literal"><span class="pre">num_positions()</span></code> containing the lower
position limits for every generalized position coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetPositions">
<code class="descname">GetPositions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetPositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the vector of generalized
positions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns an vector containing the generalized positions (<code class="docutils literal"><span class="pre">q</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">q.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">q.size()</span></code>) time.</p>
</div>
<ol class="arabic simple" start="3">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the vector of generalized
positions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns an vector containing the generalized positions (<code class="docutils literal"><span class="pre">q</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">q.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">q.size()</span></code>) time.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetPositionsAndVelocities">
<code class="descname">GetPositionsAndVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetPositionsAndVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the vector <code class="docutils literal"><span class="pre">[q;</span> <span class="pre">v]</span></code> with
<code class="docutils literal"><span class="pre">q</span></code> the vector of generalized positions and <code class="docutils literal"><span class="pre">v</span></code> the vector of
generalized velocities.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns the vector <code class="docutils literal"><span class="pre">[q;</span> <span class="pre">v]</span></code> of the model with <code class="docutils literal"><span class="pre">q</span></code> the vector of
generalized positions and <code class="docutils literal"><span class="pre">v</span></code> the vector of generalized velocities
for model instance <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model or <code class="docutils literal"><span class="pre">model_instance</span></code> is invalid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">q.size()</span> <span class="pre">+</span> <span class="pre">v.size()</span></code>
associated with <code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">q.size()</span></code>) time.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetPositionsFromArray">
<code class="descname">GetPositionsFromArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetPositionsFromArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of generalized positions for <code class="docutils literal"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal"><span class="pre">q_array</span></code> of generalized positions for the entire model
model. This method throws an exception if <code class="docutils literal"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetPositionUpperLimits">
<code class="descname">GetPositionUpperLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetPositionUpperLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit analog of GetPositionsLowerLimits(), where any unbounded
or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetPositionLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetTopologyGraphvizString">
<code class="descname">GetTopologyGraphvizString</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetTopologyGraphvizString" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Graphviz string describing the topology of this plant. To
render the string, use the Graphviz tool, <code class="docutils literal"><span class="pre">dot</span></code>.
<a class="reference external" href="http://www.graphviz.org/">http://www.graphviz.org/</a></p>
<p>Note: this method can be called either before or after <code class="docutils literal"><span class="pre">Finalize()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetVelocities">
<code class="descname">GetVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the generalized
velocities.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<ol class="arabic simple" start="2">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns a vector containing the generalized velocities (<code class="docutils literal"><span class="pre">v</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">v.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">v.size()</span></code>) time.</p>
</div>
<ol class="arabic simple" start="3">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the generalized
velocities.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<ol class="arabic simple" start="4">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns a vector containing the generalized velocities (<code class="docutils literal"><span class="pre">v</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">v.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">v.size()</span></code>) time.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetVelocitiesFromArray">
<code class="descname">GetVelocitiesFromArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetVelocitiesFromArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of generalized velocities for <code class="docutils literal"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal"><span class="pre">v</span></code> of generalized velocities for the entire MultibodyPlant
model. This method throws an exception if the input array is not of
size MultibodyPlant::num_velocities().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetVelocityLowerLimits">
<code class="descname">GetVelocityLowerLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetVelocityLowerLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of size <code class="docutils literal"><span class="pre">num_velocities()</span></code> containing the lower
velocity limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetVelocityUpperLimits">
<code class="descname">GetVelocityUpperLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].GetVelocityUpperLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit analog of GetVelocitysLowerLimits(), where any unbounded
or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetVelocityLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].gravity_field">
<code class="descname">gravity_field</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniformGravityFieldElement_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].gravity_field" title="Permalink to this definition">¶</a></dt>
<dd><p>An accessor to the current gravity field.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].HasBodyNamed">
<code class="descname">HasBodyNamed</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].HasBodyNamed" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a body named <code class="docutils literal"><span class="pre">name</span></code> was added to the MultibodyPlant.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddRigidBody().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the body name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a body named <code class="docutils literal"><span class="pre">name</span></code> was added to the MultibodyPlant
in <code class="docutils literal"><span class="pre">model_instance</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddRigidBody().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].HasJointActuatorNamed">
<code class="descname">HasJointActuatorNamed</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].HasJointActuatorNamed" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if an actuator named <code class="docutils literal"><span class="pre">name</span></code> was added to this model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJointActuator().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the actuator name occurs in multiple model</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">instances.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if an actuator named <code class="docutils literal"><span class="pre">name</span></code> was added to
<code class="docutils literal"><span class="pre">model_instance</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJointActuator().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].HasJointNamed">
<code class="descname">HasJointNamed</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].HasJointNamed" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a joint named <code class="docutils literal"><span class="pre">name</span></code> was added to this model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJoint().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the joint name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a joint named <code class="docutils literal"><span class="pre">name</span></code> was added to
<code class="docutils literal"><span class="pre">model_instance</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJoint().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].HasModelInstanceNamed">
<code class="descname">HasModelInstanceNamed</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], name: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].HasModelInstanceNamed" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a model instance named <code class="docutils literal"><span class="pre">name</span></code> was added to this
model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddModelInstance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].is_finalized">
<code class="descname">is_finalized</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].is_finalized" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if this MultibodyPlant was finalized with a call to
Finalize().</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Finalize().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].MakeActuationMatrix">
<code class="descname">MakeActuationMatrix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].MakeActuationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This method creates an actuation matrix B mapping a vector of
actuation values u into generalized forces <code class="docutils literal"><span class="pre">tau_u</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">u</span></code>, where B
is a matrix of size <code class="docutils literal"><span class="pre">nv</span> <span class="pre">x</span> <span class="pre">nu</span></code> with <code class="docutils literal"><span class="pre">nu</span></code> equal to num_actuators()
and <code class="docutils literal"><span class="pre">nv</span></code> equal to num_velocities(). The vector u of actuation values
is of size num_actuators(). For a given JointActuator,
<code class="docutils literal"><span class="pre">u[JointActuator::index()]</span></code> stores the value for the external
actuation corresponding to that actuator. <code class="docutils literal"><span class="pre">tau_u</span></code> on the other hand
is indexed by generalized velocity indexes according to
<code class="docutils literal"><span class="pre">Joint::velocity_start()</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">B is a permutation matrix. While making a permutation has <code class="docutils literal"><span class="pre">O(n)</span></code>
complexity, making a full B matrix has <code class="docutils literal"><span class="pre">O(n²)</span></code> complexity. For
most applications this cost can be neglected but it could become
significant for very large systems.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].MapQDotToVelocity">
<code class="descname">MapQDotToVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], qdot: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].MapQDotToVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the time derivative <code class="docutils literal"><span class="pre">qdot</span></code> of the generalized positions
vector <code class="docutils literal"><span class="pre">q</span></code> (stored in <code class="docutils literal"><span class="pre">context</span></code>) to generalized velocities <code class="docutils literal"><span class="pre">v</span></code>.
<cite>v</cite> and <code class="docutils literal"><span class="pre">q̇</span></code> are related linearly by <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Although
<code class="docutils literal"><span class="pre">N(q)</span></code> is not necessarily square, its left pseudo-inverse <code class="docutils literal"><span class="pre">N⁺(q)</span></code>
can be used to invert that relationship without residual error,
provided that <code class="docutils literal"><span class="pre">qdot</span></code> is in the range space of <code class="docutils literal"><span class="pre">N(q)</span></code> (that is, if
it <em>could</em> have been produced as <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code> for some <code class="docutils literal"><span class="pre">v</span></code>).
Using the configuration <code class="docutils literal"><span class="pre">q</span></code> stored in the given <code class="docutils literal"><span class="pre">context</span></code> this
method calculates <code class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">N⁺(q)⋅q̇</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">qdot</span></code>:</dt>
<dd>A vector containing the time derivatives of the generalized
positions. This method aborts if <code class="docutils literal"><span class="pre">qdot</span></code> is not of size
num_positions().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">v</span></code>:</dt>
<dd>A valid (non-null) pointer to a vector in <code class="docutils literal"><span class="pre">ℛⁿ</span></code> with n the number
of generalized velocities. This method aborts if v is nullptr or
if it is not of size num_velocities().</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MapVelocityToQDot()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Mobilizer::MapQDotToVelocity()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].MapVelocityToQDot">
<code class="descname">MapVelocityToQDot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], v: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].MapVelocityToQDot" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms generalized velocities v to time derivatives <code class="docutils literal"><span class="pre">qdot</span></code> of
the generalized positions vector <code class="docutils literal"><span class="pre">q</span></code> (stored in <code class="docutils literal"><span class="pre">context</span></code>). <cite>v</cite>
and <code class="docutils literal"><span class="pre">qdot</span></code> are related linearly by <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Using the
configuration <code class="docutils literal"><span class="pre">q</span></code> stored in the given <code class="docutils literal"><span class="pre">context</span></code> this method
calculates <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">v</span></code>:</dt>
<dd>A vector of of generalized velocities for this model. This method
aborts if v is not of size num_velocities().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">qdot</span></code>:</dt>
<dd>A valid (non-null) pointer to a vector in <code class="docutils literal"><span class="pre">ℝⁿ</span></code> with n being the
number of generalized positions in this model, given by
<code class="docutils literal"><span class="pre">num_positions()</span></code>. This method aborts if <code class="docutils literal"><span class="pre">qdot</span></code> is nullptr or
if it is not of size num_positions().</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MapQDotToVelocity()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Mobilizer::MapVelocityToQDot()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].mutable_gravity_field">
<code class="descname">mutable_gravity_field</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniformGravityFieldElement_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].mutable_gravity_field" title="Permalink to this definition">¶</a></dt>
<dd><p>A mutable accessor to the current gravity field.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_actuated_dofs">
<code class="descname">num_actuated_dofs</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_actuated_dofs" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[float]) -&gt; int</li>
</ol>
<p>Returns the total number of actuated degrees of freedom. That is, the
vector of actuation values u has this size. See AddJointActuator().</p>
<ol class="arabic simple" start="2">
<li>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the total number of actuated degrees of freedom for a specific
model instance. That is, the vector of actuation values u has this
size. See AddJointActuator().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_actuators">
<code class="descname">num_actuators</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_actuators" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of joint actuators in the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJointActuator().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_bodies">
<code class="descname">num_bodies</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of bodies in the model, including the “world” body,
which is always part of the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddRigidBody().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_collision_geometries">
<code class="descname">num_collision_geometries</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_collision_geometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of geometries registered for contact modeling. This
method can be called at any time during the lifetime of <code class="docutils literal"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize(). Post-finalize
calls will always return the same value.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_force_elements">
<code class="descname">num_force_elements</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_force_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of ForceElement objects.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddForceElement().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_frames">
<code class="descname">num_frames</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of Frame objects in this model. Frames include body
frames associated with each of the bodies, including the <em>world</em> body.
This means the minimum number of frames is one.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_joints">
<code class="descname">num_joints</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_joints" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of joints in the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJoint().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_model_instances">
<code class="descname">num_model_instances</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_model_instances" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of model instances in the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddModelInstance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_multibody_states">
<code class="descname">num_multibody_states</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_multibody_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[float]) -&gt; int</li>
</ol>
<p>Returns the size of the multibody system state vector x = [q v]. This
will be <code class="docutils literal"><span class="pre">num_positions()</span></code> plus <code class="docutils literal"><span class="pre">num_velocities()</span></code>.</p>
<ol class="arabic simple" start="2">
<li>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the size of the multibody system state vector xᵢ = [qᵢ vᵢ] for
model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.) will be
<code class="docutils literal"><span class="pre">num_positions(model_instance)</span></code> plus
<code class="docutils literal"><span class="pre">num_velocities(model_instance)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_positions">
<code class="descname">num_positions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[float]) -&gt; int</li>
</ol>
<p>Returns the size of the generalized position vector q for this model.</p>
<ol class="arabic simple" start="2">
<li>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the size of the generalized position vector qᵢ for model
instance i.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[float]) -&gt; int</li>
</ol>
<p>Returns the size of the generalized velocity vector v for this model.</p>
<ol class="arabic simple" start="2">
<li>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the size of the generalized velocity vector vᵢ for model
instance i.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].RegisterAsSourceForSceneGraph">
<code class="descname">RegisterAsSourceForSceneGraph</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], scene_graph: pydrake.geometry.SceneGraph_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.SourceId<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].RegisterAsSourceForSceneGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers <code class="docutils literal"><span class="pre">this</span></code> plant to serve as a source for an instance of
SceneGraph. This registration allows MultibodyPlant to register
geometry with <code class="docutils literal"><span class="pre">scene_graph</span></code> for visualization and/or collision
queries. Successive registration calls with SceneGraph <strong>must</strong> be
performed on the same instance to which the pointer argument
<code class="docutils literal"><span class="pre">scene_graph</span></code> points to. Failure to do so will result in runtime
exceptions.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">scene_graph</span></code>:</dt>
<dd>A valid non nullptr to the SceneGraph instance for which <code class="docutils literal"><span class="pre">this</span></code>
plant will sever as a source, see SceneGraph documentation for
further details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the SourceId of <code class="docutils literal"><span class="pre">this</span></code> plant in <code class="docutils literal"><span class="pre">scene_graph</span></code>. It can also
later on be retrieved with get_source_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called post-finalize.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">scene_graph</span></code> is the nullptr.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called more than once.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].RegisterCollisionGeometry">
<code class="descname">RegisterCollisionGeometry</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].RegisterCollisionGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Registers geometry in a SceneGraph with a given geometry::Shape to be
used for the contact modeling of a given <code class="docutils literal"><span class="pre">body</span></code>. More than one
geometry can be registered with a body, in which case the body’s
contact geometry is the union of all geometries registered to that
body.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">body</span></code>:</dt>
<dd>The body for which geometry is being registered.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_BG</span></code>:</dt>
<dd>The fixed pose of the geometry frame G in the body frame B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">shape</span></code>:</dt>
<dd>The geometry::Shape used for visualization. E.g.:
geometry::Sphere, geometry::Cylinder, etc.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">properties</span></code>:</dt>
<dd>The proximity properties associated with the collision geometry.
They <em>must</em> include the (<code class="docutils literal"><span class="pre">material</span></code>, <cite>coulomb_friction</cite>)
property of type CoulombFriction&lt;double&gt;.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called post-finalize or if the properties are</li>
<li>missing the coulomb friction property (or if it is of the wrong</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">type).</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, coulomb_friction: pydrake.multibody.plant.CoulombFriction_[float]) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Overload which specifies a single property: coulomb_friction.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].RegisterVisualGeometry">
<code class="descname">RegisterVisualGeometry</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].RegisterVisualGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RegisterVisualGeometry(self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4, 1]]) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Overload for visual geometry registration; it converts the
<code class="docutils literal"><span class="pre">diffuse_color</span></code> (RGBA with values in the range [0, 1]) into a
geometry::ConnectDrakeVisualizer()-compatible set of
geometry::IllustrationProperties.</p>
<ol class="arabic simple" start="2">
<li>RegisterVisualGeometry(self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.common.eigen_geometry.Isometry3_[float], shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4, 1]], scene_graph: pydrake.geometry.SceneGraph_[float] = None) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].set_penetration_allowance">
<code class="descname">set_penetration_allowance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], penetration_allowance: float = 0.001</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].set_penetration_allowance" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the penetration allowance used to estimate the coefficients in
the penalty method used to impose non-penetration among bodies. Refer
to the section mbp_penalty_method “Contact by penalty method” for
further details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if penetration_allowance is not positive.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].set_stiction_tolerance">
<code class="descname">set_stiction_tolerance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], v_stiction: float = 0.001</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].set_stiction_tolerance" title="Permalink to this definition">¶</a></dt>
<dd><p><a href="#id23"><span class="problematic" id="id24">**</span></a>** Stribeck model of friction</p>
<p>Currently MultibodyPlant uses the Stribeck approximation to model dry
friction. The Stribeck model of friction is an approximation to
Coulomb’s law of friction that allows using continuous time
integration without the need to specify complementarity constraints.
While this results in a simpler model immediately tractable with
standard numerical methods for integration of ODE’s, it often leads to
stiff dynamics that require an explicit integrator to take very small
time steps. It is therefore recommended to use error controlled
integrators when using this model or the discrete time stepping (see
time_advancement_strategy “Choice of Time Advancement Strategy”). See
stribeck_approximation for a detailed discussion of the Stribeck
model.</p>
<p>Sets the stiction tolerance <code class="docutils literal"><span class="pre">v_stiction</span></code> for the Stribeck model,
where <code class="docutils literal"><span class="pre">v_stiction</span></code> must be specified in m/s (meters per second.)
<code class="docutils literal"><span class="pre">v_stiction</span></code> defaults to a value of 1 millimeter per second. In
selecting a value for <code class="docutils literal"><span class="pre">v_stiction</span></code>, you must ask yourself the
question, “When two objects are ostensibly in stiction, how much slip
am I willing to allow?” There are two opposing design issues in
picking a value for vₛ. On the one hand, small values of vₛ make the
problem numerically stiff during stiction, potentially increasing the
integration cost. On the other hand, it should be picked to be
appropriate for the scale of the problem. For example, a car
simulation could allow a “large” value for vₛ of 1 cm/s (1×10⁻² m/s),
but reasonable stiction for grasping a 10 cm box might require
limiting residual slip to 1×10⁻³ m/s or less. Ultimately, picking the
largest viable value will allow your simulation to run faster and more
robustly. Note that <code class="docutils literal"><span class="pre">v_stiction</span></code> is the slip velocity that we’d have
when we are at edge of the friction cone. For cases when the friction
force is well within the friction cone the slip velocity will always
be smaller than this value. See also stribeck_approximation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">v_stiction</span></code> is non-positive.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetActuationInArray">
<code class="descname">SetActuationInArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[numpy.float64[m, 1]], u: numpy.ndarray[numpy.float64[m, 1], flags.writeable]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetActuationInArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the actuation values <code class="docutils literal"><span class="pre">u_instance</span></code> for all actuators in
<code class="docutils literal"><span class="pre">model_instance</span></code>, this method sets the actuation vector u for the
entire model to which this actuator belongs to. This method throws an
exception if the size of <code class="docutils literal"><span class="pre">u_instance</span></code> is not equal to the number of
degrees of freedom of all of the actuated joints in
<code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">u_instance</span></code>:</dt>
<dd>Actuation values for the actuators. It must be of size equal to
the number of degrees of freedom of all of the actuated joints in
<code class="docutils literal"><span class="pre">model_instance</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">u</span></code>:</dt>
<dd>The vector containing the actuation values for the entire model.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetDefaultFreeBodyPose">
<code class="descname">SetDefaultFreeBodyPose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float], X_WB: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetDefaultFreeBodyPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default pose of <code class="docutils literal"><span class="pre">body</span></code>. If <code class="docutils literal"><span class="pre">body.is_floating()</span></code> is true,
this will affect subsequent calls to SetDefaultState(); otherwise,
this value is effectively ignored.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">body</span></code>:</dt>
<dd>Body whose default pose will be set.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_WB</span></code>:</dt>
<dd>Default pose of the body.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetDefaultState">
<code class="descname">SetDefaultState</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], state: pydrake.systems.framework.State_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetDefaultState" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">state</span></code> according to defaults set by the user for joints (e.g.
RevoluteJoint::set_default_angle()) and free bodies
(SetDefaultFreeBodyPose()). If the user does not specify defaults, the
state corresponds to zero generalized positions and velocities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize. See Finalize().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetFreeBodyPose">
<code class="descname">SetFreeBodyPose</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetFreeBodyPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetFreeBodyPose(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float], X_WB: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Sets <code class="docutils literal"><span class="pre">context</span></code> to store the pose <code class="docutils literal"><span class="pre">X_WB</span></code> of a given <code class="docutils literal"><span class="pre">body</span></code> B in
the world frame W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general setting the pose and/or velocity of a body in the model
would involve a complex inverse kinematics problem. This method
allows us to simplify this process when we know the body is free
in space.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">body</span></code> is not a free body in the model.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetFreeBodyPose(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float], X_WB: pydrake.common.eigen_geometry.Isometry3_[float]) -&gt; None</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetFreeBodySpatialVelocity">
<code class="descname">SetFreeBodySpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float], V_WB: pydrake.multibody.math.SpatialVelocity_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetFreeBodySpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">context</span></code> to store the spatial velocity <code class="docutils literal"><span class="pre">V_WB</span></code> of a given
<code class="docutils literal"><span class="pre">body</span></code> B in the world frame W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general setting the pose and/or velocity of a body in the model
would involve a complex inverse kinematics problem. This method
allows us to simplify this process when we know the body is free
in space.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">body</span></code> is not a free body in the model.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetPositions">
<code class="descname">SetPositions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetPositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], q: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized positions from the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">q</span></code> is not equal to <code class="docutils literal"><span class="pre">num_positions()</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized positions from the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">q</span></code> is not equal to <code class="docutils literal"><span class="pre">num_positions()</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetPositionsAndVelocities">
<code class="descname">SetPositionsAndVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetPositionsAndVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], q_v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized positions and velocities from the given vector
[q; v].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">q_v</span></code> is not equal to <a href="#id25"><span class="problematic" id="id26">``</span></a>num_positions() +</li>
<li>num_velocities()``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Sets generalized positions and velocities from the given vector [q; v]
for the specified model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, if the model</li>
<li>instance index is invalid, or if the length of <code class="docutils literal"><span class="pre">q_v</span></code> is not</li>
<li>equal to <a href="#id27"><span class="problematic" id="id28">``</span></a>num_positions(model_instance) +</li>
<li>num_velocities(model_instance)``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetPositionsInArray">
<code class="descname">SetPositionsInArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m, 1]], q: numpy.ndarray[numpy.float64[m, 1], flags.writeable]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetPositionsInArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the vector of generalized positions for <code class="docutils literal"><span class="pre">model_instance</span></code> in
<code class="docutils literal"><span class="pre">q</span></code> using <code class="docutils literal"><span class="pre">q_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions() or <code class="docutils literal"><span class="pre">q_instance</span></code> is not of size
<code class="docutils literal"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetVelocities">
<code class="descname">SetVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized velocities from the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">v</span></code> is not equal to <code class="docutils literal"><span class="pre">num_velocities()</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Sets the generalized velocities for a particular model instance from
the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, if the model</li>
<li>instance index is invalid, or if the length of <code class="docutils literal"><span class="pre">v_instance</span></code> is</li>
<li>not equal to <code class="docutils literal"><span class="pre">num_velocities(model_instance)</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetVelocitiesInArray">
<code class="descname">SetVelocitiesInArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[numpy.float64[m, 1]], v: numpy.ndarray[numpy.float64[m, 1], flags.writeable]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].SetVelocitiesInArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the vector of generalized velocities for <code class="docutils literal"><span class="pre">model_instance</span></code> in
<code class="docutils literal"><span class="pre">v</span></code> using <code class="docutils literal"><span class="pre">v_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal"><span class="pre">v</span></code> is not of size
MultibodyPlant::num_velocities() or <code class="docutils literal"><span class="pre">v_instance</span></code> is not of size
<code class="docutils literal"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].time_step">
<code class="descname">time_step</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>The time step (or period) used to model <code class="docutils literal"><span class="pre">this</span></code> plant as a discrete
system with periodic updates. Returns 0 (zero) if the plant is modeled
as a continuous system. This property of the plant is specified at
construction and therefore this query can be performed either pre- or
post-finalize, see Finalize().</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MultibodyPlant::MultibodyPlant(double)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].WeldFrames">
<code class="descname">WeldFrames</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].WeldFrames" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>WeldFrames(self: pydrake.multibody.plant.MultibodyPlant_[float], A: pydrake.multibody.tree.Frame_[float], B: pydrake.multibody.tree.Frame_[float], X_AB: pydrake.math.RigidTransform_[float] = &lt;pydrake.math.RigidTransform_[float] object at 0x7f53d69a9c70&gt;) -&gt; pydrake.multibody.tree.WeldJoint_[float]</li>
</ol>
<p>Welds frames A and B with relative pose <code class="docutils literal"><span class="pre">X_AB</span></code>. That is, the pose of
frame B in frame A is fixed, with value <code class="docutils literal"><span class="pre">X_AB</span></code>. The call to this
method creates and adds a new WeldJoint to the model. The new
WeldJoint is named as: A.name() + “_welds_to_” + B.name().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to the WeldJoint welding frames A and B.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>WeldFrames(self: pydrake.multibody.plant.MultibodyPlant_[float], A: pydrake.multibody.tree.Frame_[float], B: pydrake.multibody.tree.Frame_[float], X_AB: pydrake.common.eigen_geometry.Isometry3_[float]) -&gt; pydrake.multibody.tree.WeldJoint_[float]</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].world_body">
<code class="descname">world_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RigidBody_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].world_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the <em>world</em> body.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].world_frame">
<code class="descname">world_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyFrame_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_.MultibodyPlant_[float].world_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the <em>world</em> frame.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">MultibodyPlant_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_[AutoDiffXd]" title="pydrake.systems.framework.LeafSystem_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></a></p>
<p>MultibodyPlant is a Drake system framework representation (see
systems::System) for the model of a physical system consisting of a
collection of interconnected bodies. See multibody for an overview of
concepts/notation.</p>
<p>&lt;table align=center cellpadding=0 cellspacing=0&gt;&lt;tr align=center&gt;&lt;td
style=”vertical-align:middle”&gt;&lt;table cellspacing=0
cellpadding=0&gt;&lt;tr&gt;&lt;td align=right style=”padding:5px 0px 5px
0px”&gt;applied_generalized_force&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=right
style=”padding:5px 0px 5px
0px”&gt;applied_spatial_force&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=right
style=”padding:5px 0px 5px 0px”&gt;&lt;em
style=”color:gray”&gt;model_instance_name[i]&lt;/em&gt;_actuation&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=right style=”padding:5px 0px 5px 0px”&gt;&lt;span
style=”color:green”&gt;geometry_query&lt;/span&gt;&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;td
align=center
style=”border:solid;padding-left:20px;padding-right:20px;vertical-align:middle”
bgcolor=#F0F0F0&gt;MultibodyPlant&lt;/td&gt;&lt;td
style=”vertical-align:middle”&gt;&lt;table cellspacing=0
cellpadding=0&gt;&lt;tr&gt;&lt;td align=left style=”padding:5px 0px 5px
0px”&gt;&amp;rarr; continuous_state&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left
style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; body_poses&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr;
body_spatial_velocities&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left style=”padding:5px
0px 5px 0px”&gt;&amp;rarr; body_spatial_accelerations&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr;
generalized_acceleration&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left
style=”padding:5px 0px 5px 0px”&gt;&amp;rarr;
reaction_forces&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left style=”padding:5px 0px 5px
0px”&gt;&amp;rarr; contact_results&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left
style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;em
style=”color:gray”&gt;model_instance_name[i]&lt;/em&gt;_continuous_state&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;em
style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt;_generalized_acceleration&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;em
style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt;_generalized_contact_forces&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;span
style=”color:green”&gt;geometry_pose&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</p>
<p>The ports whose names begin with &lt;em style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt; represent groups of ports, one for each of
the model_instances “model instances”, with i ∈ {0, …, N-1} for the
N model instances. If a model instance does not contain any data of
the indicated type the port will still be present but its value will
be a zero-length vector. (Model instances <code class="docutils literal"><span class="pre">world_model_instance()</span></code>
and <code class="docutils literal"><span class="pre">default_model_instance()</span></code> always exist.)</p>
<p>The ports shown in &lt;span style=”color:green”&gt; green&lt;/span&gt; are for
communication with Drake’s geometry::SceneGraph “SceneGraph” system
for dealing with geometry.</p>
<p>MultibodyPlant provides a user-facing API for:</p>
<ul class="simple">
<li>mbp_input_and_output_ports “Ports”: Access input and output ports. -</li>
</ul>
<p>mbp_construction “Construction”: Add bodies, joints, frames, force
elements, and actuators. - mbp_geometry “Geometry”: Register
geometries to a provided SceneGraph instance. - mbp_contact_modeling
“Contact modeling”: Select and parameterize contact models. -
mbp_state_accessors_and_mutators “State access and modification”:
Obtain and manipulate position and velocity state variables. -
mbp_working_with_free_bodies “Free bodies”: Work conveniently with
free (floating) bodies. - mbp_kinematic_and_dynamic_computations
“Kinematics and dynamics”: Perform systems::Context
“Context”-dependent kinematic and dynamic queries. -
mbp_system_matrix_computations “System matrices”: Explicitly form
matrices that appear in the equations of motion. - mbp_introspection
“Introspection”: Perform introspection to find out what’s in the
MultibodyPlant.</p>
<p><a href="#id29"><span class="problematic" id="id30">**</span></a>** Model Instances</p>
<p>A MultiBodyPlant may contain multiple model instances. Each model
instance corresponds to a set of bodies and their connections
(joints). Model instances provide methods to get or set the state of
the set of bodies (e.g., through GetPositionsAndVelocities() and
SetPositionsAndVelocities()), connecting controllers (through
get_state_output_port() and get_actuation_input_port()), and
organizing duplicate models (read through a parser). In fact, many
MultibodyPlant methods are overloaded to allow operating on the entire
plant or just the subset corresponding to the model instance; for
example, one GetPositions() method obtains the generalized positions
for the entire plant while another GetPositions() method obtains the
generalized positions for model instance.</p>
<p>Model instances are frequently defined through SDF files (using the
<code class="docutils literal"><span class="pre">model</span></code> tag) and are automatically created when SDF files are parsed
(by Parser). There are two special multibody::ModelInstanceIndex
values. The world body is always multibody::ModelInstanceIndex 0.
multibody::ModelInstanceIndex 1 is reserved for all elements with no
explicit model instance and is generally only relevant for elements
created programmatically (and only when a model instance is not
explicitly specified). Note that Parser creates model instances
(resulting in a multibody::ModelInstanceIndex ≥ 2) as needed.</p>
<p>See num_model_instances(), num_positions(), num_velocities(),
num_actuated_dofs(), AddModelInstance() GetPositionsAndVelocities(),
GetPositions(), GetVelocities(), SetPositionsAndVelocities(),
SetPositions(), SetVelocities(), GetPositionsFromArray(),
GetVelocitiesFromArray(), SetPositionsInArray(),
SetVelocitiesInArray(), SetActuationInArray(),
HasModelInstanceNamed(), GetModelInstanceName(),
get_state_output_port(), get_actuation_input_port().</p>
<p><a href="#id31"><span class="problematic" id="id32">**</span></a>** System dynamics</p>
<p>The state of a multibody system <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">[q;</span> <span class="pre">v]</span></code> is given by its
generalized positions vector q, of size <code class="docutils literal"><span class="pre">nq</span></code> (see num_positions()),
and by its generalized velocities vector v, of size <code class="docutils literal"><span class="pre">nv</span></code> (see
num_velocities()). As a Drake systems::System “System”, MultibodyPlant
implements the governing equations for a multibody dynamical system in
the form <code class="docutils literal"><span class="pre">ẋ</span> <span class="pre">=</span> <span class="pre">f(t,</span> <span class="pre">x,</span> <span class="pre">u)</span></code> with t being time and u the actuation
forces. The governing equations for the dynamics of a multibody system
modeled with MultibodyPlant are [Featherstone 2008, Jain 2010]:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">q̇</span> <span class="o">=</span> <span class="n">N</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span>
   <span class="p">(</span><span class="mi">1</span><span class="p">)</span>    <span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v̇</span> <span class="o">+</span> <span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="n">v</span> <span class="o">=</span> <span class="n">τ</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">M(q)</span></code> is the mass matrix of the multibody system, <code class="docutils literal"><span class="pre">C(q,</span>
<span class="pre">v)v</span></code> contains Coriolis, centripetal, and gyroscopic terms and
<code class="docutils literal"><span class="pre">N(q)</span></code> is the kinematic coupling matrix describing the relationship
between q̇ (the time derivatives of the generalized positions) and the
generalized velocities v, [Seth 2010]. <code class="docutils literal"><span class="pre">N(q)</span></code> is an <code class="docutils literal"><span class="pre">nq</span> <span class="pre">x</span> <span class="pre">nv</span></code>
matrix. The vector <code class="docutils literal"><span class="pre">τ</span> <span class="pre">∈</span> <span class="pre">ℝⁿᵛ</span></code> on the right hand side of Eq. (1) is
the system’s generalized forces. These incorporate gravity, springs,
externally applied body forces, constraint forces, and contact forces.</p>
<p><a href="#id33"><span class="problematic" id="id34">**</span></a>** Loading models from SDF files</p>
<p>Drake has the capability to load multibody models from SDF and URDF
files. Consider the example below which loads an acrobot model:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">acrobot</span><span class="p">;</span>
   <span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">scene_graph</span><span class="p">;</span>
   <span class="n">Parser</span> <span class="n">parser</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acrobot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scene_graph</span><span class="p">);</span>
   <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">relative_name</span> <span class="o">=</span>
     <span class="s2">&quot;drake/multibody/benchmarks/acrobot/acrobot.sdf&quot;</span><span class="p">;</span>
   <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">full_name</span> <span class="o">=</span> <span class="n">FindResourceOrThrow</span><span class="p">(</span><span class="n">relative_name</span><span class="p">);</span>
   <span class="n">parser</span><span class="o">.</span><span class="n">AddModelFromFile</span><span class="p">(</span><span class="n">full_name</span><span class="p">);</span>
</pre></div>
</div>
<p>As in the example above, for models including visual geometry,
collision geometry or both, the user must specify a SceneGraph for
geometry handling. You can find a full example of the LQR controlled
acrobot in examples/multibody/acrobot/run_lqr.cc.</p>
<p>AddModelFromFile() can be invoked multiple times on the same plant in
order to load multiple model instances. Other methods are available on
Parser such as AddAllModelsFromFile() which allows creating model
instances per each <code class="docutils literal"><span class="pre">&lt;model&gt;</span></code> tag found in the file. Please refer to
each of these methods’ documentation for further details.</p>
<p><a href="#id35"><span class="problematic" id="id36">**</span></a>** Working with SceneGraph</p>
<p>** Adding a MultibodyPlant connected to a SceneGraph to your Diagram</p>
<p>Probably the simplest way to add and wire up a MultibodyPlant with a
SceneGraph in your Diagram is using AddMultibodyPlantSceneGraph().</p>
<p>Recommended usages:</p>
<p>Assign to a MultibodyPlant reference (ignoring the SceneGraph):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">plant</span> <span class="o">=</span>
       <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">/*</span> <span class="n">time_step</span> <span class="o">*/</span><span class="p">);</span>
   <span class="n">plant</span><span class="o">.</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>This flavor is the simplest, when the SceneGraph is not explicitly
needed. (It can always be retrieved later via
GetSubsystemByName(“scene_graph”).)</p>
<p>Assign to auto, and use the named public fields:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">items</span> <span class="o">=</span> <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">/*</span> <span class="n">time_step</span> <span class="o">*/</span><span class="p">);</span>
   <span class="n">items</span><span class="o">.</span><span class="n">plant</span><span class="o">.</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
   <span class="n">items</span><span class="o">.</span><span class="n">scene_graph</span><span class="o">.</span><span class="n">DoBar</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>or taking advantage of C++17’s structured binding</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="p">[</span><span class="n">plant</span><span class="p">,</span> <span class="n">scene_graph</span><span class="p">]</span> <span class="o">=</span> <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
   <span class="o">...</span>
   <span class="n">plant</span><span class="o">.</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
   <span class="n">scene_graph</span><span class="o">.</span><span class="n">DoBar</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>This is the easiest way to use both the plant and scene_graph.</p>
<p>Assign to already-declared pointer variables:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;*</span> <span class="n">plant</span><span class="p">{};</span>
   <span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;*</span> <span class="n">scene_graph</span><span class="p">{};</span>
   <span class="n">std</span><span class="p">::</span><span class="n">tie</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span> <span class="n">scene_graph</span><span class="p">)</span> <span class="o">=</span>
       <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">/*</span> <span class="n">time_step</span> <span class="o">*/</span><span class="p">);</span>
   <span class="n">plant</span><span class="o">-&gt;</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
   <span class="n">scene_graph</span><span class="o">-&gt;</span><span class="n">DoBar</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>This flavor is most useful when the pointers are class member fields
(and so perhaps cannot be references).</p>
<p>** Registering geometry with a SceneGraph</p>
<p>MultibodyPlant users can register geometry with a SceneGraph for
essentially two purposes; a) visualization and, b) contact modeling.</p>
<p>Before any geometry registration takes place, a user <strong>must</strong> first
make a call to RegisterAsSourceForSceneGraph() in order to register
the MultibodyPlant as a client of a SceneGraph instance, point at
which the plant will have assigned a valid geometry::SourceId. At
Finalize(), MultibodyPlant will declare input/output ports as
appropriate to communicate with the SceneGraph instance on which
registrations took place. All geometry registration <strong>must</strong> be
performed pre-finalize.</p>
<p>Multibodyplant declares an input port for geometric queries, see
get_geometry_query_input_port(). If MultibodyPlant registers geometry
with a SceneGraph via calls to RegisterCollisionGeometry(), users may
use this port for geometric queries. Users must connect this input
port to the output port for geometric queries of the SceneGraph used
for registration, which can be obtained with
SceneGraph::get_query_output_port(). In summary, if MultibodyPlant
registers collision geometry, the setup process will include:</p>
<p>1. Call to RegisterAsSourceForSceneGraph(). 2. Calls to
RegisterCollisionGeometry(), as many as needed. 3. Call to Finalize(),
user is done specifying the model. 4. Connect
SceneGraph::get_query_output_port() to
get_geometry_query_input_port().</p>
<p>Refer to the documentation provided in each of the methods above for
further details.</p>
<p>** Accessing point contact parameters MultibodyPlant’s point contact
model looks for model parameters stored as
geometry::ProximityProperties by geometry::SceneGraph. These
properties can be obtained before or after context creation through
geometry::SceneGraphInspector APIs as outlined below. MultibodyPlant
expects the following properties for point contact modeling:</p>
<div class="line-block">
<div class="line">Group name | Property Name | Required | Property Type | Property</div>
</div>
<p>Description | | :——–: | :————–: | :——: |
:—————-: | :——————- | | material |
coulomb_friction | yes¹ | CoulombFriction&lt;T&gt; | Static and Dynamic
friction. | | material | point_contact_stiffness | no² | T | Penalty
method stiffness. | | material | hunt_crossley_dissipation | no² | T |
Penalty method dissipation. |</p>
<p>¹ Collision geometry is required to be registered with a
geometry::ProximityProperties object that contains the (“material”,
“coulomb_friction”) property. If the property is missing,
MultibodyPlant will throw an exeception.</p>
<p>² If the property is missing, MultibodyPlant will use a heuristic
value as the default. Refer to the section mbp_penalty_method “Penalty
method point contact” for further details.</p>
<p>Accessing and modifying contact properties requires interfacing with
geometry::SceneGraph’s model inspector. Interfacing with a model
inspector obtained from geometry::SceneGraph will provide the default
registered values for a given parameter. These are the values that
will initially appear in a systems::Context created by
CreateDefaultContext(). Subsequently, true system paramters can be
accessed and changed through a systems::Context once available. For
both of the above cases, proximity properties are accessed through
geometry::SceneGraphInspector APIs.</p>
<p>Before context creation an inspector can be retrieved directly from
SceneGraph as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">For</span> <span class="n">a</span> <span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">instance</span> <span class="n">called</span> <span class="n">scene_graph</span><span class="o">.</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">inspector</span> <span class="o">=</span>
<span class="n">scene_graph</span><span class="o">.</span><span class="n">model_inspector</span><span class="p">();</span>
</pre></div>
</div>
<p>After context creation, an inspector can be retrieved from the state
stored in the context by the plant’s geometry query input port:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">For</span> <span class="n">a</span> <span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">instance</span> <span class="n">called</span> <span class="n">mbp</span> <span class="ow">and</span> <span class="n">a</span>
<span class="o">//</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">called</span> <span class="n">context</span><span class="o">.</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">QueryObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">query_object</span> <span class="o">=</span>
<span class="n">mbp</span><span class="o">.</span><span class="n">get_geometry_query_input_port</span><span class="p">()</span>
<span class="o">.</span><span class="n">template</span> <span class="n">Eval</span><span class="o">&lt;</span><span class="n">geometry</span><span class="p">::</span><span class="n">QueryObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">inspector</span> <span class="o">=</span>
<span class="n">query_object</span><span class="o">.</span><span class="n">inspector</span><span class="p">();</span>
</pre></div>
</div>
<p>Once an inspector is available, proximity properties can be retrieved
as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">For</span> <span class="n">a</span> <span class="n">body</span> <span class="k">with</span> <span class="n">GeometryId</span> <span class="n">called</span> <span class="n">geometry_id</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">ProximityProperties</span><span class="o">*</span> <span class="n">props</span> <span class="o">=</span>
<span class="n">inspector</span><span class="o">.</span><span class="n">GetProximityProperties</span><span class="p">(</span><span class="n">geometry_id</span><span class="p">);</span>
<span class="n">const</span> <span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">geometry_friction</span> <span class="o">=</span>
<span class="n">props</span><span class="o">-&gt;</span><span class="n">GetProperty</span><span class="o">&lt;</span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s2">&quot;material&quot;</span><span class="p">,</span>
<span class="s2">&quot;coulomb_friction&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p><a href="#id37"><span class="problematic" id="id38">**</span></a>** Adding modeling elements</p>
<p>Add multibody elements to a MultibodyPlant with methods like:</p>
<ul class="simple">
<li>Bodies: AddRigidBody() - Joints: AddJoint() - see mbp_construction</li>
</ul>
<p>“Construction” for more.</p>
<p>All modeling elements <strong>must</strong> be added before Finalize() is called.
See mbp_finalize_stage “Finalize stage” for a discussion.</p>
<p><a href="#id39"><span class="problematic" id="id40">**</span></a>** Modeling contact</p>
<p>Please refer to drake_contacts “Contact Modeling in Drake” for details
on the available approximations, setup, and considerations for a
multibody simulation with frictional contact.</p>
<p><a href="#id41"><span class="problematic" id="id42">**</span></a>** Energy and Power</p>
<p>MultibodyPlant implements the System energy and power methods, with
some limitations. - Kinetic energy: fully implemented. - Potential
energy and conservative power: currently include only gravity and
contributions from ForceElement objects; potential energy from
compliant contact and joint limits are not included. - Nonconservative
power: currently includes only contributions from ForceElement
objects; actuation and input port forces, joint damping, and
dissipation from joint limits, friction, and contact dissipation are
not included.</p>
<p>See Drake issue #12942 for more discussion.</p>
<p><a href="#id43"><span class="problematic" id="id44">**</span></a>** Finalize() stage</p>
<p>Once the user is done adding modeling elements and registering
geometry, a call to Finalize() must be performed. This call will: -
Build the underlying MultibodyTree topology, see
MultibodyTree::Finalize() for details, - declare the plant’s state, -
declare the plant’s input and output ports, - declare input and output
ports for communication with a SceneGraph.</p>
<p><a href="#id45"><span class="problematic" id="id46">**</span></a>** References</p>
<ul class="simple">
<li>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics</li>
</ul>
<p>algorithms. Springer. - [Jain 2010] Jain, A., 2010. Robot and
multibody dynamics: analysis and algorithms. Springer Science &amp;
Business Media. - [Seth 2010] Seth, A., Sherman, M., Eastman, P. and
Delp, S., 2010. Minimal formulation of joint motion for biomechanisms.
Nonlinear dynamics, 62(1), pp.291-303.</p>
<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], time_step: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>This constructor creates a plant with a single “world” body.
Therefore, right after creation, num_bodies() returns one.</p>
<p>MultibodyPlant offers two different modalities to model mechanical
systems in time. These are: 1. As a discrete system with periodic
updates, <code class="docutils literal"><span class="pre">time_step</span></code> is strictly greater than zero. 2. As a
continuous system, <code class="docutils literal"><span class="pre">time_step</span></code> equals exactly zero.</p>
<p>Currently the discrete model is preferred for simulation given its
robustness and speed in problems with frictional contact. However this
might change as we work towards developing better strategies to model
contact. See time_advancement_strategy “Choice of Time Advancement
Strategy” for further details.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Users should be aware of current limitations in either modeling
modality. While the discrete model is often the preferred option
for problems with frictional contact given its robustness and
speed, it might become unstable when using large feedback gains,
high damping or large external forcing. MultibodyPlant will throw
an exception whenever the discrete solver is detected to fail.
Conversely, the continuous modality has the potential to leverage
the robustness and accuracy control provide by Drake’s
integrators. However thus far this has proved difficult in
practice and especially due to poor performance.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">time_step</span></code>:</dt>
<dd>Indicates whether <code class="docutils literal"><span class="pre">this</span></code> plant is modeled as a continuous system
(<code class="docutils literal"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code>) or as a discrete system with periodic updates
of period <code class="docutils literal"><span class="pre">time_step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. See time_advancement_strategy “Choice
of Time Advancement Strategy” for further details.</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Currently the continuous modality with <code class="docutils literal"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code> does not
support joint limits for simulation, these are ignored.
MultibodyPlant prints a warning to console if joint limits are
provided. If your simulation requires joint limits currently you
must use a discrete MultibodyPlant model.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">time_step</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddForceElement">
<code class="descname">AddForceElement</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], force_element: pydrake.multibody.tree.ForceElement_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ForceElement_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddForceElement" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a new force element model of type <code class="docutils literal"><span class="pre">ForceElementType</span></code> to
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. The arguments to this method <code class="docutils literal"><span class="pre">args</span></code> are
forwarded to <a href="#id47"><span class="problematic" id="id48">``</span></a>ForceElementType`’s constructor.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">args</span></code>:</dt>
<dd>Zero or more parameters provided to the constructor of the new
force element. It must be the case that
<cite>ForceElementType&lt;T&gt;(args)`</cite> is a valid constructor.</dd>
<dt>Template parameter <code class="docutils literal"><span class="pre">ForceElementType</span></code>:</dt>
<dd>The type of the ForceElement to add. As there is always a
UniformGravityFieldElement present (accessible through
gravity_field()), an exception will be thrown if this function is
called to add another UniformGravityFieldElement.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A constant reference to the new ForceElement just added, of type
<code class="docutils literal"><span class="pre">ForceElementType&lt;T&gt;</span></code> specialized on the scalar type T of
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. It will remain valid for the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The ForceElement class’s documentation for further details on how
a force element is defined.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddFrame">
<code class="descname">AddFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frame: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>This method adds a Frame of type <code class="docutils literal"><span class="pre">FrameType&lt;T&gt;</span></code>. For more
information, please see the corresponding constructor of
<code class="docutils literal"><span class="pre">FrameType</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">FrameType</span></code>:</dt>
<dd>Template which will be instantiated on <code class="docutils literal"><span class="pre">T</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame</span></code>:</dt>
<dd>Unique pointer frame instance.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A constant reference to the new Frame just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddJoint">
<code class="descname">AddJoint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], joint: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>This method adds a Joint of type <code class="docutils literal"><span class="pre">JointType</span></code> between two bodies. For
more information, see the below overload of <code class="docutils literal"><span class="pre">AddJoint&lt;&gt;</span></code>, and the
related <code class="docutils literal"><span class="pre">MultibodyTree::AddJoint&lt;&gt;</span></code> method.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddJointActuator">
<code class="descname">AddJointActuator</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, joint: pydrake.multibody.tree.Joint_[AutoDiffXd], effort_limit: float = inf</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuator_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddJointActuator" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and adds a JointActuator model for an actuator acting on a
given <code class="docutils literal"><span class="pre">joint</span></code>. This method returns a constant reference to the
actuator just added, which will remain valid for the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> plant.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that uniquely identifies the new actuator to be added to
<code class="docutils literal"><span class="pre">this</span></code> model. A RuntimeError is thrown if an actuator with the
same name already exists in the model. See
HasJointActuatorNamed().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">joint</span></code>:</dt>
<dd>The Joint to be actuated by the new JointActuator.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">effort_limit</span></code>:</dt>
<dd>The maximum effort for the actuator. It must be strictly positive,
otherwise an RuntimeError is thrown. If +∞, the actuator has no
limit, which is the default. The effort limit has physical units
in accordance to the joint type it actuates. For instance, it will
have units of N⋅m (torque) for revolute joints while it will have
units of N (force) for prismatic joints.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A constant reference to the new JointActuator just added, which
will remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> plant.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">joint.num_velocities()</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> since for now we</li>
<li>only support actuators for single dof joints.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddModelInstance">
<code class="descname">AddModelInstance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddModelInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new model instance. Returns the index for the model
instance.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that uniquely identifies the new instance to be added to
<code class="docutils literal"><span class="pre">this</span></code> model. An exception is thrown if an instance with the
same name already exists in the model. See
HasModelInstanceNamed().</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddRigidBody">
<code class="descname">AddRigidBody</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].AddRigidBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; pydrake.multibody.tree.RigidBody_[AutoDiffXd]</li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. The body
will use the default model instance (model_instance “more on model
instances”).</p>
<p>Example of usage:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">;</span>
  <span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">to</span> <span class="n">define</span> <span class="n">spatial_inertia</span><span class="p">,</span> <span class="n">a</span> <span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">object</span> <span class="o">...</span>
  <span class="n">const</span> <span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">body</span> <span class="o">=</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s2">&quot;BodyName&quot;</span><span class="p">,</span> <span class="n">spatial_inertia</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that identifies the new body to be added to <code class="docutils literal"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal"><span class="pre">name</span></code> already
is part of the model in the default model instance. See
HasBodyNamed(), Body::name().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>The SpatialInertia of the new rigid body to be added to <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal"><span class="pre">Bo</span></code> and
expressed in the body frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if additional model instances have been created</li>
<li>beyond the world and default instances.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; pydrake.multibody.tree.RigidBody_[AutoDiffXd]</li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<p>Example of usage:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">;</span>
  <span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">to</span> <span class="n">define</span> <span class="n">spatial_inertia</span><span class="p">,</span> <span class="n">a</span> <span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">object</span> <span class="o">...</span>
  <span class="n">ModelInstanceIndex</span> <span class="n">model_instance</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">AddModelInstance</span><span class="p">(</span><span class="s2">&quot;instance&quot;</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">body</span> <span class="o">=</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s2">&quot;BodyName&quot;</span><span class="p">,</span> <span class="n">model_instance</span><span class="p">,</span> <span class="n">spatial_inertia</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that identifies the new body to be added to <code class="docutils literal"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal"><span class="pre">name</span></code> already
is part of <code class="docutils literal"><span class="pre">model_instance</span></code>. See HasBodyNamed(), Body::name().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">model_instance</span></code>:</dt>
<dd>A model instance index which this body is part of.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>The SpatialInertia of the new rigid body to be added to <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal"><span class="pre">Bo</span></code> and
expressed in the body frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcBiasSpatialAcceleration">
<code class="descname">CalcBiasSpatialAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BoBp_B: numpy.ndarray[object[3, 1]], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcBiasSpatialAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>For one point Bp affixed/welded to a frame B, calculates A𝑠Bias_ABp,
Bp’s spatial acceleration bias in frame A with respect to “speeds” 𝑠,
where 𝑠 is either q̇ (time-derivatives of generalized positions) or v
(generalized velocities). A𝑠Bias_ABp is the term in A_ABp (Bp’s
spatial acceleration in A) that does not include 𝑠̇, i.e., A𝑠Bias_ABp
is Bi’s translational acceleration in A when 𝑠̇ = 0.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   (𝑠 = q̇ or 𝑠 = v), hence
  A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠
</pre></div>
</div>
<p>where J𝑠_V_ABp is Bp’s spatial velocity Jacobian in frame A for speeds
s (see CalcJacobianSpatialVelocity() for details on J𝑠_V_ABp).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the spatial
accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which point Bp is affixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBp_B</span></code>:</dt>
<dd>Position vector from Bo (frame_B’s origin) to point Bp (regarded
as affixed/welded to B), expressed in frame_B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures A𝑠Bias_ABp. Currently, an exception is
thrown if frame_A is not the World frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which A𝑠Bias_ABp is expressed on output.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A𝑠Bias_ABp_E Point Bp’s spatial acceleration bias in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shown below, A𝑠Bias_ABp_E = J̇𝑠_V_ABp ⋅ 𝑠 is quadratic in 𝑠.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>V_ABp =  J𝑠_V_ABp ⋅ 𝑠        which upon vector differentiation in A gives
 A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   Since J̇𝑠_V_ABp is linear in 𝑠,
 A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠                             is quadratic in 𝑠.
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcJacobianSpatialVelocity() to compute J𝑠_V_ABp, point Bp’s
translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if with_respect_to is not JacobianWrtVariable::kV</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if frame_A is not the world frame.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcBiasTerm">
<code class="descname">CalcBiasTerm</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcBiasTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the bias term <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> containing Coriolis, centripetal,
and gyroscopic effects in the multibody equations of motion:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>M(q) v̇ + C(q, v) v = tau_app + ∑ (Jv_V_WBᵀ(q) ⋅ Fapp_Bo_W)
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">M(q)</span></code> is the multibody model’s mass matrix and <code class="docutils literal"><span class="pre">tau_app</span></code> is
a vector of generalized forces. The last term is a summation over all
bodies of the dot-product of <code class="docutils literal"><span class="pre">Fapp_Bo_W</span></code> (applied spatial force on
body B at Bo) with <code class="docutils literal"><span class="pre">Jv_V_WB(q)</span></code> (B’s spatial Jacobian in world W
with respect to generalized velocities v). Note: B’s spatial velocity
in W can be written <code class="docutils literal"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model. It stores the
generalized positions q and the generalized velocities v.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">Cv</span></code>:</dt>
<dd>On output, <code class="docutils literal"><span class="pre">Cv</span></code> will contain the product <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>. It must
be a valid (non-null) pointer to a column vector in <code class="docutils literal"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities (num_velocities()) of the
model. This method aborts if Cv is nullptr or if it does not have
the proper size.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcBiasTranslationalAcceleration">
<code class="descname">CalcBiasTranslationalAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BoBi_B: numpy.ndarray[object[3, n], flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcBiasTranslationalAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi,
Bi’s translational acceleration bias in frame A with respect to
“speeds” 𝑠, where 𝑠 is either q̇ (time-derivatives of generalized
positions) or v (generalized velocities). a𝑠Bias_ABi is the term in
a_ABi (Bi’s translational acceleration in A) that does not include 𝑠̇,
i.e., a𝑠Bias_ABi is Bi’s translational acceleration in A when 𝑠̇ = 0.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇  +  J̇𝑠_v_ABi ⋅ 𝑠  (𝑠 = q̇ or 𝑠 = v), hence
  a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠
</pre></div>
</div>
<p>where J𝑠_v_ABi is Bi’s translational velocity Jacobian in frame A for
s (see CalcJacobianTranslationalVelocity() for details on J𝑠_v_ABi).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the translational
accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which points Bi are affixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBi_B</span></code>:</dt>
<dd>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B. Each column in the <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span>
<span class="pre">p</span></code> matrix p_BoBi_B corresponds to a position vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures a𝑠Bias_ABi. Currently, an exception is
thrown if frame_A is not the World frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which a𝑠Bias_ABi is expressed on output.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a𝑠Bias_ABi_E Point Bi’s translational acceleration bias in frame A
with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
a𝑠Bias_ABi_E is a <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">p</span></code> matrix, where p is the number of
points Bi.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shown below, a𝑠Bias_ABi_E = J̇𝑠_v_ABp ⋅ 𝑠 is quadratic in 𝑠.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>v_ABi =  J𝑠_v_ABi ⋅ 𝑠        which upon vector differentiation in A gives
 a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇ + J̇𝑠_v_ABi ⋅ 𝑠     Since J̇𝑠_v_ABi is linear in 𝑠,
 a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠                             is quadratic in 𝑠.
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcJacobianTranslationalVelocity() to compute J𝑠_v_ABi, point
Bi’s translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>p_BoBi_B must have 3 rows.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if with_respect_to is not JacobianWrtVariable::kV</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if frame_A is not the world frame.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcCenterOfMassPosition">
<code class="descname">CalcCenterOfMassPosition</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcCenterOfMassPosition" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the center of mass position p_WCcm of all bodies
in <code class="docutils literal"><span class="pre">MultibodyPlant</span></code> measured and expressed in world frame W. The
bodies are considered as a single composite body C, whose center of
mass <code class="docutils literal"><span class="pre">composite_mass</span></code> is located at Ccm. The world_body() is
ignored.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model. It stores the
generalized positions q of the model.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">p_WCcm</span></code>:</dt>
<dd>The output position of center of mass in the world frame W.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">MultibodyPlant</span></code> has no body except</li>
<li><code class="docutils literal"><span class="pre">world_body()</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError unless <code class="docutils literal"><span class="pre">composite_mass</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcForceElementsContribution">
<code class="descname">CalcForceElementsContribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], forces: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcForceElementsContribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the combined force contribution of ForceElement objects in
the model. A ForceElement can apply forces as a spatial force per body
or as generalized forces, depending on the ForceElement model.
ForceElement contributions are a function of the state and time only.
The output from this method can immediately be used as input to
CalcInverseDynamics() to include the effect of applied forces by force
elements.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of this model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">forces</span></code>:</dt>
<dd>A pointer to a valid, non nullptr, multibody forces object. On
output <code class="docutils literal"><span class="pre">forces</span></code> will store the forces exerted by all the
ForceElement objects in the model.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">forces</span></code> is null or not compatible with this</li>
<li>model, per MultibodyForces::CheckInvariants().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcGravityGeneralizedForces">
<code class="descname">CalcGravityGeneralizedForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcGravityGeneralizedForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the generalized forces <code class="docutils literal"><span class="pre">tau_g(q)</span></code> due to gravity as a
function of the generalized positions <code class="docutils literal"><span class="pre">q</span></code> stored in the input
<code class="docutils literal"><span class="pre">context</span></code>. The vector of generalized forces due to gravity
<code class="docutils literal"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the right hand side of
the equations of motion together with any other generalized forces,
like so:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Mv̇</span> <span class="o">+</span> <span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="n">v</span> <span class="o">=</span> <span class="n">tau_g</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau_app</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the model.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tau_g A vector containing the generalized forces due to gravity.
The generalized forces are consistent with the vector of
generalized velocities <code class="docutils literal"><span class="pre">v</span></code> for <code class="docutils literal"><span class="pre">this</span></code> so that the inner
product <code class="docutils literal"><span class="pre">v⋅tau_g</span></code> corresponds to the power applied by the
gravity forces on the mechanical system. That is, <code class="docutils literal"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>
corresponds to potential energy going into the system, as either
mechanical kinetic energy, some other potential energy, or heat,
and therefore to a decrease of the gravitational potential energy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcInverseDynamics">
<code class="descname">CalcInverseDynamics</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], known_vdot: numpy.ndarray[object[m, 1]], external_forces: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcInverseDynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the state of this model in <code class="docutils literal"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal"><span class="pre">vdot</span></code>, this method computes the set of
generalized forces <code class="docutils literal"><span class="pre">tau</span></code> that would need to be applied in order to
attain the specified generalized accelerations. Mathematically, this
method computes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>tau = M(q)v̇ + C(q, v)v - tau_app - ∑ J_WBᵀ(q) Fapp_Bo_W
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">M(q)</span></code> is the model’s mass matrix, <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> is the bias
term containing Coriolis and gyroscopic effects and <code class="docutils literal"><span class="pre">tau_app</span></code>
consists of a vector applied generalized forces. The last term is a
summation over all bodies in the model where <code class="docutils literal"><span class="pre">Fapp_Bo_W</span></code> is an
applied spatial force on body B at <code class="docutils literal"><span class="pre">Bo</span></code> which gets projected into
the space of generalized forces with the transpose of <code class="docutils literal"><span class="pre">Jv_V_WB(q)</span></code>
(where <code class="docutils literal"><span class="pre">Jv_V_WB</span></code> is B’s spatial velocity Jacobian in W with respect
to generalized velocities v). Note: B’s spatial velocity in W can be
written as <code class="docutils literal"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>. This method does not compute
explicit expressions for the mass matrix nor for the bias term, which
would be of at least <code class="docutils literal"><span class="pre">O(n²)</span></code> complexity, but it implements an
<code class="docutils literal"><span class="pre">O(n)</span></code> Newton-Euler recursive algorithm, where n is the number of
bodies in the model. The explicit formation of the mass matrix
<code class="docutils literal"><span class="pre">M(q)</span></code> would require the calculation of <code class="docutils literal"><span class="pre">O(n²)</span></code> entries while
explicitly forming the product <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)</span> <span class="pre">*</span> <span class="pre">v</span></code> could require up to
<code class="docutils literal"><span class="pre">O(n³)</span></code> operations (see [Featherstone 1987, §4]), depending on the
implementation. The recursive Newton-Euler algorithm is the most
efficient currently known general method for solving inverse dynamics
[Featherstone 2008].</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">known_vdot</span></code>:</dt>
<dd>A vector with the known generalized accelerations <code class="docutils literal"><span class="pre">vdot</span></code> for the
full model. Use the provided Joint APIs in order to access entries
into this array.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">external_forces</span></code>:</dt>
<dd>A set of forces to be applied to the system either as body spatial
forces <code class="docutils literal"><span class="pre">Fapp_Bo_W</span></code> or generalized forces <code class="docutils literal"><span class="pre">tau_app</span></code>, see
MultibodyForces for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the vector of generalized forces that would need to be applied to
the mechanical system in order to achieve the desired acceleration
given by <code class="docutils literal"><span class="pre">known_vdot</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcJacobianAngularVelocity">
<code class="descname">CalcJacobianAngularVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcJacobianAngularVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates J𝑠_w_AB, a frame B’s angular velocity Jacobian in a frame A
with respect to “speeds” 𝑠.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>J𝑠_w_AB ≜ [ ∂(w_AB)/∂𝑠₁,  ...  ∂(w_AB)/∂𝑠ₙ ]    (n is j or k)
     w_AB = J𝑠_w_AB ⋅ 𝑠          w_AB is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">w_AB</span></code> is B’s angular velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal"><span class="pre">J𝑠_w_AB</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame B in <code class="docutils literal"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame A in <code class="docutils literal"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which <code class="docutils literal"><span class="pre">w_AB</span></code> is expressed on input and the frame in
which the Jacobian <code class="docutils literal"><span class="pre">J𝑠_w_AB</span></code> is expressed on output.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">J𝑠_w_AB_E</span></code>:</dt>
<dd>Frame B’s angular velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E. The
Jacobian is a function of only generalized positions q (which are
pulled from the context). The previous definition shows
<code class="docutils literal"><span class="pre">J𝑠_w_AB_E</span></code> is a matrix of size <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code>, where n is the number
of elements in 𝑠.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">J𝑠_w_AB_E</span></code> is nullptr or not of size <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcJacobianSpatialVelocity">
<code class="descname">CalcJacobianSpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BP: numpy.ndarray[object[3, 1]], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcJacobianSpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp’s
spatial velocity Jacobian in frame A with respect to “speeds” 𝑠.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>J𝑠_V_ABp ≜ [ ∂(V_ABp)/∂𝑠₁,  ...  ∂(V_ABp)/∂𝑠ₙ ]    (n is j or k)
     V_ABp = J𝑠_V_ABp ⋅ 𝑠          V_ABp is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">V_ABp</span></code> is Bp’s spatial velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal"><span class="pre">J𝑠_V_ABp</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which point Bp is fixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBp_B</span></code>:</dt>
<dd>A position vector from Bo (frame_B’s origin) to point Bp (regarded
as fixed/welded to B), expressed in frame_B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures <code class="docutils literal"><span class="pre">v_ABp</span></code> (Bp’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAp_A (similar
to the parameter p_BoBp_B for frame_B). There is no need for
p_AoAp_A because Bp’s velocity in A is defined as the derivative
in frame A of Bp’s position vector from <em>any</em> point fixed to A.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which <code class="docutils literal"><span class="pre">v_ABp</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal"><span class="pre">J𝑠_V_ABp</span></code> is expressed on output.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">J𝑠_V_ABp_E</span></code>:</dt>
<dd>Point Bp’s spatial velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E.
<code class="docutils literal"><span class="pre">J𝑠_V_ABp_E</span></code> is a <code class="docutils literal"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where n is the number of
elements in 𝑠. The Jacobian is a function of only generalized
positions q (which are pulled from the context). Note: The
returned <code class="docutils literal"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix stores frame B’s angular velocity
Jacobian in A in rows 1-3 and stores point Bp’s translational
velocity Jacobian in A in rows 4-6, i.e.,</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">J𝑠_w_AB_E</span> <span class="o">=</span> <span class="n">J𝑠_V_ABp_E</span><span class="o">.</span><span class="n">topRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">J𝑠_v_ABp_E</span> <span class="o">=</span> <span class="n">J𝑠_V_ABp_E</span><span class="o">.</span><span class="n">bottomRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>Note: Consider CalcJacobianTranslationalVelocity() for multiple points
fixed to frame B and consider CalcJacobianAngularVelocity() to
calculate frame B’s angular velocity Jacobian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">J𝑠_V_ABp_E</span></code> is nullptr or not sized <code class="docutils literal"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcJacobianTranslationalVelocity">
<code class="descname">CalcJacobianTranslationalVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BoBi_B: numpy.ndarray[object[3, n], flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcJacobianTranslationalVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi,
Bi’s translational velocity Jacobian in frame A with respect to
“speeds” 𝑠.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>J𝑠_v_ABi ≜ [ ∂(v_ABi)/∂𝑠₁,  ...  ∂(v_ABi)/∂𝑠ₙ ]    (n is j or k)
     v_ABi = J𝑠_v_ABi ⋅ 𝑠          v_ABi is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">v_ABi</span></code> is Bi’s translational velocity in frame A and “speeds” 𝑠 is
either q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized
positions) or v ≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal"><span class="pre">J𝑠_v_ABi</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which point Bi is affixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBi_B</span></code>:</dt>
<dd>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures <code class="docutils literal"><span class="pre">v_ABi</span></code> (Bi’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAi_A (similar
to the parameter p_BoBi_B for frame_B). There is no need for
p_AoAi_A because Bi’s velocity in A is defined as the derivative
in frame A of Bi’s position vector from <em>any</em> point affixed to A.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which <code class="docutils literal"><span class="pre">v_ABi</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal"><span class="pre">J𝑠_v_ABi</span></code> is expressed on output.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">J𝑠_v_ABi_E</span></code>:</dt>
<dd>Point Bi’s velocity Jacobian in frame A with respect to speeds 𝑠
(which is either q̇ or v), expressed in frame E. <code class="docutils literal"><span class="pre">J𝑠_v_ABi_E</span></code> is
a <code class="docutils literal"><span class="pre">3*p</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where p is the number of points Bi and n is
the number of elements in 𝑠. The Jacobian is a function of only
generalized positions q (which are pulled from the context).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">J𝑠_v_ABi_E</span></code> is nullptr or not sized <a href="#id49"><span class="problematic" id="id50">``</span></a>3*p x</li>
<li>n``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When 𝑠 = q̇, <code class="docutils literal"><span class="pre">Jq̇_v_ABi</span> <span class="pre">=</span> <span class="pre">Jq_p_AoBi</span></code>. In other words, point Bi’s
velocity Jacobian in frame A with respect to q̇ is equal to point
Bi’s position Jacobian from Ao (A’s origin) in frame A with
respect to q.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>[∂(v_ABi)/∂q̇₁,  ...  ∂(v_ABi)/∂q̇ⱼ] = [∂(p_AoBi)/∂q₁,  ...  ∂(p_AoBi)/∂qⱼ]
</pre></div>
</div>
<p>Note: Each partial derivative of p_AoBi is taken in frame A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcMassMatrixViaInverseDynamics">
<code class="descname">CalcMassMatrixViaInverseDynamics</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcMassMatrixViaInverseDynamics" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcPointsPositions">
<code class="descname">CalcPointsPositions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BQi: numpy.ndarray[object[m, n], flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcPointsPositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the positions <code class="docutils literal"><span class="pre">p_BQi</span></code> for a set of points <code class="docutils literal"><span class="pre">Qi</span></code> measured and
expressed in a frame B, this method computes the positions
<code class="docutils literal"><span class="pre">p_AQi(q)</span></code> of each point <code class="docutils literal"><span class="pre">Qi</span></code> in the set as measured and expressed
in another frame A, as a function of the generalized positions q of
the model.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model. It stores the
generalized positions q of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame B in which the positions <code class="docutils literal"><span class="pre">p_BQi</span></code> of a set of points
<code class="docutils literal"><span class="pre">Qi</span></code> are given.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BQi</span></code>:</dt>
<dd>The input positions of each point <code class="docutils literal"><span class="pre">Qi</span></code> in frame B. <code class="docutils literal"><span class="pre">p_BQi</span> <span class="pre">∈</span>
<span class="pre">ℝ³ˣⁿᵖ</span></code> with <code class="docutils literal"><span class="pre">np</span></code> the number of points in the set. Each column
of <code class="docutils literal"><span class="pre">p_BQi</span></code> corresponds to a vector in ℝ³ holding the position of
one of the points in the set as measured and expressed in frame B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame A in which it is desired to compute the positions
<code class="docutils literal"><span class="pre">p_AQi</span></code> of each point <code class="docutils literal"><span class="pre">Qi</span></code> in the set.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_AQi</span></code>:</dt>
<dd>The output positions of each point <code class="docutils literal"><span class="pre">Qi</span></code> now computed as measured
and expressed in frame A. The output <code class="docutils literal"><span class="pre">p_AQi</span></code> <strong>must</strong> have the
same size as the input <code class="docutils literal"><span class="pre">p_BQi</span></code> or otherwise this method aborts.
That is <code class="docutils literal"><span class="pre">p_AQi</span></code> <strong>must</strong> be in <code class="docutils literal"><span class="pre">ℝ³ˣⁿᵖ</span></code>.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Both <code class="docutils literal"><span class="pre">p_BQi</span></code> and <code class="docutils literal"><span class="pre">p_AQi</span></code> must have three rows. Otherwise this
method will throw a RuntimeError exception. This method also
throws a RuntimeError exception if <code class="docutils literal"><span class="pre">p_BQi</span></code> and <code class="docutils literal"><span class="pre">p_AQi</span></code> differ
in the number of columns.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcRelativeTransform">
<code class="descname">CalcRelativeTransform</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], frame_A: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_B: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcRelativeTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rigid transform (pose) <code class="docutils literal"><span class="pre">X_FG</span></code> relating frame F and
frame G.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal"><span class="pre">X_FG</span></code> is a function of q.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_F</span></code>:</dt>
<dd>The frame F designated in the rigid transform <code class="docutils literal"><span class="pre">X_FG</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_G</span></code>:</dt>
<dd>The frame G designated in the rigid transform <code class="docutils literal"><span class="pre">X_FG</span></code>.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">X_FG</span></code>:</dt>
<dd>The RigidTransform relating frame F and frame G.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcSpatialAccelerationsFromVdot">
<code class="descname">CalcSpatialAccelerationsFromVdot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], known_vdot: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CalcSpatialAccelerationsFromVdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the state of this model in <code class="docutils literal"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal"><span class="pre">known_vdot</span></code>, this method computes the
spatial acceleration <code class="docutils literal"><span class="pre">A_WB</span></code> for each body as measured and expressed
in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of this model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">known_vdot</span></code>:</dt>
<dd>A vector with the generalized accelerations for the full model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">A_WB_array</span></code>:</dt>
<dd>A pointer to a valid, non nullptr, vector of spatial accelerations
containing the spatial acceleration <code class="docutils literal"><span class="pre">A_WB</span></code> for each body. It
must be of size equal to the number of bodies in the model. On
output, entries will be ordered by BodyIndex.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if A_WB_array is not of size <code class="docutils literal"><span class="pre">num_bodies()</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CollectRegisteredGeometries">
<code class="descname">CollectRegisteredGeometries</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], bodies: List[pydrake.multibody.tree.Body_[AutoDiffXd]]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.GeometrySet<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].CollectRegisteredGeometries" title="Permalink to this definition">¶</a></dt>
<dd><p>For each of the provided <code class="docutils literal"><span class="pre">bodies</span></code>, collects up all geometries that
have been registered to that body. Intended to be used in conjunction
with SceneGraph::ExcludeCollisionsWithin() and
SceneGraph::ExcludeCollisionsBetween() to filter collisions between
the geometries registered to the bodies.</p>
<p>For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Don&#39;t report on collisions between geometries affixed to ``body1``,
// ``body2``, or ``body3``.
std::vector&lt;const RigidBody&lt;T&gt;*&gt; bodies{&amp;body1, &amp;body2, &amp;body3};
geometry::GeometrySet set = plant.CollectRegisteredGeometries(bodies);
scene_graph.ExcludeCollisionsWithin(set);
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is a <em>very</em> specific order of operations:</p>
</div>
<ol class="arabic simple">
<li>Bodies and geometries must be added to the MultibodyPlant.</li>
<li>The MultibodyPlant must be finalized (via Finalize()).</li>
<li>Create GeometrySet instances from bodies (via this method).</li>
<li>Invoke SceneGraph::ExcludeCollisions*() to filter collisions.</li>
<li>Allocate context.</li>
</ol>
<p>Changing the order will cause exceptions to be thrown.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].default_coulomb_friction">
<code class="descname">default_coulomb_friction</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.plant.CoulombFriction_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].default_coulomb_friction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the friction coefficients provided during geometry
registration for the given geometry <code class="docutils literal"><span class="pre">id</span></code>. We call these the
“default” coefficients but note that we mean user-supplied
per-geometry default, not something more global.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not correspond to a geometry in</li>
<li><code class="docutils literal"><span class="pre">this</span></code> model registered for contact modeling.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RegisterCollisionGeometry() for details on geometry registration.
(Deprecated.)</p>
</div>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>default_coulomb_friction() will be removed. Please use SceneGraph
which now stores friction properties in ProximityProperties. See
the section “Accessing point contact parameters” in the
documentation for MultibodyPlant. This will be removed from Drake
on or after 2020-09-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].EvalBodyPoseInWorld">
<code class="descname">EvalBodyPoseInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].EvalBodyPoseInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the pose <code class="docutils literal"><span class="pre">X_WB</span></code> of a body B in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">body_B</span></code>:</dt>
<dd>The body B for which the pose is requested.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">X_WB</span></code>:</dt>
<dd>The pose of body frame B in the world frame W.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if Finalize() was not called on <code class="docutils literal"><span class="pre">this</span></code> model or if</li>
<li><code class="docutils literal"><span class="pre">body_B</span></code> does not belong to this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].EvalBodySpatialVelocityInWorld">
<code class="descname">EvalBodySpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].EvalBodySpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the spatial velocity <code class="docutils literal"><span class="pre">V_WB</span></code> of a body B in the world frame
W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">body_B</span></code>:</dt>
<dd>The body B for which the spatial velocity is requested.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">V_WB The spatial velocity of body frame B in the world frame W.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if Finalize() was not called on <code class="docutils literal"><span class="pre">this</span></code> model or if</li>
<li><code class="docutils literal"><span class="pre">body_B</span></code> does not belong to this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].Finalize">
<code class="descname">Finalize</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].Finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>This method must be called after all elements in the model (joints,
bodies, force elements, constraints, etc.) are added and before any
computations are performed. It essentially compiles all the necessary
“topological information”, i.e. how bodies, joints and, any other
elements connect with each other, and performs all the required
pre-processing to enable computations at a later stage.</p>
<p>If the finalize stage is successful, the topology of this
MultibodyPlant is valid, meaning that the topology is up-to-date after
this call. No more multibody elements can be added after a call to
Finalize().</p>
<p>At Finalize(), state and input/output ports for <code class="docutils literal"><span class="pre">this</span></code> plant are
declared. If <code class="docutils literal"><span class="pre">this</span></code> plant registered geometry with a SceneGraph,
input and output ports to enable communication with that SceneGraph
are declared as well.</p>
<p>If geometry has been registered on a SceneGraph instance, that
instance must be provided to the Finalize() method so that any
geometric implications of the finalization process can be
appropriately handled.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">is_finalized().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the MultibodyPlant has already been finalized.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].geometry_source_is_registered">
<code class="descname">geometry_source_is_registered</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].geometry_source_is_registered" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant was registered with a
SceneGraph. This method can be called at any time during the lifetime
of <code class="docutils literal"><span class="pre">this</span></code> plant to query if <code class="docutils literal"><span class="pre">this</span></code> plant has been registered with
a SceneGraph, either pre- or post-finalize, see Finalize().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_actuation_input_port">
<code class="descname">get_actuation_input_port</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_actuation_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; pydrake.systems.framework.InputPort_[AutoDiffXd]</li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for the case where only one model instance has actuated dofs. This
input port is a vector valued port, which can be set with
JointActuator::set_actuation_vector().</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called before Finalize(), if the model does not</li>
<li>contain any actuators, or if multiple model instances have</li>
<li>actuated dofs.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.InputPort_[AutoDiffXd]</li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for a specific model instance. This input port is a vector valued
port, which can be set with JointActuator::set_actuation_vector().</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_applied_generalized_force_input_port">
<code class="descname">get_applied_generalized_force_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_applied_generalized_force_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the vector-valued input port for
applied generalized forces, and the vector will be added directly into
<code class="docutils literal"><span class="pre">tau</span></code> (see mbp_equations_of_motion “System dynamics”). This vector
is ordered using the same convention as the plant velocities: you can
set the generalized forces that will be applied to model instance i
using, e.g., <code class="docutils literal"><span class="pre">SetVelocitiesInArray(i,</span> <span class="pre">model_forces,</span> <span class="pre">&amp;force_array)</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_applied_spatial_force_input_port">
<code class="descname">get_applied_spatial_force_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_applied_spatial_force_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the input port for applying spatial
forces to bodies in the plant. The data type for the port is an
std::vector of ExternallyAppliedSpatialForce; any number of spatial
forces can be applied to any number of bodies in the plant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_body">
<code class="descname">get_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body_index: pydrake.multibody.tree.BodyIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the body with unique index
<code class="docutils literal"><span class="pre">body_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">body_index</span></code> does not correspond to a body in</li>
<li>this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_body_poses_output_port">
<code class="descname">get_body_poses_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_body_poses_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of all body poses in the world frame. You can
obtain the pose <code class="docutils literal"><span class="pre">X_WB</span></code> of a body B in the world frame W with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">X_WB_all</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">get_body_poses_output_port</span><span class="p">()</span><span class="o">.</span>
      <span class="o">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">math</span><span class="p">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">BodyIndex</span> <span class="n">arm_body_index</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s2">&quot;arm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">math</span><span class="p">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">X_WArm</span> <span class="o">=</span> <span class="n">X_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
<p>As shown in the example above, the resulting <code class="docutils literal"><span class="pre">std::vector</span></code> of body
poses is indexed by BodyIndex, and it has size num_bodies(). BodyIndex
“zero” (0) always corresponds to the world body, with pose equal to
the identity at all times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_body_spatial_accelerations_output_port">
<code class="descname">get_body_spatial_accelerations_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_body_spatial_accelerations_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of all body spatial accelerations in the world
frame. You can obtain the spatial acceleration <code class="docutils literal"><span class="pre">A_WB</span></code> of a body B in
the world frame W with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">A_WB_all</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">get_body_spatial_accelerations_output_port</span><span class="p">()</span><span class="o">.</span>
      <span class="o">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialAcceleration</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">BodyIndex</span> <span class="n">arm_body_index</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s2">&quot;arm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">A_WArm</span> <span class="o">=</span> <span class="n">A_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
<p>As shown in the example above, the resulting <code class="docutils literal"><span class="pre">std::vector</span></code> of body
spatial accelerations is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial acceleration at all times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_body_spatial_velocities_output_port">
<code class="descname">get_body_spatial_velocities_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_body_spatial_velocities_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of all body spatial velocities in the world
frame. You can obtain the spatial velocity <code class="docutils literal"><span class="pre">V_WB</span></code> of a body B in the
world frame W with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">V_WB_all</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">get_body_spatial_velocities_output_port</span><span class="p">()</span><span class="o">.</span>
      <span class="o">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">BodyIndex</span> <span class="n">arm_body_index</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s2">&quot;arm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">V_WArm</span> <span class="o">=</span> <span class="n">V_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
<p>As shown in the example above, the resulting <code class="docutils literal"><span class="pre">std::vector</span></code> of body
spatial velocities is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial velocity at all times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_contact_penalty_method_time_scale">
<code class="descname">get_contact_penalty_method_time_scale</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_contact_penalty_method_time_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a time-scale estimate <code class="docutils literal"><span class="pre">tc</span></code> based on the requested
penetration allowance δ set with set_penetration_allowance(). For the
penalty method in use to enforce non-penetration, this time scale
relates to the time it takes the relative normal velocity between two
bodies to go to zero. This time scale <code class="docutils literal"><span class="pre">tc</span></code> is artificially
introduced by the penalty method and goes to zero in the limit to
ideal rigid contact. Since numerical integration methods for continuum
systems must be able to resolve a system’s dynamics, the time step
used by an integrator must in general be much smaller than the time
scale <code class="docutils literal"><span class="pre">tc</span></code>. How much smaller will depend on the details of the
problem and the convergence characteristics of the integrator and
should be tuned appropriately. Another factor to take into account for
setting up the simulation’s time step is the speed of the objects in
your simulation. If <code class="docutils literal"><span class="pre">vn</span></code> represents a reference velocity scale for
the normal relative velocity between bodies, the new time scale <code class="docutils literal"><span class="pre">tn</span> <span class="pre">=</span>
<span class="pre">δ</span> <span class="pre">/</span> <span class="pre">vn</span></code> represents the time it would take for the distance between
two bodies approaching with relative normal velocity <code class="docutils literal"><span class="pre">vn</span></code> to
decrease by the penetration_allowance δ. In this case a user should
choose a time step for simulation that can resolve the smallest of the
two time scales <code class="docutils literal"><span class="pre">tc</span></code> and <code class="docutils literal"><span class="pre">tn</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_contact_results_output_port">
<code class="descname">get_contact_results_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_contact_results_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the port that outputs ContactResults.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize, see Finalize().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_frame">
<code class="descname">get_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frame_index: pydrake.multibody.tree.FrameIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the frame with unique index
<code class="docutils literal"><span class="pre">frame_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">frame_index</span></code> does not correspond to a frame in</li>
<li>this plant.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_generalized_acceleration_output_port">
<code class="descname">get_generalized_acceleration_output_port</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_generalized_acceleration_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</li>
</ol>
<p>Returns a constant reference to the output port for generalized
accelerations v̇ of the model.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</li>
</ol>
<p>Returns a constant reference to the output port for the generalized
accelerations v̇ᵢ ⊆ v̇ for model instance i.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_generalized_contact_forces_output_port">
<code class="descname">get_generalized_contact_forces_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_generalized_contact_forces_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the output port of generalized contact
forces for a specific model instance.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_geometry_poses_output_port">
<code class="descname">get_geometry_poses_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_geometry_poses_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of frames’ poses to communicate with a
SceneGraph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_geometry_query_input_port">
<code class="descname">get_geometry_query_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_geometry_query_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the input port used to perform
geometric queries on a SceneGraph. See
SceneGraph::get_query_output_port(). Refer to section mbp_geometry
“Geometry” of this class’s documentation for further details on
collision geometry registration and connection with a SceneGraph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_joint">
<code class="descname">get_joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], joint_index: pydrake.multibody.tree.JointIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the joint with unique index
<code class="docutils literal"><span class="pre">joint_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError when <code class="docutils literal"><span class="pre">joint_index</span></code> does not correspond to a joint</li>
<li>in this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_joint_actuator">
<code class="descname">get_joint_actuator</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], actuator_index: pydrake.multibody.tree.JointActuatorIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuator_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_joint_actuator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the joint actuator with unique index
<code class="docutils literal"><span class="pre">actuator_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">actuator_index</span></code> does not correspond to a joint</li>
<li>actuator in this tree.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_reaction_forces_output_port">
<code class="descname">get_reaction_forces_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_reaction_forces_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the port for joint reaction forces. A Joint models the
kinematical relationship which characterizes the possible relative
motion between two bodies. In Drake, a joint connects a frame <code class="docutils literal"><span class="pre">Jp</span></code>
on <em>parent</em> body P with a frame <code class="docutils literal"><span class="pre">Jc</span></code> on a <em>child</em> body C. This usage
of the terms <em>parent</em> and <em>child</em> is just a convention and implies
nothing about the inboard-outboard relationship between the bodies.
Since a Joint imposes a kinematical relationship which characterizes
the possible relative motion between frames Jp and Jc, reaction forces
on each body are established. That is, we could cut the model at the
joint and replace it with equivalent forces equal to these reaction
forces in order to attain the same motions of the mechanical system.</p>
<p>This output port allows to evaluate the reaction force <code class="docutils literal"><span class="pre">F_CJc_Jc</span></code> on
the <em>child</em> body C, at <code class="docutils literal"><span class="pre">Jc</span></code>, and expressed in Jc for all joints in
the model. This port evaluates to a vector of type
std::vector&lt;SpatialForce&lt;T&gt;&gt; and size num_joints() indexed by
JointIndex, see Joint::index(). Each entry corresponds to the spatial
force <code class="docutils literal"><span class="pre">F_CJc_Jc</span></code> applied on the joint’s child body C
(Joint::child_body()), at the joint’s child frame <code class="docutils literal"><span class="pre">Jc</span></code>
(Joint::frame_on_child()) and expressed in frame <code class="docutils literal"><span class="pre">Jc</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_source_id">
<code class="descname">get_source_id</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; Optional[pydrake.geometry.SourceId]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_source_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unique id identifying <code class="docutils literal"><span class="pre">this</span></code> plant as a source for a
SceneGraph. Returns <code class="docutils literal"><span class="pre">nullopt</span></code> if <code class="docutils literal"><span class="pre">this</span></code> plant did not register any
geometry. This method can be called at any time during the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> plant to query if <code class="docutils literal"><span class="pre">this</span></code> plant has been registered with a
SceneGraph, either pre- or post-finalize, see Finalize(). However, a
geometry::SourceId is only assigned once at the first call of any of
this plant’s geometry registration methods, and it does not change
after that. Post-finalize calls will always return the same value.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_state_output_port">
<code class="descname">get_state_output_port</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].get_state_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</li>
</ol>
<p>Returns a constant reference to the output port for the multibody
state x = [q, v] of the model.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[AutoDiffXd]</li>
</ol>
<p>Returns a constant reference to the output port for the state xᵢ = [qᵢ
vᵢ] of model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.)</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetAccelerationLowerLimits">
<code class="descname">GetAccelerationLowerLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetAccelerationLowerLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of size <code class="docutils literal"><span class="pre">num_velocities()</span></code> containing the lower
acceleration limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetAccelerationUpperLimits">
<code class="descname">GetAccelerationUpperLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetAccelerationUpperLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit analog of GetAccelerationsLowerLimits(), where any
unbounded or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetAccelerationLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodyByName">
<code class="descname">GetBodyByName</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodyByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; pydrake.multibody.tree.Body_[AutoDiffXd]</li>
</ol>
<p>Returns a constant reference to a body that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no body with the requested name.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the body name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasBodyNamed() to query if there exists a body in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.Body_[AutoDiffXd]</li>
</ol>
<p>Returns a constant reference to the body that is uniquely identified
by the string <code class="docutils literal"><span class="pre">name</span></code> and <code class="docutils literal"><span class="pre">model_instance</span></code> in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no body with the requested name.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasBodyNamed() to query if there exists a body in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodyFrameIdIfExists">
<code class="descname">GetBodyFrameIdIfExists</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body_index: pydrake.multibody.tree.BodyIndex</em><span class="sig-paren">)</span> &#x2192; Optional[pydrake.geometry.FrameId]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodyFrameIdIfExists" title="Permalink to this definition">¶</a></dt>
<dd><p>If the body with <code class="docutils literal"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise, it
returns nullopt.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodyFrameIdOrThrow">
<code class="descname">GetBodyFrameIdOrThrow</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body_index: pydrake.multibody.tree.BodyIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.FrameId<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodyFrameIdOrThrow" title="Permalink to this definition">¶</a></dt>
<dd><p>If the body with <code class="docutils literal"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise this
method throws an exception.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the called plant does not have the body indicated</li>
<li>by <code class="docutils literal"><span class="pre">body_index</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodyFromFrameId">
<code class="descname">GetBodyFromFrameId</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], arg0: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodyFromFrameId" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a geometry frame identifier, returns a pointer to the body
associated with that id (nullptr if there is no such body).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodyIndices">
<code class="descname">GetBodyIndices</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex</em><span class="sig-paren">)</span> &#x2192; List[pydrake.multibody.tree.BodyIndex]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetBodyIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of body indices associated with <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetCollisionGeometriesForBody">
<code class="descname">GetCollisionGeometriesForBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.GeometryId]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetCollisionGeometriesForBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different contact
geometries for <code class="docutils literal"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method can be called at any time during the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RegisterCollisionGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetDefaultFreeBodyPose">
<code class="descname">GetDefaultFreeBodyPose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetDefaultFreeBodyPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default pose of <code class="docutils literal"><span class="pre">body</span></code> as set by SetDefaultFreeBodyPose().</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">body</span></code>:</dt>
<dd>Body whose default pose will be retrieved.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetFrameByName">
<code class="descname">GetFrameByName</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetFrameByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; pydrake.multibody.tree.Frame_[AutoDiffXd]</li>
</ol>
<p>Returns a constant reference to a frame that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no frame with the requested name.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the frame name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasFrameNamed() to query if there exists a frame in <code class="docutils literal"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.Frame_[AutoDiffXd]</li>
</ol>
<p>Returns a constant reference to the frame that is uniquely identified
by the string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no frame with the requested name.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasFrameNamed() to query if there exists a frame in <code class="docutils literal"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetJointActuatorByName">
<code class="descname">GetJointActuatorByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuator_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetJointActuatorByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to an actuator that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if there is no actuator with the requested name.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the actuator name occurs in multiple model</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">instances.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetJointByName">
<code class="descname">GetJointByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetJointByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal"><span class="pre">JointType</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">JointType</span></code>:</dt>
<dd>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the named joint is not of type <code class="docutils literal"><span class="pre">JointType</span></code> or if</li>
<li>there is no Joint with that name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasJointNamed() to query if there exists a joint in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetModelInstanceByName">
<code class="descname">GetModelInstanceByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetModelInstanceByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the model instance that is uniquely identified by
the string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no instance with the requested name.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasModelInstanceNamed() to query if there exists an instance in
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetModelInstanceName">
<code class="descname">GetModelInstanceName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetModelInstanceName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of a <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError when <code class="docutils literal"><span class="pre">model_instance</span></code> does not correspond to a</li>
<li>model in this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetMutableJointByName">
<code class="descname">GetMutableJointByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetMutableJointByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal"><span class="pre">JointType</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">JointType</span></code>:</dt>
<dd>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the named joint is not of type <code class="docutils literal"><span class="pre">JointType</span></code> or if</li>
<li>there is no Joint with that name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasJointNamed() to query if there exists a joint in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetMutablePositions">
<code class="descname">GetMutablePositions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1], flags.writeable]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetMutablePositions" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a mutable vector reference containing the vector of
generalized positions (<strong>see warning</strong>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You should use SetPositions() instead of this method unless you
are fully aware of the possible interactions with the caching
mechanism (see dangerous_get_mutable).</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr or if it does not</li>
<li>correspond to the context for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetMutablePositionsAndVelocities">
<code class="descname">GetMutablePositionsAndVelocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1], flags.writeable]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetMutablePositionsAndVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a mutable vector containing the vector <code class="docutils literal"><span class="pre">[q;</span> <span class="pre">v]</span></code>
of the model with <code class="docutils literal"><span class="pre">q</span></code> the vector of generalized positions and <code class="docutils literal"><span class="pre">v</span></code>
the vector of generalized velocities (<strong>see warning</strong>).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You should use SetPositionsAndVelocities() instead of this method
unless you are fully aware of the interactions with the caching
mechanism (see dangerous_get_mutable).</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr or if it does not</li>
<li>correspond to the context for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetMutableVelocities">
<code class="descname">GetMutableVelocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1], flags.writeable]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetMutableVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>See GetMutableVelocities() method above.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositionLowerLimits">
<code class="descname">GetPositionLowerLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositionLowerLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of size <code class="docutils literal"><span class="pre">num_positions()</span></code> containing the lower
position limits for every generalized position coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositions">
<code class="descname">GetPositions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the vector of generalized
positions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns an vector containing the generalized positions (<code class="docutils literal"><span class="pre">q</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">q.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">q.size()</span></code>) time.</p>
</div>
<ol class="arabic simple" start="3">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the vector of generalized
positions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns an vector containing the generalized positions (<code class="docutils literal"><span class="pre">q</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">q.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">q.size()</span></code>) time.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositionsAndVelocities">
<code class="descname">GetPositionsAndVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositionsAndVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the vector <code class="docutils literal"><span class="pre">[q;</span> <span class="pre">v]</span></code> with
<code class="docutils literal"><span class="pre">q</span></code> the vector of generalized positions and <code class="docutils literal"><span class="pre">v</span></code> the vector of
generalized velocities.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns the vector <code class="docutils literal"><span class="pre">[q;</span> <span class="pre">v]</span></code> of the model with <code class="docutils literal"><span class="pre">q</span></code> the vector of
generalized positions and <code class="docutils literal"><span class="pre">v</span></code> the vector of generalized velocities
for model instance <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model or <code class="docutils literal"><span class="pre">model_instance</span></code> is invalid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">q.size()</span> <span class="pre">+</span> <span class="pre">v.size()</span></code>
associated with <code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">q.size()</span></code>) time.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositionsFromArray">
<code class="descname">GetPositionsFromArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositionsFromArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of generalized positions for <code class="docutils literal"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal"><span class="pre">q_array</span></code> of generalized positions for the entire model
model. This method throws an exception if <code class="docutils literal"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositionUpperLimits">
<code class="descname">GetPositionUpperLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetPositionUpperLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit analog of GetPositionsLowerLimits(), where any unbounded
or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetPositionLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetTopologyGraphvizString">
<code class="descname">GetTopologyGraphvizString</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetTopologyGraphvizString" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Graphviz string describing the topology of this plant. To
render the string, use the Graphviz tool, <code class="docutils literal"><span class="pre">dot</span></code>.
<a class="reference external" href="http://www.graphviz.org/">http://www.graphviz.org/</a></p>
<p>Note: this method can be called either before or after <code class="docutils literal"><span class="pre">Finalize()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetVelocities">
<code class="descname">GetVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the generalized
velocities.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<ol class="arabic simple" start="2">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns a vector containing the generalized velocities (<code class="docutils literal"><span class="pre">v</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">v.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">v.size()</span></code>) time.</p>
</div>
<ol class="arabic simple" start="3">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the generalized
velocities.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<ol class="arabic simple" start="4">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns a vector containing the generalized velocities (<code class="docutils literal"><span class="pre">v</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">v.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">v.size()</span></code>) time.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetVelocitiesFromArray">
<code class="descname">GetVelocitiesFromArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetVelocitiesFromArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of generalized velocities for <code class="docutils literal"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal"><span class="pre">v</span></code> of generalized velocities for the entire MultibodyPlant
model. This method throws an exception if the input array is not of
size MultibodyPlant::num_velocities().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetVelocityLowerLimits">
<code class="descname">GetVelocityLowerLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetVelocityLowerLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of size <code class="docutils literal"><span class="pre">num_velocities()</span></code> containing the lower
velocity limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetVelocityUpperLimits">
<code class="descname">GetVelocityUpperLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].GetVelocityUpperLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit analog of GetVelocitysLowerLimits(), where any unbounded
or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetVelocityLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].gravity_field">
<code class="descname">gravity_field</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].gravity_field" title="Permalink to this definition">¶</a></dt>
<dd><p>An accessor to the current gravity field.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].HasBodyNamed">
<code class="descname">HasBodyNamed</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].HasBodyNamed" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a body named <code class="docutils literal"><span class="pre">name</span></code> was added to the MultibodyPlant.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddRigidBody().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the body name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a body named <code class="docutils literal"><span class="pre">name</span></code> was added to the MultibodyPlant
in <code class="docutils literal"><span class="pre">model_instance</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddRigidBody().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].HasJointActuatorNamed">
<code class="descname">HasJointActuatorNamed</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].HasJointActuatorNamed" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if an actuator named <code class="docutils literal"><span class="pre">name</span></code> was added to this model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJointActuator().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the actuator name occurs in multiple model</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">instances.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if an actuator named <code class="docutils literal"><span class="pre">name</span></code> was added to
<code class="docutils literal"><span class="pre">model_instance</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJointActuator().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].HasJointNamed">
<code class="descname">HasJointNamed</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].HasJointNamed" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a joint named <code class="docutils literal"><span class="pre">name</span></code> was added to this model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJoint().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the joint name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a joint named <code class="docutils literal"><span class="pre">name</span></code> was added to
<code class="docutils literal"><span class="pre">model_instance</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJoint().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].HasModelInstanceNamed">
<code class="descname">HasModelInstanceNamed</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], name: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].HasModelInstanceNamed" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a model instance named <code class="docutils literal"><span class="pre">name</span></code> was added to this
model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddModelInstance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].is_finalized">
<code class="descname">is_finalized</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].is_finalized" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if this MultibodyPlant was finalized with a call to
Finalize().</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Finalize().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].MakeActuationMatrix">
<code class="descname">MakeActuationMatrix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].MakeActuationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This method creates an actuation matrix B mapping a vector of
actuation values u into generalized forces <code class="docutils literal"><span class="pre">tau_u</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">u</span></code>, where B
is a matrix of size <code class="docutils literal"><span class="pre">nv</span> <span class="pre">x</span> <span class="pre">nu</span></code> with <code class="docutils literal"><span class="pre">nu</span></code> equal to num_actuators()
and <code class="docutils literal"><span class="pre">nv</span></code> equal to num_velocities(). The vector u of actuation values
is of size num_actuators(). For a given JointActuator,
<code class="docutils literal"><span class="pre">u[JointActuator::index()]</span></code> stores the value for the external
actuation corresponding to that actuator. <code class="docutils literal"><span class="pre">tau_u</span></code> on the other hand
is indexed by generalized velocity indexes according to
<code class="docutils literal"><span class="pre">Joint::velocity_start()</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">B is a permutation matrix. While making a permutation has <code class="docutils literal"><span class="pre">O(n)</span></code>
complexity, making a full B matrix has <code class="docutils literal"><span class="pre">O(n²)</span></code> complexity. For
most applications this cost can be neglected but it could become
significant for very large systems.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].MapQDotToVelocity">
<code class="descname">MapQDotToVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], qdot: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].MapQDotToVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the time derivative <code class="docutils literal"><span class="pre">qdot</span></code> of the generalized positions
vector <code class="docutils literal"><span class="pre">q</span></code> (stored in <code class="docutils literal"><span class="pre">context</span></code>) to generalized velocities <code class="docutils literal"><span class="pre">v</span></code>.
<cite>v</cite> and <code class="docutils literal"><span class="pre">q̇</span></code> are related linearly by <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Although
<code class="docutils literal"><span class="pre">N(q)</span></code> is not necessarily square, its left pseudo-inverse <code class="docutils literal"><span class="pre">N⁺(q)</span></code>
can be used to invert that relationship without residual error,
provided that <code class="docutils literal"><span class="pre">qdot</span></code> is in the range space of <code class="docutils literal"><span class="pre">N(q)</span></code> (that is, if
it <em>could</em> have been produced as <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code> for some <code class="docutils literal"><span class="pre">v</span></code>).
Using the configuration <code class="docutils literal"><span class="pre">q</span></code> stored in the given <code class="docutils literal"><span class="pre">context</span></code> this
method calculates <code class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">N⁺(q)⋅q̇</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">qdot</span></code>:</dt>
<dd>A vector containing the time derivatives of the generalized
positions. This method aborts if <code class="docutils literal"><span class="pre">qdot</span></code> is not of size
num_positions().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">v</span></code>:</dt>
<dd>A valid (non-null) pointer to a vector in <code class="docutils literal"><span class="pre">ℛⁿ</span></code> with n the number
of generalized velocities. This method aborts if v is nullptr or
if it is not of size num_velocities().</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MapVelocityToQDot()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Mobilizer::MapQDotToVelocity()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].MapVelocityToQDot">
<code class="descname">MapVelocityToQDot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].MapVelocityToQDot" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms generalized velocities v to time derivatives <code class="docutils literal"><span class="pre">qdot</span></code> of
the generalized positions vector <code class="docutils literal"><span class="pre">q</span></code> (stored in <code class="docutils literal"><span class="pre">context</span></code>). <cite>v</cite>
and <code class="docutils literal"><span class="pre">qdot</span></code> are related linearly by <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Using the
configuration <code class="docutils literal"><span class="pre">q</span></code> stored in the given <code class="docutils literal"><span class="pre">context</span></code> this method
calculates <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">v</span></code>:</dt>
<dd>A vector of of generalized velocities for this model. This method
aborts if v is not of size num_velocities().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">qdot</span></code>:</dt>
<dd>A valid (non-null) pointer to a vector in <code class="docutils literal"><span class="pre">ℝⁿ</span></code> with n being the
number of generalized positions in this model, given by
<code class="docutils literal"><span class="pre">num_positions()</span></code>. This method aborts if <code class="docutils literal"><span class="pre">qdot</span></code> is nullptr or
if it is not of size num_positions().</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MapQDotToVelocity()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Mobilizer::MapVelocityToQDot()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].mutable_gravity_field">
<code class="descname">mutable_gravity_field</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].mutable_gravity_field" title="Permalink to this definition">¶</a></dt>
<dd><p>A mutable accessor to the current gravity field.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_actuated_dofs">
<code class="descname">num_actuated_dofs</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_actuated_dofs" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; int</li>
</ol>
<p>Returns the total number of actuated degrees of freedom. That is, the
vector of actuation values u has this size. See AddJointActuator().</p>
<ol class="arabic simple" start="2">
<li>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the total number of actuated degrees of freedom for a specific
model instance. That is, the vector of actuation values u has this
size. See AddJointActuator().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_actuators">
<code class="descname">num_actuators</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_actuators" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of joint actuators in the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJointActuator().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_bodies">
<code class="descname">num_bodies</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of bodies in the model, including the “world” body,
which is always part of the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddRigidBody().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_collision_geometries">
<code class="descname">num_collision_geometries</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_collision_geometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of geometries registered for contact modeling. This
method can be called at any time during the lifetime of <code class="docutils literal"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize(). Post-finalize
calls will always return the same value.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_force_elements">
<code class="descname">num_force_elements</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_force_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of ForceElement objects.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddForceElement().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_frames">
<code class="descname">num_frames</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of Frame objects in this model. Frames include body
frames associated with each of the bodies, including the <em>world</em> body.
This means the minimum number of frames is one.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_joints">
<code class="descname">num_joints</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_joints" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of joints in the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJoint().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_model_instances">
<code class="descname">num_model_instances</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_model_instances" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of model instances in the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddModelInstance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_multibody_states">
<code class="descname">num_multibody_states</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_multibody_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; int</li>
</ol>
<p>Returns the size of the multibody system state vector x = [q v]. This
will be <code class="docutils literal"><span class="pre">num_positions()</span></code> plus <code class="docutils literal"><span class="pre">num_velocities()</span></code>.</p>
<ol class="arabic simple" start="2">
<li>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the size of the multibody system state vector xᵢ = [qᵢ vᵢ] for
model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.) will be
<code class="docutils literal"><span class="pre">num_positions(model_instance)</span></code> plus
<code class="docutils literal"><span class="pre">num_velocities(model_instance)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_positions">
<code class="descname">num_positions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; int</li>
</ol>
<p>Returns the size of the generalized position vector q for this model.</p>
<ol class="arabic simple" start="2">
<li>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the size of the generalized position vector qᵢ for model
instance i.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]) -&gt; int</li>
</ol>
<p>Returns the size of the generalized velocity vector v for this model.</p>
<ol class="arabic simple" start="2">
<li>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the size of the generalized velocity vector vᵢ for model
instance i.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].RegisterAsSourceForSceneGraph">
<code class="descname">RegisterAsSourceForSceneGraph</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], scene_graph: pydrake.geometry.SceneGraph_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.SourceId<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].RegisterAsSourceForSceneGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers <code class="docutils literal"><span class="pre">this</span></code> plant to serve as a source for an instance of
SceneGraph. This registration allows MultibodyPlant to register
geometry with <code class="docutils literal"><span class="pre">scene_graph</span></code> for visualization and/or collision
queries. Successive registration calls with SceneGraph <strong>must</strong> be
performed on the same instance to which the pointer argument
<code class="docutils literal"><span class="pre">scene_graph</span></code> points to. Failure to do so will result in runtime
exceptions.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">scene_graph</span></code>:</dt>
<dd>A valid non nullptr to the SceneGraph instance for which <code class="docutils literal"><span class="pre">this</span></code>
plant will sever as a source, see SceneGraph documentation for
further details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the SourceId of <code class="docutils literal"><span class="pre">this</span></code> plant in <code class="docutils literal"><span class="pre">scene_graph</span></code>. It can also
later on be retrieved with get_source_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called post-finalize.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">scene_graph</span></code> is the nullptr.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called more than once.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].RegisterCollisionGeometry">
<code class="descname">RegisterCollisionGeometry</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].RegisterCollisionGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Registers geometry in a SceneGraph with a given geometry::Shape to be
used for the contact modeling of a given <code class="docutils literal"><span class="pre">body</span></code>. More than one
geometry can be registered with a body, in which case the body’s
contact geometry is the union of all geometries registered to that
body.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">body</span></code>:</dt>
<dd>The body for which geometry is being registered.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_BG</span></code>:</dt>
<dd>The fixed pose of the geometry frame G in the body frame B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">shape</span></code>:</dt>
<dd>The geometry::Shape used for visualization. E.g.:
geometry::Sphere, geometry::Cylinder, etc.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">properties</span></code>:</dt>
<dd>The proximity properties associated with the collision geometry.
They <em>must</em> include the (<code class="docutils literal"><span class="pre">material</span></code>, <cite>coulomb_friction</cite>)
property of type CoulombFriction&lt;double&gt;.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called post-finalize or if the properties are</li>
<li>missing the coulomb friction property (or if it is of the wrong</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">type).</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, coulomb_friction: pydrake.multibody.plant.CoulombFriction_[float]) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Overload which specifies a single property: coulomb_friction.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].RegisterVisualGeometry">
<code class="descname">RegisterVisualGeometry</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].RegisterVisualGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RegisterVisualGeometry(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4, 1]]) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Overload for visual geometry registration; it converts the
<code class="docutils literal"><span class="pre">diffuse_color</span></code> (RGBA with values in the range [0, 1]) into a
geometry::ConnectDrakeVisualizer()-compatible set of
geometry::IllustrationProperties.</p>
<ol class="arabic simple" start="2">
<li>RegisterVisualGeometry(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd], X_BG: pydrake.common.eigen_geometry.Isometry3_[float], shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4, 1]], scene_graph: pydrake.geometry.SceneGraph_[AutoDiffXd] = None) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].set_penetration_allowance">
<code class="descname">set_penetration_allowance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], penetration_allowance: float = 0.001</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].set_penetration_allowance" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the penetration allowance used to estimate the coefficients in
the penalty method used to impose non-penetration among bodies. Refer
to the section mbp_penalty_method “Contact by penalty method” for
further details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if penetration_allowance is not positive.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].set_stiction_tolerance">
<code class="descname">set_stiction_tolerance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], v_stiction: float = 0.001</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].set_stiction_tolerance" title="Permalink to this definition">¶</a></dt>
<dd><p><a href="#id51"><span class="problematic" id="id52">**</span></a>** Stribeck model of friction</p>
<p>Currently MultibodyPlant uses the Stribeck approximation to model dry
friction. The Stribeck model of friction is an approximation to
Coulomb’s law of friction that allows using continuous time
integration without the need to specify complementarity constraints.
While this results in a simpler model immediately tractable with
standard numerical methods for integration of ODE’s, it often leads to
stiff dynamics that require an explicit integrator to take very small
time steps. It is therefore recommended to use error controlled
integrators when using this model or the discrete time stepping (see
time_advancement_strategy “Choice of Time Advancement Strategy”). See
stribeck_approximation for a detailed discussion of the Stribeck
model.</p>
<p>Sets the stiction tolerance <code class="docutils literal"><span class="pre">v_stiction</span></code> for the Stribeck model,
where <code class="docutils literal"><span class="pre">v_stiction</span></code> must be specified in m/s (meters per second.)
<code class="docutils literal"><span class="pre">v_stiction</span></code> defaults to a value of 1 millimeter per second. In
selecting a value for <code class="docutils literal"><span class="pre">v_stiction</span></code>, you must ask yourself the
question, “When two objects are ostensibly in stiction, how much slip
am I willing to allow?” There are two opposing design issues in
picking a value for vₛ. On the one hand, small values of vₛ make the
problem numerically stiff during stiction, potentially increasing the
integration cost. On the other hand, it should be picked to be
appropriate for the scale of the problem. For example, a car
simulation could allow a “large” value for vₛ of 1 cm/s (1×10⁻² m/s),
but reasonable stiction for grasping a 10 cm box might require
limiting residual slip to 1×10⁻³ m/s or less. Ultimately, picking the
largest viable value will allow your simulation to run faster and more
robustly. Note that <code class="docutils literal"><span class="pre">v_stiction</span></code> is the slip velocity that we’d have
when we are at edge of the friction cone. For cases when the friction
force is well within the friction cone the slip velocity will always
be smaller than this value. See also stribeck_approximation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">v_stiction</span></code> is non-positive.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetActuationInArray">
<code class="descname">SetActuationInArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[object[m, 1]], u: numpy.ndarray[object[m, 1], flags.writeable]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetActuationInArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the actuation values <code class="docutils literal"><span class="pre">u_instance</span></code> for all actuators in
<code class="docutils literal"><span class="pre">model_instance</span></code>, this method sets the actuation vector u for the
entire model to which this actuator belongs to. This method throws an
exception if the size of <code class="docutils literal"><span class="pre">u_instance</span></code> is not equal to the number of
degrees of freedom of all of the actuated joints in
<code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">u_instance</span></code>:</dt>
<dd>Actuation values for the actuators. It must be of size equal to
the number of degrees of freedom of all of the actuated joints in
<code class="docutils literal"><span class="pre">model_instance</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">u</span></code>:</dt>
<dd>The vector containing the actuation values for the entire model.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetDefaultFreeBodyPose">
<code class="descname">SetDefaultFreeBodyPose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd], X_WB: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetDefaultFreeBodyPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default pose of <code class="docutils literal"><span class="pre">body</span></code>. If <code class="docutils literal"><span class="pre">body.is_floating()</span></code> is true,
this will affect subsequent calls to SetDefaultState(); otherwise,
this value is effectively ignored.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">body</span></code>:</dt>
<dd>Body whose default pose will be set.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_WB</span></code>:</dt>
<dd>Default pose of the body.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetDefaultState">
<code class="descname">SetDefaultState</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], state: pydrake.systems.framework.State_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetDefaultState" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">state</span></code> according to defaults set by the user for joints (e.g.
RevoluteJoint::set_default_angle()) and free bodies
(SetDefaultFreeBodyPose()). If the user does not specify defaults, the
state corresponds to zero generalized positions and velocities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize. See Finalize().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetFreeBodyPose">
<code class="descname">SetFreeBodyPose</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetFreeBodyPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetFreeBodyPose(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd], X_WB: pydrake.math.RigidTransform_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Sets <code class="docutils literal"><span class="pre">context</span></code> to store the pose <code class="docutils literal"><span class="pre">X_WB</span></code> of a given <code class="docutils literal"><span class="pre">body</span></code> B in
the world frame W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general setting the pose and/or velocity of a body in the model
would involve a complex inverse kinematics problem. This method
allows us to simplify this process when we know the body is free
in space.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">body</span></code> is not a free body in the model.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetFreeBodyPose(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd], X_WB: pydrake.common.eigen_geometry.Isometry3_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetFreeBodySpatialVelocity">
<code class="descname">SetFreeBodySpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], body: pydrake.multibody.tree.Body_[AutoDiffXd], V_WB: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetFreeBodySpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">context</span></code> to store the spatial velocity <code class="docutils literal"><span class="pre">V_WB</span></code> of a given
<code class="docutils literal"><span class="pre">body</span></code> B in the world frame W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general setting the pose and/or velocity of a body in the model
would involve a complex inverse kinematics problem. This method
allows us to simplify this process when we know the body is free
in space.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">body</span></code> is not a free body in the model.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetPositions">
<code class="descname">SetPositions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetPositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], q: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized positions from the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">q</span></code> is not equal to <code class="docutils literal"><span class="pre">num_positions()</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized positions from the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">q</span></code> is not equal to <code class="docutils literal"><span class="pre">num_positions()</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetPositionsAndVelocities">
<code class="descname">SetPositionsAndVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetPositionsAndVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], q_v: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized positions and velocities from the given vector
[q; v].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">q_v</span></code> is not equal to <a href="#id53"><span class="problematic" id="id54">``</span></a>num_positions() +</li>
<li>num_velocities()``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Sets generalized positions and velocities from the given vector [q; v]
for the specified model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, if the model</li>
<li>instance index is invalid, or if the length of <code class="docutils literal"><span class="pre">q_v</span></code> is not</li>
<li>equal to <a href="#id55"><span class="problematic" id="id56">``</span></a>num_positions(model_instance) +</li>
<li>num_velocities(model_instance)``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetPositionsInArray">
<code class="descname">SetPositionsInArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[object[m, 1]], q: numpy.ndarray[object[m, 1], flags.writeable]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetPositionsInArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the vector of generalized positions for <code class="docutils literal"><span class="pre">model_instance</span></code> in
<code class="docutils literal"><span class="pre">q</span></code> using <code class="docutils literal"><span class="pre">q_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions() or <code class="docutils literal"><span class="pre">q_instance</span></code> is not of size
<code class="docutils literal"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetVelocities">
<code class="descname">SetVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], v: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized velocities from the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">v</span></code> is not equal to <code class="docutils literal"><span class="pre">num_velocities()</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Sets the generalized velocities for a particular model instance from
the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, if the model</li>
<li>instance index is invalid, or if the length of <code class="docutils literal"><span class="pre">v_instance</span></code> is</li>
<li>not equal to <code class="docutils literal"><span class="pre">num_velocities(model_instance)</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetVelocitiesInArray">
<code class="descname">SetVelocitiesInArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[object[m, 1]], v: numpy.ndarray[object[m, 1], flags.writeable]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].SetVelocitiesInArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the vector of generalized velocities for <code class="docutils literal"><span class="pre">model_instance</span></code> in
<code class="docutils literal"><span class="pre">v</span></code> using <code class="docutils literal"><span class="pre">v_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal"><span class="pre">v</span></code> is not of size
MultibodyPlant::num_velocities() or <code class="docutils literal"><span class="pre">v_instance</span></code> is not of size
<code class="docutils literal"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].time_step">
<code class="descname">time_step</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>The time step (or period) used to model <code class="docutils literal"><span class="pre">this</span></code> plant as a discrete
system with periodic updates. Returns 0 (zero) if the plant is modeled
as a continuous system. This property of the plant is specified at
construction and therefore this query can be performed either pre- or
post-finalize, see Finalize().</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MultibodyPlant::MultibodyPlant(double)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].WeldFrames">
<code class="descname">WeldFrames</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].WeldFrames" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>WeldFrames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], A: pydrake.multibody.tree.Frame_[AutoDiffXd], B: pydrake.multibody.tree.Frame_[AutoDiffXd], X_AB: pydrake.math.RigidTransform_[float] = &lt;pydrake.math.RigidTransform_[float] object at 0x7f53d5ef8470&gt;) -&gt; pydrake.multibody.tree.WeldJoint_[AutoDiffXd]</li>
</ol>
<p>Welds frames A and B with relative pose <code class="docutils literal"><span class="pre">X_AB</span></code>. That is, the pose of
frame B in frame A is fixed, with value <code class="docutils literal"><span class="pre">X_AB</span></code>. The call to this
method creates and adds a new WeldJoint to the model. The new
WeldJoint is named as: A.name() + “_welds_to_” + B.name().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to the WeldJoint welding frames A and B.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>WeldFrames(self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], A: pydrake.multibody.tree.Frame_[AutoDiffXd], B: pydrake.multibody.tree.Frame_[AutoDiffXd], X_AB: pydrake.common.eigen_geometry.Isometry3_[float]) -&gt; pydrake.multibody.tree.WeldJoint_[AutoDiffXd]</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].world_body">
<code class="descname">world_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RigidBody_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].world_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the <em>world</em> body.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].world_frame">
<code class="descname">world_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyFrame_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd].world_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the <em>world</em> frame.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">MultibodyPlant_[Expression]</code><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_[Expression]" title="pydrake.systems.framework.LeafSystem_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></a></p>
<p>MultibodyPlant is a Drake system framework representation (see
systems::System) for the model of a physical system consisting of a
collection of interconnected bodies. See multibody for an overview of
concepts/notation.</p>
<p>&lt;table align=center cellpadding=0 cellspacing=0&gt;&lt;tr align=center&gt;&lt;td
style=”vertical-align:middle”&gt;&lt;table cellspacing=0
cellpadding=0&gt;&lt;tr&gt;&lt;td align=right style=”padding:5px 0px 5px
0px”&gt;applied_generalized_force&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=right
style=”padding:5px 0px 5px
0px”&gt;applied_spatial_force&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=right
style=”padding:5px 0px 5px 0px”&gt;&lt;em
style=”color:gray”&gt;model_instance_name[i]&lt;/em&gt;_actuation&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=right style=”padding:5px 0px 5px 0px”&gt;&lt;span
style=”color:green”&gt;geometry_query&lt;/span&gt;&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;td
align=center
style=”border:solid;padding-left:20px;padding-right:20px;vertical-align:middle”
bgcolor=#F0F0F0&gt;MultibodyPlant&lt;/td&gt;&lt;td
style=”vertical-align:middle”&gt;&lt;table cellspacing=0
cellpadding=0&gt;&lt;tr&gt;&lt;td align=left style=”padding:5px 0px 5px
0px”&gt;&amp;rarr; continuous_state&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left
style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; body_poses&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr;
body_spatial_velocities&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left style=”padding:5px
0px 5px 0px”&gt;&amp;rarr; body_spatial_accelerations&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr;
generalized_acceleration&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left
style=”padding:5px 0px 5px 0px”&gt;&amp;rarr;
reaction_forces&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left style=”padding:5px 0px 5px
0px”&gt;&amp;rarr; contact_results&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left
style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;em
style=”color:gray”&gt;model_instance_name[i]&lt;/em&gt;_continuous_state&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;em
style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt;_generalized_acceleration&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;em
style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt;_generalized_contact_forces&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;span
style=”color:green”&gt;geometry_pose&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</p>
<p>The ports whose names begin with &lt;em style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt; represent groups of ports, one for each of
the model_instances “model instances”, with i ∈ {0, …, N-1} for the
N model instances. If a model instance does not contain any data of
the indicated type the port will still be present but its value will
be a zero-length vector. (Model instances <code class="docutils literal"><span class="pre">world_model_instance()</span></code>
and <code class="docutils literal"><span class="pre">default_model_instance()</span></code> always exist.)</p>
<p>The ports shown in &lt;span style=”color:green”&gt; green&lt;/span&gt; are for
communication with Drake’s geometry::SceneGraph “SceneGraph” system
for dealing with geometry.</p>
<p>MultibodyPlant provides a user-facing API for:</p>
<ul class="simple">
<li>mbp_input_and_output_ports “Ports”: Access input and output ports. -</li>
</ul>
<p>mbp_construction “Construction”: Add bodies, joints, frames, force
elements, and actuators. - mbp_geometry “Geometry”: Register
geometries to a provided SceneGraph instance. - mbp_contact_modeling
“Contact modeling”: Select and parameterize contact models. -
mbp_state_accessors_and_mutators “State access and modification”:
Obtain and manipulate position and velocity state variables. -
mbp_working_with_free_bodies “Free bodies”: Work conveniently with
free (floating) bodies. - mbp_kinematic_and_dynamic_computations
“Kinematics and dynamics”: Perform systems::Context
“Context”-dependent kinematic and dynamic queries. -
mbp_system_matrix_computations “System matrices”: Explicitly form
matrices that appear in the equations of motion. - mbp_introspection
“Introspection”: Perform introspection to find out what’s in the
MultibodyPlant.</p>
<p><a href="#id57"><span class="problematic" id="id58">**</span></a>** Model Instances</p>
<p>A MultiBodyPlant may contain multiple model instances. Each model
instance corresponds to a set of bodies and their connections
(joints). Model instances provide methods to get or set the state of
the set of bodies (e.g., through GetPositionsAndVelocities() and
SetPositionsAndVelocities()), connecting controllers (through
get_state_output_port() and get_actuation_input_port()), and
organizing duplicate models (read through a parser). In fact, many
MultibodyPlant methods are overloaded to allow operating on the entire
plant or just the subset corresponding to the model instance; for
example, one GetPositions() method obtains the generalized positions
for the entire plant while another GetPositions() method obtains the
generalized positions for model instance.</p>
<p>Model instances are frequently defined through SDF files (using the
<code class="docutils literal"><span class="pre">model</span></code> tag) and are automatically created when SDF files are parsed
(by Parser). There are two special multibody::ModelInstanceIndex
values. The world body is always multibody::ModelInstanceIndex 0.
multibody::ModelInstanceIndex 1 is reserved for all elements with no
explicit model instance and is generally only relevant for elements
created programmatically (and only when a model instance is not
explicitly specified). Note that Parser creates model instances
(resulting in a multibody::ModelInstanceIndex ≥ 2) as needed.</p>
<p>See num_model_instances(), num_positions(), num_velocities(),
num_actuated_dofs(), AddModelInstance() GetPositionsAndVelocities(),
GetPositions(), GetVelocities(), SetPositionsAndVelocities(),
SetPositions(), SetVelocities(), GetPositionsFromArray(),
GetVelocitiesFromArray(), SetPositionsInArray(),
SetVelocitiesInArray(), SetActuationInArray(),
HasModelInstanceNamed(), GetModelInstanceName(),
get_state_output_port(), get_actuation_input_port().</p>
<p><a href="#id59"><span class="problematic" id="id60">**</span></a>** System dynamics</p>
<p>The state of a multibody system <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">[q;</span> <span class="pre">v]</span></code> is given by its
generalized positions vector q, of size <code class="docutils literal"><span class="pre">nq</span></code> (see num_positions()),
and by its generalized velocities vector v, of size <code class="docutils literal"><span class="pre">nv</span></code> (see
num_velocities()). As a Drake systems::System “System”, MultibodyPlant
implements the governing equations for a multibody dynamical system in
the form <code class="docutils literal"><span class="pre">ẋ</span> <span class="pre">=</span> <span class="pre">f(t,</span> <span class="pre">x,</span> <span class="pre">u)</span></code> with t being time and u the actuation
forces. The governing equations for the dynamics of a multibody system
modeled with MultibodyPlant are [Featherstone 2008, Jain 2010]:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">q̇</span> <span class="o">=</span> <span class="n">N</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span>
   <span class="p">(</span><span class="mi">1</span><span class="p">)</span>    <span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v̇</span> <span class="o">+</span> <span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="n">v</span> <span class="o">=</span> <span class="n">τ</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">M(q)</span></code> is the mass matrix of the multibody system, <code class="docutils literal"><span class="pre">C(q,</span>
<span class="pre">v)v</span></code> contains Coriolis, centripetal, and gyroscopic terms and
<code class="docutils literal"><span class="pre">N(q)</span></code> is the kinematic coupling matrix describing the relationship
between q̇ (the time derivatives of the generalized positions) and the
generalized velocities v, [Seth 2010]. <code class="docutils literal"><span class="pre">N(q)</span></code> is an <code class="docutils literal"><span class="pre">nq</span> <span class="pre">x</span> <span class="pre">nv</span></code>
matrix. The vector <code class="docutils literal"><span class="pre">τ</span> <span class="pre">∈</span> <span class="pre">ℝⁿᵛ</span></code> on the right hand side of Eq. (1) is
the system’s generalized forces. These incorporate gravity, springs,
externally applied body forces, constraint forces, and contact forces.</p>
<p><a href="#id61"><span class="problematic" id="id62">**</span></a>** Loading models from SDF files</p>
<p>Drake has the capability to load multibody models from SDF and URDF
files. Consider the example below which loads an acrobot model:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">acrobot</span><span class="p">;</span>
   <span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">scene_graph</span><span class="p">;</span>
   <span class="n">Parser</span> <span class="n">parser</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acrobot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scene_graph</span><span class="p">);</span>
   <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">relative_name</span> <span class="o">=</span>
     <span class="s2">&quot;drake/multibody/benchmarks/acrobot/acrobot.sdf&quot;</span><span class="p">;</span>
   <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">full_name</span> <span class="o">=</span> <span class="n">FindResourceOrThrow</span><span class="p">(</span><span class="n">relative_name</span><span class="p">);</span>
   <span class="n">parser</span><span class="o">.</span><span class="n">AddModelFromFile</span><span class="p">(</span><span class="n">full_name</span><span class="p">);</span>
</pre></div>
</div>
<p>As in the example above, for models including visual geometry,
collision geometry or both, the user must specify a SceneGraph for
geometry handling. You can find a full example of the LQR controlled
acrobot in examples/multibody/acrobot/run_lqr.cc.</p>
<p>AddModelFromFile() can be invoked multiple times on the same plant in
order to load multiple model instances. Other methods are available on
Parser such as AddAllModelsFromFile() which allows creating model
instances per each <code class="docutils literal"><span class="pre">&lt;model&gt;</span></code> tag found in the file. Please refer to
each of these methods’ documentation for further details.</p>
<p><a href="#id63"><span class="problematic" id="id64">**</span></a>** Working with SceneGraph</p>
<p>** Adding a MultibodyPlant connected to a SceneGraph to your Diagram</p>
<p>Probably the simplest way to add and wire up a MultibodyPlant with a
SceneGraph in your Diagram is using AddMultibodyPlantSceneGraph().</p>
<p>Recommended usages:</p>
<p>Assign to a MultibodyPlant reference (ignoring the SceneGraph):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">plant</span> <span class="o">=</span>
       <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">/*</span> <span class="n">time_step</span> <span class="o">*/</span><span class="p">);</span>
   <span class="n">plant</span><span class="o">.</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>This flavor is the simplest, when the SceneGraph is not explicitly
needed. (It can always be retrieved later via
GetSubsystemByName(“scene_graph”).)</p>
<p>Assign to auto, and use the named public fields:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">items</span> <span class="o">=</span> <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">/*</span> <span class="n">time_step</span> <span class="o">*/</span><span class="p">);</span>
   <span class="n">items</span><span class="o">.</span><span class="n">plant</span><span class="o">.</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
   <span class="n">items</span><span class="o">.</span><span class="n">scene_graph</span><span class="o">.</span><span class="n">DoBar</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>or taking advantage of C++17’s structured binding</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="p">[</span><span class="n">plant</span><span class="p">,</span> <span class="n">scene_graph</span><span class="p">]</span> <span class="o">=</span> <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
   <span class="o">...</span>
   <span class="n">plant</span><span class="o">.</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
   <span class="n">scene_graph</span><span class="o">.</span><span class="n">DoBar</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>This is the easiest way to use both the plant and scene_graph.</p>
<p>Assign to already-declared pointer variables:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;*</span> <span class="n">plant</span><span class="p">{};</span>
   <span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;*</span> <span class="n">scene_graph</span><span class="p">{};</span>
   <span class="n">std</span><span class="p">::</span><span class="n">tie</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span> <span class="n">scene_graph</span><span class="p">)</span> <span class="o">=</span>
       <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">/*</span> <span class="n">time_step</span> <span class="o">*/</span><span class="p">);</span>
   <span class="n">plant</span><span class="o">-&gt;</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
   <span class="n">scene_graph</span><span class="o">-&gt;</span><span class="n">DoBar</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>This flavor is most useful when the pointers are class member fields
(and so perhaps cannot be references).</p>
<p>** Registering geometry with a SceneGraph</p>
<p>MultibodyPlant users can register geometry with a SceneGraph for
essentially two purposes; a) visualization and, b) contact modeling.</p>
<p>Before any geometry registration takes place, a user <strong>must</strong> first
make a call to RegisterAsSourceForSceneGraph() in order to register
the MultibodyPlant as a client of a SceneGraph instance, point at
which the plant will have assigned a valid geometry::SourceId. At
Finalize(), MultibodyPlant will declare input/output ports as
appropriate to communicate with the SceneGraph instance on which
registrations took place. All geometry registration <strong>must</strong> be
performed pre-finalize.</p>
<p>Multibodyplant declares an input port for geometric queries, see
get_geometry_query_input_port(). If MultibodyPlant registers geometry
with a SceneGraph via calls to RegisterCollisionGeometry(), users may
use this port for geometric queries. Users must connect this input
port to the output port for geometric queries of the SceneGraph used
for registration, which can be obtained with
SceneGraph::get_query_output_port(). In summary, if MultibodyPlant
registers collision geometry, the setup process will include:</p>
<p>1. Call to RegisterAsSourceForSceneGraph(). 2. Calls to
RegisterCollisionGeometry(), as many as needed. 3. Call to Finalize(),
user is done specifying the model. 4. Connect
SceneGraph::get_query_output_port() to
get_geometry_query_input_port().</p>
<p>Refer to the documentation provided in each of the methods above for
further details.</p>
<p>** Accessing point contact parameters MultibodyPlant’s point contact
model looks for model parameters stored as
geometry::ProximityProperties by geometry::SceneGraph. These
properties can be obtained before or after context creation through
geometry::SceneGraphInspector APIs as outlined below. MultibodyPlant
expects the following properties for point contact modeling:</p>
<div class="line-block">
<div class="line">Group name | Property Name | Required | Property Type | Property</div>
</div>
<p>Description | | :——–: | :————–: | :——: |
:—————-: | :——————- | | material |
coulomb_friction | yes¹ | CoulombFriction&lt;T&gt; | Static and Dynamic
friction. | | material | point_contact_stiffness | no² | T | Penalty
method stiffness. | | material | hunt_crossley_dissipation | no² | T |
Penalty method dissipation. |</p>
<p>¹ Collision geometry is required to be registered with a
geometry::ProximityProperties object that contains the (“material”,
“coulomb_friction”) property. If the property is missing,
MultibodyPlant will throw an exeception.</p>
<p>² If the property is missing, MultibodyPlant will use a heuristic
value as the default. Refer to the section mbp_penalty_method “Penalty
method point contact” for further details.</p>
<p>Accessing and modifying contact properties requires interfacing with
geometry::SceneGraph’s model inspector. Interfacing with a model
inspector obtained from geometry::SceneGraph will provide the default
registered values for a given parameter. These are the values that
will initially appear in a systems::Context created by
CreateDefaultContext(). Subsequently, true system paramters can be
accessed and changed through a systems::Context once available. For
both of the above cases, proximity properties are accessed through
geometry::SceneGraphInspector APIs.</p>
<p>Before context creation an inspector can be retrieved directly from
SceneGraph as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">For</span> <span class="n">a</span> <span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">instance</span> <span class="n">called</span> <span class="n">scene_graph</span><span class="o">.</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">inspector</span> <span class="o">=</span>
<span class="n">scene_graph</span><span class="o">.</span><span class="n">model_inspector</span><span class="p">();</span>
</pre></div>
</div>
<p>After context creation, an inspector can be retrieved from the state
stored in the context by the plant’s geometry query input port:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">For</span> <span class="n">a</span> <span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">instance</span> <span class="n">called</span> <span class="n">mbp</span> <span class="ow">and</span> <span class="n">a</span>
<span class="o">//</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">called</span> <span class="n">context</span><span class="o">.</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">QueryObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">query_object</span> <span class="o">=</span>
<span class="n">mbp</span><span class="o">.</span><span class="n">get_geometry_query_input_port</span><span class="p">()</span>
<span class="o">.</span><span class="n">template</span> <span class="n">Eval</span><span class="o">&lt;</span><span class="n">geometry</span><span class="p">::</span><span class="n">QueryObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">inspector</span> <span class="o">=</span>
<span class="n">query_object</span><span class="o">.</span><span class="n">inspector</span><span class="p">();</span>
</pre></div>
</div>
<p>Once an inspector is available, proximity properties can be retrieved
as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">For</span> <span class="n">a</span> <span class="n">body</span> <span class="k">with</span> <span class="n">GeometryId</span> <span class="n">called</span> <span class="n">geometry_id</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">ProximityProperties</span><span class="o">*</span> <span class="n">props</span> <span class="o">=</span>
<span class="n">inspector</span><span class="o">.</span><span class="n">GetProximityProperties</span><span class="p">(</span><span class="n">geometry_id</span><span class="p">);</span>
<span class="n">const</span> <span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">geometry_friction</span> <span class="o">=</span>
<span class="n">props</span><span class="o">-&gt;</span><span class="n">GetProperty</span><span class="o">&lt;</span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s2">&quot;material&quot;</span><span class="p">,</span>
<span class="s2">&quot;coulomb_friction&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p><a href="#id65"><span class="problematic" id="id66">**</span></a>** Adding modeling elements</p>
<p>Add multibody elements to a MultibodyPlant with methods like:</p>
<ul class="simple">
<li>Bodies: AddRigidBody() - Joints: AddJoint() - see mbp_construction</li>
</ul>
<p>“Construction” for more.</p>
<p>All modeling elements <strong>must</strong> be added before Finalize() is called.
See mbp_finalize_stage “Finalize stage” for a discussion.</p>
<p><a href="#id67"><span class="problematic" id="id68">**</span></a>** Modeling contact</p>
<p>Please refer to drake_contacts “Contact Modeling in Drake” for details
on the available approximations, setup, and considerations for a
multibody simulation with frictional contact.</p>
<p><a href="#id69"><span class="problematic" id="id70">**</span></a>** Energy and Power</p>
<p>MultibodyPlant implements the System energy and power methods, with
some limitations. - Kinetic energy: fully implemented. - Potential
energy and conservative power: currently include only gravity and
contributions from ForceElement objects; potential energy from
compliant contact and joint limits are not included. - Nonconservative
power: currently includes only contributions from ForceElement
objects; actuation and input port forces, joint damping, and
dissipation from joint limits, friction, and contact dissipation are
not included.</p>
<p>See Drake issue #12942 for more discussion.</p>
<p><a href="#id71"><span class="problematic" id="id72">**</span></a>** Finalize() stage</p>
<p>Once the user is done adding modeling elements and registering
geometry, a call to Finalize() must be performed. This call will: -
Build the underlying MultibodyTree topology, see
MultibodyTree::Finalize() for details, - declare the plant’s state, -
declare the plant’s input and output ports, - declare input and output
ports for communication with a SceneGraph.</p>
<p><a href="#id73"><span class="problematic" id="id74">**</span></a>** References</p>
<ul class="simple">
<li>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics</li>
</ul>
<p>algorithms. Springer. - [Jain 2010] Jain, A., 2010. Robot and
multibody dynamics: analysis and algorithms. Springer Science &amp;
Business Media. - [Seth 2010] Seth, A., Sherman, M., Eastman, P. and
Delp, S., 2010. Minimal formulation of joint motion for biomechanisms.
Nonlinear dynamics, 62(1), pp.291-303.</p>
<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], time_step: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>This constructor creates a plant with a single “world” body.
Therefore, right after creation, num_bodies() returns one.</p>
<p>MultibodyPlant offers two different modalities to model mechanical
systems in time. These are: 1. As a discrete system with periodic
updates, <code class="docutils literal"><span class="pre">time_step</span></code> is strictly greater than zero. 2. As a
continuous system, <code class="docutils literal"><span class="pre">time_step</span></code> equals exactly zero.</p>
<p>Currently the discrete model is preferred for simulation given its
robustness and speed in problems with frictional contact. However this
might change as we work towards developing better strategies to model
contact. See time_advancement_strategy “Choice of Time Advancement
Strategy” for further details.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Users should be aware of current limitations in either modeling
modality. While the discrete model is often the preferred option
for problems with frictional contact given its robustness and
speed, it might become unstable when using large feedback gains,
high damping or large external forcing. MultibodyPlant will throw
an exception whenever the discrete solver is detected to fail.
Conversely, the continuous modality has the potential to leverage
the robustness and accuracy control provide by Drake’s
integrators. However thus far this has proved difficult in
practice and especially due to poor performance.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">time_step</span></code>:</dt>
<dd>Indicates whether <code class="docutils literal"><span class="pre">this</span></code> plant is modeled as a continuous system
(<code class="docutils literal"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code>) or as a discrete system with periodic updates
of period <code class="docutils literal"><span class="pre">time_step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. See time_advancement_strategy “Choice
of Time Advancement Strategy” for further details.</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Currently the continuous modality with <code class="docutils literal"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code> does not
support joint limits for simulation, these are ignored.
MultibodyPlant prints a warning to console if joint limits are
provided. If your simulation requires joint limits currently you
must use a discrete MultibodyPlant model.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">time_step</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddForceElement">
<code class="descname">AddForceElement</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], force_element: pydrake.multibody.tree.ForceElement_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ForceElement_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].AddForceElement" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a new force element model of type <code class="docutils literal"><span class="pre">ForceElementType</span></code> to
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. The arguments to this method <code class="docutils literal"><span class="pre">args</span></code> are
forwarded to <a href="#id75"><span class="problematic" id="id76">``</span></a>ForceElementType`’s constructor.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">args</span></code>:</dt>
<dd>Zero or more parameters provided to the constructor of the new
force element. It must be the case that
<cite>ForceElementType&lt;T&gt;(args)`</cite> is a valid constructor.</dd>
<dt>Template parameter <code class="docutils literal"><span class="pre">ForceElementType</span></code>:</dt>
<dd>The type of the ForceElement to add. As there is always a
UniformGravityFieldElement present (accessible through
gravity_field()), an exception will be thrown if this function is
called to add another UniformGravityFieldElement.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A constant reference to the new ForceElement just added, of type
<code class="docutils literal"><span class="pre">ForceElementType&lt;T&gt;</span></code> specialized on the scalar type T of
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. It will remain valid for the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The ForceElement class’s documentation for further details on how
a force element is defined.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddFrame">
<code class="descname">AddFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], frame: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].AddFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>This method adds a Frame of type <code class="docutils literal"><span class="pre">FrameType&lt;T&gt;</span></code>. For more
information, please see the corresponding constructor of
<code class="docutils literal"><span class="pre">FrameType</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">FrameType</span></code>:</dt>
<dd>Template which will be instantiated on <code class="docutils literal"><span class="pre">T</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame</span></code>:</dt>
<dd>Unique pointer frame instance.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A constant reference to the new Frame just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddJoint">
<code class="descname">AddJoint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], joint: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].AddJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>This method adds a Joint of type <code class="docutils literal"><span class="pre">JointType</span></code> between two bodies. For
more information, see the below overload of <code class="docutils literal"><span class="pre">AddJoint&lt;&gt;</span></code>, and the
related <code class="docutils literal"><span class="pre">MultibodyTree::AddJoint&lt;&gt;</span></code> method.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddJointActuator">
<code class="descname">AddJointActuator</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, joint: pydrake.multibody.tree.Joint_[Expression], effort_limit: float = inf</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuator_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].AddJointActuator" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and adds a JointActuator model for an actuator acting on a
given <code class="docutils literal"><span class="pre">joint</span></code>. This method returns a constant reference to the
actuator just added, which will remain valid for the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> plant.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that uniquely identifies the new actuator to be added to
<code class="docutils literal"><span class="pre">this</span></code> model. A RuntimeError is thrown if an actuator with the
same name already exists in the model. See
HasJointActuatorNamed().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">joint</span></code>:</dt>
<dd>The Joint to be actuated by the new JointActuator.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">effort_limit</span></code>:</dt>
<dd>The maximum effort for the actuator. It must be strictly positive,
otherwise an RuntimeError is thrown. If +∞, the actuator has no
limit, which is the default. The effort limit has physical units
in accordance to the joint type it actuates. For instance, it will
have units of N⋅m (torque) for revolute joints while it will have
units of N (force) for prismatic joints.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A constant reference to the new JointActuator just added, which
will remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> plant.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">joint.num_velocities()</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> since for now we</li>
<li>only support actuators for single dof joints.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddModelInstance">
<code class="descname">AddModelInstance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].AddModelInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new model instance. Returns the index for the model
instance.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that uniquely identifies the new instance to be added to
<code class="docutils literal"><span class="pre">this</span></code> model. An exception is thrown if an instance with the
same name already exists in the model. See
HasModelInstanceNamed().</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].AddRigidBody">
<code class="descname">AddRigidBody</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].AddRigidBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; pydrake.multibody.tree.RigidBody_[Expression]</li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. The body
will use the default model instance (model_instance “more on model
instances”).</p>
<p>Example of usage:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">;</span>
  <span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">to</span> <span class="n">define</span> <span class="n">spatial_inertia</span><span class="p">,</span> <span class="n">a</span> <span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">object</span> <span class="o">...</span>
  <span class="n">const</span> <span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">body</span> <span class="o">=</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s2">&quot;BodyName&quot;</span><span class="p">,</span> <span class="n">spatial_inertia</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that identifies the new body to be added to <code class="docutils literal"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal"><span class="pre">name</span></code> already
is part of the model in the default model instance. See
HasBodyNamed(), Body::name().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>The SpatialInertia of the new rigid body to be added to <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal"><span class="pre">Bo</span></code> and
expressed in the body frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if additional model instances have been created</li>
<li>beyond the world and default instances.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; pydrake.multibody.tree.RigidBody_[Expression]</li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<p>Example of usage:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">;</span>
  <span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">to</span> <span class="n">define</span> <span class="n">spatial_inertia</span><span class="p">,</span> <span class="n">a</span> <span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">object</span> <span class="o">...</span>
  <span class="n">ModelInstanceIndex</span> <span class="n">model_instance</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">AddModelInstance</span><span class="p">(</span><span class="s2">&quot;instance&quot;</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">body</span> <span class="o">=</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s2">&quot;BodyName&quot;</span><span class="p">,</span> <span class="n">model_instance</span><span class="p">,</span> <span class="n">spatial_inertia</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that identifies the new body to be added to <code class="docutils literal"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal"><span class="pre">name</span></code> already
is part of <code class="docutils literal"><span class="pre">model_instance</span></code>. See HasBodyNamed(), Body::name().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">model_instance</span></code>:</dt>
<dd>A model instance index which this body is part of.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>The SpatialInertia of the new rigid body to be added to <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal"><span class="pre">Bo</span></code> and
expressed in the body frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcBiasSpatialAcceleration">
<code class="descname">CalcBiasSpatialAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[Expression], p_BoBp_B: numpy.ndarray[object[3, 1]], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].CalcBiasSpatialAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>For one point Bp affixed/welded to a frame B, calculates A𝑠Bias_ABp,
Bp’s spatial acceleration bias in frame A with respect to “speeds” 𝑠,
where 𝑠 is either q̇ (time-derivatives of generalized positions) or v
(generalized velocities). A𝑠Bias_ABp is the term in A_ABp (Bp’s
spatial acceleration in A) that does not include 𝑠̇, i.e., A𝑠Bias_ABp
is Bi’s translational acceleration in A when 𝑠̇ = 0.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   (𝑠 = q̇ or 𝑠 = v), hence
  A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠
</pre></div>
</div>
<p>where J𝑠_V_ABp is Bp’s spatial velocity Jacobian in frame A for speeds
s (see CalcJacobianSpatialVelocity() for details on J𝑠_V_ABp).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the spatial
accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which point Bp is affixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBp_B</span></code>:</dt>
<dd>Position vector from Bo (frame_B’s origin) to point Bp (regarded
as affixed/welded to B), expressed in frame_B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures A𝑠Bias_ABp. Currently, an exception is
thrown if frame_A is not the World frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which A𝑠Bias_ABp is expressed on output.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A𝑠Bias_ABp_E Point Bp’s spatial acceleration bias in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shown below, A𝑠Bias_ABp_E = J̇𝑠_V_ABp ⋅ 𝑠 is quadratic in 𝑠.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>V_ABp =  J𝑠_V_ABp ⋅ 𝑠        which upon vector differentiation in A gives
 A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   Since J̇𝑠_V_ABp is linear in 𝑠,
 A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠                             is quadratic in 𝑠.
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcJacobianSpatialVelocity() to compute J𝑠_V_ABp, point Bp’s
translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if with_respect_to is not JacobianWrtVariable::kV</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if frame_A is not the world frame.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcBiasTerm">
<code class="descname">CalcBiasTerm</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].CalcBiasTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the bias term <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> containing Coriolis, centripetal,
and gyroscopic effects in the multibody equations of motion:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>M(q) v̇ + C(q, v) v = tau_app + ∑ (Jv_V_WBᵀ(q) ⋅ Fapp_Bo_W)
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">M(q)</span></code> is the multibody model’s mass matrix and <code class="docutils literal"><span class="pre">tau_app</span></code> is
a vector of generalized forces. The last term is a summation over all
bodies of the dot-product of <code class="docutils literal"><span class="pre">Fapp_Bo_W</span></code> (applied spatial force on
body B at Bo) with <code class="docutils literal"><span class="pre">Jv_V_WB(q)</span></code> (B’s spatial Jacobian in world W
with respect to generalized velocities v). Note: B’s spatial velocity
in W can be written <code class="docutils literal"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model. It stores the
generalized positions q and the generalized velocities v.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">Cv</span></code>:</dt>
<dd>On output, <code class="docutils literal"><span class="pre">Cv</span></code> will contain the product <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>. It must
be a valid (non-null) pointer to a column vector in <code class="docutils literal"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities (num_velocities()) of the
model. This method aborts if Cv is nullptr or if it does not have
the proper size.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcBiasTranslationalAcceleration">
<code class="descname">CalcBiasTranslationalAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[Expression], p_BoBi_B: numpy.ndarray[object[3, n], flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].CalcBiasTranslationalAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi,
Bi’s translational acceleration bias in frame A with respect to
“speeds” 𝑠, where 𝑠 is either q̇ (time-derivatives of generalized
positions) or v (generalized velocities). a𝑠Bias_ABi is the term in
a_ABi (Bi’s translational acceleration in A) that does not include 𝑠̇,
i.e., a𝑠Bias_ABi is Bi’s translational acceleration in A when 𝑠̇ = 0.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇  +  J̇𝑠_v_ABi ⋅ 𝑠  (𝑠 = q̇ or 𝑠 = v), hence
  a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠
</pre></div>
</div>
<p>where J𝑠_v_ABi is Bi’s translational velocity Jacobian in frame A for
s (see CalcJacobianTranslationalVelocity() for details on J𝑠_v_ABi).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the translational
accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which points Bi are affixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBi_B</span></code>:</dt>
<dd>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B. Each column in the <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span>
<span class="pre">p</span></code> matrix p_BoBi_B corresponds to a position vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures a𝑠Bias_ABi. Currently, an exception is
thrown if frame_A is not the World frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which a𝑠Bias_ABi is expressed on output.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a𝑠Bias_ABi_E Point Bi’s translational acceleration bias in frame A
with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
a𝑠Bias_ABi_E is a <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">p</span></code> matrix, where p is the number of
points Bi.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shown below, a𝑠Bias_ABi_E = J̇𝑠_v_ABp ⋅ 𝑠 is quadratic in 𝑠.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>v_ABi =  J𝑠_v_ABi ⋅ 𝑠        which upon vector differentiation in A gives
 a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇ + J̇𝑠_v_ABi ⋅ 𝑠     Since J̇𝑠_v_ABi is linear in 𝑠,
 a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠                             is quadratic in 𝑠.
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcJacobianTranslationalVelocity() to compute J𝑠_v_ABi, point
Bi’s translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>p_BoBi_B must have 3 rows.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if with_respect_to is not JacobianWrtVariable::kV</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if frame_A is not the world frame.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcCenterOfMassPosition">
<code class="descname">CalcCenterOfMassPosition</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].CalcCenterOfMassPosition" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the center of mass position p_WCcm of all bodies
in <code class="docutils literal"><span class="pre">MultibodyPlant</span></code> measured and expressed in world frame W. The
bodies are considered as a single composite body C, whose center of
mass <code class="docutils literal"><span class="pre">composite_mass</span></code> is located at Ccm. The world_body() is
ignored.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model. It stores the
generalized positions q of the model.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">p_WCcm</span></code>:</dt>
<dd>The output position of center of mass in the world frame W.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">MultibodyPlant</span></code> has no body except</li>
<li><code class="docutils literal"><span class="pre">world_body()</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError unless <code class="docutils literal"><span class="pre">composite_mass</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcForceElementsContribution">
<code class="descname">CalcForceElementsContribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], forces: pydrake.multibody.tree.MultibodyForces_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].CalcForceElementsContribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the combined force contribution of ForceElement objects in
the model. A ForceElement can apply forces as a spatial force per body
or as generalized forces, depending on the ForceElement model.
ForceElement contributions are a function of the state and time only.
The output from this method can immediately be used as input to
CalcInverseDynamics() to include the effect of applied forces by force
elements.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of this model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">forces</span></code>:</dt>
<dd>A pointer to a valid, non nullptr, multibody forces object. On
output <code class="docutils literal"><span class="pre">forces</span></code> will store the forces exerted by all the
ForceElement objects in the model.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">forces</span></code> is null or not compatible with this</li>
<li>model, per MultibodyForces::CheckInvariants().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcGravityGeneralizedForces">
<code class="descname">CalcGravityGeneralizedForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].CalcGravityGeneralizedForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the generalized forces <code class="docutils literal"><span class="pre">tau_g(q)</span></code> due to gravity as a
function of the generalized positions <code class="docutils literal"><span class="pre">q</span></code> stored in the input
<code class="docutils literal"><span class="pre">context</span></code>. The vector of generalized forces due to gravity
<code class="docutils literal"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the right hand side of
the equations of motion together with any other generalized forces,
like so:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Mv̇</span> <span class="o">+</span> <span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="n">v</span> <span class="o">=</span> <span class="n">tau_g</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau_app</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the model.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tau_g A vector containing the generalized forces due to gravity.
The generalized forces are consistent with the vector of
generalized velocities <code class="docutils literal"><span class="pre">v</span></code> for <code class="docutils literal"><span class="pre">this</span></code> so that the inner
product <code class="docutils literal"><span class="pre">v⋅tau_g</span></code> corresponds to the power applied by the
gravity forces on the mechanical system. That is, <code class="docutils literal"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>
corresponds to potential energy going into the system, as either
mechanical kinetic energy, some other potential energy, or heat,
and therefore to a decrease of the gravitational potential energy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcInverseDynamics">
<code class="descname">CalcInverseDynamics</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], known_vdot: numpy.ndarray[object[m, 1]], external_forces: pydrake.multibody.tree.MultibodyForces_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].CalcInverseDynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the state of this model in <code class="docutils literal"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal"><span class="pre">vdot</span></code>, this method computes the set of
generalized forces <code class="docutils literal"><span class="pre">tau</span></code> that would need to be applied in order to
attain the specified generalized accelerations. Mathematically, this
method computes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>tau = M(q)v̇ + C(q, v)v - tau_app - ∑ J_WBᵀ(q) Fapp_Bo_W
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">M(q)</span></code> is the model’s mass matrix, <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> is the bias
term containing Coriolis and gyroscopic effects and <code class="docutils literal"><span class="pre">tau_app</span></code>
consists of a vector applied generalized forces. The last term is a
summation over all bodies in the model where <code class="docutils literal"><span class="pre">Fapp_Bo_W</span></code> is an
applied spatial force on body B at <code class="docutils literal"><span class="pre">Bo</span></code> which gets projected into
the space of generalized forces with the transpose of <code class="docutils literal"><span class="pre">Jv_V_WB(q)</span></code>
(where <code class="docutils literal"><span class="pre">Jv_V_WB</span></code> is B’s spatial velocity Jacobian in W with respect
to generalized velocities v). Note: B’s spatial velocity in W can be
written as <code class="docutils literal"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>. This method does not compute
explicit expressions for the mass matrix nor for the bias term, which
would be of at least <code class="docutils literal"><span class="pre">O(n²)</span></code> complexity, but it implements an
<code class="docutils literal"><span class="pre">O(n)</span></code> Newton-Euler recursive algorithm, where n is the number of
bodies in the model. The explicit formation of the mass matrix
<code class="docutils literal"><span class="pre">M(q)</span></code> would require the calculation of <code class="docutils literal"><span class="pre">O(n²)</span></code> entries while
explicitly forming the product <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)</span> <span class="pre">*</span> <span class="pre">v</span></code> could require up to
<code class="docutils literal"><span class="pre">O(n³)</span></code> operations (see [Featherstone 1987, §4]), depending on the
implementation. The recursive Newton-Euler algorithm is the most
efficient currently known general method for solving inverse dynamics
[Featherstone 2008].</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">known_vdot</span></code>:</dt>
<dd>A vector with the known generalized accelerations <code class="docutils literal"><span class="pre">vdot</span></code> for the
full model. Use the provided Joint APIs in order to access entries
into this array.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">external_forces</span></code>:</dt>
<dd>A set of forces to be applied to the system either as body spatial
forces <code class="docutils literal"><span class="pre">Fapp_Bo_W</span></code> or generalized forces <code class="docutils literal"><span class="pre">tau_app</span></code>, see
MultibodyForces for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the vector of generalized forces that would need to be applied to
the mechanical system in order to achieve the desired acceleration
given by <code class="docutils literal"><span class="pre">known_vdot</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcJacobianAngularVelocity">
<code class="descname">CalcJacobianAngularVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[Expression], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].CalcJacobianAngularVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates J𝑠_w_AB, a frame B’s angular velocity Jacobian in a frame A
with respect to “speeds” 𝑠.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>J𝑠_w_AB ≜ [ ∂(w_AB)/∂𝑠₁,  ...  ∂(w_AB)/∂𝑠ₙ ]    (n is j or k)
     w_AB = J𝑠_w_AB ⋅ 𝑠          w_AB is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">w_AB</span></code> is B’s angular velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal"><span class="pre">J𝑠_w_AB</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame B in <code class="docutils literal"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame A in <code class="docutils literal"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which <code class="docutils literal"><span class="pre">w_AB</span></code> is expressed on input and the frame in
which the Jacobian <code class="docutils literal"><span class="pre">J𝑠_w_AB</span></code> is expressed on output.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">J𝑠_w_AB_E</span></code>:</dt>
<dd>Frame B’s angular velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E. The
Jacobian is a function of only generalized positions q (which are
pulled from the context). The previous definition shows
<code class="docutils literal"><span class="pre">J𝑠_w_AB_E</span></code> is a matrix of size <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code>, where n is the number
of elements in 𝑠.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">J𝑠_w_AB_E</span></code> is nullptr or not of size <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcJacobianSpatialVelocity">
<code class="descname">CalcJacobianSpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[Expression], p_BP: numpy.ndarray[object[3, 1]], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].CalcJacobianSpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp’s
spatial velocity Jacobian in frame A with respect to “speeds” 𝑠.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>J𝑠_V_ABp ≜ [ ∂(V_ABp)/∂𝑠₁,  ...  ∂(V_ABp)/∂𝑠ₙ ]    (n is j or k)
     V_ABp = J𝑠_V_ABp ⋅ 𝑠          V_ABp is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">V_ABp</span></code> is Bp’s spatial velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal"><span class="pre">J𝑠_V_ABp</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which point Bp is fixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBp_B</span></code>:</dt>
<dd>A position vector from Bo (frame_B’s origin) to point Bp (regarded
as fixed/welded to B), expressed in frame_B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures <code class="docutils literal"><span class="pre">v_ABp</span></code> (Bp’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAp_A (similar
to the parameter p_BoBp_B for frame_B). There is no need for
p_AoAp_A because Bp’s velocity in A is defined as the derivative
in frame A of Bp’s position vector from <em>any</em> point fixed to A.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which <code class="docutils literal"><span class="pre">v_ABp</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal"><span class="pre">J𝑠_V_ABp</span></code> is expressed on output.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">J𝑠_V_ABp_E</span></code>:</dt>
<dd>Point Bp’s spatial velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E.
<code class="docutils literal"><span class="pre">J𝑠_V_ABp_E</span></code> is a <code class="docutils literal"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where n is the number of
elements in 𝑠. The Jacobian is a function of only generalized
positions q (which are pulled from the context). Note: The
returned <code class="docutils literal"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix stores frame B’s angular velocity
Jacobian in A in rows 1-3 and stores point Bp’s translational
velocity Jacobian in A in rows 4-6, i.e.,</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">J𝑠_w_AB_E</span> <span class="o">=</span> <span class="n">J𝑠_V_ABp_E</span><span class="o">.</span><span class="n">topRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">J𝑠_v_ABp_E</span> <span class="o">=</span> <span class="n">J𝑠_V_ABp_E</span><span class="o">.</span><span class="n">bottomRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>Note: Consider CalcJacobianTranslationalVelocity() for multiple points
fixed to frame B and consider CalcJacobianAngularVelocity() to
calculate frame B’s angular velocity Jacobian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">J𝑠_V_ABp_E</span></code> is nullptr or not sized <code class="docutils literal"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcJacobianTranslationalVelocity">
<code class="descname">CalcJacobianTranslationalVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[Expression], p_BoBi_B: numpy.ndarray[object[3, n], flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].CalcJacobianTranslationalVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi,
Bi’s translational velocity Jacobian in frame A with respect to
“speeds” 𝑠.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>J𝑠_v_ABi ≜ [ ∂(v_ABi)/∂𝑠₁,  ...  ∂(v_ABi)/∂𝑠ₙ ]    (n is j or k)
     v_ABi = J𝑠_v_ABi ⋅ 𝑠          v_ABi is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">v_ABi</span></code> is Bi’s translational velocity in frame A and “speeds” 𝑠 is
either q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized
positions) or v ≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal"><span class="pre">J𝑠_v_ABi</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which point Bi is affixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBi_B</span></code>:</dt>
<dd>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures <code class="docutils literal"><span class="pre">v_ABi</span></code> (Bi’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAi_A (similar
to the parameter p_BoBi_B for frame_B). There is no need for
p_AoAi_A because Bi’s velocity in A is defined as the derivative
in frame A of Bi’s position vector from <em>any</em> point affixed to A.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which <code class="docutils literal"><span class="pre">v_ABi</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal"><span class="pre">J𝑠_v_ABi</span></code> is expressed on output.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">J𝑠_v_ABi_E</span></code>:</dt>
<dd>Point Bi’s velocity Jacobian in frame A with respect to speeds 𝑠
(which is either q̇ or v), expressed in frame E. <code class="docutils literal"><span class="pre">J𝑠_v_ABi_E</span></code> is
a <code class="docutils literal"><span class="pre">3*p</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where p is the number of points Bi and n is
the number of elements in 𝑠. The Jacobian is a function of only
generalized positions q (which are pulled from the context).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">J𝑠_v_ABi_E</span></code> is nullptr or not sized <a href="#id77"><span class="problematic" id="id78">``</span></a>3*p x</li>
<li>n``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When 𝑠 = q̇, <code class="docutils literal"><span class="pre">Jq̇_v_ABi</span> <span class="pre">=</span> <span class="pre">Jq_p_AoBi</span></code>. In other words, point Bi’s
velocity Jacobian in frame A with respect to q̇ is equal to point
Bi’s position Jacobian from Ao (A’s origin) in frame A with
respect to q.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>[∂(v_ABi)/∂q̇₁,  ...  ∂(v_ABi)/∂q̇ⱼ] = [∂(p_AoBi)/∂q₁,  ...  ∂(p_AoBi)/∂qⱼ]
</pre></div>
</div>
<p>Note: Each partial derivative of p_AoBi is taken in frame A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcMassMatrixViaInverseDynamics">
<code class="descname">CalcMassMatrixViaInverseDynamics</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].CalcMassMatrixViaInverseDynamics" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcPointsPositions">
<code class="descname">CalcPointsPositions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], frame_B: pydrake.multibody.tree.Frame_[Expression], p_BQi: numpy.ndarray[object[m, n], flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].CalcPointsPositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the positions <code class="docutils literal"><span class="pre">p_BQi</span></code> for a set of points <code class="docutils literal"><span class="pre">Qi</span></code> measured and
expressed in a frame B, this method computes the positions
<code class="docutils literal"><span class="pre">p_AQi(q)</span></code> of each point <code class="docutils literal"><span class="pre">Qi</span></code> in the set as measured and expressed
in another frame A, as a function of the generalized positions q of
the model.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model. It stores the
generalized positions q of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame B in which the positions <code class="docutils literal"><span class="pre">p_BQi</span></code> of a set of points
<code class="docutils literal"><span class="pre">Qi</span></code> are given.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BQi</span></code>:</dt>
<dd>The input positions of each point <code class="docutils literal"><span class="pre">Qi</span></code> in frame B. <code class="docutils literal"><span class="pre">p_BQi</span> <span class="pre">∈</span>
<span class="pre">ℝ³ˣⁿᵖ</span></code> with <code class="docutils literal"><span class="pre">np</span></code> the number of points in the set. Each column
of <code class="docutils literal"><span class="pre">p_BQi</span></code> corresponds to a vector in ℝ³ holding the position of
one of the points in the set as measured and expressed in frame B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame A in which it is desired to compute the positions
<code class="docutils literal"><span class="pre">p_AQi</span></code> of each point <code class="docutils literal"><span class="pre">Qi</span></code> in the set.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_AQi</span></code>:</dt>
<dd>The output positions of each point <code class="docutils literal"><span class="pre">Qi</span></code> now computed as measured
and expressed in frame A. The output <code class="docutils literal"><span class="pre">p_AQi</span></code> <strong>must</strong> have the
same size as the input <code class="docutils literal"><span class="pre">p_BQi</span></code> or otherwise this method aborts.
That is <code class="docutils literal"><span class="pre">p_AQi</span></code> <strong>must</strong> be in <code class="docutils literal"><span class="pre">ℝ³ˣⁿᵖ</span></code>.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Both <code class="docutils literal"><span class="pre">p_BQi</span></code> and <code class="docutils literal"><span class="pre">p_AQi</span></code> must have three rows. Otherwise this
method will throw a RuntimeError exception. This method also
throws a RuntimeError exception if <code class="docutils literal"><span class="pre">p_BQi</span></code> and <code class="docutils literal"><span class="pre">p_AQi</span></code> differ
in the number of columns.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcRelativeTransform">
<code class="descname">CalcRelativeTransform</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], frame_A: pydrake.multibody.tree.Frame_[Expression], frame_B: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].CalcRelativeTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rigid transform (pose) <code class="docutils literal"><span class="pre">X_FG</span></code> relating frame F and
frame G.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal"><span class="pre">X_FG</span></code> is a function of q.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_F</span></code>:</dt>
<dd>The frame F designated in the rigid transform <code class="docutils literal"><span class="pre">X_FG</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_G</span></code>:</dt>
<dd>The frame G designated in the rigid transform <code class="docutils literal"><span class="pre">X_FG</span></code>.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">X_FG</span></code>:</dt>
<dd>The RigidTransform relating frame F and frame G.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].CalcSpatialAccelerationsFromVdot">
<code class="descname">CalcSpatialAccelerationsFromVdot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], known_vdot: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.multibody.math.SpatialAcceleration_[Expression]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].CalcSpatialAccelerationsFromVdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the state of this model in <code class="docutils literal"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal"><span class="pre">known_vdot</span></code>, this method computes the
spatial acceleration <code class="docutils literal"><span class="pre">A_WB</span></code> for each body as measured and expressed
in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of this model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">known_vdot</span></code>:</dt>
<dd>A vector with the generalized accelerations for the full model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">A_WB_array</span></code>:</dt>
<dd>A pointer to a valid, non nullptr, vector of spatial accelerations
containing the spatial acceleration <code class="docutils literal"><span class="pre">A_WB</span></code> for each body. It
must be of size equal to the number of bodies in the model. On
output, entries will be ordered by BodyIndex.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if A_WB_array is not of size <code class="docutils literal"><span class="pre">num_bodies()</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].CollectRegisteredGeometries">
<code class="descname">CollectRegisteredGeometries</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], bodies: List[pydrake.multibody.tree.Body_[Expression]]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.GeometrySet<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].CollectRegisteredGeometries" title="Permalink to this definition">¶</a></dt>
<dd><p>For each of the provided <code class="docutils literal"><span class="pre">bodies</span></code>, collects up all geometries that
have been registered to that body. Intended to be used in conjunction
with SceneGraph::ExcludeCollisionsWithin() and
SceneGraph::ExcludeCollisionsBetween() to filter collisions between
the geometries registered to the bodies.</p>
<p>For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Don&#39;t report on collisions between geometries affixed to ``body1``,
// ``body2``, or ``body3``.
std::vector&lt;const RigidBody&lt;T&gt;*&gt; bodies{&amp;body1, &amp;body2, &amp;body3};
geometry::GeometrySet set = plant.CollectRegisteredGeometries(bodies);
scene_graph.ExcludeCollisionsWithin(set);
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is a <em>very</em> specific order of operations:</p>
</div>
<ol class="arabic simple">
<li>Bodies and geometries must be added to the MultibodyPlant.</li>
<li>The MultibodyPlant must be finalized (via Finalize()).</li>
<li>Create GeometrySet instances from bodies (via this method).</li>
<li>Invoke SceneGraph::ExcludeCollisions*() to filter collisions.</li>
<li>Allocate context.</li>
</ol>
<p>Changing the order will cause exceptions to be thrown.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].default_coulomb_friction">
<code class="descname">default_coulomb_friction</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.plant.CoulombFriction_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].default_coulomb_friction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the friction coefficients provided during geometry
registration for the given geometry <code class="docutils literal"><span class="pre">id</span></code>. We call these the
“default” coefficients but note that we mean user-supplied
per-geometry default, not something more global.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not correspond to a geometry in</li>
<li><code class="docutils literal"><span class="pre">this</span></code> model registered for contact modeling.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RegisterCollisionGeometry() for details on geometry registration.
(Deprecated.)</p>
</div>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>default_coulomb_friction() will be removed. Please use SceneGraph
which now stores friction properties in ProximityProperties. See
the section “Accessing point contact parameters” in the
documentation for MultibodyPlant. This will be removed from Drake
on or after 2020-09-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].EvalBodyPoseInWorld">
<code class="descname">EvalBodyPoseInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], body: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].EvalBodyPoseInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the pose <code class="docutils literal"><span class="pre">X_WB</span></code> of a body B in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">body_B</span></code>:</dt>
<dd>The body B for which the pose is requested.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">X_WB</span></code>:</dt>
<dd>The pose of body frame B in the world frame W.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if Finalize() was not called on <code class="docutils literal"><span class="pre">this</span></code> model or if</li>
<li><code class="docutils literal"><span class="pre">body_B</span></code> does not belong to this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].EvalBodySpatialVelocityInWorld">
<code class="descname">EvalBodySpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], body: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].EvalBodySpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the spatial velocity <code class="docutils literal"><span class="pre">V_WB</span></code> of a body B in the world frame
W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">body_B</span></code>:</dt>
<dd>The body B for which the spatial velocity is requested.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">V_WB The spatial velocity of body frame B in the world frame W.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if Finalize() was not called on <code class="docutils literal"><span class="pre">this</span></code> model or if</li>
<li><code class="docutils literal"><span class="pre">body_B</span></code> does not belong to this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].Finalize">
<code class="descname">Finalize</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].Finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>This method must be called after all elements in the model (joints,
bodies, force elements, constraints, etc.) are added and before any
computations are performed. It essentially compiles all the necessary
“topological information”, i.e. how bodies, joints and, any other
elements connect with each other, and performs all the required
pre-processing to enable computations at a later stage.</p>
<p>If the finalize stage is successful, the topology of this
MultibodyPlant is valid, meaning that the topology is up-to-date after
this call. No more multibody elements can be added after a call to
Finalize().</p>
<p>At Finalize(), state and input/output ports for <code class="docutils literal"><span class="pre">this</span></code> plant are
declared. If <code class="docutils literal"><span class="pre">this</span></code> plant registered geometry with a SceneGraph,
input and output ports to enable communication with that SceneGraph
are declared as well.</p>
<p>If geometry has been registered on a SceneGraph instance, that
instance must be provided to the Finalize() method so that any
geometric implications of the finalization process can be
appropriately handled.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">is_finalized().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the MultibodyPlant has already been finalized.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].geometry_source_is_registered">
<code class="descname">geometry_source_is_registered</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].geometry_source_is_registered" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant was registered with a
SceneGraph. This method can be called at any time during the lifetime
of <code class="docutils literal"><span class="pre">this</span></code> plant to query if <code class="docutils literal"><span class="pre">this</span></code> plant has been registered with
a SceneGraph, either pre- or post-finalize, see Finalize().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_actuation_input_port">
<code class="descname">get_actuation_input_port</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_actuation_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; pydrake.systems.framework.InputPort_[Expression]</li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for the case where only one model instance has actuated dofs. This
input port is a vector valued port, which can be set with
JointActuator::set_actuation_vector().</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called before Finalize(), if the model does not</li>
<li>contain any actuators, or if multiple model instances have</li>
<li>actuated dofs.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.InputPort_[Expression]</li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for a specific model instance. This input port is a vector valued
port, which can be set with JointActuator::set_actuation_vector().</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_applied_generalized_force_input_port">
<code class="descname">get_applied_generalized_force_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_applied_generalized_force_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the vector-valued input port for
applied generalized forces, and the vector will be added directly into
<code class="docutils literal"><span class="pre">tau</span></code> (see mbp_equations_of_motion “System dynamics”). This vector
is ordered using the same convention as the plant velocities: you can
set the generalized forces that will be applied to model instance i
using, e.g., <code class="docutils literal"><span class="pre">SetVelocitiesInArray(i,</span> <span class="pre">model_forces,</span> <span class="pre">&amp;force_array)</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_applied_spatial_force_input_port">
<code class="descname">get_applied_spatial_force_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_applied_spatial_force_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the input port for applying spatial
forces to bodies in the plant. The data type for the port is an
std::vector of ExternallyAppliedSpatialForce; any number of spatial
forces can be applied to any number of bodies in the plant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_body">
<code class="descname">get_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], body_index: pydrake.multibody.tree.BodyIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the body with unique index
<code class="docutils literal"><span class="pre">body_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">body_index</span></code> does not correspond to a body in</li>
<li>this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_body_poses_output_port">
<code class="descname">get_body_poses_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_body_poses_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of all body poses in the world frame. You can
obtain the pose <code class="docutils literal"><span class="pre">X_WB</span></code> of a body B in the world frame W with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">X_WB_all</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">get_body_poses_output_port</span><span class="p">()</span><span class="o">.</span>
      <span class="o">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">math</span><span class="p">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">BodyIndex</span> <span class="n">arm_body_index</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s2">&quot;arm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">math</span><span class="p">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">X_WArm</span> <span class="o">=</span> <span class="n">X_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
<p>As shown in the example above, the resulting <code class="docutils literal"><span class="pre">std::vector</span></code> of body
poses is indexed by BodyIndex, and it has size num_bodies(). BodyIndex
“zero” (0) always corresponds to the world body, with pose equal to
the identity at all times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_body_spatial_accelerations_output_port">
<code class="descname">get_body_spatial_accelerations_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_body_spatial_accelerations_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of all body spatial accelerations in the world
frame. You can obtain the spatial acceleration <code class="docutils literal"><span class="pre">A_WB</span></code> of a body B in
the world frame W with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">A_WB_all</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">get_body_spatial_accelerations_output_port</span><span class="p">()</span><span class="o">.</span>
      <span class="o">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialAcceleration</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">BodyIndex</span> <span class="n">arm_body_index</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s2">&quot;arm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">A_WArm</span> <span class="o">=</span> <span class="n">A_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
<p>As shown in the example above, the resulting <code class="docutils literal"><span class="pre">std::vector</span></code> of body
spatial accelerations is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial acceleration at all times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_body_spatial_velocities_output_port">
<code class="descname">get_body_spatial_velocities_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_body_spatial_velocities_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of all body spatial velocities in the world
frame. You can obtain the spatial velocity <code class="docutils literal"><span class="pre">V_WB</span></code> of a body B in the
world frame W with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">V_WB_all</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">get_body_spatial_velocities_output_port</span><span class="p">()</span><span class="o">.</span>
      <span class="o">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">BodyIndex</span> <span class="n">arm_body_index</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s2">&quot;arm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">V_WArm</span> <span class="o">=</span> <span class="n">V_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
<p>As shown in the example above, the resulting <code class="docutils literal"><span class="pre">std::vector</span></code> of body
spatial velocities is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial velocity at all times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_contact_penalty_method_time_scale">
<code class="descname">get_contact_penalty_method_time_scale</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_contact_penalty_method_time_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a time-scale estimate <code class="docutils literal"><span class="pre">tc</span></code> based on the requested
penetration allowance δ set with set_penetration_allowance(). For the
penalty method in use to enforce non-penetration, this time scale
relates to the time it takes the relative normal velocity between two
bodies to go to zero. This time scale <code class="docutils literal"><span class="pre">tc</span></code> is artificially
introduced by the penalty method and goes to zero in the limit to
ideal rigid contact. Since numerical integration methods for continuum
systems must be able to resolve a system’s dynamics, the time step
used by an integrator must in general be much smaller than the time
scale <code class="docutils literal"><span class="pre">tc</span></code>. How much smaller will depend on the details of the
problem and the convergence characteristics of the integrator and
should be tuned appropriately. Another factor to take into account for
setting up the simulation’s time step is the speed of the objects in
your simulation. If <code class="docutils literal"><span class="pre">vn</span></code> represents a reference velocity scale for
the normal relative velocity between bodies, the new time scale <code class="docutils literal"><span class="pre">tn</span> <span class="pre">=</span>
<span class="pre">δ</span> <span class="pre">/</span> <span class="pre">vn</span></code> represents the time it would take for the distance between
two bodies approaching with relative normal velocity <code class="docutils literal"><span class="pre">vn</span></code> to
decrease by the penetration_allowance δ. In this case a user should
choose a time step for simulation that can resolve the smallest of the
two time scales <code class="docutils literal"><span class="pre">tc</span></code> and <code class="docutils literal"><span class="pre">tn</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_contact_results_output_port">
<code class="descname">get_contact_results_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_contact_results_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the port that outputs ContactResults.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize, see Finalize().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_frame">
<code class="descname">get_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], frame_index: pydrake.multibody.tree.FrameIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the frame with unique index
<code class="docutils literal"><span class="pre">frame_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">frame_index</span></code> does not correspond to a frame in</li>
<li>this plant.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_generalized_acceleration_output_port">
<code class="descname">get_generalized_acceleration_output_port</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_generalized_acceleration_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; pydrake.systems.framework.OutputPort_[Expression]</li>
</ol>
<p>Returns a constant reference to the output port for generalized
accelerations v̇ of the model.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[Expression]</li>
</ol>
<p>Returns a constant reference to the output port for the generalized
accelerations v̇ᵢ ⊆ v̇ for model instance i.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_generalized_contact_forces_output_port">
<code class="descname">get_generalized_contact_forces_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_generalized_contact_forces_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the output port of generalized contact
forces for a specific model instance.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_geometry_poses_output_port">
<code class="descname">get_geometry_poses_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_geometry_poses_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of frames’ poses to communicate with a
SceneGraph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_geometry_query_input_port">
<code class="descname">get_geometry_query_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_geometry_query_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the input port used to perform
geometric queries on a SceneGraph. See
SceneGraph::get_query_output_port(). Refer to section mbp_geometry
“Geometry” of this class’s documentation for further details on
collision geometry registration and connection with a SceneGraph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_joint">
<code class="descname">get_joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], joint_index: pydrake.multibody.tree.JointIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the joint with unique index
<code class="docutils literal"><span class="pre">joint_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError when <code class="docutils literal"><span class="pre">joint_index</span></code> does not correspond to a joint</li>
<li>in this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_joint_actuator">
<code class="descname">get_joint_actuator</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], actuator_index: pydrake.multibody.tree.JointActuatorIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuator_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_joint_actuator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the joint actuator with unique index
<code class="docutils literal"><span class="pre">actuator_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">actuator_index</span></code> does not correspond to a joint</li>
<li>actuator in this tree.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_reaction_forces_output_port">
<code class="descname">get_reaction_forces_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_reaction_forces_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the port for joint reaction forces. A Joint models the
kinematical relationship which characterizes the possible relative
motion between two bodies. In Drake, a joint connects a frame <code class="docutils literal"><span class="pre">Jp</span></code>
on <em>parent</em> body P with a frame <code class="docutils literal"><span class="pre">Jc</span></code> on a <em>child</em> body C. This usage
of the terms <em>parent</em> and <em>child</em> is just a convention and implies
nothing about the inboard-outboard relationship between the bodies.
Since a Joint imposes a kinematical relationship which characterizes
the possible relative motion between frames Jp and Jc, reaction forces
on each body are established. That is, we could cut the model at the
joint and replace it with equivalent forces equal to these reaction
forces in order to attain the same motions of the mechanical system.</p>
<p>This output port allows to evaluate the reaction force <code class="docutils literal"><span class="pre">F_CJc_Jc</span></code> on
the <em>child</em> body C, at <code class="docutils literal"><span class="pre">Jc</span></code>, and expressed in Jc for all joints in
the model. This port evaluates to a vector of type
std::vector&lt;SpatialForce&lt;T&gt;&gt; and size num_joints() indexed by
JointIndex, see Joint::index(). Each entry corresponds to the spatial
force <code class="docutils literal"><span class="pre">F_CJc_Jc</span></code> applied on the joint’s child body C
(Joint::child_body()), at the joint’s child frame <code class="docutils literal"><span class="pre">Jc</span></code>
(Joint::frame_on_child()) and expressed in frame <code class="docutils literal"><span class="pre">Jc</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_source_id">
<code class="descname">get_source_id</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; Optional[pydrake.geometry.SourceId]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_source_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unique id identifying <code class="docutils literal"><span class="pre">this</span></code> plant as a source for a
SceneGraph. Returns <code class="docutils literal"><span class="pre">nullopt</span></code> if <code class="docutils literal"><span class="pre">this</span></code> plant did not register any
geometry. This method can be called at any time during the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> plant to query if <code class="docutils literal"><span class="pre">this</span></code> plant has been registered with a
SceneGraph, either pre- or post-finalize, see Finalize(). However, a
geometry::SourceId is only assigned once at the first call of any of
this plant’s geometry registration methods, and it does not change
after that. Post-finalize calls will always return the same value.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].get_state_output_port">
<code class="descname">get_state_output_port</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].get_state_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; pydrake.systems.framework.OutputPort_[Expression]</li>
</ol>
<p>Returns a constant reference to the output port for the multibody
state x = [q, v] of the model.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[Expression]</li>
</ol>
<p>Returns a constant reference to the output port for the state xᵢ = [qᵢ
vᵢ] of model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.)</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetAccelerationLowerLimits">
<code class="descname">GetAccelerationLowerLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetAccelerationLowerLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of size <code class="docutils literal"><span class="pre">num_velocities()</span></code> containing the lower
acceleration limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetAccelerationUpperLimits">
<code class="descname">GetAccelerationUpperLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetAccelerationUpperLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit analog of GetAccelerationsLowerLimits(), where any
unbounded or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetAccelerationLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodyByName">
<code class="descname">GetBodyByName</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodyByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; pydrake.multibody.tree.Body_[Expression]</li>
</ol>
<p>Returns a constant reference to a body that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no body with the requested name.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the body name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasBodyNamed() to query if there exists a body in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.Body_[Expression]</li>
</ol>
<p>Returns a constant reference to the body that is uniquely identified
by the string <code class="docutils literal"><span class="pre">name</span></code> and <code class="docutils literal"><span class="pre">model_instance</span></code> in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no body with the requested name.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasBodyNamed() to query if there exists a body in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodyFrameIdIfExists">
<code class="descname">GetBodyFrameIdIfExists</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], body_index: pydrake.multibody.tree.BodyIndex</em><span class="sig-paren">)</span> &#x2192; Optional[pydrake.geometry.FrameId]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodyFrameIdIfExists" title="Permalink to this definition">¶</a></dt>
<dd><p>If the body with <code class="docutils literal"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise, it
returns nullopt.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodyFrameIdOrThrow">
<code class="descname">GetBodyFrameIdOrThrow</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], body_index: pydrake.multibody.tree.BodyIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.FrameId<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodyFrameIdOrThrow" title="Permalink to this definition">¶</a></dt>
<dd><p>If the body with <code class="docutils literal"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise this
method throws an exception.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the called plant does not have the body indicated</li>
<li>by <code class="docutils literal"><span class="pre">body_index</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodyFromFrameId">
<code class="descname">GetBodyFromFrameId</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], arg0: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodyFromFrameId" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a geometry frame identifier, returns a pointer to the body
associated with that id (nullptr if there is no such body).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodyIndices">
<code class="descname">GetBodyIndices</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex</em><span class="sig-paren">)</span> &#x2192; List[pydrake.multibody.tree.BodyIndex]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetBodyIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of body indices associated with <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetCollisionGeometriesForBody">
<code class="descname">GetCollisionGeometriesForBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], body: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.GeometryId]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetCollisionGeometriesForBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different contact
geometries for <code class="docutils literal"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method can be called at any time during the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RegisterCollisionGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetDefaultFreeBodyPose">
<code class="descname">GetDefaultFreeBodyPose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], body: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetDefaultFreeBodyPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default pose of <code class="docutils literal"><span class="pre">body</span></code> as set by SetDefaultFreeBodyPose().</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">body</span></code>:</dt>
<dd>Body whose default pose will be retrieved.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetFrameByName">
<code class="descname">GetFrameByName</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetFrameByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; pydrake.multibody.tree.Frame_[Expression]</li>
</ol>
<p>Returns a constant reference to a frame that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no frame with the requested name.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the frame name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasFrameNamed() to query if there exists a frame in <code class="docutils literal"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.Frame_[Expression]</li>
</ol>
<p>Returns a constant reference to the frame that is uniquely identified
by the string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no frame with the requested name.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasFrameNamed() to query if there exists a frame in <code class="docutils literal"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetJointActuatorByName">
<code class="descname">GetJointActuatorByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuator_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetJointActuatorByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to an actuator that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if there is no actuator with the requested name.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the actuator name occurs in multiple model</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">instances.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetJointByName">
<code class="descname">GetJointByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetJointByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal"><span class="pre">JointType</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">JointType</span></code>:</dt>
<dd>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the named joint is not of type <code class="docutils literal"><span class="pre">JointType</span></code> or if</li>
<li>there is no Joint with that name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasJointNamed() to query if there exists a joint in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetModelInstanceByName">
<code class="descname">GetModelInstanceByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetModelInstanceByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the model instance that is uniquely identified by
the string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no instance with the requested name.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasModelInstanceNamed() to query if there exists an instance in
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetModelInstanceName">
<code class="descname">GetModelInstanceName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetModelInstanceName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of a <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError when <code class="docutils literal"><span class="pre">model_instance</span></code> does not correspond to a</li>
<li>model in this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetMutableJointByName">
<code class="descname">GetMutableJointByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetMutableJointByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal"><span class="pre">JointType</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">JointType</span></code>:</dt>
<dd>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the named joint is not of type <code class="docutils literal"><span class="pre">JointType</span></code> or if</li>
<li>there is no Joint with that name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasJointNamed() to query if there exists a joint in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetMutablePositions">
<code class="descname">GetMutablePositions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1], flags.writeable]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetMutablePositions" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a mutable vector reference containing the vector of
generalized positions (<strong>see warning</strong>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You should use SetPositions() instead of this method unless you
are fully aware of the possible interactions with the caching
mechanism (see dangerous_get_mutable).</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr or if it does not</li>
<li>correspond to the context for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetMutablePositionsAndVelocities">
<code class="descname">GetMutablePositionsAndVelocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1], flags.writeable]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetMutablePositionsAndVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a mutable vector containing the vector <code class="docutils literal"><span class="pre">[q;</span> <span class="pre">v]</span></code>
of the model with <code class="docutils literal"><span class="pre">q</span></code> the vector of generalized positions and <code class="docutils literal"><span class="pre">v</span></code>
the vector of generalized velocities (<strong>see warning</strong>).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You should use SetPositionsAndVelocities() instead of this method
unless you are fully aware of the interactions with the caching
mechanism (see dangerous_get_mutable).</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr or if it does not</li>
<li>correspond to the context for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetMutableVelocities">
<code class="descname">GetMutableVelocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1], flags.writeable]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetMutableVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>See GetMutableVelocities() method above.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositionLowerLimits">
<code class="descname">GetPositionLowerLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositionLowerLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of size <code class="docutils literal"><span class="pre">num_positions()</span></code> containing the lower
position limits for every generalized position coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositions">
<code class="descname">GetPositions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the vector of generalized
positions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns an vector containing the generalized positions (<code class="docutils literal"><span class="pre">q</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">q.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">q.size()</span></code>) time.</p>
</div>
<ol class="arabic simple" start="3">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the vector of generalized
positions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns an vector containing the generalized positions (<code class="docutils literal"><span class="pre">q</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">q.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">q.size()</span></code>) time.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositionsAndVelocities">
<code class="descname">GetPositionsAndVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositionsAndVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the vector <code class="docutils literal"><span class="pre">[q;</span> <span class="pre">v]</span></code> with
<code class="docutils literal"><span class="pre">q</span></code> the vector of generalized positions and <code class="docutils literal"><span class="pre">v</span></code> the vector of
generalized velocities.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns the vector <code class="docutils literal"><span class="pre">[q;</span> <span class="pre">v]</span></code> of the model with <code class="docutils literal"><span class="pre">q</span></code> the vector of
generalized positions and <code class="docutils literal"><span class="pre">v</span></code> the vector of generalized velocities
for model instance <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model or <code class="docutils literal"><span class="pre">model_instance</span></code> is invalid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">q.size()</span> <span class="pre">+</span> <span class="pre">v.size()</span></code>
associated with <code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">q.size()</span></code>) time.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositionsFromArray">
<code class="descname">GetPositionsFromArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositionsFromArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of generalized positions for <code class="docutils literal"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal"><span class="pre">q_array</span></code> of generalized positions for the entire model
model. This method throws an exception if <code class="docutils literal"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositionUpperLimits">
<code class="descname">GetPositionUpperLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetPositionUpperLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit analog of GetPositionsLowerLimits(), where any unbounded
or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetPositionLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetTopologyGraphvizString">
<code class="descname">GetTopologyGraphvizString</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetTopologyGraphvizString" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Graphviz string describing the topology of this plant. To
render the string, use the Graphviz tool, <code class="docutils literal"><span class="pre">dot</span></code>.
<a class="reference external" href="http://www.graphviz.org/">http://www.graphviz.org/</a></p>
<p>Note: this method can be called either before or after <code class="docutils literal"><span class="pre">Finalize()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetVelocities">
<code class="descname">GetVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the generalized
velocities.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<ol class="arabic simple" start="2">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns a vector containing the generalized velocities (<code class="docutils literal"><span class="pre">v</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">v.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">v.size()</span></code>) time.</p>
</div>
<ol class="arabic simple" start="3">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the generalized
velocities.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<ol class="arabic simple" start="4">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Returns a vector containing the generalized velocities (<code class="docutils literal"><span class="pre">v</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">v.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">v.size()</span></code>) time.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetVelocitiesFromArray">
<code class="descname">GetVelocitiesFromArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetVelocitiesFromArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of generalized velocities for <code class="docutils literal"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal"><span class="pre">v</span></code> of generalized velocities for the entire MultibodyPlant
model. This method throws an exception if the input array is not of
size MultibodyPlant::num_velocities().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetVelocityLowerLimits">
<code class="descname">GetVelocityLowerLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetVelocityLowerLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of size <code class="docutils literal"><span class="pre">num_velocities()</span></code> containing the lower
velocity limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].GetVelocityUpperLimits">
<code class="descname">GetVelocityUpperLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].GetVelocityUpperLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit analog of GetVelocitysLowerLimits(), where any unbounded
or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetVelocityLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].gravity_field">
<code class="descname">gravity_field</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniformGravityFieldElement_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].gravity_field" title="Permalink to this definition">¶</a></dt>
<dd><p>An accessor to the current gravity field.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].HasBodyNamed">
<code class="descname">HasBodyNamed</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].HasBodyNamed" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a body named <code class="docutils literal"><span class="pre">name</span></code> was added to the MultibodyPlant.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddRigidBody().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the body name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a body named <code class="docutils literal"><span class="pre">name</span></code> was added to the MultibodyPlant
in <code class="docutils literal"><span class="pre">model_instance</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddRigidBody().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].HasJointActuatorNamed">
<code class="descname">HasJointActuatorNamed</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].HasJointActuatorNamed" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if an actuator named <code class="docutils literal"><span class="pre">name</span></code> was added to this model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJointActuator().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the actuator name occurs in multiple model</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">instances.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if an actuator named <code class="docutils literal"><span class="pre">name</span></code> was added to
<code class="docutils literal"><span class="pre">model_instance</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJointActuator().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].HasJointNamed">
<code class="descname">HasJointNamed</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].HasJointNamed" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a joint named <code class="docutils literal"><span class="pre">name</span></code> was added to this model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJoint().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the joint name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a joint named <code class="docutils literal"><span class="pre">name</span></code> was added to
<code class="docutils literal"><span class="pre">model_instance</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJoint().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].HasModelInstanceNamed">
<code class="descname">HasModelInstanceNamed</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], name: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].HasModelInstanceNamed" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a model instance named <code class="docutils literal"><span class="pre">name</span></code> was added to this
model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddModelInstance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].is_finalized">
<code class="descname">is_finalized</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].is_finalized" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if this MultibodyPlant was finalized with a call to
Finalize().</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Finalize().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].MakeActuationMatrix">
<code class="descname">MakeActuationMatrix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].MakeActuationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This method creates an actuation matrix B mapping a vector of
actuation values u into generalized forces <code class="docutils literal"><span class="pre">tau_u</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">u</span></code>, where B
is a matrix of size <code class="docutils literal"><span class="pre">nv</span> <span class="pre">x</span> <span class="pre">nu</span></code> with <code class="docutils literal"><span class="pre">nu</span></code> equal to num_actuators()
and <code class="docutils literal"><span class="pre">nv</span></code> equal to num_velocities(). The vector u of actuation values
is of size num_actuators(). For a given JointActuator,
<code class="docutils literal"><span class="pre">u[JointActuator::index()]</span></code> stores the value for the external
actuation corresponding to that actuator. <code class="docutils literal"><span class="pre">tau_u</span></code> on the other hand
is indexed by generalized velocity indexes according to
<code class="docutils literal"><span class="pre">Joint::velocity_start()</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">B is a permutation matrix. While making a permutation has <code class="docutils literal"><span class="pre">O(n)</span></code>
complexity, making a full B matrix has <code class="docutils literal"><span class="pre">O(n²)</span></code> complexity. For
most applications this cost can be neglected but it could become
significant for very large systems.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].MapQDotToVelocity">
<code class="descname">MapQDotToVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], qdot: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].MapQDotToVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the time derivative <code class="docutils literal"><span class="pre">qdot</span></code> of the generalized positions
vector <code class="docutils literal"><span class="pre">q</span></code> (stored in <code class="docutils literal"><span class="pre">context</span></code>) to generalized velocities <code class="docutils literal"><span class="pre">v</span></code>.
<cite>v</cite> and <code class="docutils literal"><span class="pre">q̇</span></code> are related linearly by <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Although
<code class="docutils literal"><span class="pre">N(q)</span></code> is not necessarily square, its left pseudo-inverse <code class="docutils literal"><span class="pre">N⁺(q)</span></code>
can be used to invert that relationship without residual error,
provided that <code class="docutils literal"><span class="pre">qdot</span></code> is in the range space of <code class="docutils literal"><span class="pre">N(q)</span></code> (that is, if
it <em>could</em> have been produced as <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code> for some <code class="docutils literal"><span class="pre">v</span></code>).
Using the configuration <code class="docutils literal"><span class="pre">q</span></code> stored in the given <code class="docutils literal"><span class="pre">context</span></code> this
method calculates <code class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">N⁺(q)⋅q̇</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">qdot</span></code>:</dt>
<dd>A vector containing the time derivatives of the generalized
positions. This method aborts if <code class="docutils literal"><span class="pre">qdot</span></code> is not of size
num_positions().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">v</span></code>:</dt>
<dd>A valid (non-null) pointer to a vector in <code class="docutils literal"><span class="pre">ℛⁿ</span></code> with n the number
of generalized velocities. This method aborts if v is nullptr or
if it is not of size num_velocities().</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MapVelocityToQDot()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Mobilizer::MapQDotToVelocity()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].MapVelocityToQDot">
<code class="descname">MapVelocityToQDot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].MapVelocityToQDot" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms generalized velocities v to time derivatives <code class="docutils literal"><span class="pre">qdot</span></code> of
the generalized positions vector <code class="docutils literal"><span class="pre">q</span></code> (stored in <code class="docutils literal"><span class="pre">context</span></code>). <cite>v</cite>
and <code class="docutils literal"><span class="pre">qdot</span></code> are related linearly by <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Using the
configuration <code class="docutils literal"><span class="pre">q</span></code> stored in the given <code class="docutils literal"><span class="pre">context</span></code> this method
calculates <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">v</span></code>:</dt>
<dd>A vector of of generalized velocities for this model. This method
aborts if v is not of size num_velocities().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">qdot</span></code>:</dt>
<dd>A valid (non-null) pointer to a vector in <code class="docutils literal"><span class="pre">ℝⁿ</span></code> with n being the
number of generalized positions in this model, given by
<code class="docutils literal"><span class="pre">num_positions()</span></code>. This method aborts if <code class="docutils literal"><span class="pre">qdot</span></code> is nullptr or
if it is not of size num_positions().</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MapQDotToVelocity()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Mobilizer::MapVelocityToQDot()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].mutable_gravity_field">
<code class="descname">mutable_gravity_field</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniformGravityFieldElement_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].mutable_gravity_field" title="Permalink to this definition">¶</a></dt>
<dd><p>A mutable accessor to the current gravity field.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_actuated_dofs">
<code class="descname">num_actuated_dofs</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].num_actuated_dofs" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; int</li>
</ol>
<p>Returns the total number of actuated degrees of freedom. That is, the
vector of actuation values u has this size. See AddJointActuator().</p>
<ol class="arabic simple" start="2">
<li>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the total number of actuated degrees of freedom for a specific
model instance. That is, the vector of actuation values u has this
size. See AddJointActuator().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_actuators">
<code class="descname">num_actuators</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].num_actuators" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of joint actuators in the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJointActuator().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_bodies">
<code class="descname">num_bodies</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].num_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of bodies in the model, including the “world” body,
which is always part of the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddRigidBody().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_collision_geometries">
<code class="descname">num_collision_geometries</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].num_collision_geometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of geometries registered for contact modeling. This
method can be called at any time during the lifetime of <code class="docutils literal"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize(). Post-finalize
calls will always return the same value.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_force_elements">
<code class="descname">num_force_elements</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].num_force_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of ForceElement objects.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddForceElement().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_frames">
<code class="descname">num_frames</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].num_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of Frame objects in this model. Frames include body
frames associated with each of the bodies, including the <em>world</em> body.
This means the minimum number of frames is one.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_joints">
<code class="descname">num_joints</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].num_joints" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of joints in the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJoint().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_model_instances">
<code class="descname">num_model_instances</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].num_model_instances" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of model instances in the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddModelInstance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_multibody_states">
<code class="descname">num_multibody_states</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].num_multibody_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; int</li>
</ol>
<p>Returns the size of the multibody system state vector x = [q v]. This
will be <code class="docutils literal"><span class="pre">num_positions()</span></code> plus <code class="docutils literal"><span class="pre">num_velocities()</span></code>.</p>
<ol class="arabic simple" start="2">
<li>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the size of the multibody system state vector xᵢ = [qᵢ vᵢ] for
model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.) will be
<code class="docutils literal"><span class="pre">num_positions(model_instance)</span></code> plus
<code class="docutils literal"><span class="pre">num_velocities(model_instance)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_positions">
<code class="descname">num_positions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].num_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; int</li>
</ol>
<p>Returns the size of the generalized position vector q for this model.</p>
<ol class="arabic simple" start="2">
<li>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the size of the generalized position vector qᵢ for model
instance i.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression]) -&gt; int</li>
</ol>
<p>Returns the size of the generalized velocity vector v for this model.</p>
<ol class="arabic simple" start="2">
<li>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the size of the generalized velocity vector vᵢ for model
instance i.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].RegisterAsSourceForSceneGraph">
<code class="descname">RegisterAsSourceForSceneGraph</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], scene_graph: drake::geometry::SceneGraph&lt;drake::symbolic::Expression&gt;</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.SourceId<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].RegisterAsSourceForSceneGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers <code class="docutils literal"><span class="pre">this</span></code> plant to serve as a source for an instance of
SceneGraph. This registration allows MultibodyPlant to register
geometry with <code class="docutils literal"><span class="pre">scene_graph</span></code> for visualization and/or collision
queries. Successive registration calls with SceneGraph <strong>must</strong> be
performed on the same instance to which the pointer argument
<code class="docutils literal"><span class="pre">scene_graph</span></code> points to. Failure to do so will result in runtime
exceptions.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">scene_graph</span></code>:</dt>
<dd>A valid non nullptr to the SceneGraph instance for which <code class="docutils literal"><span class="pre">this</span></code>
plant will sever as a source, see SceneGraph documentation for
further details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the SourceId of <code class="docutils literal"><span class="pre">this</span></code> plant in <code class="docutils literal"><span class="pre">scene_graph</span></code>. It can also
later on be retrieved with get_source_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called post-finalize.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">scene_graph</span></code> is the nullptr.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called more than once.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].RegisterCollisionGeometry">
<code class="descname">RegisterCollisionGeometry</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].RegisterCollisionGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[Expression], body: pydrake.multibody.tree.Body_[Expression], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Registers geometry in a SceneGraph with a given geometry::Shape to be
used for the contact modeling of a given <code class="docutils literal"><span class="pre">body</span></code>. More than one
geometry can be registered with a body, in which case the body’s
contact geometry is the union of all geometries registered to that
body.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">body</span></code>:</dt>
<dd>The body for which geometry is being registered.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_BG</span></code>:</dt>
<dd>The fixed pose of the geometry frame G in the body frame B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">shape</span></code>:</dt>
<dd>The geometry::Shape used for visualization. E.g.:
geometry::Sphere, geometry::Cylinder, etc.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">properties</span></code>:</dt>
<dd>The proximity properties associated with the collision geometry.
They <em>must</em> include the (<code class="docutils literal"><span class="pre">material</span></code>, <cite>coulomb_friction</cite>)
property of type CoulombFriction&lt;double&gt;.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called post-finalize or if the properties are</li>
<li>missing the coulomb friction property (or if it is of the wrong</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">type).</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[Expression], body: pydrake.multibody.tree.Body_[Expression], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, coulomb_friction: pydrake.multibody.plant.CoulombFriction_[float]) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Overload which specifies a single property: coulomb_friction.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].RegisterVisualGeometry">
<code class="descname">RegisterVisualGeometry</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].RegisterVisualGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RegisterVisualGeometry(self: pydrake.multibody.plant.MultibodyPlant_[Expression], body: pydrake.multibody.tree.Body_[Expression], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4, 1]]) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Overload for visual geometry registration; it converts the
<code class="docutils literal"><span class="pre">diffuse_color</span></code> (RGBA with values in the range [0, 1]) into a
geometry::ConnectDrakeVisualizer()-compatible set of
geometry::IllustrationProperties.</p>
<ol class="arabic simple" start="2">
<li>RegisterVisualGeometry(self: pydrake.multibody.plant.MultibodyPlant_[Expression], body: pydrake.multibody.tree.Body_[Expression], X_BG: pydrake.common.eigen_geometry.Isometry3_[float], shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4, 1]], scene_graph: drake::geometry::SceneGraph&lt;drake::symbolic::Expression&gt; = None) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].set_penetration_allowance">
<code class="descname">set_penetration_allowance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], penetration_allowance: float = 0.001</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].set_penetration_allowance" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the penetration allowance used to estimate the coefficients in
the penalty method used to impose non-penetration among bodies. Refer
to the section mbp_penalty_method “Contact by penalty method” for
further details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if penetration_allowance is not positive.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].set_stiction_tolerance">
<code class="descname">set_stiction_tolerance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], v_stiction: float = 0.001</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].set_stiction_tolerance" title="Permalink to this definition">¶</a></dt>
<dd><p><a href="#id79"><span class="problematic" id="id80">**</span></a>** Stribeck model of friction</p>
<p>Currently MultibodyPlant uses the Stribeck approximation to model dry
friction. The Stribeck model of friction is an approximation to
Coulomb’s law of friction that allows using continuous time
integration without the need to specify complementarity constraints.
While this results in a simpler model immediately tractable with
standard numerical methods for integration of ODE’s, it often leads to
stiff dynamics that require an explicit integrator to take very small
time steps. It is therefore recommended to use error controlled
integrators when using this model or the discrete time stepping (see
time_advancement_strategy “Choice of Time Advancement Strategy”). See
stribeck_approximation for a detailed discussion of the Stribeck
model.</p>
<p>Sets the stiction tolerance <code class="docutils literal"><span class="pre">v_stiction</span></code> for the Stribeck model,
where <code class="docutils literal"><span class="pre">v_stiction</span></code> must be specified in m/s (meters per second.)
<code class="docutils literal"><span class="pre">v_stiction</span></code> defaults to a value of 1 millimeter per second. In
selecting a value for <code class="docutils literal"><span class="pre">v_stiction</span></code>, you must ask yourself the
question, “When two objects are ostensibly in stiction, how much slip
am I willing to allow?” There are two opposing design issues in
picking a value for vₛ. On the one hand, small values of vₛ make the
problem numerically stiff during stiction, potentially increasing the
integration cost. On the other hand, it should be picked to be
appropriate for the scale of the problem. For example, a car
simulation could allow a “large” value for vₛ of 1 cm/s (1×10⁻² m/s),
but reasonable stiction for grasping a 10 cm box might require
limiting residual slip to 1×10⁻³ m/s or less. Ultimately, picking the
largest viable value will allow your simulation to run faster and more
robustly. Note that <code class="docutils literal"><span class="pre">v_stiction</span></code> is the slip velocity that we’d have
when we are at edge of the friction cone. For cases when the friction
force is well within the friction cone the slip velocity will always
be smaller than this value. See also stribeck_approximation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">v_stiction</span></code> is non-positive.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetActuationInArray">
<code class="descname">SetActuationInArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[object[m, 1]], u: numpy.ndarray[object[m, 1], flags.writeable]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].SetActuationInArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the actuation values <code class="docutils literal"><span class="pre">u_instance</span></code> for all actuators in
<code class="docutils literal"><span class="pre">model_instance</span></code>, this method sets the actuation vector u for the
entire model to which this actuator belongs to. This method throws an
exception if the size of <code class="docutils literal"><span class="pre">u_instance</span></code> is not equal to the number of
degrees of freedom of all of the actuated joints in
<code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">u_instance</span></code>:</dt>
<dd>Actuation values for the actuators. It must be of size equal to
the number of degrees of freedom of all of the actuated joints in
<code class="docutils literal"><span class="pre">model_instance</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">u</span></code>:</dt>
<dd>The vector containing the actuation values for the entire model.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetDefaultFreeBodyPose">
<code class="descname">SetDefaultFreeBodyPose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], body: pydrake.multibody.tree.Body_[Expression], X_WB: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].SetDefaultFreeBodyPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default pose of <code class="docutils literal"><span class="pre">body</span></code>. If <code class="docutils literal"><span class="pre">body.is_floating()</span></code> is true,
this will affect subsequent calls to SetDefaultState(); otherwise,
this value is effectively ignored.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">body</span></code>:</dt>
<dd>Body whose default pose will be set.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_WB</span></code>:</dt>
<dd>Default pose of the body.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetDefaultState">
<code class="descname">SetDefaultState</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], state: pydrake.systems.framework.State_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].SetDefaultState" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">state</span></code> according to defaults set by the user for joints (e.g.
RevoluteJoint::set_default_angle()) and free bodies
(SetDefaultFreeBodyPose()). If the user does not specify defaults, the
state corresponds to zero generalized positions and velocities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize. See Finalize().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetFreeBodyPose">
<code class="descname">SetFreeBodyPose</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].SetFreeBodyPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetFreeBodyPose(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], body: pydrake.multibody.tree.Body_[Expression], X_WB: pydrake.math.RigidTransform_[Expression]) -&gt; None</li>
</ol>
<p>Sets <code class="docutils literal"><span class="pre">context</span></code> to store the pose <code class="docutils literal"><span class="pre">X_WB</span></code> of a given <code class="docutils literal"><span class="pre">body</span></code> B in
the world frame W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general setting the pose and/or velocity of a body in the model
would involve a complex inverse kinematics problem. This method
allows us to simplify this process when we know the body is free
in space.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">body</span></code> is not a free body in the model.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetFreeBodyPose(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], body: pydrake.multibody.tree.Body_[Expression], X_WB: pydrake.common.eigen_geometry.Isometry3_[Expression]) -&gt; None</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetFreeBodySpatialVelocity">
<code class="descname">SetFreeBodySpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], body: pydrake.multibody.tree.Body_[Expression], V_WB: pydrake.multibody.math.SpatialVelocity_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].SetFreeBodySpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">context</span></code> to store the spatial velocity <code class="docutils literal"><span class="pre">V_WB</span></code> of a given
<code class="docutils literal"><span class="pre">body</span></code> B in the world frame W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general setting the pose and/or velocity of a body in the model
would involve a complex inverse kinematics problem. This method
allows us to simplify this process when we know the body is free
in space.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">body</span></code> is not a free body in the model.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetPositions">
<code class="descname">SetPositions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].SetPositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], q: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized positions from the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">q</span></code> is not equal to <code class="docutils literal"><span class="pre">num_positions()</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized positions from the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">q</span></code> is not equal to <code class="docutils literal"><span class="pre">num_positions()</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetPositionsAndVelocities">
<code class="descname">SetPositionsAndVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].SetPositionsAndVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], q_v: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized positions and velocities from the given vector
[q; v].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">q_v</span></code> is not equal to <a href="#id81"><span class="problematic" id="id82">``</span></a>num_positions() +</li>
<li>num_velocities()``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Sets generalized positions and velocities from the given vector [q; v]
for the specified model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, if the model</li>
<li>instance index is invalid, or if the length of <code class="docutils literal"><span class="pre">q_v</span></code> is not</li>
<li>equal to <a href="#id83"><span class="problematic" id="id84">``</span></a>num_positions(model_instance) +</li>
<li>num_velocities(model_instance)``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetPositionsInArray">
<code class="descname">SetPositionsInArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[object[m, 1]], q: numpy.ndarray[object[m, 1], flags.writeable]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].SetPositionsInArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the vector of generalized positions for <code class="docutils literal"><span class="pre">model_instance</span></code> in
<code class="docutils literal"><span class="pre">q</span></code> using <code class="docutils literal"><span class="pre">q_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions() or <code class="docutils literal"><span class="pre">q_instance</span></code> is not of size
<code class="docutils literal"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetVelocities">
<code class="descname">SetVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].SetVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], v: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized velocities from the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">v</span></code> is not equal to <code class="docutils literal"><span class="pre">num_velocities()</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[Expression], context: pydrake.systems.framework.Context_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Sets the generalized velocities for a particular model instance from
the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, if the model</li>
<li>instance index is invalid, or if the length of <code class="docutils literal"><span class="pre">v_instance</span></code> is</li>
<li>not equal to <code class="docutils literal"><span class="pre">num_velocities(model_instance)</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].SetVelocitiesInArray">
<code class="descname">SetVelocitiesInArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[object[m, 1]], v: numpy.ndarray[object[m, 1], flags.writeable]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].SetVelocitiesInArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the vector of generalized velocities for <code class="docutils literal"><span class="pre">model_instance</span></code> in
<code class="docutils literal"><span class="pre">v</span></code> using <code class="docutils literal"><span class="pre">v_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal"><span class="pre">v</span></code> is not of size
MultibodyPlant::num_velocities() or <code class="docutils literal"><span class="pre">v_instance</span></code> is not of size
<code class="docutils literal"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].time_step">
<code class="descname">time_step</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>The time step (or period) used to model <code class="docutils literal"><span class="pre">this</span></code> plant as a discrete
system with periodic updates. Returns 0 (zero) if the plant is modeled
as a continuous system. This property of the plant is specified at
construction and therefore this query can be performed either pre- or
post-finalize, see Finalize().</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MultibodyPlant::MultibodyPlant(double)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].WeldFrames">
<code class="descname">WeldFrames</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].WeldFrames" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>WeldFrames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], A: pydrake.multibody.tree.Frame_[Expression], B: pydrake.multibody.tree.Frame_[Expression], X_AB: pydrake.math.RigidTransform_[float] = &lt;pydrake.math.RigidTransform_[float] object at 0x7f53d5ef84b0&gt;) -&gt; pydrake.multibody.tree.WeldJoint_[Expression]</li>
</ol>
<p>Welds frames A and B with relative pose <code class="docutils literal"><span class="pre">X_AB</span></code>. That is, the pose of
frame B in frame A is fixed, with value <code class="docutils literal"><span class="pre">X_AB</span></code>. The call to this
method creates and adds a new WeldJoint to the model. The new
WeldJoint is named as: A.name() + “_welds_to_” + B.name().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to the WeldJoint welding frames A and B.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>WeldFrames(self: pydrake.multibody.plant.MultibodyPlant_[Expression], A: pydrake.multibody.tree.Frame_[Expression], B: pydrake.multibody.tree.Frame_[Expression], X_AB: pydrake.common.eigen_geometry.Isometry3_[float]) -&gt; pydrake.multibody.tree.WeldJoint_[Expression]</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].world_body">
<code class="descname">world_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RigidBody_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].world_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the <em>world</em> body.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[Expression].world_frame">
<code class="descname">world_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyFrame_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[Expression].world_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the <em>world</em> frame.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">MultibodyPlant_[float]</code><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_[float]" title="pydrake.systems.framework.LeafSystem_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.framework.LeafSystem_[float]</span></code></a></p>
<p>MultibodyPlant is a Drake system framework representation (see
systems::System) for the model of a physical system consisting of a
collection of interconnected bodies. See multibody for an overview of
concepts/notation.</p>
<p>&lt;table align=center cellpadding=0 cellspacing=0&gt;&lt;tr align=center&gt;&lt;td
style=”vertical-align:middle”&gt;&lt;table cellspacing=0
cellpadding=0&gt;&lt;tr&gt;&lt;td align=right style=”padding:5px 0px 5px
0px”&gt;applied_generalized_force&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=right
style=”padding:5px 0px 5px
0px”&gt;applied_spatial_force&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=right
style=”padding:5px 0px 5px 0px”&gt;&lt;em
style=”color:gray”&gt;model_instance_name[i]&lt;/em&gt;_actuation&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=right style=”padding:5px 0px 5px 0px”&gt;&lt;span
style=”color:green”&gt;geometry_query&lt;/span&gt;&amp;rarr;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;td
align=center
style=”border:solid;padding-left:20px;padding-right:20px;vertical-align:middle”
bgcolor=#F0F0F0&gt;MultibodyPlant&lt;/td&gt;&lt;td
style=”vertical-align:middle”&gt;&lt;table cellspacing=0
cellpadding=0&gt;&lt;tr&gt;&lt;td align=left style=”padding:5px 0px 5px
0px”&gt;&amp;rarr; continuous_state&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left
style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; body_poses&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr;
body_spatial_velocities&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left style=”padding:5px
0px 5px 0px”&gt;&amp;rarr; body_spatial_accelerations&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr;
generalized_acceleration&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left
style=”padding:5px 0px 5px 0px”&gt;&amp;rarr;
reaction_forces&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left style=”padding:5px 0px 5px
0px”&gt;&amp;rarr; contact_results&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=left
style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;em
style=”color:gray”&gt;model_instance_name[i]&lt;/em&gt;_continuous_state&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;em
style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt;_generalized_acceleration&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;em
style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt;_generalized_contact_forces&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td
align=left style=”padding:5px 0px 5px 0px”&gt;&amp;rarr; &lt;span
style=”color:green”&gt;geometry_pose&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</p>
<p>The ports whose names begin with &lt;em style=”color:gray”&gt;
model_instance_name[i]&lt;/em&gt; represent groups of ports, one for each of
the model_instances “model instances”, with i ∈ {0, …, N-1} for the
N model instances. If a model instance does not contain any data of
the indicated type the port will still be present but its value will
be a zero-length vector. (Model instances <code class="docutils literal"><span class="pre">world_model_instance()</span></code>
and <code class="docutils literal"><span class="pre">default_model_instance()</span></code> always exist.)</p>
<p>The ports shown in &lt;span style=”color:green”&gt; green&lt;/span&gt; are for
communication with Drake’s geometry::SceneGraph “SceneGraph” system
for dealing with geometry.</p>
<p>MultibodyPlant provides a user-facing API for:</p>
<ul class="simple">
<li>mbp_input_and_output_ports “Ports”: Access input and output ports. -</li>
</ul>
<p>mbp_construction “Construction”: Add bodies, joints, frames, force
elements, and actuators. - mbp_geometry “Geometry”: Register
geometries to a provided SceneGraph instance. - mbp_contact_modeling
“Contact modeling”: Select and parameterize contact models. -
mbp_state_accessors_and_mutators “State access and modification”:
Obtain and manipulate position and velocity state variables. -
mbp_working_with_free_bodies “Free bodies”: Work conveniently with
free (floating) bodies. - mbp_kinematic_and_dynamic_computations
“Kinematics and dynamics”: Perform systems::Context
“Context”-dependent kinematic and dynamic queries. -
mbp_system_matrix_computations “System matrices”: Explicitly form
matrices that appear in the equations of motion. - mbp_introspection
“Introspection”: Perform introspection to find out what’s in the
MultibodyPlant.</p>
<p><a href="#id85"><span class="problematic" id="id86">**</span></a>** Model Instances</p>
<p>A MultiBodyPlant may contain multiple model instances. Each model
instance corresponds to a set of bodies and their connections
(joints). Model instances provide methods to get or set the state of
the set of bodies (e.g., through GetPositionsAndVelocities() and
SetPositionsAndVelocities()), connecting controllers (through
get_state_output_port() and get_actuation_input_port()), and
organizing duplicate models (read through a parser). In fact, many
MultibodyPlant methods are overloaded to allow operating on the entire
plant or just the subset corresponding to the model instance; for
example, one GetPositions() method obtains the generalized positions
for the entire plant while another GetPositions() method obtains the
generalized positions for model instance.</p>
<p>Model instances are frequently defined through SDF files (using the
<code class="docutils literal"><span class="pre">model</span></code> tag) and are automatically created when SDF files are parsed
(by Parser). There are two special multibody::ModelInstanceIndex
values. The world body is always multibody::ModelInstanceIndex 0.
multibody::ModelInstanceIndex 1 is reserved for all elements with no
explicit model instance and is generally only relevant for elements
created programmatically (and only when a model instance is not
explicitly specified). Note that Parser creates model instances
(resulting in a multibody::ModelInstanceIndex ≥ 2) as needed.</p>
<p>See num_model_instances(), num_positions(), num_velocities(),
num_actuated_dofs(), AddModelInstance() GetPositionsAndVelocities(),
GetPositions(), GetVelocities(), SetPositionsAndVelocities(),
SetPositions(), SetVelocities(), GetPositionsFromArray(),
GetVelocitiesFromArray(), SetPositionsInArray(),
SetVelocitiesInArray(), SetActuationInArray(),
HasModelInstanceNamed(), GetModelInstanceName(),
get_state_output_port(), get_actuation_input_port().</p>
<p><a href="#id87"><span class="problematic" id="id88">**</span></a>** System dynamics</p>
<p>The state of a multibody system <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">[q;</span> <span class="pre">v]</span></code> is given by its
generalized positions vector q, of size <code class="docutils literal"><span class="pre">nq</span></code> (see num_positions()),
and by its generalized velocities vector v, of size <code class="docutils literal"><span class="pre">nv</span></code> (see
num_velocities()). As a Drake systems::System “System”, MultibodyPlant
implements the governing equations for a multibody dynamical system in
the form <code class="docutils literal"><span class="pre">ẋ</span> <span class="pre">=</span> <span class="pre">f(t,</span> <span class="pre">x,</span> <span class="pre">u)</span></code> with t being time and u the actuation
forces. The governing equations for the dynamics of a multibody system
modeled with MultibodyPlant are [Featherstone 2008, Jain 2010]:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">q̇</span> <span class="o">=</span> <span class="n">N</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v</span>
   <span class="p">(</span><span class="mi">1</span><span class="p">)</span>    <span class="n">M</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="n">v̇</span> <span class="o">+</span> <span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="n">v</span> <span class="o">=</span> <span class="n">τ</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">M(q)</span></code> is the mass matrix of the multibody system, <code class="docutils literal"><span class="pre">C(q,</span>
<span class="pre">v)v</span></code> contains Coriolis, centripetal, and gyroscopic terms and
<code class="docutils literal"><span class="pre">N(q)</span></code> is the kinematic coupling matrix describing the relationship
between q̇ (the time derivatives of the generalized positions) and the
generalized velocities v, [Seth 2010]. <code class="docutils literal"><span class="pre">N(q)</span></code> is an <code class="docutils literal"><span class="pre">nq</span> <span class="pre">x</span> <span class="pre">nv</span></code>
matrix. The vector <code class="docutils literal"><span class="pre">τ</span> <span class="pre">∈</span> <span class="pre">ℝⁿᵛ</span></code> on the right hand side of Eq. (1) is
the system’s generalized forces. These incorporate gravity, springs,
externally applied body forces, constraint forces, and contact forces.</p>
<p><a href="#id89"><span class="problematic" id="id90">**</span></a>** Loading models from SDF files</p>
<p>Drake has the capability to load multibody models from SDF and URDF
files. Consider the example below which loads an acrobot model:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">acrobot</span><span class="p">;</span>
   <span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">scene_graph</span><span class="p">;</span>
   <span class="n">Parser</span> <span class="n">parser</span><span class="p">(</span><span class="o">&amp;</span><span class="n">acrobot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scene_graph</span><span class="p">);</span>
   <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">relative_name</span> <span class="o">=</span>
     <span class="s2">&quot;drake/multibody/benchmarks/acrobot/acrobot.sdf&quot;</span><span class="p">;</span>
   <span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">full_name</span> <span class="o">=</span> <span class="n">FindResourceOrThrow</span><span class="p">(</span><span class="n">relative_name</span><span class="p">);</span>
   <span class="n">parser</span><span class="o">.</span><span class="n">AddModelFromFile</span><span class="p">(</span><span class="n">full_name</span><span class="p">);</span>
</pre></div>
</div>
<p>As in the example above, for models including visual geometry,
collision geometry or both, the user must specify a SceneGraph for
geometry handling. You can find a full example of the LQR controlled
acrobot in examples/multibody/acrobot/run_lqr.cc.</p>
<p>AddModelFromFile() can be invoked multiple times on the same plant in
order to load multiple model instances. Other methods are available on
Parser such as AddAllModelsFromFile() which allows creating model
instances per each <code class="docutils literal"><span class="pre">&lt;model&gt;</span></code> tag found in the file. Please refer to
each of these methods’ documentation for further details.</p>
<p><a href="#id91"><span class="problematic" id="id92">**</span></a>** Working with SceneGraph</p>
<p>** Adding a MultibodyPlant connected to a SceneGraph to your Diagram</p>
<p>Probably the simplest way to add and wire up a MultibodyPlant with a
SceneGraph in your Diagram is using AddMultibodyPlantSceneGraph().</p>
<p>Recommended usages:</p>
<p>Assign to a MultibodyPlant reference (ignoring the SceneGraph):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">plant</span> <span class="o">=</span>
       <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">/*</span> <span class="n">time_step</span> <span class="o">*/</span><span class="p">);</span>
   <span class="n">plant</span><span class="o">.</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>This flavor is the simplest, when the SceneGraph is not explicitly
needed. (It can always be retrieved later via
GetSubsystemByName(“scene_graph”).)</p>
<p>Assign to auto, and use the named public fields:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">items</span> <span class="o">=</span> <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">/*</span> <span class="n">time_step</span> <span class="o">*/</span><span class="p">);</span>
   <span class="n">items</span><span class="o">.</span><span class="n">plant</span><span class="o">.</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
   <span class="n">items</span><span class="o">.</span><span class="n">scene_graph</span><span class="o">.</span><span class="n">DoBar</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>or taking advantage of C++17’s structured binding</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="p">[</span><span class="n">plant</span><span class="p">,</span> <span class="n">scene_graph</span><span class="p">]</span> <span class="o">=</span> <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
   <span class="o">...</span>
   <span class="n">plant</span><span class="o">.</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
   <span class="n">scene_graph</span><span class="o">.</span><span class="n">DoBar</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>This is the easiest way to use both the plant and scene_graph.</p>
<p>Assign to already-declared pointer variables:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;*</span> <span class="n">plant</span><span class="p">{};</span>
   <span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;*</span> <span class="n">scene_graph</span><span class="p">{};</span>
   <span class="n">std</span><span class="p">::</span><span class="n">tie</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span> <span class="n">scene_graph</span><span class="p">)</span> <span class="o">=</span>
       <span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">/*</span> <span class="n">time_step</span> <span class="o">*/</span><span class="p">);</span>
   <span class="n">plant</span><span class="o">-&gt;</span><span class="n">DoFoo</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
   <span class="n">scene_graph</span><span class="o">-&gt;</span><span class="n">DoBar</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</pre></div>
</div>
<p>This flavor is most useful when the pointers are class member fields
(and so perhaps cannot be references).</p>
<p>** Registering geometry with a SceneGraph</p>
<p>MultibodyPlant users can register geometry with a SceneGraph for
essentially two purposes; a) visualization and, b) contact modeling.</p>
<p>Before any geometry registration takes place, a user <strong>must</strong> first
make a call to RegisterAsSourceForSceneGraph() in order to register
the MultibodyPlant as a client of a SceneGraph instance, point at
which the plant will have assigned a valid geometry::SourceId. At
Finalize(), MultibodyPlant will declare input/output ports as
appropriate to communicate with the SceneGraph instance on which
registrations took place. All geometry registration <strong>must</strong> be
performed pre-finalize.</p>
<p>Multibodyplant declares an input port for geometric queries, see
get_geometry_query_input_port(). If MultibodyPlant registers geometry
with a SceneGraph via calls to RegisterCollisionGeometry(), users may
use this port for geometric queries. Users must connect this input
port to the output port for geometric queries of the SceneGraph used
for registration, which can be obtained with
SceneGraph::get_query_output_port(). In summary, if MultibodyPlant
registers collision geometry, the setup process will include:</p>
<p>1. Call to RegisterAsSourceForSceneGraph(). 2. Calls to
RegisterCollisionGeometry(), as many as needed. 3. Call to Finalize(),
user is done specifying the model. 4. Connect
SceneGraph::get_query_output_port() to
get_geometry_query_input_port().</p>
<p>Refer to the documentation provided in each of the methods above for
further details.</p>
<p>** Accessing point contact parameters MultibodyPlant’s point contact
model looks for model parameters stored as
geometry::ProximityProperties by geometry::SceneGraph. These
properties can be obtained before or after context creation through
geometry::SceneGraphInspector APIs as outlined below. MultibodyPlant
expects the following properties for point contact modeling:</p>
<div class="line-block">
<div class="line">Group name | Property Name | Required | Property Type | Property</div>
</div>
<p>Description | | :——–: | :————–: | :——: |
:—————-: | :——————- | | material |
coulomb_friction | yes¹ | CoulombFriction&lt;T&gt; | Static and Dynamic
friction. | | material | point_contact_stiffness | no² | T | Penalty
method stiffness. | | material | hunt_crossley_dissipation | no² | T |
Penalty method dissipation. |</p>
<p>¹ Collision geometry is required to be registered with a
geometry::ProximityProperties object that contains the (“material”,
“coulomb_friction”) property. If the property is missing,
MultibodyPlant will throw an exeception.</p>
<p>² If the property is missing, MultibodyPlant will use a heuristic
value as the default. Refer to the section mbp_penalty_method “Penalty
method point contact” for further details.</p>
<p>Accessing and modifying contact properties requires interfacing with
geometry::SceneGraph’s model inspector. Interfacing with a model
inspector obtained from geometry::SceneGraph will provide the default
registered values for a given parameter. These are the values that
will initially appear in a systems::Context created by
CreateDefaultContext(). Subsequently, true system paramters can be
accessed and changed through a systems::Context once available. For
both of the above cases, proximity properties are accessed through
geometry::SceneGraphInspector APIs.</p>
<p>Before context creation an inspector can be retrieved directly from
SceneGraph as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">For</span> <span class="n">a</span> <span class="n">SceneGraph</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">instance</span> <span class="n">called</span> <span class="n">scene_graph</span><span class="o">.</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">inspector</span> <span class="o">=</span>
<span class="n">scene_graph</span><span class="o">.</span><span class="n">model_inspector</span><span class="p">();</span>
</pre></div>
</div>
<p>After context creation, an inspector can be retrieved from the state
stored in the context by the plant’s geometry query input port:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">For</span> <span class="n">a</span> <span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">instance</span> <span class="n">called</span> <span class="n">mbp</span> <span class="ow">and</span> <span class="n">a</span>
<span class="o">//</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">called</span> <span class="n">context</span><span class="o">.</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">QueryObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">query_object</span> <span class="o">=</span>
<span class="n">mbp</span><span class="o">.</span><span class="n">get_geometry_query_input_port</span><span class="p">()</span>
<span class="o">.</span><span class="n">template</span> <span class="n">Eval</span><span class="o">&lt;</span><span class="n">geometry</span><span class="p">::</span><span class="n">QueryObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">SceneGraphInspector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">inspector</span> <span class="o">=</span>
<span class="n">query_object</span><span class="o">.</span><span class="n">inspector</span><span class="p">();</span>
</pre></div>
</div>
<p>Once an inspector is available, proximity properties can be retrieved
as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">For</span> <span class="n">a</span> <span class="n">body</span> <span class="k">with</span> <span class="n">GeometryId</span> <span class="n">called</span> <span class="n">geometry_id</span>
<span class="n">const</span> <span class="n">geometry</span><span class="p">::</span><span class="n">ProximityProperties</span><span class="o">*</span> <span class="n">props</span> <span class="o">=</span>
<span class="n">inspector</span><span class="o">.</span><span class="n">GetProximityProperties</span><span class="p">(</span><span class="n">geometry_id</span><span class="p">);</span>
<span class="n">const</span> <span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">geometry_friction</span> <span class="o">=</span>
<span class="n">props</span><span class="o">-&gt;</span><span class="n">GetProperty</span><span class="o">&lt;</span><span class="n">CoulombFriction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s2">&quot;material&quot;</span><span class="p">,</span>
<span class="s2">&quot;coulomb_friction&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p><a href="#id93"><span class="problematic" id="id94">**</span></a>** Adding modeling elements</p>
<p>Add multibody elements to a MultibodyPlant with methods like:</p>
<ul class="simple">
<li>Bodies: AddRigidBody() - Joints: AddJoint() - see mbp_construction</li>
</ul>
<p>“Construction” for more.</p>
<p>All modeling elements <strong>must</strong> be added before Finalize() is called.
See mbp_finalize_stage “Finalize stage” for a discussion.</p>
<p><a href="#id95"><span class="problematic" id="id96">**</span></a>** Modeling contact</p>
<p>Please refer to drake_contacts “Contact Modeling in Drake” for details
on the available approximations, setup, and considerations for a
multibody simulation with frictional contact.</p>
<p><a href="#id97"><span class="problematic" id="id98">**</span></a>** Energy and Power</p>
<p>MultibodyPlant implements the System energy and power methods, with
some limitations. - Kinetic energy: fully implemented. - Potential
energy and conservative power: currently include only gravity and
contributions from ForceElement objects; potential energy from
compliant contact and joint limits are not included. - Nonconservative
power: currently includes only contributions from ForceElement
objects; actuation and input port forces, joint damping, and
dissipation from joint limits, friction, and contact dissipation are
not included.</p>
<p>See Drake issue #12942 for more discussion.</p>
<p><a href="#id99"><span class="problematic" id="id100">**</span></a>** Finalize() stage</p>
<p>Once the user is done adding modeling elements and registering
geometry, a call to Finalize() must be performed. This call will: -
Build the underlying MultibodyTree topology, see
MultibodyTree::Finalize() for details, - declare the plant’s state, -
declare the plant’s input and output ports, - declare input and output
ports for communication with a SceneGraph.</p>
<p><a href="#id101"><span class="problematic" id="id102">**</span></a>** References</p>
<ul class="simple">
<li>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics</li>
</ul>
<p>algorithms. Springer. - [Jain 2010] Jain, A., 2010. Robot and
multibody dynamics: analysis and algorithms. Springer Science &amp;
Business Media. - [Seth 2010] Seth, A., Sherman, M., Eastman, P. and
Delp, S., 2010. Minimal formulation of joint motion for biomechanisms.
Nonlinear dynamics, 62(1), pp.291-303.</p>
<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], time_step: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>This constructor creates a plant with a single “world” body.
Therefore, right after creation, num_bodies() returns one.</p>
<p>MultibodyPlant offers two different modalities to model mechanical
systems in time. These are: 1. As a discrete system with periodic
updates, <code class="docutils literal"><span class="pre">time_step</span></code> is strictly greater than zero. 2. As a
continuous system, <code class="docutils literal"><span class="pre">time_step</span></code> equals exactly zero.</p>
<p>Currently the discrete model is preferred for simulation given its
robustness and speed in problems with frictional contact. However this
might change as we work towards developing better strategies to model
contact. See time_advancement_strategy “Choice of Time Advancement
Strategy” for further details.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Users should be aware of current limitations in either modeling
modality. While the discrete model is often the preferred option
for problems with frictional contact given its robustness and
speed, it might become unstable when using large feedback gains,
high damping or large external forcing. MultibodyPlant will throw
an exception whenever the discrete solver is detected to fail.
Conversely, the continuous modality has the potential to leverage
the robustness and accuracy control provide by Drake’s
integrators. However thus far this has proved difficult in
practice and especially due to poor performance.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">time_step</span></code>:</dt>
<dd>Indicates whether <code class="docutils literal"><span class="pre">this</span></code> plant is modeled as a continuous system
(<code class="docutils literal"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code>) or as a discrete system with periodic updates
of period <code class="docutils literal"><span class="pre">time_step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. See time_advancement_strategy “Choice
of Time Advancement Strategy” for further details.</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Currently the continuous modality with <code class="docutils literal"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code> does not
support joint limits for simulation, these are ignored.
MultibodyPlant prints a warning to console if joint limits are
provided. If your simulation requires joint limits currently you
must use a discrete MultibodyPlant model.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">time_step</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].AddForceElement">
<code class="descname">AddForceElement</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], force_element: pydrake.multibody.tree.ForceElement_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ForceElement_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].AddForceElement" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a new force element model of type <code class="docutils literal"><span class="pre">ForceElementType</span></code> to
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. The arguments to this method <code class="docutils literal"><span class="pre">args</span></code> are
forwarded to <a href="#id103"><span class="problematic" id="id104">``</span></a>ForceElementType`’s constructor.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">args</span></code>:</dt>
<dd>Zero or more parameters provided to the constructor of the new
force element. It must be the case that
<cite>ForceElementType&lt;T&gt;(args)`</cite> is a valid constructor.</dd>
<dt>Template parameter <code class="docutils literal"><span class="pre">ForceElementType</span></code>:</dt>
<dd>The type of the ForceElement to add. As there is always a
UniformGravityFieldElement present (accessible through
gravity_field()), an exception will be thrown if this function is
called to add another UniformGravityFieldElement.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A constant reference to the new ForceElement just added, of type
<code class="docutils literal"><span class="pre">ForceElementType&lt;T&gt;</span></code> specialized on the scalar type T of
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. It will remain valid for the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The ForceElement class’s documentation for further details on how
a force element is defined.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].AddFrame">
<code class="descname">AddFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], frame: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].AddFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>This method adds a Frame of type <code class="docutils literal"><span class="pre">FrameType&lt;T&gt;</span></code>. For more
information, please see the corresponding constructor of
<code class="docutils literal"><span class="pre">FrameType</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">FrameType</span></code>:</dt>
<dd>Template which will be instantiated on <code class="docutils literal"><span class="pre">T</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame</span></code>:</dt>
<dd>Unique pointer frame instance.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A constant reference to the new Frame just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].AddJoint">
<code class="descname">AddJoint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], joint: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].AddJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>This method adds a Joint of type <code class="docutils literal"><span class="pre">JointType</span></code> between two bodies. For
more information, see the below overload of <code class="docutils literal"><span class="pre">AddJoint&lt;&gt;</span></code>, and the
related <code class="docutils literal"><span class="pre">MultibodyTree::AddJoint&lt;&gt;</span></code> method.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].AddJointActuator">
<code class="descname">AddJointActuator</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, joint: pydrake.multibody.tree.Joint_[float], effort_limit: float = inf</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuator_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].AddJointActuator" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and adds a JointActuator model for an actuator acting on a
given <code class="docutils literal"><span class="pre">joint</span></code>. This method returns a constant reference to the
actuator just added, which will remain valid for the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> plant.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that uniquely identifies the new actuator to be added to
<code class="docutils literal"><span class="pre">this</span></code> model. A RuntimeError is thrown if an actuator with the
same name already exists in the model. See
HasJointActuatorNamed().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">joint</span></code>:</dt>
<dd>The Joint to be actuated by the new JointActuator.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">effort_limit</span></code>:</dt>
<dd>The maximum effort for the actuator. It must be strictly positive,
otherwise an RuntimeError is thrown. If +∞, the actuator has no
limit, which is the default. The effort limit has physical units
in accordance to the joint type it actuates. For instance, it will
have units of N⋅m (torque) for revolute joints while it will have
units of N (force) for prismatic joints.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A constant reference to the new JointActuator just added, which
will remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> plant.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">joint.num_velocities()</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> since for now we</li>
<li>only support actuators for single dof joints.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].AddModelInstance">
<code class="descname">AddModelInstance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], name: str</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].AddModelInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new model instance. Returns the index for the model
instance.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that uniquely identifies the new instance to be added to
<code class="docutils literal"><span class="pre">this</span></code> model. An exception is thrown if an instance with the
same name already exists in the model. See
HasModelInstanceNamed().</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].AddRigidBody">
<code class="descname">AddRigidBody</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].AddRigidBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; pydrake.multibody.tree.RigidBody_[float]</li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. The body
will use the default model instance (model_instance “more on model
instances”).</p>
<p>Example of usage:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">;</span>
  <span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">to</span> <span class="n">define</span> <span class="n">spatial_inertia</span><span class="p">,</span> <span class="n">a</span> <span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">object</span> <span class="o">...</span>
  <span class="n">const</span> <span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">body</span> <span class="o">=</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s2">&quot;BodyName&quot;</span><span class="p">,</span> <span class="n">spatial_inertia</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that identifies the new body to be added to <code class="docutils literal"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal"><span class="pre">name</span></code> already
is part of the model in the default model instance. See
HasBodyNamed(), Body::name().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>The SpatialInertia of the new rigid body to be added to <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal"><span class="pre">Bo</span></code> and
expressed in the body frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if additional model instances have been created</li>
<li>beyond the world and default instances.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>AddRigidBody(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; pydrake.multibody.tree.RigidBody_[float]</li>
</ol>
<p>Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<p>Example of usage:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">;</span>
  <span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">to</span> <span class="n">define</span> <span class="n">spatial_inertia</span><span class="p">,</span> <span class="n">a</span> <span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">object</span> <span class="o">...</span>
  <span class="n">ModelInstanceIndex</span> <span class="n">model_instance</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">AddModelInstance</span><span class="p">(</span><span class="s2">&quot;instance&quot;</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">RigidBody</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">body</span> <span class="o">=</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="s2">&quot;BodyName&quot;</span><span class="p">,</span> <span class="n">model_instance</span><span class="p">,</span> <span class="n">spatial_inertia</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>A string that identifies the new body to be added to <code class="docutils literal"><span class="pre">this</span></code>
model. A RuntimeError is thrown if a body named <code class="docutils literal"><span class="pre">name</span></code> already
is part of <code class="docutils literal"><span class="pre">model_instance</span></code>. See HasBodyNamed(), Body::name().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">model_instance</span></code>:</dt>
<dd>A model instance index which this body is part of.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>The SpatialInertia of the new rigid body to be added to <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant, computed about the body frame origin <code class="docutils literal"><span class="pre">Bo</span></code> and
expressed in the body frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A constant reference to the new RigidBody just added, which will
remain valid for the lifetime of <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].CalcBiasSpatialAcceleration">
<code class="descname">CalcBiasSpatialAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BoBp_B: numpy.ndarray[numpy.float64[3, 1]], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].CalcBiasSpatialAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>For one point Bp affixed/welded to a frame B, calculates A𝑠Bias_ABp,
Bp’s spatial acceleration bias in frame A with respect to “speeds” 𝑠,
where 𝑠 is either q̇ (time-derivatives of generalized positions) or v
(generalized velocities). A𝑠Bias_ABp is the term in A_ABp (Bp’s
spatial acceleration in A) that does not include 𝑠̇, i.e., A𝑠Bias_ABp
is Bi’s translational acceleration in A when 𝑠̇ = 0.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   (𝑠 = q̇ or 𝑠 = v), hence
  A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠
</pre></div>
</div>
<p>where J𝑠_V_ABp is Bp’s spatial velocity Jacobian in frame A for speeds
s (see CalcJacobianSpatialVelocity() for details on J𝑠_V_ABp).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the spatial
accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which point Bp is affixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBp_B</span></code>:</dt>
<dd>Position vector from Bo (frame_B’s origin) to point Bp (regarded
as affixed/welded to B), expressed in frame_B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures A𝑠Bias_ABp. Currently, an exception is
thrown if frame_A is not the World frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which A𝑠Bias_ABp is expressed on output.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A𝑠Bias_ABp_E Point Bp’s spatial acceleration bias in frame A with
respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shown below, A𝑠Bias_ABp_E = J̇𝑠_V_ABp ⋅ 𝑠 is quadratic in 𝑠.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>V_ABp =  J𝑠_V_ABp ⋅ 𝑠        which upon vector differentiation in A gives
 A_ABp =  J𝑠_V_ABp ⋅ 𝑠̇  +  J̇𝑠_V_ABp ⋅ 𝑠   Since J̇𝑠_V_ABp is linear in 𝑠,
 A𝑠Bias_ABp = J̇𝑠_V_ABp ⋅ 𝑠                             is quadratic in 𝑠.
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcJacobianSpatialVelocity() to compute J𝑠_V_ABp, point Bp’s
translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if with_respect_to is not JacobianWrtVariable::kV</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if frame_A is not the world frame.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].CalcBiasTerm">
<code class="descname">CalcBiasTerm</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].CalcBiasTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the bias term <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> containing Coriolis, centripetal,
and gyroscopic effects in the multibody equations of motion:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>M(q) v̇ + C(q, v) v = tau_app + ∑ (Jv_V_WBᵀ(q) ⋅ Fapp_Bo_W)
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">M(q)</span></code> is the multibody model’s mass matrix and <code class="docutils literal"><span class="pre">tau_app</span></code> is
a vector of generalized forces. The last term is a summation over all
bodies of the dot-product of <code class="docutils literal"><span class="pre">Fapp_Bo_W</span></code> (applied spatial force on
body B at Bo) with <code class="docutils literal"><span class="pre">Jv_V_WB(q)</span></code> (B’s spatial Jacobian in world W
with respect to generalized velocities v). Note: B’s spatial velocity
in W can be written <code class="docutils literal"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model. It stores the
generalized positions q and the generalized velocities v.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">Cv</span></code>:</dt>
<dd>On output, <code class="docutils literal"><span class="pre">Cv</span></code> will contain the product <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)v</span></code>. It must
be a valid (non-null) pointer to a column vector in <code class="docutils literal"><span class="pre">ℛⁿ</span></code> with n
the number of generalized velocities (num_velocities()) of the
model. This method aborts if Cv is nullptr or if it does not have
the proper size.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].CalcBiasTranslationalAcceleration">
<code class="descname">CalcBiasTranslationalAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BoBi_B: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].CalcBiasTranslationalAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates a𝑠Bias_ABi,
Bi’s translational acceleration bias in frame A with respect to
“speeds” 𝑠, where 𝑠 is either q̇ (time-derivatives of generalized
positions) or v (generalized velocities). a𝑠Bias_ABi is the term in
a_ABi (Bi’s translational acceleration in A) that does not include 𝑠̇,
i.e., a𝑠Bias_ABi is Bi’s translational acceleration in A when 𝑠̇ = 0.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇  +  J̇𝑠_v_ABi ⋅ 𝑠  (𝑠 = q̇ or 𝑠 = v), hence
  a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠
</pre></div>
</div>
<p>where J𝑠_v_ABi is Bi’s translational velocity Jacobian in frame A for
s (see CalcJacobianTranslationalVelocity() for details on J𝑠_v_ABi).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the translational
accceleration bias is with respect to 𝑠 = q̇ or 𝑠 = v.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which points Bi are affixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBi_B</span></code>:</dt>
<dd>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B. Each column in the <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span>
<span class="pre">p</span></code> matrix p_BoBi_B corresponds to a position vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures a𝑠Bias_ABi. Currently, an exception is
thrown if frame_A is not the World frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which a𝑠Bias_ABi is expressed on output.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a𝑠Bias_ABi_E Point Bi’s translational acceleration bias in frame A
with respect to speeds 𝑠 (𝑠 = q̇ or 𝑠 = v), expressed in frame E.
a𝑠Bias_ABi_E is a <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">p</span></code> matrix, where p is the number of
points Bi.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Shown below, a𝑠Bias_ABi_E = J̇𝑠_v_ABp ⋅ 𝑠 is quadratic in 𝑠.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>v_ABi =  J𝑠_v_ABi ⋅ 𝑠        which upon vector differentiation in A gives
 a_ABi =  J𝑠_v_ABi ⋅ 𝑠̇ + J̇𝑠_v_ABi ⋅ 𝑠     Since J̇𝑠_v_ABi is linear in 𝑠,
 a𝑠Bias_ABi = J̇𝑠_v_ABi ⋅ 𝑠                             is quadratic in 𝑠.
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcJacobianTranslationalVelocity() to compute J𝑠_v_ABi, point
Bi’s translational velocity Jacobian in frame A with respect to 𝑠.</p>
</div>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>p_BoBi_B must have 3 rows.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if with_respect_to is not JacobianWrtVariable::kV</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if frame_A is not the world frame.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].CalcCenterOfMassPosition">
<code class="descname">CalcCenterOfMassPosition</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].CalcCenterOfMassPosition" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the center of mass position p_WCcm of all bodies
in <code class="docutils literal"><span class="pre">MultibodyPlant</span></code> measured and expressed in world frame W. The
bodies are considered as a single composite body C, whose center of
mass <code class="docutils literal"><span class="pre">composite_mass</span></code> is located at Ccm. The world_body() is
ignored.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model. It stores the
generalized positions q of the model.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">p_WCcm</span></code>:</dt>
<dd>The output position of center of mass in the world frame W.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">MultibodyPlant</span></code> has no body except</li>
<li><code class="docutils literal"><span class="pre">world_body()</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError unless <code class="docutils literal"><span class="pre">composite_mass</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].CalcForceElementsContribution">
<code class="descname">CalcForceElementsContribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], forces: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].CalcForceElementsContribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the combined force contribution of ForceElement objects in
the model. A ForceElement can apply forces as a spatial force per body
or as generalized forces, depending on the ForceElement model.
ForceElement contributions are a function of the state and time only.
The output from this method can immediately be used as input to
CalcInverseDynamics() to include the effect of applied forces by force
elements.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of this model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">forces</span></code>:</dt>
<dd>A pointer to a valid, non nullptr, multibody forces object. On
output <code class="docutils literal"><span class="pre">forces</span></code> will store the forces exerted by all the
ForceElement objects in the model.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">forces</span></code> is null or not compatible with this</li>
<li>model, per MultibodyForces::CheckInvariants().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].CalcGravityGeneralizedForces">
<code class="descname">CalcGravityGeneralizedForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].CalcGravityGeneralizedForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the generalized forces <code class="docutils literal"><span class="pre">tau_g(q)</span></code> due to gravity as a
function of the generalized positions <code class="docutils literal"><span class="pre">q</span></code> stored in the input
<code class="docutils literal"><span class="pre">context</span></code>. The vector of generalized forces due to gravity
<code class="docutils literal"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the right hand side of
the equations of motion together with any other generalized forces,
like so:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Mv̇</span> <span class="o">+</span> <span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="n">v</span> <span class="o">=</span> <span class="n">tau_g</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau_app</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the model.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tau_g A vector containing the generalized forces due to gravity.
The generalized forces are consistent with the vector of
generalized velocities <code class="docutils literal"><span class="pre">v</span></code> for <code class="docutils literal"><span class="pre">this</span></code> so that the inner
product <code class="docutils literal"><span class="pre">v⋅tau_g</span></code> corresponds to the power applied by the
gravity forces on the mechanical system. That is, <code class="docutils literal"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>
corresponds to potential energy going into the system, as either
mechanical kinetic energy, some other potential energy, or heat,
and therefore to a decrease of the gravitational potential energy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].CalcInverseDynamics">
<code class="descname">CalcInverseDynamics</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], known_vdot: numpy.ndarray[numpy.float64[m, 1]], external_forces: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].CalcInverseDynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the state of this model in <code class="docutils literal"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal"><span class="pre">vdot</span></code>, this method computes the set of
generalized forces <code class="docutils literal"><span class="pre">tau</span></code> that would need to be applied in order to
attain the specified generalized accelerations. Mathematically, this
method computes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>tau = M(q)v̇ + C(q, v)v - tau_app - ∑ J_WBᵀ(q) Fapp_Bo_W
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">M(q)</span></code> is the model’s mass matrix, <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)v</span></code> is the bias
term containing Coriolis and gyroscopic effects and <code class="docutils literal"><span class="pre">tau_app</span></code>
consists of a vector applied generalized forces. The last term is a
summation over all bodies in the model where <code class="docutils literal"><span class="pre">Fapp_Bo_W</span></code> is an
applied spatial force on body B at <code class="docutils literal"><span class="pre">Bo</span></code> which gets projected into
the space of generalized forces with the transpose of <code class="docutils literal"><span class="pre">Jv_V_WB(q)</span></code>
(where <code class="docutils literal"><span class="pre">Jv_V_WB</span></code> is B’s spatial velocity Jacobian in W with respect
to generalized velocities v). Note: B’s spatial velocity in W can be
written as <code class="docutils literal"><span class="pre">V_WB</span> <span class="pre">=</span> <span class="pre">Jv_V_WB</span> <span class="pre">*</span> <span class="pre">v</span></code>. This method does not compute
explicit expressions for the mass matrix nor for the bias term, which
would be of at least <code class="docutils literal"><span class="pre">O(n²)</span></code> complexity, but it implements an
<code class="docutils literal"><span class="pre">O(n)</span></code> Newton-Euler recursive algorithm, where n is the number of
bodies in the model. The explicit formation of the mass matrix
<code class="docutils literal"><span class="pre">M(q)</span></code> would require the calculation of <code class="docutils literal"><span class="pre">O(n²)</span></code> entries while
explicitly forming the product <code class="docutils literal"><span class="pre">C(q,</span> <span class="pre">v)</span> <span class="pre">*</span> <span class="pre">v</span></code> could require up to
<code class="docutils literal"><span class="pre">O(n³)</span></code> operations (see [Featherstone 1987, §4]), depending on the
implementation. The recursive Newton-Euler algorithm is the most
efficient currently known general method for solving inverse dynamics
[Featherstone 2008].</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">known_vdot</span></code>:</dt>
<dd>A vector with the known generalized accelerations <code class="docutils literal"><span class="pre">vdot</span></code> for the
full model. Use the provided Joint APIs in order to access entries
into this array.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">external_forces</span></code>:</dt>
<dd>A set of forces to be applied to the system either as body spatial
forces <code class="docutils literal"><span class="pre">Fapp_Bo_W</span></code> or generalized forces <code class="docutils literal"><span class="pre">tau_app</span></code>, see
MultibodyForces for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the vector of generalized forces that would need to be applied to
the mechanical system in order to achieve the desired acceleration
given by <code class="docutils literal"><span class="pre">known_vdot</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].CalcJacobianAngularVelocity">
<code class="descname">CalcJacobianAngularVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].CalcJacobianAngularVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates J𝑠_w_AB, a frame B’s angular velocity Jacobian in a frame A
with respect to “speeds” 𝑠.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>J𝑠_w_AB ≜ [ ∂(w_AB)/∂𝑠₁,  ...  ∂(w_AB)/∂𝑠ₙ ]    (n is j or k)
     w_AB = J𝑠_w_AB ⋅ 𝑠          w_AB is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">w_AB</span></code> is B’s angular velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal"><span class="pre">J𝑠_w_AB</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame B in <code class="docutils literal"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame A in <code class="docutils literal"><span class="pre">w_AB</span></code> (B’s angular velocity in A).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which <code class="docutils literal"><span class="pre">w_AB</span></code> is expressed on input and the frame in
which the Jacobian <code class="docutils literal"><span class="pre">J𝑠_w_AB</span></code> is expressed on output.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">J𝑠_w_AB_E</span></code>:</dt>
<dd>Frame B’s angular velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E. The
Jacobian is a function of only generalized positions q (which are
pulled from the context). The previous definition shows
<code class="docutils literal"><span class="pre">J𝑠_w_AB_E</span></code> is a matrix of size <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code>, where n is the number
of elements in 𝑠.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">J𝑠_w_AB_E</span></code> is nullptr or not of size <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].CalcJacobianSpatialVelocity">
<code class="descname">CalcJacobianSpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BP: numpy.ndarray[numpy.float64[3, 1]], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].CalcJacobianSpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>For one point Bp fixed/welded to a frame B, calculates J𝑠_V_ABp, Bp’s
spatial velocity Jacobian in frame A with respect to “speeds” 𝑠.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>J𝑠_V_ABp ≜ [ ∂(V_ABp)/∂𝑠₁,  ...  ∂(V_ABp)/∂𝑠ₙ ]    (n is j or k)
     V_ABp = J𝑠_V_ABp ⋅ 𝑠          V_ABp is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">V_ABp</span></code> is Bp’s spatial velocity in frame A and “speeds” 𝑠 is either
q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized positions) or v
≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal"><span class="pre">J𝑠_V_ABp</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which point Bp is fixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBp_B</span></code>:</dt>
<dd>A position vector from Bo (frame_B’s origin) to point Bp (regarded
as fixed/welded to B), expressed in frame_B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures <code class="docutils literal"><span class="pre">v_ABp</span></code> (Bp’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAp_A (similar
to the parameter p_BoBp_B for frame_B). There is no need for
p_AoAp_A because Bp’s velocity in A is defined as the derivative
in frame A of Bp’s position vector from <em>any</em> point fixed to A.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which <code class="docutils literal"><span class="pre">v_ABp</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal"><span class="pre">J𝑠_V_ABp</span></code> is expressed on output.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">J𝑠_V_ABp_E</span></code>:</dt>
<dd>Point Bp’s spatial velocity Jacobian in frame A with respect to
speeds 𝑠 (which is either q̇ or v), expressed in frame E.
<code class="docutils literal"><span class="pre">J𝑠_V_ABp_E</span></code> is a <code class="docutils literal"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where n is the number of
elements in 𝑠. The Jacobian is a function of only generalized
positions q (which are pulled from the context). Note: The
returned <code class="docutils literal"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix stores frame B’s angular velocity
Jacobian in A in rows 1-3 and stores point Bp’s translational
velocity Jacobian in A in rows 4-6, i.e.,</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">J𝑠_w_AB_E</span> <span class="o">=</span> <span class="n">J𝑠_V_ABp_E</span><span class="o">.</span><span class="n">topRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">J𝑠_v_ABp_E</span> <span class="o">=</span> <span class="n">J𝑠_V_ABp_E</span><span class="o">.</span><span class="n">bottomRows</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>Note: Consider CalcJacobianTranslationalVelocity() for multiple points
fixed to frame B and consider CalcJacobianAngularVelocity() to
calculate frame B’s angular velocity Jacobian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">J𝑠_V_ABp_E</span></code> is nullptr or not sized <code class="docutils literal"><span class="pre">6</span> <span class="pre">x</span> <span class="pre">n</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].CalcJacobianTranslationalVelocity">
<code class="descname">CalcJacobianTranslationalVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], with_respect_to: pydrake.multibody.tree.JacobianWrtVariable, frame_B: pydrake.multibody.tree.Frame_[float], p_BoBi_B: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].CalcJacobianTranslationalVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>For each point Bi affixed/welded to a frame B, calculates J𝑠_v_ABi,
Bi’s translational velocity Jacobian in frame A with respect to
“speeds” 𝑠.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>J𝑠_v_ABi ≜ [ ∂(v_ABi)/∂𝑠₁,  ...  ∂(v_ABi)/∂𝑠ₙ ]    (n is j or k)
     v_ABi = J𝑠_v_ABi ⋅ 𝑠          v_ABi is linear in 𝑠 ≜ [𝑠₁ ... 𝑠ₙ]ᵀ
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">v_ABi</span></code> is Bi’s translational velocity in frame A and “speeds” 𝑠 is
either q̇ ≜ [q̇₁ … q̇ⱼ]ᵀ (time-derivatives of j generalized
positions) or v ≜ [v₁ … vₖ]ᵀ (k generalized velocities).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">with_respect_to</span></code>:</dt>
<dd>Enum equal to JacobianWrtVariable::kQDot or
JacobianWrtVariable::kV, indicating whether the Jacobian
<code class="docutils literal"><span class="pre">J𝑠_v_ABi</span></code> is partial derivatives with respect to 𝑠 = q̇
(time-derivatives of generalized positions) or with respect to 𝑠 =
v (generalized velocities).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame on which point Bi is affixed/welded.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoBi_B</span></code>:</dt>
<dd>A position vector or list of p position vectors from Bo (frame_B’s
origin) to points Bi (regarded as affixed to B), where each
position vector is expressed in frame_B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame that measures <code class="docutils literal"><span class="pre">v_ABi</span></code> (Bi’s velocity in A). Note: It
is natural to wonder why there is no parameter p_AoAi_A (similar
to the parameter p_BoBi_B for frame_B). There is no need for
p_AoAi_A because Bi’s velocity in A is defined as the derivative
in frame A of Bi’s position vector from <em>any</em> point affixed to A.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_E</span></code>:</dt>
<dd>The frame in which <code class="docutils literal"><span class="pre">v_ABi</span></code> is expressed on input and the frame
in which the Jacobian <code class="docutils literal"><span class="pre">J𝑠_v_ABi</span></code> is expressed on output.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">J𝑠_v_ABi_E</span></code>:</dt>
<dd>Point Bi’s velocity Jacobian in frame A with respect to speeds 𝑠
(which is either q̇ or v), expressed in frame E. <code class="docutils literal"><span class="pre">J𝑠_v_ABi_E</span></code> is
a <code class="docutils literal"><span class="pre">3*p</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix, where p is the number of points Bi and n is
the number of elements in 𝑠. The Jacobian is a function of only
generalized positions q (which are pulled from the context).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">J𝑠_v_ABi_E</span></code> is nullptr or not sized <a href="#id105"><span class="problematic" id="id106">``</span></a>3*p x</li>
<li>n``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When 𝑠 = q̇, <code class="docutils literal"><span class="pre">Jq̇_v_ABi</span> <span class="pre">=</span> <span class="pre">Jq_p_AoBi</span></code>. In other words, point Bi’s
velocity Jacobian in frame A with respect to q̇ is equal to point
Bi’s position Jacobian from Ao (A’s origin) in frame A with
respect to q.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>[∂(v_ABi)/∂q̇₁,  ...  ∂(v_ABi)/∂q̇ⱼ] = [∂(p_AoBi)/∂q₁,  ...  ∂(p_AoBi)/∂qⱼ]
</pre></div>
</div>
<p>Note: Each partial derivative of p_AoBi is taken in frame A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].CalcMassMatrixViaInverseDynamics">
<code class="descname">CalcMassMatrixViaInverseDynamics</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].CalcMassMatrixViaInverseDynamics" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].CalcPointsPositions">
<code class="descname">CalcPointsPositions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], frame_B: pydrake.multibody.tree.Frame_[float], p_BQi: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], frame_A: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].CalcPointsPositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the positions <code class="docutils literal"><span class="pre">p_BQi</span></code> for a set of points <code class="docutils literal"><span class="pre">Qi</span></code> measured and
expressed in a frame B, this method computes the positions
<code class="docutils literal"><span class="pre">p_AQi(q)</span></code> of each point <code class="docutils literal"><span class="pre">Qi</span></code> in the set as measured and expressed
in another frame A, as a function of the generalized positions q of
the model.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model. It stores the
generalized positions q of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_B</span></code>:</dt>
<dd>The frame B in which the positions <code class="docutils literal"><span class="pre">p_BQi</span></code> of a set of points
<code class="docutils literal"><span class="pre">Qi</span></code> are given.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BQi</span></code>:</dt>
<dd>The input positions of each point <code class="docutils literal"><span class="pre">Qi</span></code> in frame B. <code class="docutils literal"><span class="pre">p_BQi</span> <span class="pre">∈</span>
<span class="pre">ℝ³ˣⁿᵖ</span></code> with <code class="docutils literal"><span class="pre">np</span></code> the number of points in the set. Each column
of <code class="docutils literal"><span class="pre">p_BQi</span></code> corresponds to a vector in ℝ³ holding the position of
one of the points in the set as measured and expressed in frame B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_A</span></code>:</dt>
<dd>The frame A in which it is desired to compute the positions
<code class="docutils literal"><span class="pre">p_AQi</span></code> of each point <code class="docutils literal"><span class="pre">Qi</span></code> in the set.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_AQi</span></code>:</dt>
<dd>The output positions of each point <code class="docutils literal"><span class="pre">Qi</span></code> now computed as measured
and expressed in frame A. The output <code class="docutils literal"><span class="pre">p_AQi</span></code> <strong>must</strong> have the
same size as the input <code class="docutils literal"><span class="pre">p_BQi</span></code> or otherwise this method aborts.
That is <code class="docutils literal"><span class="pre">p_AQi</span></code> <strong>must</strong> be in <code class="docutils literal"><span class="pre">ℝ³ˣⁿᵖ</span></code>.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Both <code class="docutils literal"><span class="pre">p_BQi</span></code> and <code class="docutils literal"><span class="pre">p_AQi</span></code> must have three rows. Otherwise this
method will throw a RuntimeError exception. This method also
throws a RuntimeError exception if <code class="docutils literal"><span class="pre">p_BQi</span></code> and <code class="docutils literal"><span class="pre">p_AQi</span></code> differ
in the number of columns.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].CalcRelativeTransform">
<code class="descname">CalcRelativeTransform</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], frame_A: pydrake.multibody.tree.Frame_[float], frame_B: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].CalcRelativeTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rigid transform (pose) <code class="docutils literal"><span class="pre">X_FG</span></code> relating frame F and
frame G.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system, which includes the system’s
generalized positions q. Note: <code class="docutils literal"><span class="pre">X_FG</span></code> is a function of q.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_F</span></code>:</dt>
<dd>The frame F designated in the rigid transform <code class="docutils literal"><span class="pre">X_FG</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_G</span></code>:</dt>
<dd>The frame G designated in the rigid transform <code class="docutils literal"><span class="pre">X_FG</span></code>.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">X_FG</span></code>:</dt>
<dd>The RigidTransform relating frame F and frame G.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].CalcSpatialAccelerationsFromVdot">
<code class="descname">CalcSpatialAccelerationsFromVdot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], known_vdot: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.multibody.math.SpatialAcceleration_[float]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].CalcSpatialAccelerationsFromVdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the state of this model in <code class="docutils literal"><span class="pre">context</span></code> and a known vector of
generalized accelerations <code class="docutils literal"><span class="pre">known_vdot</span></code>, this method computes the
spatial acceleration <code class="docutils literal"><span class="pre">A_WB</span></code> for each body as measured and expressed
in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of this model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">known_vdot</span></code>:</dt>
<dd>A vector with the generalized accelerations for the full model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">A_WB_array</span></code>:</dt>
<dd>A pointer to a valid, non nullptr, vector of spatial accelerations
containing the spatial acceleration <code class="docutils literal"><span class="pre">A_WB</span></code> for each body. It
must be of size equal to the number of bodies in the model. On
output, entries will be ordered by BodyIndex.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if A_WB_array is not of size <code class="docutils literal"><span class="pre">num_bodies()</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].CollectRegisteredGeometries">
<code class="descname">CollectRegisteredGeometries</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], bodies: List[pydrake.multibody.tree.Body_[float]]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.GeometrySet<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].CollectRegisteredGeometries" title="Permalink to this definition">¶</a></dt>
<dd><p>For each of the provided <code class="docutils literal"><span class="pre">bodies</span></code>, collects up all geometries that
have been registered to that body. Intended to be used in conjunction
with SceneGraph::ExcludeCollisionsWithin() and
SceneGraph::ExcludeCollisionsBetween() to filter collisions between
the geometries registered to the bodies.</p>
<p>For example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Don&#39;t report on collisions between geometries affixed to ``body1``,
// ``body2``, or ``body3``.
std::vector&lt;const RigidBody&lt;T&gt;*&gt; bodies{&amp;body1, &amp;body2, &amp;body3};
geometry::GeometrySet set = plant.CollectRegisteredGeometries(bodies);
scene_graph.ExcludeCollisionsWithin(set);
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is a <em>very</em> specific order of operations:</p>
</div>
<ol class="arabic simple">
<li>Bodies and geometries must be added to the MultibodyPlant.</li>
<li>The MultibodyPlant must be finalized (via Finalize()).</li>
<li>Create GeometrySet instances from bodies (via this method).</li>
<li>Invoke SceneGraph::ExcludeCollisions*() to filter collisions.</li>
<li>Allocate context.</li>
</ol>
<p>Changing the order will cause exceptions to be thrown.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].default_coulomb_friction">
<code class="descname">default_coulomb_friction</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.plant.CoulombFriction_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].default_coulomb_friction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the friction coefficients provided during geometry
registration for the given geometry <code class="docutils literal"><span class="pre">id</span></code>. We call these the
“default” coefficients but note that we mean user-supplied
per-geometry default, not something more global.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not correspond to a geometry in</li>
<li><code class="docutils literal"><span class="pre">this</span></code> model registered for contact modeling.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RegisterCollisionGeometry() for details on geometry registration.
(Deprecated.)</p>
</div>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>default_coulomb_friction() will be removed. Please use SceneGraph
which now stores friction properties in ProximityProperties. See
the section “Accessing point contact parameters” in the
documentation for MultibodyPlant. This will be removed from Drake
on or after 2020-09-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].EvalBodyPoseInWorld">
<code class="descname">EvalBodyPoseInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].EvalBodyPoseInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the pose <code class="docutils literal"><span class="pre">X_WB</span></code> of a body B in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">body_B</span></code>:</dt>
<dd>The body B for which the pose is requested.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">X_WB</span></code>:</dt>
<dd>The pose of body frame B in the world frame W.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if Finalize() was not called on <code class="docutils literal"><span class="pre">this</span></code> model or if</li>
<li><code class="docutils literal"><span class="pre">body_B</span></code> does not belong to this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].EvalBodySpatialVelocityInWorld">
<code class="descname">EvalBodySpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].EvalBodySpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the spatial velocity <code class="docutils literal"><span class="pre">V_WB</span></code> of a body B in the world frame
W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">body_B</span></code>:</dt>
<dd>The body B for which the spatial velocity is requested.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">V_WB The spatial velocity of body frame B in the world frame W.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if Finalize() was not called on <code class="docutils literal"><span class="pre">this</span></code> model or if</li>
<li><code class="docutils literal"><span class="pre">body_B</span></code> does not belong to this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].Finalize">
<code class="descname">Finalize</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].Finalize" title="Permalink to this definition">¶</a></dt>
<dd><p>This method must be called after all elements in the model (joints,
bodies, force elements, constraints, etc.) are added and before any
computations are performed. It essentially compiles all the necessary
“topological information”, i.e. how bodies, joints and, any other
elements connect with each other, and performs all the required
pre-processing to enable computations at a later stage.</p>
<p>If the finalize stage is successful, the topology of this
MultibodyPlant is valid, meaning that the topology is up-to-date after
this call. No more multibody elements can be added after a call to
Finalize().</p>
<p>At Finalize(), state and input/output ports for <code class="docutils literal"><span class="pre">this</span></code> plant are
declared. If <code class="docutils literal"><span class="pre">this</span></code> plant registered geometry with a SceneGraph,
input and output ports to enable communication with that SceneGraph
are declared as well.</p>
<p>If geometry has been registered on a SceneGraph instance, that
instance must be provided to the Finalize() method so that any
geometric implications of the finalization process can be
appropriately handled.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">is_finalized().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the MultibodyPlant has already been finalized.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].geometry_source_is_registered">
<code class="descname">geometry_source_is_registered</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].geometry_source_is_registered" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant was registered with a
SceneGraph. This method can be called at any time during the lifetime
of <code class="docutils literal"><span class="pre">this</span></code> plant to query if <code class="docutils literal"><span class="pre">this</span></code> plant has been registered with
a SceneGraph, either pre- or post-finalize, see Finalize().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_actuation_input_port">
<code class="descname">get_actuation_input_port</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_actuation_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[float]) -&gt; pydrake.systems.framework.InputPort_[float]</li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for the case where only one model instance has actuated dofs. This
input port is a vector valued port, which can be set with
JointActuator::set_actuation_vector().</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called before Finalize(), if the model does not</li>
<li>contain any actuators, or if multiple model instances have</li>
<li>actuated dofs.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>get_actuation_input_port(self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.InputPort_[float]</li>
</ol>
<p>Returns a constant reference to the input port for external actuation
for a specific model instance. This input port is a vector valued
port, which can be set with JointActuator::set_actuation_vector().</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_applied_generalized_force_input_port">
<code class="descname">get_applied_generalized_force_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_applied_generalized_force_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the vector-valued input port for
applied generalized forces, and the vector will be added directly into
<code class="docutils literal"><span class="pre">tau</span></code> (see mbp_equations_of_motion “System dynamics”). This vector
is ordered using the same convention as the plant velocities: you can
set the generalized forces that will be applied to model instance i
using, e.g., <code class="docutils literal"><span class="pre">SetVelocitiesInArray(i,</span> <span class="pre">model_forces,</span> <span class="pre">&amp;force_array)</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_applied_spatial_force_input_port">
<code class="descname">get_applied_spatial_force_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_applied_spatial_force_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the input port for applying spatial
forces to bodies in the plant. The data type for the port is an
std::vector of ExternallyAppliedSpatialForce; any number of spatial
forces can be applied to any number of bodies in the plant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_body">
<code class="descname">get_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], body_index: pydrake.multibody.tree.BodyIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the body with unique index
<code class="docutils literal"><span class="pre">body_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">body_index</span></code> does not correspond to a body in</li>
<li>this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_body_poses_output_port">
<code class="descname">get_body_poses_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_body_poses_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of all body poses in the world frame. You can
obtain the pose <code class="docutils literal"><span class="pre">X_WB</span></code> of a body B in the world frame W with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">X_WB_all</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">get_body_poses_output_port</span><span class="p">()</span><span class="o">.</span>
      <span class="o">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">math</span><span class="p">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">BodyIndex</span> <span class="n">arm_body_index</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s2">&quot;arm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">math</span><span class="p">::</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">X_WArm</span> <span class="o">=</span> <span class="n">X_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
<p>As shown in the example above, the resulting <code class="docutils literal"><span class="pre">std::vector</span></code> of body
poses is indexed by BodyIndex, and it has size num_bodies(). BodyIndex
“zero” (0) always corresponds to the world body, with pose equal to
the identity at all times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_body_spatial_accelerations_output_port">
<code class="descname">get_body_spatial_accelerations_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_body_spatial_accelerations_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of all body spatial accelerations in the world
frame. You can obtain the spatial acceleration <code class="docutils literal"><span class="pre">A_WB</span></code> of a body B in
the world frame W with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">A_WB_all</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">get_body_spatial_accelerations_output_port</span><span class="p">()</span><span class="o">.</span>
      <span class="o">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialAcceleration</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">BodyIndex</span> <span class="n">arm_body_index</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s2">&quot;arm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">A_WArm</span> <span class="o">=</span> <span class="n">A_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
<p>As shown in the example above, the resulting <code class="docutils literal"><span class="pre">std::vector</span></code> of body
spatial accelerations is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial acceleration at all times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_body_spatial_velocities_output_port">
<code class="descname">get_body_spatial_velocities_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_body_spatial_velocities_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of all body spatial velocities in the world
frame. You can obtain the spatial velocity <code class="docutils literal"><span class="pre">V_WB</span></code> of a body B in the
world frame W with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">V_WB_all</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">get_body_spatial_velocities_output_port</span><span class="p">()</span><span class="o">.</span>
      <span class="o">.</span><span class="n">Eval</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">BodyIndex</span> <span class="n">arm_body_index</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">GetBodyByName</span><span class="p">(</span><span class="s2">&quot;arm&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">();</span>
  <span class="n">const</span> <span class="n">SpatialVelocity</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">V_WArm</span> <span class="o">=</span> <span class="n">V_WB_all</span><span class="p">[</span><span class="n">arm_body_index</span><span class="p">];</span>
</pre></div>
</div>
<p>As shown in the example above, the resulting <code class="docutils literal"><span class="pre">std::vector</span></code> of body
spatial velocities is indexed by BodyIndex, and it has size
num_bodies(). BodyIndex “zero” (0) always corresponds to the world
body, with zero spatial velocity at all times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_contact_penalty_method_time_scale">
<code class="descname">get_contact_penalty_method_time_scale</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_contact_penalty_method_time_scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a time-scale estimate <code class="docutils literal"><span class="pre">tc</span></code> based on the requested
penetration allowance δ set with set_penetration_allowance(). For the
penalty method in use to enforce non-penetration, this time scale
relates to the time it takes the relative normal velocity between two
bodies to go to zero. This time scale <code class="docutils literal"><span class="pre">tc</span></code> is artificially
introduced by the penalty method and goes to zero in the limit to
ideal rigid contact. Since numerical integration methods for continuum
systems must be able to resolve a system’s dynamics, the time step
used by an integrator must in general be much smaller than the time
scale <code class="docutils literal"><span class="pre">tc</span></code>. How much smaller will depend on the details of the
problem and the convergence characteristics of the integrator and
should be tuned appropriately. Another factor to take into account for
setting up the simulation’s time step is the speed of the objects in
your simulation. If <code class="docutils literal"><span class="pre">vn</span></code> represents a reference velocity scale for
the normal relative velocity between bodies, the new time scale <code class="docutils literal"><span class="pre">tn</span> <span class="pre">=</span>
<span class="pre">δ</span> <span class="pre">/</span> <span class="pre">vn</span></code> represents the time it would take for the distance between
two bodies approaching with relative normal velocity <code class="docutils literal"><span class="pre">vn</span></code> to
decrease by the penetration_allowance δ. In this case a user should
choose a time step for simulation that can resolve the smallest of the
two time scales <code class="docutils literal"><span class="pre">tc</span></code> and <code class="docutils literal"><span class="pre">tn</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_contact_results_output_port">
<code class="descname">get_contact_results_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_contact_results_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the port that outputs ContactResults.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize, see Finalize().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_frame">
<code class="descname">get_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], frame_index: pydrake.multibody.tree.FrameIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the frame with unique index
<code class="docutils literal"><span class="pre">frame_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">frame_index</span></code> does not correspond to a frame in</li>
<li>this plant.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_generalized_acceleration_output_port">
<code class="descname">get_generalized_acceleration_output_port</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_generalized_acceleration_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[float]) -&gt; pydrake.systems.framework.OutputPort_[float]</li>
</ol>
<p>Returns a constant reference to the output port for generalized
accelerations v̇ of the model.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>get_generalized_acceleration_output_port(self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[float]</li>
</ol>
<p>Returns a constant reference to the output port for the generalized
accelerations v̇ᵢ ⊆ v̇ for model instance i.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_generalized_contact_forces_output_port">
<code class="descname">get_generalized_contact_forces_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_generalized_contact_forces_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the output port of generalized contact
forces for a specific model instance.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_geometry_poses_output_port">
<code class="descname">get_geometry_poses_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_geometry_poses_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port of frames’ poses to communicate with a
SceneGraph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_geometry_query_input_port">
<code class="descname">get_geometry_query_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_geometry_query_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the input port used to perform
geometric queries on a SceneGraph. See
SceneGraph::get_query_output_port(). Refer to section mbp_geometry
“Geometry” of this class’s documentation for further details on
collision geometry registration and connection with a SceneGraph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_joint">
<code class="descname">get_joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], joint_index: pydrake.multibody.tree.JointIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the joint with unique index
<code class="docutils literal"><span class="pre">joint_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError when <code class="docutils literal"><span class="pre">joint_index</span></code> does not correspond to a joint</li>
<li>in this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_joint_actuator">
<code class="descname">get_joint_actuator</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], actuator_index: pydrake.multibody.tree.JointActuatorIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuator_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_joint_actuator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the joint actuator with unique index
<code class="docutils literal"><span class="pre">actuator_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">actuator_index</span></code> does not correspond to a joint</li>
<li>actuator in this tree.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_reaction_forces_output_port">
<code class="descname">get_reaction_forces_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_reaction_forces_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the port for joint reaction forces. A Joint models the
kinematical relationship which characterizes the possible relative
motion between two bodies. In Drake, a joint connects a frame <code class="docutils literal"><span class="pre">Jp</span></code>
on <em>parent</em> body P with a frame <code class="docutils literal"><span class="pre">Jc</span></code> on a <em>child</em> body C. This usage
of the terms <em>parent</em> and <em>child</em> is just a convention and implies
nothing about the inboard-outboard relationship between the bodies.
Since a Joint imposes a kinematical relationship which characterizes
the possible relative motion between frames Jp and Jc, reaction forces
on each body are established. That is, we could cut the model at the
joint and replace it with equivalent forces equal to these reaction
forces in order to attain the same motions of the mechanical system.</p>
<p>This output port allows to evaluate the reaction force <code class="docutils literal"><span class="pre">F_CJc_Jc</span></code> on
the <em>child</em> body C, at <code class="docutils literal"><span class="pre">Jc</span></code>, and expressed in Jc for all joints in
the model. This port evaluates to a vector of type
std::vector&lt;SpatialForce&lt;T&gt;&gt; and size num_joints() indexed by
JointIndex, see Joint::index(). Each entry corresponds to the spatial
force <code class="docutils literal"><span class="pre">F_CJc_Jc</span></code> applied on the joint’s child body C
(Joint::child_body()), at the joint’s child frame <code class="docutils literal"><span class="pre">Jc</span></code>
(Joint::frame_on_child()) and expressed in frame <code class="docutils literal"><span class="pre">Jc</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_source_id">
<code class="descname">get_source_id</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; Optional[pydrake.geometry.SourceId]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_source_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unique id identifying <code class="docutils literal"><span class="pre">this</span></code> plant as a source for a
SceneGraph. Returns <code class="docutils literal"><span class="pre">nullopt</span></code> if <code class="docutils literal"><span class="pre">this</span></code> plant did not register any
geometry. This method can be called at any time during the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> plant to query if <code class="docutils literal"><span class="pre">this</span></code> plant has been registered with a
SceneGraph, either pre- or post-finalize, see Finalize(). However, a
geometry::SourceId is only assigned once at the first call of any of
this plant’s geometry registration methods, and it does not change
after that. Post-finalize calls will always return the same value.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].get_state_output_port">
<code class="descname">get_state_output_port</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].get_state_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[float]) -&gt; pydrake.systems.framework.OutputPort_[float]</li>
</ol>
<p>Returns a constant reference to the output port for the multibody
state x = [q, v] of the model.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>get_state_output_port(self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.systems.framework.OutputPort_[float]</li>
</ol>
<p>Returns a constant reference to the output port for the state xᵢ = [qᵢ
vᵢ] of model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.)</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Finalize() was already called on <code class="docutils literal"><span class="pre">this</span></code> plant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called before Finalize().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the model instance does not exist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetAccelerationLowerLimits">
<code class="descname">GetAccelerationLowerLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetAccelerationLowerLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of size <code class="docutils literal"><span class="pre">num_velocities()</span></code> containing the lower
acceleration limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetAccelerationUpperLimits">
<code class="descname">GetAccelerationUpperLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetAccelerationUpperLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit analog of GetAccelerationsLowerLimits(), where any
unbounded or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetAccelerationLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetBodyByName">
<code class="descname">GetBodyByName</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetBodyByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str) -&gt; pydrake.multibody.tree.Body_[float]</li>
</ol>
<p>Returns a constant reference to a body that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no body with the requested name.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the body name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasBodyNamed() to query if there exists a body in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li>GetBodyByName(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.Body_[float]</li>
</ol>
<p>Returns a constant reference to the body that is uniquely identified
by the string <code class="docutils literal"><span class="pre">name</span></code> and <code class="docutils literal"><span class="pre">model_instance</span></code> in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no body with the requested name.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasBodyNamed() to query if there exists a body in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetBodyFrameIdIfExists">
<code class="descname">GetBodyFrameIdIfExists</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], body_index: pydrake.multibody.tree.BodyIndex</em><span class="sig-paren">)</span> &#x2192; Optional[pydrake.geometry.FrameId]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetBodyFrameIdIfExists" title="Permalink to this definition">¶</a></dt>
<dd><p>If the body with <code class="docutils literal"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise, it
returns nullopt.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetBodyFrameIdOrThrow">
<code class="descname">GetBodyFrameIdOrThrow</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], body_index: pydrake.multibody.tree.BodyIndex</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.FrameId<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetBodyFrameIdOrThrow" title="Permalink to this definition">¶</a></dt>
<dd><p>If the body with <code class="docutils literal"><span class="pre">body_index</span></code> belongs to the called plant, it
returns the geometry::FrameId associated with it. Otherwise this
method throws an exception.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the called plant does not have the body indicated</li>
<li>by <code class="docutils literal"><span class="pre">body_index</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetBodyFromFrameId">
<code class="descname">GetBodyFromFrameId</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], arg0: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetBodyFromFrameId" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a geometry frame identifier, returns a pointer to the body
associated with that id (nullptr if there is no such body).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetBodyIndices">
<code class="descname">GetBodyIndices</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex</em><span class="sig-paren">)</span> &#x2192; List[pydrake.multibody.tree.BodyIndex]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetBodyIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of body indices associated with <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetCollisionGeometriesForBody">
<code class="descname">GetCollisionGeometriesForBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.GeometryId]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetCollisionGeometriesForBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of GeometryId’s identifying the different contact
geometries for <code class="docutils literal"><span class="pre">body</span></code> previously registered with a SceneGraph.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method can be called at any time during the lifetime of
<code class="docutils literal"><span class="pre">this</span></code> plant, either pre- or post-finalize, see Finalize().
Post-finalize calls will always return the same value.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RegisterCollisionGeometry(), Finalize()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetDefaultFreeBodyPose">
<code class="descname">GetDefaultFreeBodyPose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetDefaultFreeBodyPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default pose of <code class="docutils literal"><span class="pre">body</span></code> as set by SetDefaultFreeBodyPose().</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">body</span></code>:</dt>
<dd>Body whose default pose will be retrieved.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetFrameByName">
<code class="descname">GetFrameByName</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetFrameByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str) -&gt; pydrake.multibody.tree.Frame_[float]</li>
</ol>
<p>Returns a constant reference to a frame that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no frame with the requested name.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the frame name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasFrameNamed() to query if there exists a frame in <code class="docutils literal"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
<ol class="arabic simple" start="2">
<li>GetFrameByName(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; pydrake.multibody.tree.Frame_[float]</li>
</ol>
<p>Returns a constant reference to the frame that is uniquely identified
by the string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no frame with the requested name.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasFrameNamed() to query if there exists a frame in <code class="docutils literal"><span class="pre">this</span></code> model
with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetJointActuatorByName">
<code class="descname">GetJointActuatorByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], name: str</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuator_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetJointActuatorByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to an actuator that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if there is no actuator with the requested name.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the actuator name occurs in multiple model</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">instances.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasJointActuatorNamed() to query if there exists an actuator in
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetJointByName">
<code class="descname">GetJointByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetJointByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal"><span class="pre">JointType</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">JointType</span></code>:</dt>
<dd>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the named joint is not of type <code class="docutils literal"><span class="pre">JointType</span></code> or if</li>
<li>there is no Joint with that name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasJointNamed() to query if there exists a joint in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetModelInstanceByName">
<code class="descname">GetModelInstanceByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], name: str</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetModelInstanceByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the model instance that is uniquely identified by
the string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no instance with the requested name.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasModelInstanceNamed() to query if there exists an instance in
<code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetModelInstanceName">
<code class="descname">GetModelInstanceName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetModelInstanceName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of a <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError when <code class="docutils literal"><span class="pre">model_instance</span></code> does not correspond to a</li>
<li>model in this model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetMutableJointByName">
<code class="descname">GetMutableJointByName</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetMutableJointByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to a joint that is identified by the
string <code class="docutils literal"><span class="pre">name</span></code> in <code class="docutils literal"><span class="pre">this</span></code> MultibodyPlant. If the optional template
argument is supplied, then the returned value is downcast to the
specified <code class="docutils literal"><span class="pre">JointType</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">JointType</span></code>:</dt>
<dd>The specific type of the Joint to be retrieved. It must be a
subclass of Joint.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the named joint is not of type <code class="docutils literal"><span class="pre">JointType</span></code> or if</li>
<li>there is no Joint with that name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">HasJointNamed() to query if there exists a joint in <code class="docutils literal"><span class="pre">this</span></code>
MultibodyPlant with a given specified name.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetMutablePositions">
<code class="descname">GetMutablePositions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1], flags.writeable]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetMutablePositions" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a mutable vector reference containing the vector of
generalized positions (<strong>see warning</strong>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You should use SetPositions() instead of this method unless you
are fully aware of the possible interactions with the caching
mechanism (see dangerous_get_mutable).</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr or if it does not</li>
<li>correspond to the context for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetMutablePositionsAndVelocities">
<code class="descname">GetMutablePositionsAndVelocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1], flags.writeable]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetMutablePositionsAndVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a mutable vector containing the vector <code class="docutils literal"><span class="pre">[q;</span> <span class="pre">v]</span></code>
of the model with <code class="docutils literal"><span class="pre">q</span></code> the vector of generalized positions and <code class="docutils literal"><span class="pre">v</span></code>
the vector of generalized velocities (<strong>see warning</strong>).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You should use SetPositionsAndVelocities() instead of this method
unless you are fully aware of the interactions with the caching
mechanism (see dangerous_get_mutable).</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr or if it does not</li>
<li>correspond to the context for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetMutableVelocities">
<code class="descname">GetMutableVelocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1], flags.writeable]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetMutableVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>See GetMutableVelocities() method above.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetPositionLowerLimits">
<code class="descname">GetPositionLowerLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetPositionLowerLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of size <code class="docutils literal"><span class="pre">num_positions()</span></code> containing the lower
position limits for every generalized position coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetPositions">
<code class="descname">GetPositions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetPositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the vector of generalized
positions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns an vector containing the generalized positions (<code class="docutils literal"><span class="pre">q</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">q.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">q.size()</span></code>) time.</p>
</div>
<ol class="arabic simple" start="3">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the vector of generalized
positions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>GetPositions(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns an vector containing the generalized positions (<code class="docutils literal"><span class="pre">q</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">q.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">q.size()</span></code>) time.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetPositionsAndVelocities">
<code class="descname">GetPositionsAndVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetPositionsAndVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the vector <code class="docutils literal"><span class="pre">[q;</span> <span class="pre">v]</span></code> with
<code class="docutils literal"><span class="pre">q</span></code> the vector of generalized positions and <code class="docutils literal"><span class="pre">v</span></code> the vector of
generalized velocities.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns the vector <code class="docutils literal"><span class="pre">[q;</span> <span class="pre">v]</span></code> of the model with <code class="docutils literal"><span class="pre">q</span></code> the vector of
generalized positions and <code class="docutils literal"><span class="pre">v</span></code> the vector of generalized velocities
for model instance <code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model or <code class="docutils literal"><span class="pre">model_instance</span></code> is invalid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">q.size()</span> <span class="pre">+</span> <span class="pre">v.size()</span></code>
associated with <code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">q.size()</span></code>) time.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetPositionsFromArray">
<code class="descname">GetPositionsFromArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetPositionsFromArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of generalized positions for <code class="docutils literal"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal"><span class="pre">q_array</span></code> of generalized positions for the entire model
model. This method throws an exception if <code class="docutils literal"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetPositionUpperLimits">
<code class="descname">GetPositionUpperLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetPositionUpperLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit analog of GetPositionsLowerLimits(), where any unbounded
or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetPositionLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetTopologyGraphvizString">
<code class="descname">GetTopologyGraphvizString</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetTopologyGraphvizString" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Graphviz string describing the topology of this plant. To
render the string, use the Graphviz tool, <code class="docutils literal"><span class="pre">dot</span></code>.
<a class="reference external" href="http://www.graphviz.org/">http://www.graphviz.org/</a></p>
<p>Note: this method can be called either before or after <code class="docutils literal"><span class="pre">Finalize()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetVelocities">
<code class="descname">GetVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the generalized
velocities.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<ol class="arabic simple" start="2">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns a vector containing the generalized velocities (<code class="docutils literal"><span class="pre">v</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">v.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">v.size()</span></code>) time.</p>
</div>
<ol class="arabic simple" start="3">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns a const vector reference containing the generalized
velocities.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method returns a reference to existing data, exhibits
constant i.e., O(1) time complexity, and runs very quickly.</p>
</div>
<ol class="arabic simple" start="4">
<li>GetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Returns a vector containing the generalized velocities (<code class="docutils literal"><span class="pre">v</span></code>) for the
given model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> does not correspond to the context</li>
<li>for a multibody model.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">returns a dense vector of dimension <code class="docutils literal"><span class="pre">v.size()</span></code> associated with
<code class="docutils literal"><span class="pre">model_instance</span></code> in O(<code class="docutils literal"><span class="pre">v.size()</span></code>) time.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetVelocitiesFromArray">
<code class="descname">GetVelocitiesFromArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetVelocitiesFromArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of generalized velocities for <code class="docutils literal"><span class="pre">model_instance</span></code> from
a vector <code class="docutils literal"><span class="pre">v</span></code> of generalized velocities for the entire MultibodyPlant
model. This method throws an exception if the input array is not of
size MultibodyPlant::num_velocities().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetVelocityLowerLimits">
<code class="descname">GetVelocityLowerLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetVelocityLowerLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a vector of size <code class="docutils literal"><span class="pre">num_velocities()</span></code> containing the lower
velocity limits for every generalized velocity coordinate. These
include joint and free body coordinates. Any unbounded or unspecified
limits will be -infinity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].GetVelocityUpperLimits">
<code class="descname">GetVelocityUpperLimits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].GetVelocityUpperLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper limit analog of GetVelocitysLowerLimits(), where any unbounded
or unspecified limits will be +infinity.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetVelocityLowerLimits() for more information.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].gravity_field">
<code class="descname">gravity_field</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniformGravityFieldElement_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].gravity_field" title="Permalink to this definition">¶</a></dt>
<dd><p>An accessor to the current gravity field.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].HasBodyNamed">
<code class="descname">HasBodyNamed</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].HasBodyNamed" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a body named <code class="docutils literal"><span class="pre">name</span></code> was added to the MultibodyPlant.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddRigidBody().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the body name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>HasBodyNamed(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a body named <code class="docutils literal"><span class="pre">name</span></code> was added to the MultibodyPlant
in <code class="docutils literal"><span class="pre">model_instance</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddRigidBody().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].HasJointActuatorNamed">
<code class="descname">HasJointActuatorNamed</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].HasJointActuatorNamed" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if an actuator named <code class="docutils literal"><span class="pre">name</span></code> was added to this model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJointActuator().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the actuator name occurs in multiple model</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">instances.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>HasJointActuatorNamed(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if an actuator named <code class="docutils literal"><span class="pre">name</span></code> was added to
<code class="docutils literal"><span class="pre">model_instance</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJointActuator().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].HasJointNamed">
<code class="descname">HasJointNamed</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].HasJointNamed" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a joint named <code class="docutils literal"><span class="pre">name</span></code> was added to this model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJoint().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the joint name occurs in multiple model instances.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>HasJointNamed(self: pydrake.multibody.plant.MultibodyPlant_[float], name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; bool</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a joint named <code class="docutils literal"><span class="pre">name</span></code> was added to
<code class="docutils literal"><span class="pre">model_instance</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJoint().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">model_instance</span></code> is not valid for this model.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].HasModelInstanceNamed">
<code class="descname">HasModelInstanceNamed</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], name: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].HasModelInstanceNamed" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if a model instance named <code class="docutils literal"><span class="pre">name</span></code> was added to this
model.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddModelInstance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].is_finalized">
<code class="descname">is_finalized</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].is_finalized" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if this MultibodyPlant was finalized with a call to
Finalize().</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Finalize().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].MakeActuationMatrix">
<code class="descname">MakeActuationMatrix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].MakeActuationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This method creates an actuation matrix B mapping a vector of
actuation values u into generalized forces <code class="docutils literal"><span class="pre">tau_u</span> <span class="pre">=</span> <span class="pre">B</span> <span class="pre">*</span> <span class="pre">u</span></code>, where B
is a matrix of size <code class="docutils literal"><span class="pre">nv</span> <span class="pre">x</span> <span class="pre">nu</span></code> with <code class="docutils literal"><span class="pre">nu</span></code> equal to num_actuators()
and <code class="docutils literal"><span class="pre">nv</span></code> equal to num_velocities(). The vector u of actuation values
is of size num_actuators(). For a given JointActuator,
<code class="docutils literal"><span class="pre">u[JointActuator::index()]</span></code> stores the value for the external
actuation corresponding to that actuator. <code class="docutils literal"><span class="pre">tau_u</span></code> on the other hand
is indexed by generalized velocity indexes according to
<code class="docutils literal"><span class="pre">Joint::velocity_start()</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">B is a permutation matrix. While making a permutation has <code class="docutils literal"><span class="pre">O(n)</span></code>
complexity, making a full B matrix has <code class="docutils literal"><span class="pre">O(n²)</span></code> complexity. For
most applications this cost can be neglected but it could become
significant for very large systems.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].MapQDotToVelocity">
<code class="descname">MapQDotToVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], qdot: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].MapQDotToVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the time derivative <code class="docutils literal"><span class="pre">qdot</span></code> of the generalized positions
vector <code class="docutils literal"><span class="pre">q</span></code> (stored in <code class="docutils literal"><span class="pre">context</span></code>) to generalized velocities <code class="docutils literal"><span class="pre">v</span></code>.
<cite>v</cite> and <code class="docutils literal"><span class="pre">q̇</span></code> are related linearly by <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Although
<code class="docutils literal"><span class="pre">N(q)</span></code> is not necessarily square, its left pseudo-inverse <code class="docutils literal"><span class="pre">N⁺(q)</span></code>
can be used to invert that relationship without residual error,
provided that <code class="docutils literal"><span class="pre">qdot</span></code> is in the range space of <code class="docutils literal"><span class="pre">N(q)</span></code> (that is, if
it <em>could</em> have been produced as <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code> for some <code class="docutils literal"><span class="pre">v</span></code>).
Using the configuration <code class="docutils literal"><span class="pre">q</span></code> stored in the given <code class="docutils literal"><span class="pre">context</span></code> this
method calculates <code class="docutils literal"><span class="pre">v</span> <span class="pre">=</span> <span class="pre">N⁺(q)⋅q̇</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">qdot</span></code>:</dt>
<dd>A vector containing the time derivatives of the generalized
positions. This method aborts if <code class="docutils literal"><span class="pre">qdot</span></code> is not of size
num_positions().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">v</span></code>:</dt>
<dd>A valid (non-null) pointer to a vector in <code class="docutils literal"><span class="pre">ℛⁿ</span></code> with n the number
of generalized velocities. This method aborts if v is nullptr or
if it is not of size num_velocities().</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MapVelocityToQDot()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Mobilizer::MapQDotToVelocity()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].MapVelocityToQDot">
<code class="descname">MapVelocityToQDot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], v: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].MapVelocityToQDot" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms generalized velocities v to time derivatives <code class="docutils literal"><span class="pre">qdot</span></code> of
the generalized positions vector <code class="docutils literal"><span class="pre">q</span></code> (stored in <code class="docutils literal"><span class="pre">context</span></code>). <cite>v</cite>
and <code class="docutils literal"><span class="pre">qdot</span></code> are related linearly by <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>. Using the
configuration <code class="docutils literal"><span class="pre">q</span></code> stored in the given <code class="docutils literal"><span class="pre">context</span></code> this method
calculates <code class="docutils literal"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">N(q)⋅v</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The context containing the state of the model.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">v</span></code>:</dt>
<dd>A vector of of generalized velocities for this model. This method
aborts if v is not of size num_velocities().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">qdot</span></code>:</dt>
<dd>A valid (non-null) pointer to a vector in <code class="docutils literal"><span class="pre">ℝⁿ</span></code> with n being the
number of generalized positions in this model, given by
<code class="docutils literal"><span class="pre">num_positions()</span></code>. This method aborts if <code class="docutils literal"><span class="pre">qdot</span></code> is nullptr or
if it is not of size num_positions().</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MapQDotToVelocity()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Mobilizer::MapVelocityToQDot()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].mutable_gravity_field">
<code class="descname">mutable_gravity_field</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniformGravityFieldElement_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].mutable_gravity_field" title="Permalink to this definition">¶</a></dt>
<dd><p>A mutable accessor to the current gravity field.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].num_actuated_dofs">
<code class="descname">num_actuated_dofs</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].num_actuated_dofs" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[float]) -&gt; int</li>
</ol>
<p>Returns the total number of actuated degrees of freedom. That is, the
vector of actuation values u has this size. See AddJointActuator().</p>
<ol class="arabic simple" start="2">
<li>num_actuated_dofs(self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the total number of actuated degrees of freedom for a specific
model instance. That is, the vector of actuation values u has this
size. See AddJointActuator().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].num_actuators">
<code class="descname">num_actuators</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].num_actuators" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of joint actuators in the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJointActuator().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].num_bodies">
<code class="descname">num_bodies</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].num_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of bodies in the model, including the “world” body,
which is always part of the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddRigidBody().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].num_collision_geometries">
<code class="descname">num_collision_geometries</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].num_collision_geometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of geometries registered for contact modeling. This
method can be called at any time during the lifetime of <code class="docutils literal"><span class="pre">this</span></code>
plant, either pre- or post-finalize, see Finalize(). Post-finalize
calls will always return the same value.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].num_force_elements">
<code class="descname">num_force_elements</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].num_force_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of ForceElement objects.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddForceElement().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].num_frames">
<code class="descname">num_frames</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].num_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of Frame objects in this model. Frames include body
frames associated with each of the bodies, including the <em>world</em> body.
This means the minimum number of frames is one.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].num_joints">
<code class="descname">num_joints</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].num_joints" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of joints in the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddJoint().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].num_model_instances">
<code class="descname">num_model_instances</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].num_model_instances" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of model instances in the model.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddModelInstance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].num_multibody_states">
<code class="descname">num_multibody_states</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].num_multibody_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[float]) -&gt; int</li>
</ol>
<p>Returns the size of the multibody system state vector x = [q v]. This
will be <code class="docutils literal"><span class="pre">num_positions()</span></code> plus <code class="docutils literal"><span class="pre">num_velocities()</span></code>.</p>
<ol class="arabic simple" start="2">
<li>num_multibody_states(self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the size of the multibody system state vector xᵢ = [qᵢ vᵢ] for
model instance i. (Here qᵢ ⊆ q and vᵢ ⊆ v.) will be
<code class="docutils literal"><span class="pre">num_positions(model_instance)</span></code> plus
<code class="docutils literal"><span class="pre">num_velocities(model_instance)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].num_positions">
<code class="descname">num_positions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].num_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[float]) -&gt; int</li>
</ol>
<p>Returns the size of the generalized position vector q for this model.</p>
<ol class="arabic simple" start="2">
<li>num_positions(self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the size of the generalized position vector qᵢ for model
instance i.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[float]) -&gt; int</li>
</ol>
<p>Returns the size of the generalized velocity vector v for this model.</p>
<ol class="arabic simple" start="2">
<li>num_velocities(self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex) -&gt; int</li>
</ol>
<p>Returns the size of the generalized velocity vector vᵢ for model
instance i.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].RegisterAsSourceForSceneGraph">
<code class="descname">RegisterAsSourceForSceneGraph</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], scene_graph: pydrake.geometry.SceneGraph_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.SourceId<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].RegisterAsSourceForSceneGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers <code class="docutils literal"><span class="pre">this</span></code> plant to serve as a source for an instance of
SceneGraph. This registration allows MultibodyPlant to register
geometry with <code class="docutils literal"><span class="pre">scene_graph</span></code> for visualization and/or collision
queries. Successive registration calls with SceneGraph <strong>must</strong> be
performed on the same instance to which the pointer argument
<code class="docutils literal"><span class="pre">scene_graph</span></code> points to. Failure to do so will result in runtime
exceptions.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">scene_graph</span></code>:</dt>
<dd>A valid non nullptr to the SceneGraph instance for which <code class="docutils literal"><span class="pre">this</span></code>
plant will sever as a source, see SceneGraph documentation for
further details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the SourceId of <code class="docutils literal"><span class="pre">this</span></code> plant in <code class="docutils literal"><span class="pre">scene_graph</span></code>. It can also
later on be retrieved with get_source_id().</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called post-finalize.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">scene_graph</span></code> is the nullptr.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called more than once.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].RegisterCollisionGeometry">
<code class="descname">RegisterCollisionGeometry</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].RegisterCollisionGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, properties: pydrake.geometry.ProximityProperties) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Registers geometry in a SceneGraph with a given geometry::Shape to be
used for the contact modeling of a given <code class="docutils literal"><span class="pre">body</span></code>. More than one
geometry can be registered with a body, in which case the body’s
contact geometry is the union of all geometries registered to that
body.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">body</span></code>:</dt>
<dd>The body for which geometry is being registered.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_BG</span></code>:</dt>
<dd>The fixed pose of the geometry frame G in the body frame B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">shape</span></code>:</dt>
<dd>The geometry::Shape used for visualization. E.g.:
geometry::Sphere, geometry::Cylinder, etc.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">properties</span></code>:</dt>
<dd>The proximity properties associated with the collision geometry.
They <em>must</em> include the (<code class="docutils literal"><span class="pre">material</span></code>, <cite>coulomb_friction</cite>)
property of type CoulombFriction&lt;double&gt;.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called post-finalize or if the properties are</li>
<li>missing the coulomb friction property (or if it is of the wrong</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">type).</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>RegisterCollisionGeometry(self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, coulomb_friction: pydrake.multibody.plant.CoulombFriction_[float]) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Overload which specifies a single property: coulomb_friction.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].RegisterVisualGeometry">
<code class="descname">RegisterVisualGeometry</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].RegisterVisualGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RegisterVisualGeometry(self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4, 1]]) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Overload for visual geometry registration; it converts the
<code class="docutils literal"><span class="pre">diffuse_color</span></code> (RGBA with values in the range [0, 1]) into a
geometry::ConnectDrakeVisualizer()-compatible set of
geometry::IllustrationProperties.</p>
<ol class="arabic simple" start="2">
<li>RegisterVisualGeometry(self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float], X_BG: pydrake.common.eigen_geometry.Isometry3_[float], shape: pydrake.geometry.Shape, name: str, diffuse_color: numpy.ndarray[numpy.float64[4, 1]], scene_graph: pydrake.geometry.SceneGraph_[float] = None) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].set_penetration_allowance">
<code class="descname">set_penetration_allowance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], penetration_allowance: float = 0.001</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].set_penetration_allowance" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the penetration allowance used to estimate the coefficients in
the penalty method used to impose non-penetration among bodies. Refer
to the section mbp_penalty_method “Contact by penalty method” for
further details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if penetration_allowance is not positive.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].set_stiction_tolerance">
<code class="descname">set_stiction_tolerance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], v_stiction: float = 0.001</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].set_stiction_tolerance" title="Permalink to this definition">¶</a></dt>
<dd><p><a href="#id107"><span class="problematic" id="id108">**</span></a>** Stribeck model of friction</p>
<p>Currently MultibodyPlant uses the Stribeck approximation to model dry
friction. The Stribeck model of friction is an approximation to
Coulomb’s law of friction that allows using continuous time
integration without the need to specify complementarity constraints.
While this results in a simpler model immediately tractable with
standard numerical methods for integration of ODE’s, it often leads to
stiff dynamics that require an explicit integrator to take very small
time steps. It is therefore recommended to use error controlled
integrators when using this model or the discrete time stepping (see
time_advancement_strategy “Choice of Time Advancement Strategy”). See
stribeck_approximation for a detailed discussion of the Stribeck
model.</p>
<p>Sets the stiction tolerance <code class="docutils literal"><span class="pre">v_stiction</span></code> for the Stribeck model,
where <code class="docutils literal"><span class="pre">v_stiction</span></code> must be specified in m/s (meters per second.)
<code class="docutils literal"><span class="pre">v_stiction</span></code> defaults to a value of 1 millimeter per second. In
selecting a value for <code class="docutils literal"><span class="pre">v_stiction</span></code>, you must ask yourself the
question, “When two objects are ostensibly in stiction, how much slip
am I willing to allow?” There are two opposing design issues in
picking a value for vₛ. On the one hand, small values of vₛ make the
problem numerically stiff during stiction, potentially increasing the
integration cost. On the other hand, it should be picked to be
appropriate for the scale of the problem. For example, a car
simulation could allow a “large” value for vₛ of 1 cm/s (1×10⁻² m/s),
but reasonable stiction for grasping a 10 cm box might require
limiting residual slip to 1×10⁻³ m/s or less. Ultimately, picking the
largest viable value will allow your simulation to run faster and more
robustly. Note that <code class="docutils literal"><span class="pre">v_stiction</span></code> is the slip velocity that we’d have
when we are at edge of the friction cone. For cases when the friction
force is well within the friction cone the slip velocity will always
be smaller than this value. See also stribeck_approximation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">v_stiction</span></code> is non-positive.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].SetActuationInArray">
<code class="descname">SetActuationInArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, u_instance: numpy.ndarray[numpy.float64[m, 1]], u: numpy.ndarray[numpy.float64[m, 1], flags.writeable]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].SetActuationInArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the actuation values <code class="docutils literal"><span class="pre">u_instance</span></code> for all actuators in
<code class="docutils literal"><span class="pre">model_instance</span></code>, this method sets the actuation vector u for the
entire model to which this actuator belongs to. This method throws an
exception if the size of <code class="docutils literal"><span class="pre">u_instance</span></code> is not equal to the number of
degrees of freedom of all of the actuated joints in
<code class="docutils literal"><span class="pre">model_instance</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">u_instance</span></code>:</dt>
<dd>Actuation values for the actuators. It must be of size equal to
the number of degrees of freedom of all of the actuated joints in
<code class="docutils literal"><span class="pre">model_instance</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">u</span></code>:</dt>
<dd>The vector containing the actuation values for the entire model.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].SetDefaultFreeBodyPose">
<code class="descname">SetDefaultFreeBodyPose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float], X_WB: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].SetDefaultFreeBodyPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default pose of <code class="docutils literal"><span class="pre">body</span></code>. If <code class="docutils literal"><span class="pre">body.is_floating()</span></code> is true,
this will affect subsequent calls to SetDefaultState(); otherwise,
this value is effectively ignored.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">body</span></code>:</dt>
<dd>Body whose default pose will be set.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_WB</span></code>:</dt>
<dd>Default pose of the body.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].SetDefaultState">
<code class="descname">SetDefaultState</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], state: pydrake.systems.framework.State_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].SetDefaultState" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">state</span></code> according to defaults set by the user for joints (e.g.
RevoluteJoint::set_default_angle()) and free bodies
(SetDefaultFreeBodyPose()). If the user does not specify defaults, the
state corresponds to zero generalized positions and velocities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize. See Finalize().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].SetFreeBodyPose">
<code class="descname">SetFreeBodyPose</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].SetFreeBodyPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetFreeBodyPose(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float], X_WB: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Sets <code class="docutils literal"><span class="pre">context</span></code> to store the pose <code class="docutils literal"><span class="pre">X_WB</span></code> of a given <code class="docutils literal"><span class="pre">body</span></code> B in
the world frame W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general setting the pose and/or velocity of a body in the model
would involve a complex inverse kinematics problem. This method
allows us to simplify this process when we know the body is free
in space.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">body</span></code> is not a free body in the model.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetFreeBodyPose(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], body: pydrake.multibody.tree.Body_[float], X_WB: pydrake.common.eigen_geometry.Isometry3_[float]) -&gt; None</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].SetFreeBodySpatialVelocity">
<code class="descname">SetFreeBodySpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], body: pydrake.multibody.tree.Body_[float], V_WB: pydrake.multibody.math.SpatialVelocity_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].SetFreeBodySpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">context</span></code> to store the spatial velocity <code class="docutils literal"><span class="pre">V_WB</span></code> of a given
<code class="docutils literal"><span class="pre">body</span></code> B in the world frame W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general setting the pose and/or velocity of a body in the model
would involve a complex inverse kinematics problem. This method
allows us to simplify this process when we know the body is free
in space.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">body</span></code> is not a free body in the model.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if called pre-finalize.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].SetPositions">
<code class="descname">SetPositions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].SetPositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], q: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized positions from the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">q</span></code> is not equal to <code class="docutils literal"><span class="pre">num_positions()</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetPositions(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized positions from the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">q</span></code> is not equal to <code class="docutils literal"><span class="pre">num_positions()</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].SetPositionsAndVelocities">
<code class="descname">SetPositionsAndVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].SetPositionsAndVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], q_v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized positions and velocities from the given vector
[q; v].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">q_v</span></code> is not equal to <a href="#id109"><span class="problematic" id="id110">``</span></a>num_positions() +</li>
<li>num_velocities()``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetPositionsAndVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Sets generalized positions and velocities from the given vector [q; v]
for the specified model instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, if the model</li>
<li>instance index is invalid, or if the length of <code class="docutils literal"><span class="pre">q_v</span></code> is not</li>
<li>equal to <a href="#id111"><span class="problematic" id="id112">``</span></a>num_positions(model_instance) +</li>
<li>num_velocities(model_instance)``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].SetPositionsInArray">
<code class="descname">SetPositionsInArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, q_instance: numpy.ndarray[numpy.float64[m, 1]], q: numpy.ndarray[numpy.float64[m, 1], flags.writeable]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].SetPositionsInArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the vector of generalized positions for <code class="docutils literal"><span class="pre">model_instance</span></code> in
<code class="docutils literal"><span class="pre">q</span></code> using <code class="docutils literal"><span class="pre">q_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal"><span class="pre">q</span></code> is not of size
MultibodyPlant::num_positions() or <code class="docutils literal"><span class="pre">q_instance</span></code> is not of size
<code class="docutils literal"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].SetVelocities">
<code class="descname">SetVelocities</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].SetVelocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Sets all generalized velocities from the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, or if the</li>
<li>length of <code class="docutils literal"><span class="pre">v</span></code> is not equal to <code class="docutils literal"><span class="pre">num_velocities()</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetVelocities(self: pydrake.multibody.plant.MultibodyPlant_[float], context: pydrake.systems.framework.Context_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Sets the generalized velocities for a particular model instance from
the given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the <code class="docutils literal"><span class="pre">context</span></code> is nullptr, if the context does</li>
<li>not correspond to the context for a multibody model, if the model</li>
<li>instance index is invalid, or if the length of <code class="docutils literal"><span class="pre">v_instance</span></code> is</li>
<li>not equal to <code class="docutils literal"><span class="pre">num_velocities(model_instance)</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].SetVelocitiesInArray">
<code class="descname">SetVelocitiesInArray</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float], model_instance: pydrake.multibody.tree.ModelInstanceIndex, v_instance: numpy.ndarray[numpy.float64[m, 1]], v: numpy.ndarray[numpy.float64[m, 1], flags.writeable]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].SetVelocitiesInArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the vector of generalized velocities for <code class="docutils literal"><span class="pre">model_instance</span></code> in
<code class="docutils literal"><span class="pre">v</span></code> using <code class="docutils literal"><span class="pre">v_instance</span></code>, leaving all other elements in the array
untouched. This method throws an exception if <code class="docutils literal"><span class="pre">v</span></code> is not of size
MultibodyPlant::num_velocities() or <code class="docutils literal"><span class="pre">v_instance</span></code> is not of size
<code class="docutils literal"><span class="pre">MultibodyPlant::num_positions(model_instance)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].time_step">
<code class="descname">time_step</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>The time step (or period) used to model <code class="docutils literal"><span class="pre">this</span></code> plant as a discrete
system with periodic updates. Returns 0 (zero) if the plant is modeled
as a continuous system. This property of the plant is specified at
construction and therefore this query can be performed either pre- or
post-finalize, see Finalize().</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MultibodyPlant::MultibodyPlant(double)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].WeldFrames">
<code class="descname">WeldFrames</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].WeldFrames" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>WeldFrames(self: pydrake.multibody.plant.MultibodyPlant_[float], A: pydrake.multibody.tree.Frame_[float], B: pydrake.multibody.tree.Frame_[float], X_AB: pydrake.math.RigidTransform_[float] = &lt;pydrake.math.RigidTransform_[float] object at 0x7f53d69a9c70&gt;) -&gt; pydrake.multibody.tree.WeldJoint_[float]</li>
</ol>
<p>Welds frames A and B with relative pose <code class="docutils literal"><span class="pre">X_AB</span></code>. That is, the pose of
frame B in frame A is fixed, with value <code class="docutils literal"><span class="pre">X_AB</span></code>. The call to this
method creates and adds a new WeldJoint to the model. The new
WeldJoint is named as: A.name() + “_welds_to_” + B.name().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to the WeldJoint welding frames A and B.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>WeldFrames(self: pydrake.multibody.plant.MultibodyPlant_[float], A: pydrake.multibody.tree.Frame_[float], B: pydrake.multibody.tree.Frame_[float], X_AB: pydrake.common.eigen_geometry.Isometry3_[float]) -&gt; pydrake.multibody.tree.WeldJoint_[float]</li>
</ol>
<p>This API using Isometry3 is / will be deprecated soon with the resolution of
#9865. We only offer it for backwards compatibility. DO NOT USE!.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].world_body">
<code class="descname">world_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RigidBody_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].world_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the <em>world</em> body.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.MultibodyPlant_[float].world_frame">
<code class="descname">world_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.MultibodyPlant_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyFrame_[float]<a class="headerlink" href="#pydrake.multibody.plant.MultibodyPlant_[float].world_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the <em>world</em> frame.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.PointPairContactInfo">
<code class="descclassname">pydrake.multibody.plant.</code><code class="descname">PointPairContactInfo</code><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_[float]" title="pydrake.multibody.plant.PointPairContactInfo_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.plant.PointPairContactInfo_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.plant.PointPairContactInfo_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">PointPairContactInfo_</code><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_[float]" title="pydrake.multibody.plant.PointPairContactInfo_[float]"><code class="xref py py-class docutils literal"><span class="pre">PointPairContactInfo_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd]" title="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">PointPairContactInfo_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.PointPairContactInfo_[Expression]" title="pydrake.multibody.plant.PointPairContactInfo_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">PointPairContactInfo_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float]">
<em class="property">class </em><code class="descname">PointPairContactInfo_[float]</code><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A class containing information regarding contact response between two
bodies including:</p>
<ul class="simple">
<li>The pair of bodies that are contacting, referenced by their BodyIndex.</li>
<li>A resultant contact force.</li>
<li>A contact point.</li>
<li>Separation speed.</li>
<li>Slip speed.</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float], bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[numpy.float64[3, 1]], p_WC: numpy.ndarray[numpy.float64[3, 1]], separation_speed: float, slip_speed: float, point_pair: pydrake.geometry.PenetrationAsPointPair_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the contact information for a given pair of two colliding
bodies.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">bodyA_index</span></code>:</dt>
<dd>Index that references body A in <code class="docutils literal"><span class="pre">this</span></code> contact pair.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">bodyB_index</span></code>:</dt>
<dd>Index that references body B in <code class="docutils literal"><span class="pre">this</span></code> contact pair.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">f_Bc_W</span></code>:</dt>
<dd>Force on body B applied at contact point C, expressed in the world
frame W.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_WC</span></code>:</dt>
<dd>Position of the contact point C in the world frame W.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">separation_speed</span></code>:</dt>
<dd>Separation speed along the normal direction between body A and
body B, in meters per second. A positive value indicates bodies
are moving apart. A negative value indicates bodies are moving
towards each other.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">slip_speed</span></code>:</dt>
<dd>Slip speed, that is, the magnitude of the relative tangential
velocity at the contact point in meters per second. A non-negative
value always.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">point_pair</span></code>:</dt>
<dd>Additional point pair information for <code class="docutils literal"><span class="pre">this</span></code> contact info. Refer
to the documentation for PenetrationAsPointPair for further
details.</dd>
<dt>Precondition:</dt>
<dd>The two body indexes must reference bodies from the same
MultibodyPlant. Contact values should likewise be generated by the
same MultibodyPlant.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].bodyA_index">
<code class="descname">bodyA_index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].bodyA_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of body A in the contact pair.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].bodyB_index">
<code class="descname">bodyB_index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].bodyB_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of body B in the contact pair.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].contact_force">
<code class="descname">contact_force</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].contact_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the contact force <code class="docutils literal"><span class="pre">f_Bc_W</span></code> on B at contact point C expressed
in the world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].contact_point">
<code class="descname">contact_point</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].contact_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position <code class="docutils literal"><span class="pre">p_WC</span></code> of the contact point C in the world
frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].point_pair">
<code class="descname">point_pair</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.PenetrationAsPointPair_[float]<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].point_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns additional information for the geometric contact query for
<code class="docutils literal"><span class="pre">this</span></code> pair as a PenetrationAsPointPair.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].separation_speed">
<code class="descname">separation_speed</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].separation_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the separation speed between body A and B along the normal
direction (see PenetrationAsPointPair::nhat_BA_W) at the contact
point. It is defined positive for bodies moving apart in the normal
direction.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].slip_speed">
<code class="descname">slip_speed</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_.PointPairContactInfo_[float].slip_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the slip speed between body A and B at contact point C.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">PointPairContactInfo_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>A class containing information regarding contact response between two
bodies including:</p>
<ul class="simple">
<li>The pair of bodies that are contacting, referenced by their BodyIndex.</li>
<li>A resultant contact force.</li>
<li>A contact point.</li>
<li>Separation speed.</li>
<li>Slip speed.</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd], bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[object[3, 1]], p_WC: numpy.ndarray[object[3, 1]], separation_speed: pydrake.autodiffutils.AutoDiffXd, slip_speed: pydrake.autodiffutils.AutoDiffXd, point_pair: pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the contact information for a given pair of two colliding
bodies.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">bodyA_index</span></code>:</dt>
<dd>Index that references body A in <code class="docutils literal"><span class="pre">this</span></code> contact pair.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">bodyB_index</span></code>:</dt>
<dd>Index that references body B in <code class="docutils literal"><span class="pre">this</span></code> contact pair.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">f_Bc_W</span></code>:</dt>
<dd>Force on body B applied at contact point C, expressed in the world
frame W.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_WC</span></code>:</dt>
<dd>Position of the contact point C in the world frame W.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">separation_speed</span></code>:</dt>
<dd>Separation speed along the normal direction between body A and
body B, in meters per second. A positive value indicates bodies
are moving apart. A negative value indicates bodies are moving
towards each other.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">slip_speed</span></code>:</dt>
<dd>Slip speed, that is, the magnitude of the relative tangential
velocity at the contact point in meters per second. A non-negative
value always.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">point_pair</span></code>:</dt>
<dd>Additional point pair information for <code class="docutils literal"><span class="pre">this</span></code> contact info. Refer
to the documentation for PenetrationAsPointPair for further
details.</dd>
<dt>Precondition:</dt>
<dd>The two body indexes must reference bodies from the same
MultibodyPlant. Contact values should likewise be generated by the
same MultibodyPlant.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].bodyA_index">
<code class="descname">bodyA_index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].bodyA_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of body A in the contact pair.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].bodyB_index">
<code class="descname">bodyB_index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].bodyB_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of body B in the contact pair.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].contact_force">
<code class="descname">contact_force</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].contact_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the contact force <code class="docutils literal"><span class="pre">f_Bc_W</span></code> on B at contact point C expressed
in the world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].contact_point">
<code class="descname">contact_point</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].contact_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position <code class="docutils literal"><span class="pre">p_WC</span></code> of the contact point C in the world
frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].point_pair">
<code class="descname">point_pair</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].point_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns additional information for the geometric contact query for
<code class="docutils literal"><span class="pre">this</span></code> pair as a PenetrationAsPointPair.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].separation_speed">
<code class="descname">separation_speed</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].separation_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the separation speed between body A and B along the normal
direction (see PenetrationAsPointPair::nhat_BA_W) at the contact
point. It is defined positive for bodies moving apart in the normal
direction.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].slip_speed">
<code class="descname">slip_speed</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[AutoDiffXd].slip_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the slip speed between body A and B at contact point C.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">PointPairContactInfo_[Expression]</code><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>A class containing information regarding contact response between two
bodies including:</p>
<ul class="simple">
<li>The pair of bodies that are contacting, referenced by their BodyIndex.</li>
<li>A resultant contact force.</li>
<li>A contact point.</li>
<li>Separation speed.</li>
<li>Slip speed.</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[Expression], bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[object[3, 1]], p_WC: numpy.ndarray[object[3, 1]], separation_speed: pydrake.symbolic.Expression, slip_speed: pydrake.symbolic.Expression, point_pair: drake::geometry::PenetrationAsPointPair&lt;drake::symbolic::Expression&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the contact information for a given pair of two colliding
bodies.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">bodyA_index</span></code>:</dt>
<dd>Index that references body A in <code class="docutils literal"><span class="pre">this</span></code> contact pair.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">bodyB_index</span></code>:</dt>
<dd>Index that references body B in <code class="docutils literal"><span class="pre">this</span></code> contact pair.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">f_Bc_W</span></code>:</dt>
<dd>Force on body B applied at contact point C, expressed in the world
frame W.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_WC</span></code>:</dt>
<dd>Position of the contact point C in the world frame W.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">separation_speed</span></code>:</dt>
<dd>Separation speed along the normal direction between body A and
body B, in meters per second. A positive value indicates bodies
are moving apart. A negative value indicates bodies are moving
towards each other.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">slip_speed</span></code>:</dt>
<dd>Slip speed, that is, the magnitude of the relative tangential
velocity at the contact point in meters per second. A non-negative
value always.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">point_pair</span></code>:</dt>
<dd>Additional point pair information for <code class="docutils literal"><span class="pre">this</span></code> contact info. Refer
to the documentation for PenetrationAsPointPair for further
details.</dd>
<dt>Precondition:</dt>
<dd>The two body indexes must reference bodies from the same
MultibodyPlant. Contact values should likewise be generated by the
same MultibodyPlant.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[Expression].bodyA_index">
<code class="descname">bodyA_index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[Expression].bodyA_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of body A in the contact pair.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[Expression].bodyB_index">
<code class="descname">bodyB_index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[Expression].bodyB_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of body B in the contact pair.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[Expression].contact_force">
<code class="descname">contact_force</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[Expression].contact_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the contact force <code class="docutils literal"><span class="pre">f_Bc_W</span></code> on B at contact point C expressed
in the world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[Expression].contact_point">
<code class="descname">contact_point</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[Expression].contact_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position <code class="docutils literal"><span class="pre">p_WC</span></code> of the contact point C in the world
frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[Expression].point_pair">
<code class="descname">point_pair</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[Expression]</em><span class="sig-paren">)</span> &#x2192; drake::geometry::PenetrationAsPointPair&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[Expression].point_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns additional information for the geometric contact query for
<code class="docutils literal"><span class="pre">this</span></code> pair as a PenetrationAsPointPair.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[Expression].separation_speed">
<code class="descname">separation_speed</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[Expression].separation_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the separation speed between body A and B along the normal
direction (see PenetrationAsPointPair::nhat_BA_W) at the contact
point. It is defined positive for bodies moving apart in the normal
direction.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[Expression].slip_speed">
<code class="descname">slip_speed</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[Expression].slip_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the slip speed between body A and B at contact point C.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">PointPairContactInfo_[float]</code><a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A class containing information regarding contact response between two
bodies including:</p>
<ul class="simple">
<li>The pair of bodies that are contacting, referenced by their BodyIndex.</li>
<li>A resultant contact force.</li>
<li>A contact point.</li>
<li>Separation speed.</li>
<li>Slip speed.</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float], bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, f_Bc_W: numpy.ndarray[numpy.float64[3, 1]], p_WC: numpy.ndarray[numpy.float64[3, 1]], separation_speed: float, slip_speed: float, point_pair: pydrake.geometry.PenetrationAsPointPair_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the contact information for a given pair of two colliding
bodies.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">bodyA_index</span></code>:</dt>
<dd>Index that references body A in <code class="docutils literal"><span class="pre">this</span></code> contact pair.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">bodyB_index</span></code>:</dt>
<dd>Index that references body B in <code class="docutils literal"><span class="pre">this</span></code> contact pair.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">f_Bc_W</span></code>:</dt>
<dd>Force on body B applied at contact point C, expressed in the world
frame W.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_WC</span></code>:</dt>
<dd>Position of the contact point C in the world frame W.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">separation_speed</span></code>:</dt>
<dd>Separation speed along the normal direction between body A and
body B, in meters per second. A positive value indicates bodies
are moving apart. A negative value indicates bodies are moving
towards each other.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">slip_speed</span></code>:</dt>
<dd>Slip speed, that is, the magnitude of the relative tangential
velocity at the contact point in meters per second. A non-negative
value always.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">point_pair</span></code>:</dt>
<dd>Additional point pair information for <code class="docutils literal"><span class="pre">this</span></code> contact info. Refer
to the documentation for PenetrationAsPointPair for further
details.</dd>
<dt>Precondition:</dt>
<dd>The two body indexes must reference bodies from the same
MultibodyPlant. Contact values should likewise be generated by the
same MultibodyPlant.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[float].bodyA_index">
<code class="descname">bodyA_index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[float].bodyA_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of body A in the contact pair.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[float].bodyB_index">
<code class="descname">bodyB_index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[float].bodyB_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of body B in the contact pair.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[float].contact_force">
<code class="descname">contact_force</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[float].contact_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the contact force <code class="docutils literal"><span class="pre">f_Bc_W</span></code> on B at contact point C expressed
in the world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[float].contact_point">
<code class="descname">contact_point</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[float].contact_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position <code class="docutils literal"><span class="pre">p_WC</span></code> of the contact point C in the world
frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[float].point_pair">
<code class="descname">point_pair</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.PenetrationAsPointPair_[float]<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[float].point_pair" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns additional information for the geometric contact query for
<code class="docutils literal"><span class="pre">this</span></code> pair as a PenetrationAsPointPair.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[float].separation_speed">
<code class="descname">separation_speed</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[float].separation_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the separation speed between body A and B along the normal
direction (see PenetrationAsPointPair::nhat_BA_W) at the contact
point. It is defined positive for bodies moving apart in the normal
direction.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.PointPairContactInfo_[float].slip_speed">
<code class="descname">slip_speed</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PointPairContactInfo_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.plant.PointPairContactInfo_[float].slip_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the slip speed between body A and B at contact point C.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.Propeller">
<code class="descclassname">pydrake.multibody.plant.</code><code class="descname">Propeller</code><a class="headerlink" href="#pydrake.multibody.plant.Propeller" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.plant.Propeller_[float]" title="pydrake.multibody.plant.Propeller_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.plant.Propeller_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.plant.Propeller_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">Propeller_</code><a class="headerlink" href="#pydrake.multibody.plant.Propeller_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.plant.Propeller_[float]" title="pydrake.multibody.plant.Propeller_[float]"><code class="xref py py-class docutils literal"><span class="pre">Propeller_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.Propeller_[AutoDiffXd]" title="pydrake.multibody.plant.Propeller_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">Propeller_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.Propeller_[Expression]" title="pydrake.multibody.plant.Propeller_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">Propeller_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.plant.Propeller_.Propeller_[float]">
<em class="property">class </em><code class="descname">Propeller_[float]</code><a class="headerlink" href="#pydrake.multibody.plant.Propeller_.Propeller_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_[float]" title="pydrake.systems.framework.LeafSystem_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.framework.LeafSystem_[float]</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
effects of one or more controlled propellers acting on a Body.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">command&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Propeller</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_forces</td></tr></table></td></tr></table><ul class="simple">
<li>The command input is a BasicVector&lt;T&gt; with one element per propeller.</li>
<li>It is expected that the body_poses input should be connected to the</li>
</ul>
<p>MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port”.
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.
- This system does not have any state.</p>
<p>The resulting iᵗʰ spatial force will have a force component in the
z-axis of the iᵗʰ propeller frame with magnitude <code class="docutils literal"><span class="pre">thrust_ratio</span> <span class="pre">*</span>
<span class="pre">command</span></code> Newtons, and a moment around the z-axis with magnitude
<code class="docutils literal"><span class="pre">moment_ratio</span> <span class="pre">*</span> <span class="pre">command</span></code> Newton-meters. (Including these moments
tends to be important – a quadrotor does not have a stabilizable
linearization around a hovering fixed point in 3D without them).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Set PropellerInfo::moment_ratio to zero if you want a simple
thruster which applies only a force (no moment) in the Propeller
coordinates.</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_.Propeller_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_.Propeller_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.plant.Propeller_[float], body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform_[float] = &lt;pydrake.math.RigidTransform_[float] object at 0x7f53d5ef8330&gt;, thrust_ratio: float = 1.0, moment_ratio: float = 0.0) -&gt; None</li>
</ol>
<p>Constructs a system describing a single propeller.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">PropellerInfo for details on the arguments.</p>
</div>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.plant.Propeller_[float], propeller_info: List[drake::multibody::PropellerInfo]) -&gt; None</li>
</ol>
<p>Constructs a system describing multiple propellers.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">PropellerInfo.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_.Propeller_[float].get_body_poses_input_port">
<code class="descname">get_body_poses_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.Propeller_.Propeller_[float].get_body_poses_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_.Propeller_[float].get_command_input_port">
<code class="descname">get_command_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.Propeller_.Propeller_[float].get_command_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the vector-valued input port for the propeller
commands. It has size <code class="docutils literal"><span class="pre">num_propellers()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_.Propeller_[float].get_spatial_forces_output_port">
<code class="descname">get_spatial_forces_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.Propeller_.Propeller_[float].get_spatial_forces_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_.Propeller_[float].num_propellers">
<code class="descname">num_propellers</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.Propeller_.Propeller_[float].num_propellers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of propellers modeled by this system.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.Propeller_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">Propeller_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.plant.Propeller_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_[AutoDiffXd]" title="pydrake.systems.framework.LeafSystem_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
effects of one or more controlled propellers acting on a Body.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">command&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Propeller</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_forces</td></tr></table></td></tr></table><ul class="simple">
<li>The command input is a BasicVector&lt;T&gt; with one element per propeller.</li>
<li>It is expected that the body_poses input should be connected to the</li>
</ul>
<p>MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port”.
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.
- This system does not have any state.</p>
<p>The resulting iᵗʰ spatial force will have a force component in the
z-axis of the iᵗʰ propeller frame with magnitude <code class="docutils literal"><span class="pre">thrust_ratio</span> <span class="pre">*</span>
<span class="pre">command</span></code> Newtons, and a moment around the z-axis with magnitude
<code class="docutils literal"><span class="pre">moment_ratio</span> <span class="pre">*</span> <span class="pre">command</span></code> Newton-meters. (Including these moments
tends to be important – a quadrotor does not have a stabilizable
linearization around a hovering fixed point in 3D without them).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Set PropellerInfo::moment_ratio to zero if you want a simple
thruster which applies only a force (no moment) in the Propeller
coordinates.</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.plant.Propeller_[AutoDiffXd], body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform_[float] = &lt;pydrake.math.RigidTransform_[float] object at 0x7f53d69a9670&gt;, thrust_ratio: float = 1.0, moment_ratio: float = 0.0) -&gt; None</li>
</ol>
<p>Constructs a system describing a single propeller.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">PropellerInfo for details on the arguments.</p>
</div>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.plant.Propeller_[AutoDiffXd], propeller_info: List[drake::multibody::PropellerInfo]) -&gt; None</li>
</ol>
<p>Constructs a system describing multiple propellers.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">PropellerInfo.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_[AutoDiffXd].get_body_poses_input_port">
<code class="descname">get_body_poses_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.Propeller_[AutoDiffXd].get_body_poses_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_[AutoDiffXd].get_command_input_port">
<code class="descname">get_command_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.Propeller_[AutoDiffXd].get_command_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the vector-valued input port for the propeller
commands. It has size <code class="docutils literal"><span class="pre">num_propellers()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_[AutoDiffXd].get_spatial_forces_output_port">
<code class="descname">get_spatial_forces_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.plant.Propeller_[AutoDiffXd].get_spatial_forces_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_[AutoDiffXd].num_propellers">
<code class="descname">num_propellers</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.Propeller_[AutoDiffXd].num_propellers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of propellers modeled by this system.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.Propeller_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">Propeller_[Expression]</code><a class="headerlink" href="#pydrake.multibody.plant.Propeller_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_[Expression]" title="pydrake.systems.framework.LeafSystem_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
effects of one or more controlled propellers acting on a Body.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">command&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Propeller</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_forces</td></tr></table></td></tr></table><ul class="simple">
<li>The command input is a BasicVector&lt;T&gt; with one element per propeller.</li>
<li>It is expected that the body_poses input should be connected to the</li>
</ul>
<p>MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port”.
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.
- This system does not have any state.</p>
<p>The resulting iᵗʰ spatial force will have a force component in the
z-axis of the iᵗʰ propeller frame with magnitude <code class="docutils literal"><span class="pre">thrust_ratio</span> <span class="pre">*</span>
<span class="pre">command</span></code> Newtons, and a moment around the z-axis with magnitude
<code class="docutils literal"><span class="pre">moment_ratio</span> <span class="pre">*</span> <span class="pre">command</span></code> Newton-meters. (Including these moments
tends to be important – a quadrotor does not have a stabilizable
linearization around a hovering fixed point in 3D without them).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Set PropellerInfo::moment_ratio to zero if you want a simple
thruster which applies only a force (no moment) in the Propeller
coordinates.</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.plant.Propeller_[Expression], body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform_[float] = &lt;pydrake.math.RigidTransform_[float] object at 0x7f53d83a6b70&gt;, thrust_ratio: float = 1.0, moment_ratio: float = 0.0) -&gt; None</li>
</ol>
<p>Constructs a system describing a single propeller.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">PropellerInfo for details on the arguments.</p>
</div>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.plant.Propeller_[Expression], propeller_info: List[drake::multibody::PropellerInfo]) -&gt; None</li>
</ol>
<p>Constructs a system describing multiple propellers.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">PropellerInfo.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_[Expression].get_body_poses_input_port">
<code class="descname">get_body_poses_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.Propeller_[Expression].get_body_poses_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_[Expression].get_command_input_port">
<code class="descname">get_command_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.Propeller_[Expression].get_command_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the vector-valued input port for the propeller
commands. It has size <code class="docutils literal"><span class="pre">num_propellers()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_[Expression].get_spatial_forces_output_port">
<code class="descname">get_spatial_forces_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[Expression]<a class="headerlink" href="#pydrake.multibody.plant.Propeller_[Expression].get_spatial_forces_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_[Expression].num_propellers">
<code class="descname">num_propellers</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.Propeller_[Expression].num_propellers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of propellers modeled by this system.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.Propeller_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">Propeller_[float]</code><a class="headerlink" href="#pydrake.multibody.plant.Propeller_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_[float]" title="pydrake.systems.framework.LeafSystem_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.framework.LeafSystem_[float]</span></code></a></p>
<p>A System that connects to the MultibodyPlant in order to model the
effects of one or more controlled propellers acting on a Body.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">command&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">body_poses&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Propeller</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; spatial_forces</td></tr></table></td></tr></table><ul class="simple">
<li>The command input is a BasicVector&lt;T&gt; with one element per propeller.</li>
<li>It is expected that the body_poses input should be connected to the</li>
</ul>
<p>MultibodyPlant::get_body_poses_output_port() “MultibodyPlant body_poses
output port”.
- The output is of type std::vector&lt;ExternallyAppliedSpatialForce&lt;T&gt;&gt;; it is
expected that this output will be connected to the MultibodyPlant::get_applied_spatial_force_input_port()
“externally_applied_spatial_force input port” of the MultibodyPlant.
- This system does not have any state.</p>
<p>The resulting iᵗʰ spatial force will have a force component in the
z-axis of the iᵗʰ propeller frame with magnitude <code class="docutils literal"><span class="pre">thrust_ratio</span> <span class="pre">*</span>
<span class="pre">command</span></code> Newtons, and a moment around the z-axis with magnitude
<code class="docutils literal"><span class="pre">moment_ratio</span> <span class="pre">*</span> <span class="pre">command</span></code> Newton-meters. (Including these moments
tends to be important – a quadrotor does not have a stabilizable
linearization around a hovering fixed point in 3D without them).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Set PropellerInfo::moment_ratio to zero if you want a simple
thruster which applies only a force (no moment) in the Propeller
coordinates.</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.plant.Propeller_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.plant.Propeller_[float], body_index: pydrake.multibody.tree.BodyIndex, X_BP: pydrake.math.RigidTransform_[float] = &lt;pydrake.math.RigidTransform_[float] object at 0x7f53d5ef8330&gt;, thrust_ratio: float = 1.0, moment_ratio: float = 0.0) -&gt; None</li>
</ol>
<p>Constructs a system describing a single propeller.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">PropellerInfo for details on the arguments.</p>
</div>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.plant.Propeller_[float], propeller_info: List[drake::multibody::PropellerInfo]) -&gt; None</li>
</ol>
<p>Constructs a system describing multiple propellers.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">PropellerInfo.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_[float].get_body_poses_input_port">
<code class="descname">get_body_poses_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.Propeller_[float].get_body_poses_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the body_poses input port. It is anticipated
that this port will be connected the body_poses output port of a
MultibodyPlant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_[float].get_command_input_port">
<code class="descname">get_command_input_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.Propeller_[float].get_command_input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the vector-valued input port for the propeller
commands. It has size <code class="docutils literal"><span class="pre">num_propellers()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_[float].get_spatial_forces_output_port">
<code class="descname">get_spatial_forces_output_port</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.multibody.plant.Propeller_[float].get_spatial_forces_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the spatial_forces output port. It is
anticipated that this port will be connected to the
MultibodyPlant::get_applied_spatial_force_input_port()
“applied_spatial_force” input port of a MultibodyPlant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.plant.Propeller_[float].num_propellers">
<code class="descname">num_propellers</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.Propeller_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.plant.Propeller_[float].num_propellers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of propellers modeled by this system.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.PropellerInfo">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">PropellerInfo</code><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters that describe the kinematic frame and force-production
properties of a single propeller.</p>
<dl class="method">
<dt id="pydrake.multibody.plant.PropellerInfo.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.plant.PropellerInfo</em>, <em>body_index: pydrake.multibody.tree.BodyIndex</em>, <em>X_BP: pydrake.math.RigidTransform_[float] = &lt;pydrake.math.RigidTransform_[float] object at 0x7f53d5ef85b0&gt;</em>, <em>thrust_ratio: float = 1.0</em>, <em>moment_ratio: float = 0.0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.PropellerInfo.body_index">
<code class="descname">body_index</code><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo.body_index" title="Permalink to this definition">¶</a></dt>
<dd><p>The BodyIndex of a Body in the MultibodyPlant to which the propeller
is attached. The spatial forces will be applied to this body.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.PropellerInfo.moment_ratio">
<code class="descname">moment_ratio</code><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo.moment_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>The moment about the z axis (in frame P) of the spatial force will
have magnitude <code class="docutils literal"><span class="pre">moment_ratio*command</span></code> in Newton-meters. The default
is 0, which makes the propeller a simple Cartesian force generator.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.PropellerInfo.thrust_ratio">
<code class="descname">thrust_ratio</code><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo.thrust_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>The z component (in frame P) of the spatial force will have magnitude
<code class="docutils literal"><span class="pre">thrust_ratio*command</span></code> in Newtons. The default is 1 (command in
Newtons), but this can also be used to scale an actuator command to
the resulting force.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.PropellerInfo.X_BP">
<code class="descname">X_BP</code><a class="headerlink" href="#pydrake.multibody.plant.PropellerInfo.X_BP" title="Permalink to this definition">¶</a></dt>
<dd><p>Pose of the propeller frame P measured in the body frame B.
$*Default:* is the identity matrix.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.plant.VectorExternallyAppliedSpatialForced">
<code class="descclassname">pydrake.multibody.plant.</code><code class="descname">VectorExternallyAppliedSpatialForced</code><a class="headerlink" href="#pydrake.multibody.plant.VectorExternallyAppliedSpatialForced" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_[float]" title="pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">VectorExternallyAppliedSpatialForced_</code><a class="headerlink" href="#pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_[float]" title="pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_[float]"><code class="xref py py-class docutils literal"><span class="pre">VectorExternallyAppliedSpatialForced_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_[AutoDiffXd]" title="pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">VectorExternallyAppliedSpatialForced_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_[Expression]" title="pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">VectorExternallyAppliedSpatialForced_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_.VectorExternallyAppliedSpatialForced_[float]">
<em class="property">class </em><code class="descname">VectorExternallyAppliedSpatialForced_[float]</code><a class="headerlink" href="#pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_.VectorExternallyAppliedSpatialForced_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">list</span></code></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><code class="docutils literal"><span class="pre">VectorExternallyAppliedSpatialForced</span></code> and
<code class="docutils literal"><span class="pre">Value[VectorExternallyAppliedSpatialForced]</span></code> are deprecated. Please use
<code class="docutils literal"><span class="pre">list()</span></code> and <code class="docutils literal"><span class="pre">Value[List[ExternallyAppliedSpatialForce]]</span></code> instead.
The deprecated code will be removed from Drake on or after 2020-09-01.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">VectorExternallyAppliedSpatialForced_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">list</span></code></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><code class="docutils literal"><span class="pre">VectorExternallyAppliedSpatialForced</span></code> and
<code class="docutils literal"><span class="pre">Value[VectorExternallyAppliedSpatialForced]</span></code> are deprecated. Please use
<code class="docutils literal"><span class="pre">list()</span></code> and <code class="docutils literal"><span class="pre">Value[List[ExternallyAppliedSpatialForce]]</span></code> instead.
The deprecated code will be removed from Drake on or after 2020-09-01.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">VectorExternallyAppliedSpatialForced_[Expression]</code><a class="headerlink" href="#pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">list</span></code></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><code class="docutils literal"><span class="pre">VectorExternallyAppliedSpatialForced</span></code> and
<code class="docutils literal"><span class="pre">Value[VectorExternallyAppliedSpatialForced]</span></code> are deprecated. Please use
<code class="docutils literal"><span class="pre">list()</span></code> and <code class="docutils literal"><span class="pre">Value[List[ExternallyAppliedSpatialForce]]</span></code> instead.
The deprecated code will be removed from Drake on or after 2020-09-01.</p>
</div>
</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.plant.</code><code class="descname">VectorExternallyAppliedSpatialForced_[float]</code><a class="headerlink" href="#pydrake.multibody.plant.VectorExternallyAppliedSpatialForced_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">list</span></code></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><code class="docutils literal"><span class="pre">VectorExternallyAppliedSpatialForced</span></code> and
<code class="docutils literal"><span class="pre">Value[VectorExternallyAppliedSpatialForced]</span></code> are deprecated. Please use
<code class="docutils literal"><span class="pre">list()</span></code> and <code class="docutils literal"><span class="pre">Value[List[ExternallyAppliedSpatialForce]]</span></code> instead.
The deprecated code will be removed from Drake on or after 2020-09-01.</p>
</div>
</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pydrake.multibody.tree.html" class="btn btn-neutral float-right" title="pydrake.multibody.tree" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pydrake.multibody.parsing.html" class="btn btn-neutral" title="pydrake.multibody.parsing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>