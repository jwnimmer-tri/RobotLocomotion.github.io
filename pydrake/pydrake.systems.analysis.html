

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydrake.systems.analysis &mdash; pydrake  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="pydrake  documentation" href="index.html"/>
        <link rel="up" title="pydrake.systems" href="pydrake.systems.html"/>
        <link rel="next" title="pydrake.systems.controllers" href="pydrake.systems.controllers.html"/>
        <link rel="prev" title="pydrake.systems.all" href="pydrake.systems.all.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> pydrake
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.all.html">pydrake.systems.all</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.systems.analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.controllers.html">pydrake.systems.controllers</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.drawing.html">pydrake.systems.drawing</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.framework.html">pydrake.systems.framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.lcm.html">pydrake.systems.lcm</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.meshcat_visualizer.html">pydrake.systems.meshcat_visualizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.perception.html">pydrake.systems.perception</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.planar_scenegraph_visualizer.html">pydrake.systems.planar_scenegraph_visualizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.primitives.html">pydrake.systems.primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.pyplot_visualizer.html">pydrake.systems.pyplot_visualizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.rendering.html">pydrake.systems.rendering</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.scalar_conversion.html">pydrake.systems.scalar_conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.sensors.html">pydrake.systems.sensors</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.system_sliders.html">pydrake.systems.system_sliders</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.trajectory_optimization.html">pydrake.systems.trajectory_optimization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="pydrake.systems.html">pydrake.systems</a> &raquo;</li>
        
      <li>pydrake.systems.analysis</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pydrake.systems.analysis">
<span id="pydrake-systems-analysis"></span><h1>pydrake.systems.analysis<a class="headerlink" href="#module-pydrake.systems.analysis" title="Permalink to this headline">¶</a></h1>
<p>Bindings for the analysis portion of the Systems framework.</p>
<dl class="function">
<dt id="pydrake.systems.analysis.GetIntegrationSchemes">
<code class="descclassname">pydrake.systems.analysis.</code><code class="descname">GetIntegrationSchemes</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; List[str]<a class="headerlink" href="#pydrake.systems.analysis.GetIntegrationSchemes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the allowed string values for the <code class="docutils literal"><span class="pre">scheme</span></code> parameter in
ResetIntegratorFromFlags().</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.systems.analysis.IntegratorBase">
<code class="descclassname">pydrake.systems.analysis.</code><code class="descname">IntegratorBase</code><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_[float]" title="pydrake.systems.analysis.IntegratorBase_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.analysis.IntegratorBase_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.systems.analysis.IntegratorBase_">
<em class="property">template </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">IntegratorBase_</code><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_[float]" title="pydrake.systems.analysis.IntegratorBase_[float]"><code class="xref py py-class docutils literal"><span class="pre">IntegratorBase_[float]</span></code></a>, <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]" title="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">IntegratorBase_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_[Expression]" title="pydrake.systems.analysis.IntegratorBase_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">IntegratorBase_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float]">
<em class="property">class </em><code class="descname">IntegratorBase_[float]</code><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class for an integrator for ODEs and DAEs as represented
by a Drake System. Integrators solve initial value problems of the
form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>ẋ(t) = f(t, x(t)) with f : ℝ × ℝⁿ → ℝⁿ
</pre></div>
</div>
<p>(i.e., <code class="docutils literal"><span class="pre">f()</span></code> is an ordinary differential equation) given initial
conditions (t₀, x₀). Thus, integrators advance the continuous state of
a dynamical system forward in time.</p>
<p>Drake’s subclasses of IntegratorBase&lt;T&gt; should follow the naming
pattern <code class="docutils literal"><span class="pre">FooIntegrator&lt;T&gt;</span></code> by convention.</p>
<dl class="attribute">
<dt id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_dense_output">
<code class="descname">get_dense_output</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.trajectories.PiecewisePolynomial<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_dense_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const pointer to the integrator’s current
PiecewisePolynomial instance, holding a representation of the
continuous state trajectory since the last StartDenseIntegration()
call. This is suitable to query the integrator’s current dense output,
if any (may be nullptr).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_fixed_step_mode">
<code class="descname">get_fixed_step_mode</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_fixed_step_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets whether an integrator is running in fixed step mode. If the
integrator does not support error estimation, this function will
always return <code class="docutils literal"><span class="pre">True</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_fixed_step_mode()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_maximum_step_size">
<code class="descname">get_maximum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_maximum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the maximum step size that may be taken by this integrator. This
is a soft maximum: the integrator may stretch it by as much as 1% to
hit a discrete event.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_requested_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_requested_minimum_step_size">
<code class="descname">get_requested_minimum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_requested_minimum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the requested minimum step size <code class="docutils literal"><span class="pre">h_min</span></code> for this integrator.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_working_minimum_step_size(T)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_target_accuracy">
<code class="descname">get_target_accuracy</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_target_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the target accuracy.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_accuracy_in_use()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_throw_on_minimum_step_size_violation">
<code class="descname">get_throw_on_minimum_step_size_violation</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_throw_on_minimum_step_size_violation" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the current setting of the
throw_on_minimum_step_size_violation flag.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_throw_on_minimum_step_size_violation().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].set_fixed_step_mode">
<code class="descname">set_fixed_step_mode</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float], arg0: bool</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].set_fixed_step_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets an integrator with error control to fixed step mode. If the
integrator runs in fixed step mode, it will always take the maximum
step size directed (which may be that determined by
get_maximum_step_size(), or may be smaller, as directed by, e.g.,
Simulator for event handling purposes).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The error estimation process will still be active (so
get_error_estimate() will still return a correct result), meaning
that the additional (typically, but not necessarily small)
computation required for error estimation will still be performed.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if integrator does not support error estimation and</li>
<li><code class="docutils literal"><span class="pre">flag</span></code> is set to <code class="docutils literal"><span class="pre">False</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].set_maximum_step_size">
<code class="descname">set_maximum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float], arg0: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].set_maximum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;anchor integrator-maxstep &#64;name Methods related to maximum
integration step size</p>
<p>Sets the <em>nominal</em> maximum step size- the actual maximum step size
taken may be slightly larger (see set_maximum_step_size() and
get_stretch_factor())- that an integrator will take. Each integrator
has a default maximum step size, which might be infinite. Sets the
maximum step size that may be taken by this integrator. This setting
should be used if you know the maximum time scale of your problem. The
integrator may stretch the maximum step size by as much as 1% to reach
a discrete event. For fixed step integrators, all steps will be taken
at the maximum step size <em>unless</em> an event would be missed.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">See integrator-initial-step-size “Initial step size selection”</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].set_requested_minimum_step_size">
<code class="descname">set_requested_minimum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float], arg0: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].set_requested_minimum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the requested minimum step size <code class="docutils literal"><span class="pre">h_min</span></code> that may be taken by
this integrator. No step smaller than this will be taken except under
circumstances as described integrator-minstep “above”. This setting
will be ignored if it is smaller than the absolute minimum <code class="docutils literal"><span class="pre">h_floor</span></code>
also described above. Default value is zero.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">min_step_size</span></code>:</dt>
<dd>a non-negative value. Setting this value to zero will cause the
integrator to use a reasonable value instead (see
get_working_minimum_step_size()).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_working_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].set_target_accuracy">
<code class="descname">set_target_accuracy</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float], arg0: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].set_target_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;anchor integrator-accuracy &#64;name Methods for getting and setting
integrator accuracy The precise meaning of <em>accuracy</em> is a complicated
discussion, but it translates roughly to the number of significant
digits you want in the results. By convention it is supplied as
<code class="docutils literal"><span class="pre">10^-digits</span></code>, meaning that an accuracy of 1e-3 provides about three
significant digits. For more discussion of accuracy, see
accuracy_and_tolerance and ref. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">[1]</a>.</p>
<p>Integrators vary in the range of accuracy (loosest to tightest) that
they can support, and each integrator will choose a default accuracy
to be used that lies somewhere within this range and attempts to
balance computation and accuracy. If you request accuracy outside the
supported range for the chosen integrator it will be quietly adjusted
to be in range. You can find out the accuracy setting actually being
used using <code class="docutils literal"><span class="pre">get_accuracy_in_use()</span></code>.</p>
<p>Implicit integrators additionally use the accuracy setting for
determining when the underlying Newton-Raphson root finding process
has converged. For those integrators, the accuracy setting also limits
the allowable iteration error in the Newton-Raphson process. Looser
accuracy in that process certainly implies greater error in the ODE
solution and might impact the stability of the solution negatively as
well.</p>
<ul class="simple">
<li>[1] M. Sherman, A. Seth, S. Delp. Procedia IUTAM 2:241-261 (2011),</li>
</ul>
<p>Section 3.3. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">https://dx.doi.org/10.1016/j.piutam.2011.04.023</a></p>
<p>Request that the integrator attempt to achieve a particular accuracy
for the continuous portions of the simulation. Otherwise a default
accuracy is chosen for you. This may be ignored for fixed-step
integration since accuracy control requires variable step sizes. You
should call supports_error_estimation() to ensure that the integrator
supports this capability before calling this function; if the
integrator does not support it, this method will throw an exception.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if integrator does not support error estimation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].set_throw_on_minimum_step_size_violation">
<code class="descname">set_throw_on_minimum_step_size_violation</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float], arg0: bool</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].set_throw_on_minimum_step_size_violation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets whether the integrator should throw a RuntimeError exception when
the integrator’s step size selection algorithm determines that it must
take a step smaller than the minimum step size (for, e.g., purposes of
error control). Default is <code class="docutils literal"><span class="pre">True</span></code>. If <code class="docutils literal"><span class="pre">False</span></code>, the integrator will
advance time and state using the minimum specified step size in such
situations. See integrator-minstep “this section” for more detail.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].StartDenseIntegration">
<code class="descname">StartDenseIntegration</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].StartDenseIntegration" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts dense integration, allocating a new dense output for this
integrator to use.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>The integrator has been initialized.</dd>
<dt>Precondition:</dt>
<dd>The system being integrated has continuous state.</dd>
<dt>Precondition:</dt>
<dd>No dense integration is in progress (no dense output is held by
the integrator)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any of the preconditions is not met.</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Dense integration may incur significant overhead.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].StopDenseIntegration">
<code class="descname">StopDenseIntegration</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.trajectories.PiecewisePolynomial<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].StopDenseIntegration" title="Permalink to this definition">¶</a></dt>
<dd><p>Stops dense integration, yielding ownership of the current dense
output to the caller.</p>
<dl class="docutils">
<dt>Remark:</dt>
<dd>This process is irreversible.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A PiecewisePolynomial instance, i.e. a representation of the
continuous state trajectory of the system being integrated that
can be evaluated at any time within its extension. This
representation is defined starting at the context time of the last
StartDenseIntegration() call and finishing at the current context
time.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Dense integration is in progress (a dense output is held by this
integrator, after a call to StartDenseIntegration()).</dd>
<dt>Postcondition:</dt>
<dd>Previously held dense output is not updated nor referenced by the
integrator anymore.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any of the preconditions is not met.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">IntegratorBase_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class for an integrator for ODEs and DAEs as represented
by a Drake System. Integrators solve initial value problems of the
form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>ẋ(t) = f(t, x(t)) with f : ℝ × ℝⁿ → ℝⁿ
</pre></div>
</div>
<p>(i.e., <code class="docutils literal"><span class="pre">f()</span></code> is an ordinary differential equation) given initial
conditions (t₀, x₀). Thus, integrators advance the continuous state of
a dynamical system forward in time.</p>
<p>Drake’s subclasses of IntegratorBase&lt;T&gt; should follow the naming
pattern <code class="docutils literal"><span class="pre">FooIntegrator&lt;T&gt;</span></code> by convention.</p>
<dl class="attribute">
<dt id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_dense_output">
<code class="descname">get_dense_output</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; drake::trajectories::PiecewisePolynomial&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_dense_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const pointer to the integrator’s current
PiecewisePolynomial instance, holding a representation of the
continuous state trajectory since the last StartDenseIntegration()
call. This is suitable to query the integrator’s current dense output,
if any (may be nullptr).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_fixed_step_mode">
<code class="descname">get_fixed_step_mode</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_fixed_step_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets whether an integrator is running in fixed step mode. If the
integrator does not support error estimation, this function will
always return <code class="docutils literal"><span class="pre">True</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_fixed_step_mode()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_maximum_step_size">
<code class="descname">get_maximum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_maximum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the maximum step size that may be taken by this integrator. This
is a soft maximum: the integrator may stretch it by as much as 1% to
hit a discrete event.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_requested_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_requested_minimum_step_size">
<code class="descname">get_requested_minimum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_requested_minimum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the requested minimum step size <code class="docutils literal"><span class="pre">h_min</span></code> for this integrator.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_working_minimum_step_size(T)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_target_accuracy">
<code class="descname">get_target_accuracy</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_target_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the target accuracy.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_accuracy_in_use()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_throw_on_minimum_step_size_violation">
<code class="descname">get_throw_on_minimum_step_size_violation</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_throw_on_minimum_step_size_violation" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the current setting of the
throw_on_minimum_step_size_violation flag.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_throw_on_minimum_step_size_violation().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].set_fixed_step_mode">
<code class="descname">set_fixed_step_mode</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[AutoDiffXd], arg0: bool</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].set_fixed_step_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets an integrator with error control to fixed step mode. If the
integrator runs in fixed step mode, it will always take the maximum
step size directed (which may be that determined by
get_maximum_step_size(), or may be smaller, as directed by, e.g.,
Simulator for event handling purposes).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The error estimation process will still be active (so
get_error_estimate() will still return a correct result), meaning
that the additional (typically, but not necessarily small)
computation required for error estimation will still be performed.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if integrator does not support error estimation and</li>
<li><code class="docutils literal"><span class="pre">flag</span></code> is set to <code class="docutils literal"><span class="pre">False</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].set_maximum_step_size">
<code class="descname">set_maximum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[AutoDiffXd], arg0: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].set_maximum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;anchor integrator-maxstep &#64;name Methods related to maximum
integration step size</p>
<p>Sets the <em>nominal</em> maximum step size- the actual maximum step size
taken may be slightly larger (see set_maximum_step_size() and
get_stretch_factor())- that an integrator will take. Each integrator
has a default maximum step size, which might be infinite. Sets the
maximum step size that may be taken by this integrator. This setting
should be used if you know the maximum time scale of your problem. The
integrator may stretch the maximum step size by as much as 1% to reach
a discrete event. For fixed step integrators, all steps will be taken
at the maximum step size <em>unless</em> an event would be missed.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">See integrator-initial-step-size “Initial step size selection”</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].set_requested_minimum_step_size">
<code class="descname">set_requested_minimum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[AutoDiffXd], arg0: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].set_requested_minimum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the requested minimum step size <code class="docutils literal"><span class="pre">h_min</span></code> that may be taken by
this integrator. No step smaller than this will be taken except under
circumstances as described integrator-minstep “above”. This setting
will be ignored if it is smaller than the absolute minimum <code class="docutils literal"><span class="pre">h_floor</span></code>
also described above. Default value is zero.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">min_step_size</span></code>:</dt>
<dd>a non-negative value. Setting this value to zero will cause the
integrator to use a reasonable value instead (see
get_working_minimum_step_size()).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_working_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].set_target_accuracy">
<code class="descname">set_target_accuracy</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[AutoDiffXd], arg0: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].set_target_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;anchor integrator-accuracy &#64;name Methods for getting and setting
integrator accuracy The precise meaning of <em>accuracy</em> is a complicated
discussion, but it translates roughly to the number of significant
digits you want in the results. By convention it is supplied as
<code class="docutils literal"><span class="pre">10^-digits</span></code>, meaning that an accuracy of 1e-3 provides about three
significant digits. For more discussion of accuracy, see
accuracy_and_tolerance and ref. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">[1]</a>.</p>
<p>Integrators vary in the range of accuracy (loosest to tightest) that
they can support, and each integrator will choose a default accuracy
to be used that lies somewhere within this range and attempts to
balance computation and accuracy. If you request accuracy outside the
supported range for the chosen integrator it will be quietly adjusted
to be in range. You can find out the accuracy setting actually being
used using <code class="docutils literal"><span class="pre">get_accuracy_in_use()</span></code>.</p>
<p>Implicit integrators additionally use the accuracy setting for
determining when the underlying Newton-Raphson root finding process
has converged. For those integrators, the accuracy setting also limits
the allowable iteration error in the Newton-Raphson process. Looser
accuracy in that process certainly implies greater error in the ODE
solution and might impact the stability of the solution negatively as
well.</p>
<ul class="simple">
<li>[1] M. Sherman, A. Seth, S. Delp. Procedia IUTAM 2:241-261 (2011),</li>
</ul>
<p>Section 3.3. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">https://dx.doi.org/10.1016/j.piutam.2011.04.023</a></p>
<p>Request that the integrator attempt to achieve a particular accuracy
for the continuous portions of the simulation. Otherwise a default
accuracy is chosen for you. This may be ignored for fixed-step
integration since accuracy control requires variable step sizes. You
should call supports_error_estimation() to ensure that the integrator
supports this capability before calling this function; if the
integrator does not support it, this method will throw an exception.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if integrator does not support error estimation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].set_throw_on_minimum_step_size_violation">
<code class="descname">set_throw_on_minimum_step_size_violation</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[AutoDiffXd], arg0: bool</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].set_throw_on_minimum_step_size_violation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets whether the integrator should throw a RuntimeError exception when
the integrator’s step size selection algorithm determines that it must
take a step smaller than the minimum step size (for, e.g., purposes of
error control). Default is <code class="docutils literal"><span class="pre">True</span></code>. If <code class="docutils literal"><span class="pre">False</span></code>, the integrator will
advance time and state using the minimum specified step size in such
situations. See integrator-minstep “this section” for more detail.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].StartDenseIntegration">
<code class="descname">StartDenseIntegration</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].StartDenseIntegration" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts dense integration, allocating a new dense output for this
integrator to use.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>The integrator has been initialized.</dd>
<dt>Precondition:</dt>
<dd>The system being integrated has continuous state.</dd>
<dt>Precondition:</dt>
<dd>No dense integration is in progress (no dense output is held by
the integrator)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any of the preconditions is not met.</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Dense integration may incur significant overhead.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].StopDenseIntegration">
<code class="descname">StopDenseIntegration</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; drake::trajectories::PiecewisePolynomial&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].StopDenseIntegration" title="Permalink to this definition">¶</a></dt>
<dd><p>Stops dense integration, yielding ownership of the current dense
output to the caller.</p>
<dl class="docutils">
<dt>Remark:</dt>
<dd>This process is irreversible.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A PiecewisePolynomial instance, i.e. a representation of the
continuous state trajectory of the system being integrated that
can be evaluated at any time within its extension. This
representation is defined starting at the context time of the last
StartDenseIntegration() call and finishing at the current context
time.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Dense integration is in progress (a dense output is held by this
integrator, after a call to StartDenseIntegration()).</dd>
<dt>Postcondition:</dt>
<dd>Previously held dense output is not updated nor referenced by the
integrator anymore.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any of the preconditions is not met.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.systems.analysis.IntegratorBase_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">IntegratorBase_[Expression]</code><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class for an integrator for ODEs and DAEs as represented
by a Drake System. Integrators solve initial value problems of the
form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>ẋ(t) = f(t, x(t)) with f : ℝ × ℝⁿ → ℝⁿ
</pre></div>
</div>
<p>(i.e., <code class="docutils literal"><span class="pre">f()</span></code> is an ordinary differential equation) given initial
conditions (t₀, x₀). Thus, integrators advance the continuous state of
a dynamical system forward in time.</p>
<p>Drake’s subclasses of IntegratorBase&lt;T&gt; should follow the naming
pattern <code class="docutils literal"><span class="pre">FooIntegrator&lt;T&gt;</span></code> by convention.</p>
<dl class="attribute">
<dt id="pydrake.systems.analysis.IntegratorBase_[Expression].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[Expression].get_dense_output">
<code class="descname">get_dense_output</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[Expression]</em><span class="sig-paren">)</span> &#x2192; drake::trajectories::PiecewisePolynomial&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[Expression].get_dense_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const pointer to the integrator’s current
PiecewisePolynomial instance, holding a representation of the
continuous state trajectory since the last StartDenseIntegration()
call. This is suitable to query the integrator’s current dense output,
if any (may be nullptr).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[Expression].get_fixed_step_mode">
<code class="descname">get_fixed_step_mode</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[Expression]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[Expression].get_fixed_step_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets whether an integrator is running in fixed step mode. If the
integrator does not support error estimation, this function will
always return <code class="docutils literal"><span class="pre">True</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_fixed_step_mode()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[Expression].get_maximum_step_size">
<code class="descname">get_maximum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[Expression].get_maximum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the maximum step size that may be taken by this integrator. This
is a soft maximum: the integrator may stretch it by as much as 1% to
hit a discrete event.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_requested_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[Expression].get_requested_minimum_step_size">
<code class="descname">get_requested_minimum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[Expression].get_requested_minimum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the requested minimum step size <code class="docutils literal"><span class="pre">h_min</span></code> for this integrator.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_working_minimum_step_size(T)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[Expression].get_target_accuracy">
<code class="descname">get_target_accuracy</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[Expression].get_target_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the target accuracy.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_accuracy_in_use()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[Expression].get_throw_on_minimum_step_size_violation">
<code class="descname">get_throw_on_minimum_step_size_violation</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[Expression]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[Expression].get_throw_on_minimum_step_size_violation" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the current setting of the
throw_on_minimum_step_size_violation flag.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_throw_on_minimum_step_size_violation().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[Expression].set_fixed_step_mode">
<code class="descname">set_fixed_step_mode</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[Expression], arg0: bool</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[Expression].set_fixed_step_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets an integrator with error control to fixed step mode. If the
integrator runs in fixed step mode, it will always take the maximum
step size directed (which may be that determined by
get_maximum_step_size(), or may be smaller, as directed by, e.g.,
Simulator for event handling purposes).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The error estimation process will still be active (so
get_error_estimate() will still return a correct result), meaning
that the additional (typically, but not necessarily small)
computation required for error estimation will still be performed.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if integrator does not support error estimation and</li>
<li><code class="docutils literal"><span class="pre">flag</span></code> is set to <code class="docutils literal"><span class="pre">False</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[Expression].set_maximum_step_size">
<code class="descname">set_maximum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[Expression], arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[Expression].set_maximum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;anchor integrator-maxstep &#64;name Methods related to maximum
integration step size</p>
<p>Sets the <em>nominal</em> maximum step size- the actual maximum step size
taken may be slightly larger (see set_maximum_step_size() and
get_stretch_factor())- that an integrator will take. Each integrator
has a default maximum step size, which might be infinite. Sets the
maximum step size that may be taken by this integrator. This setting
should be used if you know the maximum time scale of your problem. The
integrator may stretch the maximum step size by as much as 1% to reach
a discrete event. For fixed step integrators, all steps will be taken
at the maximum step size <em>unless</em> an event would be missed.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">See integrator-initial-step-size “Initial step size selection”</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[Expression].set_requested_minimum_step_size">
<code class="descname">set_requested_minimum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[Expression], arg0: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[Expression].set_requested_minimum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the requested minimum step size <code class="docutils literal"><span class="pre">h_min</span></code> that may be taken by
this integrator. No step smaller than this will be taken except under
circumstances as described integrator-minstep “above”. This setting
will be ignored if it is smaller than the absolute minimum <code class="docutils literal"><span class="pre">h_floor</span></code>
also described above. Default value is zero.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">min_step_size</span></code>:</dt>
<dd>a non-negative value. Setting this value to zero will cause the
integrator to use a reasonable value instead (see
get_working_minimum_step_size()).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_working_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[Expression].set_target_accuracy">
<code class="descname">set_target_accuracy</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[Expression], arg0: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[Expression].set_target_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;anchor integrator-accuracy &#64;name Methods for getting and setting
integrator accuracy The precise meaning of <em>accuracy</em> is a complicated
discussion, but it translates roughly to the number of significant
digits you want in the results. By convention it is supplied as
<code class="docutils literal"><span class="pre">10^-digits</span></code>, meaning that an accuracy of 1e-3 provides about three
significant digits. For more discussion of accuracy, see
accuracy_and_tolerance and ref. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">[1]</a>.</p>
<p>Integrators vary in the range of accuracy (loosest to tightest) that
they can support, and each integrator will choose a default accuracy
to be used that lies somewhere within this range and attempts to
balance computation and accuracy. If you request accuracy outside the
supported range for the chosen integrator it will be quietly adjusted
to be in range. You can find out the accuracy setting actually being
used using <code class="docutils literal"><span class="pre">get_accuracy_in_use()</span></code>.</p>
<p>Implicit integrators additionally use the accuracy setting for
determining when the underlying Newton-Raphson root finding process
has converged. For those integrators, the accuracy setting also limits
the allowable iteration error in the Newton-Raphson process. Looser
accuracy in that process certainly implies greater error in the ODE
solution and might impact the stability of the solution negatively as
well.</p>
<ul class="simple">
<li>[1] M. Sherman, A. Seth, S. Delp. Procedia IUTAM 2:241-261 (2011),</li>
</ul>
<p>Section 3.3. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">https://dx.doi.org/10.1016/j.piutam.2011.04.023</a></p>
<p>Request that the integrator attempt to achieve a particular accuracy
for the continuous portions of the simulation. Otherwise a default
accuracy is chosen for you. This may be ignored for fixed-step
integration since accuracy control requires variable step sizes. You
should call supports_error_estimation() to ensure that the integrator
supports this capability before calling this function; if the
integrator does not support it, this method will throw an exception.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if integrator does not support error estimation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[Expression].set_throw_on_minimum_step_size_violation">
<code class="descname">set_throw_on_minimum_step_size_violation</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[Expression], arg0: bool</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[Expression].set_throw_on_minimum_step_size_violation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets whether the integrator should throw a RuntimeError exception when
the integrator’s step size selection algorithm determines that it must
take a step smaller than the minimum step size (for, e.g., purposes of
error control). Default is <code class="docutils literal"><span class="pre">True</span></code>. If <code class="docutils literal"><span class="pre">False</span></code>, the integrator will
advance time and state using the minimum specified step size in such
situations. See integrator-minstep “this section” for more detail.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[Expression].StartDenseIntegration">
<code class="descname">StartDenseIntegration</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[Expression].StartDenseIntegration" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts dense integration, allocating a new dense output for this
integrator to use.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>The integrator has been initialized.</dd>
<dt>Precondition:</dt>
<dd>The system being integrated has continuous state.</dd>
<dt>Precondition:</dt>
<dd>No dense integration is in progress (no dense output is held by
the integrator)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any of the preconditions is not met.</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Dense integration may incur significant overhead.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[Expression].StopDenseIntegration">
<code class="descname">StopDenseIntegration</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[Expression]</em><span class="sig-paren">)</span> &#x2192; drake::trajectories::PiecewisePolynomial&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[Expression].StopDenseIntegration" title="Permalink to this definition">¶</a></dt>
<dd><p>Stops dense integration, yielding ownership of the current dense
output to the caller.</p>
<dl class="docutils">
<dt>Remark:</dt>
<dd>This process is irreversible.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A PiecewisePolynomial instance, i.e. a representation of the
continuous state trajectory of the system being integrated that
can be evaluated at any time within its extension. This
representation is defined starting at the context time of the last
StartDenseIntegration() call and finishing at the current context
time.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Dense integration is in progress (a dense output is held by this
integrator, after a call to StartDenseIntegration()).</dd>
<dt>Postcondition:</dt>
<dd>Previously held dense output is not updated nor referenced by the
integrator anymore.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any of the preconditions is not met.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.systems.analysis.IntegratorBase_[float]">
<em class="property">class </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">IntegratorBase_[float]</code><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract class for an integrator for ODEs and DAEs as represented
by a Drake System. Integrators solve initial value problems of the
form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>ẋ(t) = f(t, x(t)) with f : ℝ × ℝⁿ → ℝⁿ
</pre></div>
</div>
<p>(i.e., <code class="docutils literal"><span class="pre">f()</span></code> is an ordinary differential equation) given initial
conditions (t₀, x₀). Thus, integrators advance the continuous state of
a dynamical system forward in time.</p>
<p>Drake’s subclasses of IntegratorBase&lt;T&gt; should follow the naming
pattern <code class="docutils literal"><span class="pre">FooIntegrator&lt;T&gt;</span></code> by convention.</p>
<dl class="attribute">
<dt id="pydrake.systems.analysis.IntegratorBase_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[float].get_dense_output">
<code class="descname">get_dense_output</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.trajectories.PiecewisePolynomial<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[float].get_dense_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const pointer to the integrator’s current
PiecewisePolynomial instance, holding a representation of the
continuous state trajectory since the last StartDenseIntegration()
call. This is suitable to query the integrator’s current dense output,
if any (may be nullptr).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[float].get_fixed_step_mode">
<code class="descname">get_fixed_step_mode</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[float].get_fixed_step_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets whether an integrator is running in fixed step mode. If the
integrator does not support error estimation, this function will
always return <code class="docutils literal"><span class="pre">True</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_fixed_step_mode()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[float].get_maximum_step_size">
<code class="descname">get_maximum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[float].get_maximum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the maximum step size that may be taken by this integrator. This
is a soft maximum: the integrator may stretch it by as much as 1% to
hit a discrete event.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_requested_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[float].get_requested_minimum_step_size">
<code class="descname">get_requested_minimum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[float].get_requested_minimum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the requested minimum step size <code class="docutils literal"><span class="pre">h_min</span></code> for this integrator.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_working_minimum_step_size(T)</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[float].get_target_accuracy">
<code class="descname">get_target_accuracy</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[float].get_target_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the target accuracy.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_accuracy_in_use()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[float].get_throw_on_minimum_step_size_violation">
<code class="descname">get_throw_on_minimum_step_size_violation</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[float].get_throw_on_minimum_step_size_violation" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the current setting of the
throw_on_minimum_step_size_violation flag.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_throw_on_minimum_step_size_violation().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[float].set_fixed_step_mode">
<code class="descname">set_fixed_step_mode</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float], arg0: bool</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[float].set_fixed_step_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets an integrator with error control to fixed step mode. If the
integrator runs in fixed step mode, it will always take the maximum
step size directed (which may be that determined by
get_maximum_step_size(), or may be smaller, as directed by, e.g.,
Simulator for event handling purposes).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The error estimation process will still be active (so
get_error_estimate() will still return a correct result), meaning
that the additional (typically, but not necessarily small)
computation required for error estimation will still be performed.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if integrator does not support error estimation and</li>
<li><code class="docutils literal"><span class="pre">flag</span></code> is set to <code class="docutils literal"><span class="pre">False</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[float].set_maximum_step_size">
<code class="descname">set_maximum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float], arg0: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[float].set_maximum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;anchor integrator-maxstep &#64;name Methods related to maximum
integration step size</p>
<p>Sets the <em>nominal</em> maximum step size- the actual maximum step size
taken may be slightly larger (see set_maximum_step_size() and
get_stretch_factor())- that an integrator will take. Each integrator
has a default maximum step size, which might be infinite. Sets the
maximum step size that may be taken by this integrator. This setting
should be used if you know the maximum time scale of your problem. The
integrator may stretch the maximum step size by as much as 1% to reach
a discrete event. For fixed step integrators, all steps will be taken
at the maximum step size <em>unless</em> an event would be missed.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">See integrator-initial-step-size “Initial step size selection”</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[float].set_requested_minimum_step_size">
<code class="descname">set_requested_minimum_step_size</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float], arg0: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[float].set_requested_minimum_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the requested minimum step size <code class="docutils literal"><span class="pre">h_min</span></code> that may be taken by
this integrator. No step smaller than this will be taken except under
circumstances as described integrator-minstep “above”. This setting
will be ignored if it is smaller than the absolute minimum <code class="docutils literal"><span class="pre">h_floor</span></code>
also described above. Default value is zero.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">min_step_size</span></code>:</dt>
<dd>a non-negative value. Setting this value to zero will cause the
integrator to use a reasonable value instead (see
get_working_minimum_step_size()).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">get_working_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[float].set_target_accuracy">
<code class="descname">set_target_accuracy</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float], arg0: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[float].set_target_accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;anchor integrator-accuracy &#64;name Methods for getting and setting
integrator accuracy The precise meaning of <em>accuracy</em> is a complicated
discussion, but it translates roughly to the number of significant
digits you want in the results. By convention it is supplied as
<code class="docutils literal"><span class="pre">10^-digits</span></code>, meaning that an accuracy of 1e-3 provides about three
significant digits. For more discussion of accuracy, see
accuracy_and_tolerance and ref. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">[1]</a>.</p>
<p>Integrators vary in the range of accuracy (loosest to tightest) that
they can support, and each integrator will choose a default accuracy
to be used that lies somewhere within this range and attempts to
balance computation and accuracy. If you request accuracy outside the
supported range for the chosen integrator it will be quietly adjusted
to be in range. You can find out the accuracy setting actually being
used using <code class="docutils literal"><span class="pre">get_accuracy_in_use()</span></code>.</p>
<p>Implicit integrators additionally use the accuracy setting for
determining when the underlying Newton-Raphson root finding process
has converged. For those integrators, the accuracy setting also limits
the allowable iteration error in the Newton-Raphson process. Looser
accuracy in that process certainly implies greater error in the ODE
solution and might impact the stability of the solution negatively as
well.</p>
<ul class="simple">
<li>[1] M. Sherman, A. Seth, S. Delp. Procedia IUTAM 2:241-261 (2011),</li>
</ul>
<p>Section 3.3. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">https://dx.doi.org/10.1016/j.piutam.2011.04.023</a></p>
<p>Request that the integrator attempt to achieve a particular accuracy
for the continuous portions of the simulation. Otherwise a default
accuracy is chosen for you. This may be ignored for fixed-step
integration since accuracy control requires variable step sizes. You
should call supports_error_estimation() to ensure that the integrator
supports this capability before calling this function; if the
integrator does not support it, this method will throw an exception.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if integrator does not support error estimation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[float].set_throw_on_minimum_step_size_violation">
<code class="descname">set_throw_on_minimum_step_size_violation</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float], arg0: bool</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[float].set_throw_on_minimum_step_size_violation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets whether the integrator should throw a RuntimeError exception when
the integrator’s step size selection algorithm determines that it must
take a step smaller than the minimum step size (for, e.g., purposes of
error control). Default is <code class="docutils literal"><span class="pre">True</span></code>. If <code class="docutils literal"><span class="pre">False</span></code>, the integrator will
advance time and state using the minimum specified step size in such
situations. See integrator-minstep “this section” for more detail.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[float].StartDenseIntegration">
<code class="descname">StartDenseIntegration</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[float].StartDenseIntegration" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts dense integration, allocating a new dense output for this
integrator to use.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>The integrator has been initialized.</dd>
<dt>Precondition:</dt>
<dd>The system being integrated has continuous state.</dd>
<dt>Precondition:</dt>
<dd>No dense integration is in progress (no dense output is held by
the integrator)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any of the preconditions is not met.</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Dense integration may incur significant overhead.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.IntegratorBase_[float].StopDenseIntegration">
<code class="descname">StopDenseIntegration</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.trajectories.PiecewisePolynomial<a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_[float].StopDenseIntegration" title="Permalink to this definition">¶</a></dt>
<dd><p>Stops dense integration, yielding ownership of the current dense
output to the caller.</p>
<dl class="docutils">
<dt>Remark:</dt>
<dd>This process is irreversible.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A PiecewisePolynomial instance, i.e. a representation of the
continuous state trajectory of the system being integrated that
can be evaluated at any time within its extension. This
representation is defined starting at the context time of the last
StartDenseIntegration() call and finishing at the current context
time.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Dense integration is in progress (a dense output is held by this
integrator, after a call to StartDenseIntegration()).</dd>
<dt>Postcondition:</dt>
<dd>Previously held dense output is not updated nor referenced by the
integrator anymore.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any of the preconditions is not met.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.systems.analysis.MonteCarloSimulation">
<code class="descclassname">pydrake.systems.analysis.</code><code class="descname">MonteCarloSimulation</code><span class="sig-paren">(</span><em>make_simulator: Callable[[pydrake.common._module_py.RandomGenerator], pydrake.systems.analysis.Simulator_[float]], output: Callable[[pydrake.systems.framework.System_[float], pydrake.systems.framework.Context_[float]], float], final_time: float, num_samples: int, generator: pydrake.common._module_py.RandomGenerator</em><span class="sig-paren">)</span> &#x2192; List[pydrake.systems.analysis.RandomSimulationResult]<a class="headerlink" href="#pydrake.systems.analysis.MonteCarloSimulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate samples of a scalar random variable output by running many
random simulations drawn from independent samples of the distributions
governing the stochastic simulation.</p>
<p>In pseudo-code, this algorithm implements:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">num_samples</span>
    <span class="n">const</span> <span class="n">generator_snapshot</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">RandomSimulation</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">generator</span><span class="p">)</span>
    <span class="n">data</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="p">(</span><span class="n">generator_snapshot</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RandomSimulation() for details about <code class="docutils literal"><span class="pre">make_simulator</span></code>,
<code class="docutils literal"><span class="pre">output</span></code>, and <code class="docutils literal"><span class="pre">final_time</span></code>.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">num_samples</span></code>:</dt>
<dd>Number of independent samples to draw from the distribution (and
equivalently, the number of simulations to run).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">generator</span></code>:</dt>
<dd>Random number generator to be used to generate the random samples.
If null, then a new RandomGenerator will be allocated and used
internally (and repeated calls to this method will return
identical results). To produce statistically “independent” samples
on a future call to MonteCarloSimulation, you should make repeated
uses of the same RandomGenerator object.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of RandomSimulationResult’s.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pydrake.systems.analysis.PrintSimulatorStatistics">
<code class="descclassname">pydrake.systems.analysis.</code><code class="descname">PrintSimulatorStatistics</code><span class="sig-paren">(</span><em>arg0: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.PrintSimulatorStatistics" title="Permalink to this definition">¶</a></dt>
<dd><p>This method outputs to stdout relevant simulation statistics for a
simulator that advanced the state of a system forward in time.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">simulator</span></code>:</dt>
<dd>The simulator to output statistics for.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.systems.analysis.RandomSimulation">
<code class="descclassname">pydrake.systems.analysis.</code><code class="descname">RandomSimulation</code><span class="sig-paren">(</span><em>make_simulator: Callable[[pydrake.common._module_py.RandomGenerator], pydrake.systems.analysis.Simulator_[float]], output: Callable[[pydrake.systems.framework.System_[float], pydrake.systems.framework.Context_[float]], float], final_time: float, generator: pydrake.common._module_py.RandomGenerator</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.RandomSimulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a deterministic simulation of a (stochastic) System using the
<code class="docutils literal"><span class="pre">generator</span></code> to instantiate all “random” quantities.</p>
<p>In pseudo-code, this algorithm implements:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">simulator</span> <span class="o">=</span> <span class="n">make_simulator</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>
  <span class="n">simulator</span><span class="o">.</span><span class="n">get_system</span><span class="p">()</span><span class="o">.</span><span class="n">SetRandomContext</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>
  <span class="n">simulator</span><span class="o">.</span><span class="n">AdvanceTo</span><span class="p">(</span><span class="n">final_time</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">output</span><span class="p">(</span><span class="n">simulator</span><span class="o">.</span><span class="n">get_context</span><span class="p">())</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">make_simulator</span></code>:</dt>
<dd>Callers to this method define a stochastic simulation by providing
the <code class="docutils literal"><span class="pre">make_simulator</span></code> factory method to return a Simulator using
the supplied RandomGenerator as the only source of randomness.
This interface was designed to support cases where the
System/Diagram is random (not only the Context), e.g. in the case
where are variable number of objects are added to a multibody
simulation.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">output</span></code>:</dt>
<dd>The scalar random variable output, denoted <code class="docutils literal"><span class="pre">output</span></code>, is defined
as a function of the Simulator’s System’s Context, evaluated at
the <code class="docutils literal"><span class="pre">final_time</span></code>. Monte-Carlo investigations that studying the
details of an entire trajectory can still use this interface, e.g.
by including a “runtime monitor” System that latches the
worst-case deviation of a specification into it’s Context to be
queried at the final time.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">final_time</span></code>:</dt>
<dd>The time that each instance of the Simulator is stepped to. In
many cases, this will be equivalent to the duration of the
simulation, but it need not be because SetRandomContext() could
initialize the time to a non-zero value, or an event could trigger
premature termination of the simulation (see #4447).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">generator</span></code>:</dt>
<dd>Random number generator to be used to generate the random samples.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the <code class="docutils literal"><span class="pre">output</span></code> evaluated from the Context at <code class="docutils literal"><span class="pre">final_time</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pydrake.systems.analysis.RandomSimulationResult">
<em class="property">class </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">RandomSimulationResult</code><a class="headerlink" href="#pydrake.systems.analysis.RandomSimulationResult" title="Permalink to this definition">¶</a></dt>
<dd><p>A snapshot of the generator used to produce the random simulation.
Use, e.g.,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RandomGenerator</span> <span class="n">generator</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">generator_snapshot</span><span class="p">)</span>
  <span class="n">RandomSimulation</span><span class="p">(</span><span class="n">make_simulator</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">final_time</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">generator</span><span class="p">)</span>
</pre></div>
</div>
<p>for a deterministic playback of the sampled simulation. Use the
operator&lt;&lt;() operator&gt;&gt;() methods provided for the generator, which
implements the Standard Template Library &lt;a href=
“<a class="reference external" href="https://en.cppreference.com/w/cpp/named_req/RandomNumberEngine">https://en.cppreference.com/w/cpp/named_req/RandomNumberEngine</a>”&gt;
RandomNumberEngine concept&lt;/a&gt;, if you wish to serialize the results.
Note that the generator “snapshots” are returned as const, because any
non-const operations on that object may advance the state of the
generator (making it no-longer valuable in reproducing the
simulation).</p>
<dl class="attribute">
<dt id="pydrake.systems.analysis.RandomSimulationResult.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.systems.analysis.RandomSimulationResult.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.systems.analysis.RandomSimulationResult.generator_snapshot">
<code class="descname">generator_snapshot</code><a class="headerlink" href="#pydrake.systems.analysis.RandomSimulationResult.generator_snapshot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.systems.analysis.RandomSimulationResult.output">
<code class="descname">output</code><a class="headerlink" href="#pydrake.systems.analysis.RandomSimulationResult.output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.systems.analysis.RegionOfAttraction">
<code class="descclassname">pydrake.systems.analysis.</code><code class="descname">RegionOfAttraction</code><span class="sig-paren">(</span><em>system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float], options: pydrake.systems.analysis.RegionOfAttractionOptions = &lt;pydrake.systems.analysis.RegionOfAttractionOptions object at 0x7f7b53ea7c30&gt;</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.systems.analysis.RegionOfAttraction" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the region of attraction of the time-invariant <code class="docutils literal"><span class="pre">system</span></code> at
the fixed point defined by <code class="docutils literal"><span class="pre">context</span></code>.</p>
<p>This implementation only searches for the largest level set of the
<code class="docutils literal"><span class="pre">lyapunov_candidate</span></code> function from <code class="docutils literal"><span class="pre">options</span></code> (or a candidate
obtained from solving the Lyapunov equation on the linearization).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">system</span></code>:</dt>
<dd>a time-invariant continuous-time System that supports scalar-type
conversion to symbolic::Expression. The dynamics of the system
must be polynomial.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>a Context that defines the parameters of the system and the
fixed-point about which we are analyzing the regional stability.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">options</span></code>:</dt>
<dd>provides a variety of configuration options.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RegionOfAttractionOptions.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a symbolic::Expression representing a Lyapunov function using the
symbolic Variables named x0, x1…, where the order matches the
continuous state vector in the <code class="docutils literal"><span class="pre">context</span></code>, or the vector
state_variables passed in through the options structure (if it is
non-empty). The level set {x | V(x)&lt;=1} containing the fixed-point
in <code class="docutils literal"><span class="pre">context</span></code> represents the region of attraction.</td>
</tr>
</tbody>
</table>
<p>Note: There are more numerical techniques that we know how to apply
here. Do report an issue if you discover a system for which this code
does not perform well.</p>
</dd></dl>

<dl class="class">
<dt id="pydrake.systems.analysis.RegionOfAttractionOptions">
<em class="property">class </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">RegionOfAttractionOptions</code><a class="headerlink" href="#pydrake.systems.analysis.RegionOfAttractionOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Consolidates the many possible options to be passed to the region of
attraction algorithm.</p>
<dl class="method">
<dt id="pydrake.systems.analysis.RegionOfAttractionOptions.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.RegionOfAttractionOptions</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.RegionOfAttractionOptions.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.systems.analysis.RegionOfAttractionOptions.lyapunov_candidate">
<code class="descname">lyapunov_candidate</code><a class="headerlink" href="#pydrake.systems.analysis.RegionOfAttractionOptions.lyapunov_candidate" title="Permalink to this definition">¶</a></dt>
<dd><p>A candidate Lyapunov function using the symbolic Variables named x0,
x1, …, where the order matches the continuous state vector of the
system being evaluated (or the vector state_variables).</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.systems.analysis.RegionOfAttractionOptions.state_variables">
<code class="descname">state_variables</code><a class="headerlink" href="#pydrake.systems.analysis.RegionOfAttractionOptions.state_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>If non-empty, a list of Variable that associates the variable name
with the elements of the System’s continuous state vector. Must be
empty or have size equal to the number of continuous state variables
in the system.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.systems.analysis.ResetIntegratorFromFlags">
<code class="descclassname">pydrake.systems.analysis.</code><code class="descname">ResetIntegratorFromFlags</code><span class="sig-paren">(</span><em>simulator: pydrake.systems.analysis.Simulator_[float], scheme: str, max_step_size: float</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.IntegratorBase_[float]<a class="headerlink" href="#pydrake.systems.analysis.ResetIntegratorFromFlags" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the integrator used to advanced the continuous time dynamics of
the system associated with <code class="docutils literal"><span class="pre">simulator</span></code> according to the given
arguments.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">simulator</span></code>:</dt>
<dd>On input, a valid pointer to a Simulator. On output the integrator
for <code class="docutils literal"><span class="pre">simulator</span></code> is reset according to the given arguments.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">scheme</span></code>:</dt>
<dd>Integration scheme to be used, e.g., “runge_kutta2”. See
GetIntegrationSchemes() for a the list of valid options.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">max_step_size</span></code>:</dt>
<dd>The IntegratorBase::set_maximum_step_size() value.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A reference to the the newly created integrator owned by
<code class="docutils literal"><span class="pre">simulator</span></code>.</td>
</tr>
</tbody>
</table>
<p>&#64;tparam_default_nonsymbolic_scalar</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.systems.analysis.RungeKutta2Integrator">
<code class="descclassname">pydrake.systems.analysis.</code><code class="descname">RungeKutta2Integrator</code><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.systems.analysis.RungeKutta2Integrator_[float]" title="pydrake.systems.analysis.RungeKutta2Integrator_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.analysis.RungeKutta2Integrator_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.systems.analysis.RungeKutta2Integrator_">
<em class="property">template </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">RungeKutta2Integrator_</code><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.systems.analysis.RungeKutta2Integrator_[float]" title="pydrake.systems.analysis.RungeKutta2Integrator_[float]"><code class="xref py py-class docutils literal"><span class="pre">RungeKutta2Integrator_[float]</span></code></a>, <a class="reference internal" href="#pydrake.systems.analysis.RungeKutta2Integrator_[AutoDiffXd]" title="pydrake.systems.analysis.RungeKutta2Integrator_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">RungeKutta2Integrator_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.systems.analysis.RungeKutta2Integrator_[Expression]" title="pydrake.systems.analysis.RungeKutta2Integrator_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">RungeKutta2Integrator_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.systems.analysis.RungeKutta2Integrator_.RungeKutta2Integrator_[float]">
<em class="property">class </em><code class="descname">RungeKutta2Integrator_[float]</code><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_.RungeKutta2Integrator_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_[float]" title="pydrake.systems.analysis.IntegratorBase_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.analysis.IntegratorBase_[float]</span></code></a></p>
<p>A second-order, explicit Runge Kutta integrator.</p>
<dl class="method">
<dt id="pydrake.systems.analysis.RungeKutta2Integrator_.RungeKutta2Integrator_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.RungeKutta2Integrator_[float], system: pydrake.systems.framework.System_[float], max_step_size: float, context: pydrake.systems.framework.Context_[float] = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_.RungeKutta2Integrator_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs fixed-step integrator for a given system using the given
context for initial conditions.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">system</span></code>:</dt>
<dd>A reference to the system to be simulated</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">max_step_size</span></code>:</dt>
<dd>The maximum (fixed) step size; the integrator will not take larger
step sizes than this.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>pointer to the context (nullptr is ok, but the caller must set a
non-null context before Initialize()-ing the integrator).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Initialize()</p>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.systems.analysis.RungeKutta2Integrator_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">RungeKutta2Integrator_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]" title="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]</span></code></a></p>
<p>A second-order, explicit Runge Kutta integrator.</p>
<dl class="method">
<dt id="pydrake.systems.analysis.RungeKutta2Integrator_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.RungeKutta2Integrator_[AutoDiffXd], system: pydrake.systems.framework.System_[AutoDiffXd], max_step_size: pydrake.autodiffutils.AutoDiffXd, context: pydrake.systems.framework.Context_[AutoDiffXd] = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs fixed-step integrator for a given system using the given
context for initial conditions.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">system</span></code>:</dt>
<dd>A reference to the system to be simulated</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">max_step_size</span></code>:</dt>
<dd>The maximum (fixed) step size; the integrator will not take larger
step sizes than this.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>pointer to the context (nullptr is ok, but the caller must set a
non-null context before Initialize()-ing the integrator).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Initialize()</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.systems.analysis.RungeKutta2Integrator_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">RungeKutta2Integrator_[Expression]</code><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_[Expression]" title="pydrake.systems.analysis.IntegratorBase_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.analysis.IntegratorBase_[Expression]</span></code></a></p>
<p>A second-order, explicit Runge Kutta integrator.</p>
<dl class="method">
<dt id="pydrake.systems.analysis.RungeKutta2Integrator_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.RungeKutta2Integrator_[Expression], system: pydrake.systems.framework.System_[Expression], max_step_size: pydrake.symbolic.Expression, context: pydrake.systems.framework.Context_[Expression] = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs fixed-step integrator for a given system using the given
context for initial conditions.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">system</span></code>:</dt>
<dd>A reference to the system to be simulated</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">max_step_size</span></code>:</dt>
<dd>The maximum (fixed) step size; the integrator will not take larger
step sizes than this.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>pointer to the context (nullptr is ok, but the caller must set a
non-null context before Initialize()-ing the integrator).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Initialize()</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.systems.analysis.RungeKutta2Integrator_[float]">
<em class="property">class </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">RungeKutta2Integrator_[float]</code><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_[float]" title="pydrake.systems.analysis.IntegratorBase_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.analysis.IntegratorBase_[float]</span></code></a></p>
<p>A second-order, explicit Runge Kutta integrator.</p>
<dl class="method">
<dt id="pydrake.systems.analysis.RungeKutta2Integrator_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.RungeKutta2Integrator_[float], system: pydrake.systems.framework.System_[float], max_step_size: float, context: pydrake.systems.framework.Context_[float] = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs fixed-step integrator for a given system using the given
context for initial conditions.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">system</span></code>:</dt>
<dd>A reference to the system to be simulated</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">max_step_size</span></code>:</dt>
<dd>The maximum (fixed) step size; the integrator will not take larger
step sizes than this.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>pointer to the context (nullptr is ok, but the caller must set a
non-null context before Initialize()-ing the integrator).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Initialize()</p>
</div>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.systems.analysis.RungeKutta3Integrator">
<code class="descclassname">pydrake.systems.analysis.</code><code class="descname">RungeKutta3Integrator</code><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.systems.analysis.RungeKutta3Integrator_[float]" title="pydrake.systems.analysis.RungeKutta3Integrator_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.analysis.RungeKutta3Integrator_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.systems.analysis.RungeKutta3Integrator_">
<em class="property">template </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">RungeKutta3Integrator_</code><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.systems.analysis.RungeKutta3Integrator_[float]" title="pydrake.systems.analysis.RungeKutta3Integrator_[float]"><code class="xref py py-class docutils literal"><span class="pre">RungeKutta3Integrator_[float]</span></code></a>, <a class="reference internal" href="#pydrake.systems.analysis.RungeKutta3Integrator_[AutoDiffXd]" title="pydrake.systems.analysis.RungeKutta3Integrator_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">RungeKutta3Integrator_[AutoDiffXd]</span></code></a></p>
<dl class="class">
<dt id="pydrake.systems.analysis.RungeKutta3Integrator_.RungeKutta3Integrator_[float]">
<em class="property">class </em><code class="descname">RungeKutta3Integrator_[float]</code><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator_.RungeKutta3Integrator_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_[float]" title="pydrake.systems.analysis.IntegratorBase_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.analysis.IntegratorBase_[float]</span></code></a></p>
<p>A third-order Runge Kutta integrator with a third order error
estimate.</p>
<p>For a discussion of this Runge-Kutta method, see [Butcher, 1987]. The
embedded error estimate was derived using the method mentioned in
[Hairer, 1993].</p>
<p>The Butcher tableau for this integrator follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span>
<span class="mi">0</span>      <span class="o">|</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">2</span>    <span class="o">|</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="mi">1</span>      <span class="o">|</span> <span class="o">-</span><span class="mi">1</span>          <span class="mi">2</span>
<span class="o">---------------------------------------------------------------------------</span>
         <span class="mi">1</span><span class="o">/</span><span class="mi">6</span>         <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>       <span class="mi">1</span><span class="o">/</span><span class="mi">6</span>
         <span class="mi">0</span>           <span class="mi">1</span>         <span class="mi">0</span>
</pre></div>
</div>
<p>where the second to last row is the 3rd-order propagated solution and
the last row is the 2nd-order midpoint used for the error estimate.</p>
<p>The following documentation is pulled from Simbody’s implementation of
this integrator: “This is a 3-stage, first-same-as-last (FSAL) 3rd
order method which gives us an embedded 2nd order method as well, so
we can extract a 3rd-order error estimate for the 2nd-order result,
which error estimate can then be used for step size control, since it
will behave as h^3. We then propagate the 3rd order result (whose
error is unknown), which Hairer calls ‘local extrapolation’. We call
the initial state (t0,y0) and want (t0+h,y1). We are given the initial
derivative f0=f(t0,y0), which most likely is left over from an
evaluation at the end of the last step.”</p>
<ul class="simple">
<li>[Butcher, 1987] J. C. Butcher. The Numerical Analysis of Ordinary
Differential Equations. John Wiley &amp; Sons, 1987. p. 325.</li>
<li>[Hairer, 1993] E. Hairer, S. Noersett, and G. Wanner. Solving ODEs I. 2nd
rev. ed. Springer, 1993. p. 166.</li>
</ul>
<dl class="method">
<dt id="pydrake.systems.analysis.RungeKutta3Integrator_.RungeKutta3Integrator_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.RungeKutta3Integrator_[float], system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float] = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator_.RungeKutta3Integrator_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.systems.analysis.RungeKutta3Integrator_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">RungeKutta3Integrator_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]" title="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]</span></code></a></p>
<p>A third-order Runge Kutta integrator with a third order error
estimate.</p>
<p>For a discussion of this Runge-Kutta method, see [Butcher, 1987]. The
embedded error estimate was derived using the method mentioned in
[Hairer, 1993].</p>
<p>The Butcher tableau for this integrator follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span>
<span class="mi">0</span>      <span class="o">|</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">2</span>    <span class="o">|</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="mi">1</span>      <span class="o">|</span> <span class="o">-</span><span class="mi">1</span>          <span class="mi">2</span>
<span class="o">---------------------------------------------------------------------------</span>
         <span class="mi">1</span><span class="o">/</span><span class="mi">6</span>         <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>       <span class="mi">1</span><span class="o">/</span><span class="mi">6</span>
         <span class="mi">0</span>           <span class="mi">1</span>         <span class="mi">0</span>
</pre></div>
</div>
<p>where the second to last row is the 3rd-order propagated solution and
the last row is the 2nd-order midpoint used for the error estimate.</p>
<p>The following documentation is pulled from Simbody’s implementation of
this integrator: “This is a 3-stage, first-same-as-last (FSAL) 3rd
order method which gives us an embedded 2nd order method as well, so
we can extract a 3rd-order error estimate for the 2nd-order result,
which error estimate can then be used for step size control, since it
will behave as h^3. We then propagate the 3rd order result (whose
error is unknown), which Hairer calls ‘local extrapolation’. We call
the initial state (t0,y0) and want (t0+h,y1). We are given the initial
derivative f0=f(t0,y0), which most likely is left over from an
evaluation at the end of the last step.”</p>
<ul class="simple">
<li>[Butcher, 1987] J. C. Butcher. The Numerical Analysis of Ordinary
Differential Equations. John Wiley &amp; Sons, 1987. p. 325.</li>
<li>[Hairer, 1993] E. Hairer, S. Noersett, and G. Wanner. Solving ODEs I. 2nd
rev. ed. Springer, 1993. p. 166.</li>
</ul>
<dl class="method">
<dt id="pydrake.systems.analysis.RungeKutta3Integrator_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.RungeKutta3Integrator_[AutoDiffXd], system: pydrake.systems.framework.System_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd] = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.systems.analysis.RungeKutta3Integrator_[float]">
<em class="property">class </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">RungeKutta3Integrator_[float]</code><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_[float]" title="pydrake.systems.analysis.IntegratorBase_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.analysis.IntegratorBase_[float]</span></code></a></p>
<p>A third-order Runge Kutta integrator with a third order error
estimate.</p>
<p>For a discussion of this Runge-Kutta method, see [Butcher, 1987]. The
embedded error estimate was derived using the method mentioned in
[Hairer, 1993].</p>
<p>The Butcher tableau for this integrator follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|</span>
<span class="mi">0</span>      <span class="o">|</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">2</span>    <span class="o">|</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="mi">1</span>      <span class="o">|</span> <span class="o">-</span><span class="mi">1</span>          <span class="mi">2</span>
<span class="o">---------------------------------------------------------------------------</span>
         <span class="mi">1</span><span class="o">/</span><span class="mi">6</span>         <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>       <span class="mi">1</span><span class="o">/</span><span class="mi">6</span>
         <span class="mi">0</span>           <span class="mi">1</span>         <span class="mi">0</span>
</pre></div>
</div>
<p>where the second to last row is the 3rd-order propagated solution and
the last row is the 2nd-order midpoint used for the error estimate.</p>
<p>The following documentation is pulled from Simbody’s implementation of
this integrator: “This is a 3-stage, first-same-as-last (FSAL) 3rd
order method which gives us an embedded 2nd order method as well, so
we can extract a 3rd-order error estimate for the 2nd-order result,
which error estimate can then be used for step size control, since it
will behave as h^3. We then propagate the 3rd order result (whose
error is unknown), which Hairer calls ‘local extrapolation’. We call
the initial state (t0,y0) and want (t0+h,y1). We are given the initial
derivative f0=f(t0,y0), which most likely is left over from an
evaluation at the end of the last step.”</p>
<ul class="simple">
<li>[Butcher, 1987] J. C. Butcher. The Numerical Analysis of Ordinary
Differential Equations. John Wiley &amp; Sons, 1987. p. 325.</li>
<li>[Hairer, 1993] E. Hairer, S. Noersett, and G. Wanner. Solving ODEs I. 2nd
rev. ed. Springer, 1993. p. 166.</li>
</ul>
<dl class="method">
<dt id="pydrake.systems.analysis.RungeKutta3Integrator_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.RungeKutta3Integrator_[float], system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float] = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.systems.analysis.Simulator">
<code class="descclassname">pydrake.systems.analysis.</code><code class="descname">Simulator</code><a class="headerlink" href="#pydrake.systems.analysis.Simulator" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.systems.analysis.Simulator_[float]" title="pydrake.systems.analysis.Simulator_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.analysis.Simulator_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.systems.analysis.Simulator_">
<em class="property">template </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">Simulator_</code><a class="headerlink" href="#pydrake.systems.analysis.Simulator_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.systems.analysis.Simulator_[float]" title="pydrake.systems.analysis.Simulator_[float]"><code class="xref py py-class docutils literal"><span class="pre">Simulator_[float]</span></code></a>, <a class="reference internal" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd]" title="pydrake.systems.analysis.Simulator_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">Simulator_[AutoDiffXd]</span></code></a></p>
<dl class="class">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float]">
<em class="property">class </em><code class="descname">Simulator_[float]</code><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for advancing the state of hybrid dynamic systems, represented
by <code class="docutils literal"><span class="pre">System&lt;T&gt;</span></code> objects, forward in time. Starting with an initial
Context for a given System, Simulator advances time and produces a
series of Context values that forms a trajectory satisfying the
system’s dynamic equations to a specified accuracy. Only the Context
is modified by a Simulator; the System is const.</p>
<p>A Drake System is a continuous/discrete/hybrid dynamic system where
the continuous part is a DAE, that is, it is expected to consist of a
set of differential equations and bilateral algebraic constraints. The
set of active constraints may change as a result of particular events,
such as contact.</p>
<p>Given a current Context, we expect a System to provide us with -
derivatives for the continuous differential equations that already
satisfy the differentiated form of the constraints (typically,
acceleration constraints), - a projection method for least-squares
correction of violated higher-level constraints (position and velocity
level), - a time-of-next-update method that can be used to adjust the
integrator step size in preparation for a discrete update, - methods
that can update discrete variables when their update time is reached,
- witness (guard) functions for event isolation, - event handlers
(reset functions) for making appropriate changes to state and mode
variables when an event has been isolated.</p>
<p>The continuous parts of the trajectory are advanced using a numerical
integrator. Different integrators have different properties; you can
choose the one that is most appropriate for your application or use
the default which is adequate for most systems.</p>
<p>&lt;h3&gt;How the simulation is stepped: simulation mechanics for authors of
discrete and hybrid systems&lt;/h3&gt;</p>
<p>This section is targeted toward users who have created a LeafSystem
implementing a discrete or hybrid system. For authors of such systems,
it can be useful to understand the simulation details in order to
attain the desired state behavior over time. This behavior is
dependent on the ordering in which discrete events and continuous
updates are processed. (By “discrete events” we mean to include any of
Drake’s event handlers.) The basic issues and terminology are
introduced in the discrete_systems module; please look there first
before proceeding.</p>
<p>As pictured in discrete_systems, when a continuous-time system has
discrete events, the state x can have two significant values at the
event time t. These are - x⁻(t), the value of x <em>before</em> the discrete
update occurs (○ markers), and - x⁺(t), the value of x <em>after</em> the
discrete update occurs (● markers).</p>
<p>Thus the value of the Context, which contains both time and state,
advances from {t, x⁻(t)} to {t, x⁺(t)} as a result of the update.
While those Context values are user-visible, the details of stepping
here require an intermediate value which we’ll denote {t, x*(t)}.</p>
<p>Recall that Drake’s state x is partitioned into continuous, discrete,
and abstract partitions xc, xd, and xa, so <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">xc,</span> <span class="pre">xd,</span> <span class="pre">xa</span> <span class="pre">}</span></code>.
Within a single step, these are updated in three stages: -</p>
<p>Unrestricted update (can change x) -</p>
<p>Discrete update (can change only xd) -</p>
<p>Continuous update (changes t and xc)</p>
<p>Where needed, we extend the above notation to xc⁻, xa⁺, etc. to
indicate the value of an individual partition at a particular stage of
the stepping algorithm.</p>
<p>The following pseudocode uses the above notation to describe the
algorithm “Step()” that the Simulator uses to incrementally advance
the system trajectory (time t and state x). The Simulator’s
AdvanceTo() method will be defined in terms of Step below. In general,
the length of a step is not known a priori and is determined by the
Step() algorithm. Each step consists of zero or more unrestricted
updates, followed by zero or more discrete updates, followed by
(possibly zero-length) continuous time and state advancement, followed
by zero or more publishes, and then a call to the monitor() function
if one has been defined. Updates, publishes, and the monitor can
report errors or detect a termination condition; that is not shown in
the pseudocode below.</p>
<p>The pseudocode will clarify the effects on time and state of each of
the update stages above. This algorithm is given a starting Context
value <code class="docutils literal"><span class="pre">{tₛ,</span> <span class="pre">x⁻(tₛ)}</span></code> and returns an end Context value <code class="docutils literal"><span class="pre">{tₑ,</span>
<span class="pre">x⁻(tₑ)}</span></code>, where tₑ is <em>no later</em> than a given tₘₐₓ.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Advance the trajectory (time and state) from start value {tₛ, x⁻(tₛ)} to an
// end value {tₑ, x⁻(tₑ)}, where tₛ ≤ tₑ ≤ tₘₐₓ.
procedure Step(tₛ, x⁻(tₛ), tₘₐₓ)

// Update any variables (no restrictions).
x*(tₛ) ← DoAnyUnrestrictedUpdates(tₛ, x⁻(tₛ))

// ----------------------------------
// Time and state are at {tₛ, x*(tₛ)}
// ----------------------------------

// Update discrete variables.
xd⁺(tₛ) ← DoAnyDiscreteUpdates(tₛ, x*(tₛ))

xc⁺(tₛ) ← xc*(tₛ)  // These values carry over from x*(tₛ).
xa⁺(tₛ) ← xa*(tₛ)

// ----------------------------------
// Time and state are at {tₛ, x⁺(tₛ)}
// ----------------------------------

// See how far it is safe to integrate without missing any events.
tₑᵥₑₙₜ ← CalcNextEventTime(tₛ, x⁺(tₛ))

// Integrate continuous variables forward in time. Integration may terminate
// before reaching tₛₜₒₚ due to witnessed events.
tₛₜₒₚ ← min(tₑᵥₑₙₜ, tₘₐₓ)
tₑ, xc⁻(tₑ) ← Integrate(tₛ, x⁺(tₛ), tₛₜₒₚ)

xd⁻(tₑ) ← xd⁺(tₛ)  // Discrete values are held from x⁺(tₛ).
xa⁻(tₑ) ← xa⁺(tₛ)

// ----------------------------------
// Time and state are at {tₑ, x⁻(tₑ)}
// ----------------------------------

DoAnyPublishes(tₑ, x⁻(tₑ))
CallMonitor(tₑ, x⁻(tₑ))

return {tₑ, x⁻(tₑ)}
</pre></div>
</div>
<p>We can use the notation and pseudocode to flesh out the AdvanceTo(),
AdvancePendingEvents(), and Initialize() functions. Termination and
error conditions detected by event handlers or the monitor are
reported as status returns from these methods.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Advance the simulation until time tₘₐₓ.
procedure AdvanceTo(tₘₐₓ) → status
t ← current_time
while t &lt; tₘₐₓ
{tₑ, x⁻(tₑ)} ← Step(t, x⁻(t), tₘₐₓ)
{t, x⁻(t)} ← {tₑ, x⁻(tₑ)}
endwhile

// AdvancePendingEvents() is an advanced method, not commonly used.
// Perform just the start-of-step update to advance from x⁻(t) to x⁺(t).
procedure AdvancePendingEvents() → status
t ≜ current_time, x⁻(t) ≜ current_state
x⁺(t) ← DoAnyPendingUpdates(t, x⁻(t)) as in Step()
x(t) ← x⁺(t)  // No continuous update needed.
DoAnyPublishes(t, x(t))
CallMonitor(t, x(t))

// Update time and state to {t₀, x⁻(t₀)}, which is the starting value of the
// trajectory, and thus the value the Context should contain at the start of the
// first simulation step.
procedure Initialize(t₀, x₀) → status
x⁺(t₀) ← DoAnyInitializationUpdates as in Step()
x⁻(t₀) ← x⁺(t₀)  // No continuous update needed.

// ----------------------------------
// Time and state are at {t₀, x⁻(t₀)}
// ----------------------------------

DoAnyPublishes(t₀, x⁻(t₀))
CallMonitor(t₀, x⁻(t₀))
</pre></div>
</div>
<p>Initialize() can be viewed as a “0ᵗʰ step” that occurs before the
first Step() call as described above. Like Step(), Initialize() first
performs pending updates (in this case only initialization events can
be “pending”). Time doesn’t advance so there is no continuous update
phase and witnesses cannot trigger. Finally, again like Step(), the
initial trajectory point <code class="docutils literal"><span class="pre">{t₀,</span> <span class="pre">x⁻(t₀)}</span></code> is provided to the handlers
for any triggered publish events. That includes initialization publish
events, per-step publish events, and periodic or timed publish events
that trigger at t₀, followed by a call to the monitor() function if
one has been defined (a monitor is semantically identical to a
per-step publish).</p>
<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float], system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float] = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Simulator that can advance a given System through time to
produce a trajectory consisting of a sequence of Context values. The
System must not have unresolved input ports if the values of those
ports are necessary for computations performed during simulation (see
class documentation).</p>
<p>The Simulator holds an internal, non-owned reference to the System
object so you must ensure that <code class="docutils literal"><span class="pre">system</span></code> has a longer lifetime than
the Simulator. It also owns a compatible Context internally that takes
on each of the trajectory values. You may optionally provide a Context
that will be used as the initial condition for the simulation;
otherwise the Simulator will obtain a default Context from <code class="docutils literal"><span class="pre">system</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].AdvancePendingEvents">
<code class="descname">AdvancePendingEvents</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.SimulatorStatus<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].AdvancePendingEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Handles discrete and abstract state update events that are
pending from the previous AdvanceTo() call, without advancing time.
See the Simulator class description for details about how Simulator
advances time and handles events. In the terminology used there, this
method advances the internal Context from <code class="docutils literal"><span class="pre">{t,</span> <span class="pre">x⁻(t)}</span></code> to <code class="docutils literal"><span class="pre">{t,</span>
<span class="pre">x⁺(t)}</span></code>.</p>
<p>Normally, these update events would be handled at the start of the
next AdvanceTo() call, so this method is rarely needed. It can be
useful at the end of a simulation or to get intermediate results when
you are specifically interested in the <code class="docutils literal"><span class="pre">x⁺(t)</span></code> result.</p>
<p>This method is equivalent to <code class="docutils literal"><span class="pre">AdvanceTo(current_time)</span></code>, where
<code class="docutils literal"><span class="pre">current_time=simulator.get_context().get_time())</span></code>. If there are no
pending events, nothing happens except possibly a final per-step
publish call (if enabled) followed by a call to the monitor() function
(if one has been provided).</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">status</span></code>:</dt>
<dd>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AdvanceTo(), Initialize(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].AdvanceTo">
<code class="descname">AdvanceTo</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float], boundary_time: float</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.SimulatorStatus<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].AdvanceTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Advances the System’s trajectory until <code class="docutils literal"><span class="pre">boundary_time</span></code> is reached in
the context or some other termination condition occurs. A variety of
<code class="docutils literal"><span class="pre">RuntimeError</span></code> conditions are possible here, as well as error
conditions that may be thrown by the System when it is asked to
perform computations. Be sure to enclose your simulation in a
<code class="docutils literal"><span class="pre">try-catch</span></code> block and display the <code class="docutils literal"><span class="pre">what()</span></code> message.</p>
<p>We recommend that you call Initialize() prior to making the first call
to AdvanceTo(). However, if you don’t it will be called for you the
first time that you attempt a step, possibly resulting in unexpected
error conditions. See documentation for <code class="docutils literal"><span class="pre">Initialize()</span></code> for the error
conditions it might produce.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You should consider calling Initialize() if you alter the the
Context or Simulator options between successive AdvanceTo() calls.
See Initialize() for more information.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">boundary_time</span></code>:</dt>
<dd>The maximum time to which the trajectory will be advanced by this
call to AdvanceTo(). The method may return earlier if an event or
the monitor function requests termination or reports an error
condition.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">status</span></code>:</dt>
<dd>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function. The time in the context will be set either to the
boundary_time or the time a termination or error was first
detected.</dd>
<dt>Precondition:</dt>
<dd>The internal Context satisfies all System constraints or will
after pending Context updates are performed.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Initialize(), AdvancePendingEvents(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].clear_monitor">
<code class="descname">clear_monitor</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].clear_monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the monitoring function if there is one.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_monitor()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_actual_realtime_rate">
<code class="descname">get_actual_realtime_rate</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].get_actual_realtime_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the rate that simulated time has progressed relative to real
time. A return of 1 means the simulation just matched real time, 2
means the simulation was twice as fast as real time, 0.5 means it was
running in 2X slow motion, etc.</p>
<p>The value returned here is calculated as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">simulated_time_now</span> <span class="o">-</span> <span class="n">initial_simulated_time</span>
  <span class="n">rate</span> <span class="o">=</span> <span class="o">-------------------------------------------</span>
               <span class="n">realtime_now</span> <span class="o">-</span> <span class="n">initial_realtime</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">initial</span></code> times are recorded when Initialize() or
ResetStatistics() is called. The returned rate is undefined if
Initialize() has not yet been called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rate achieved since the last Initialize() or ResetStatistics()
call.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_target_realtime_rate()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_context">
<code class="descname">get_context</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.Context_[float]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].get_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the internally-maintained Context holding
the most recent step in the trajectory. This is suitable for
publishing or extracting information about this trajectory step. Do
not call this method if there is no Context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_integrator">
<code class="descname">get_integrator</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.IntegratorBase_[float]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].get_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a reference to the integrator used to advance the continuous
aspects of the system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_monitor">
<code class="descname">get_monitor</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; Callable[[pydrake.systems.framework.Context_[float]], pydrake.systems.framework.EventStatus]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].get_monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtains a reference to the monitoring function, which may be empty.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_monitor()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_mutable_context">
<code class="descname">get_mutable_context</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.Context_[float]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].get_mutable_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a mutable reference to the internally-maintained Context
holding the most recent step in the trajectory. This is suitable for
use in updates, sampling operations, event handlers, and constraint
projection. You can also modify this prior to calling Initialize() to
set initial conditions. Do not call this method if there is no
Context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_mutable_integrator">
<code class="descname">get_mutable_integrator</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.IntegratorBase_[float]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].get_mutable_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a reference to the mutable integrator used to advance the
continuous state of the system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_system">
<code class="descname">get_system</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.System_[float]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].get_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a constant reference to the system.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">a mutable reference is not available.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_target_realtime_rate">
<code class="descname">get_target_realtime_rate</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].get_target_realtime_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real time rate target currently in effect. The default is
zero, meaning the Simulator runs as fast as possible. You can change
the target with set_target_realtime_rate().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].has_context">
<code class="descname">has_context</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].has_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if this Simulator has an internally-maintained
Context. This is always true unless <code class="docutils literal"><span class="pre">reset_context()</span></code> has been
called.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].Initialize">
<code class="descname">Initialize</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.SimulatorStatus<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].Initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepares the Simulator for a simulation. In order, the sequence of
actions taken here are: - The active integrator’s Initialize() method
is invoked. - Statistics are reset. - Initialization update events are
triggered and handled to produce the initial trajectory value <code class="docutils literal"><span class="pre">{t₀,</span>
<span class="pre">x(t₀)}</span></code>. - Then that initial value is provided to the handlers for
any publish events that have triggered, including initialization and
per-step publish events, periodic or other time-triggered publish
events that are scheduled for the initial time t₀, and finally a call
to the monitor() function if one has been defined.</p>
<p>See the class documentation for more information. We recommend calling
Initialize() explicitly prior to beginning a simulation so that error
conditions will be discovered early. However, Initialize() will be
called automatically by the first AdvanceTo() call if it hasn’t
already been called.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you make a change to the Context or to Simulator options
between AdvanceTo() calls you should consider whether to call
Initialize() before resuming; AdvanceTo() will not do that
automatically for you. Whether to do so depends on whether you
want the above initialization operations performed. For example,
if you changed the time you will likely want the time-triggered
events to be recalculated in case one is due at the new starting
time.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Initialize() does not automatically attempt to satisfy System
constraints – it is up to you to make sure that constraints are
satisfied by the initial conditions.</p>
</div>
<p>This method will throw <code class="docutils literal"><span class="pre">RuntimeError</span></code> if the combination of options
doesn’t make sense. Other failures are possible from the System and
integrator in use.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">status</span></code>:</dt>
<dd>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AdvanceTo(), AdvancePendingEvents(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].reset_context">
<code class="descname">reset_context</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].reset_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the internally-maintained Context with a different one. The
current Context is deleted. This is useful for supplying a new set of
initial conditions. You should invoke Initialize() after replacing the
Context.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The new context, which may be null. If the context is null, a new
context must be set before attempting to step the system forward.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].reset_integrator">
<code class="descname">reset_integrator</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float], integrator: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.IntegratorBase_[float]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].reset_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.) pydrake.systems.Simulator.reset_integrator is deprecated and will be removed from Drake on or after 2020-08-01. Use pydrake.systems.ResetIntegratorFromFlags instead.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].ResetStatistics">
<code class="descname">ResetStatistics</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].ResetStatistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Forget accumulated statistics. Statistics are reset to the values they
have post construction or immediately after <code class="docutils literal"><span class="pre">Initialize()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].set_monitor">
<code class="descname">set_monitor</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float], monitor: Callable[[pydrake.systems.framework.Context_[float]], pydrake.systems.framework.EventStatus]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].set_monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a monitoring function that will be invoked at the end of
every step. (See the Simulator class documentation for a precise
definition of “step”.) A monitor() function can be used to capture the
trajectory, to terminate the simulation, or to detect error
conditions. The monitor() function is invoked by the Simulator with a
Context whose value is a point along the simulated trajectory. The
monitor can be any functor and should capture any System references it
needs to operate correctly.</p>
<p>A monitor() function behaves the same as would a per-step Publish
event handler included in the top-level System or Diagram being
simulated. As in the case of Publish(), the monitor is called at the
end of every step taken internally by AdvanceTo(), and also at the end
of Initialize() and AdvancePendingEvents(). (See the Simulator class
documentation for more detail about what happens when in these
methods.) The monitor receives the top-level (root) Context, from
which any sub-Context can be obtained using
<code class="docutils literal"><span class="pre">subsystem.GetMyContextFromRoot()</span></code>, provided the necessary subsystem
reference has been captured for use in the monitor.</p>
<p>** Examples Output time and continuous states whenever the trajectory
is advanced:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">root_context</span><span class="o">.</span><span class="n">get_time</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot; &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">root_context</span><span class="o">.</span><span class="n">get_continuous_state_vector</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Terminate early but successfully on a condition in a subsystem of the
System diagram being simulated:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([</span><span class="o">&amp;</span><span class="n">my_subsystem</span><span class="p">](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">subcontext</span> <span class="o">=</span>
      <span class="n">my_subsystem</span><span class="o">.</span><span class="n">GetMyContextFromRoot</span><span class="p">(</span><span class="n">root_context</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">my_subsystem</span><span class="o">.</span><span class="n">GoalReached</span><span class="p">(</span><span class="n">subcontext</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">ReachedTermination</span><span class="p">(</span><span class="n">my_subsystem</span><span class="p">,</span>
        <span class="s2">&quot;Simulation achieved the desired goal.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>In the above case, the Simulator’s AdvanceTo() method will return
early when the subsystem reports that it has reached its goal. The
returned status will indicate the termination reason, and a
human-readable termination message containing the message provided by
the monitor can be obtained with status.FormatMessage().</p>
<p>Failure due to plant center of mass falling below a threshold:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([</span><span class="o">&amp;</span><span class="n">plant</span><span class="p">](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">plant_context</span> <span class="o">=</span>
      <span class="n">plant</span><span class="o">.</span><span class="n">GetMyContextFromRoot</span><span class="p">(</span><span class="n">root_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">com</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">CalcCenterOfMassPosition</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">)</span> <span class="p">{</span>  <span class="o">//</span> <span class="n">Check</span> <span class="n">z</span> <span class="n">height</span> <span class="n">of</span> <span class="n">com</span><span class="o">.</span>
    <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Failed</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span> <span class="s2">&quot;System fell over.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>In the above case the Simulator’s AdvanceTo() method will throw an
RuntimeError containing a human-readable message including the text
provided in the monitor.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">monitor() is called every time the trajectory is advanced by a
step, which can mean it is called many times during a single
AdvanceTo() call.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The presence of a monitor has no effect on the step sizes taken,
so a termination or error condition will be discovered only when
first observed after a step is complete; it will not be further
localized. Use witness-triggered events instead if you need
precise isolation.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].set_publish_every_time_step">
<code class="descname">set_publish_every_time_step</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float], arg0: bool</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].set_publish_every_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets whether the simulation should trigger a forced-Publish event on
the System under simulation at the end of every trajectory-advancing
step. Specifically, that means the System::Publish() event dispatcher
will be invoked on each subsystem of the System and passed the current
Context and a forced-publish Event. If a subsystem has declared a
forced-publish event handler, that will be called. Otherwise, nothing
will happen unless the DoPublish() dispatcher has been overridden.</p>
<p>Enabling this option does not cause a forced-publish to be triggered
at initialization; if you want that you should also call
<code class="docutils literal"><span class="pre">set_publish_at_initialization(true)</span></code>. If you want a forced-publish
at the end of every step, you will usually also want one at the end of
initialization, requiring both options to be enabled.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">LeafSystem::DeclareForcedPublishEvent()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_.Simulator_[float].set_target_realtime_rate">
<code class="descname">set_target_realtime_rate</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float], arg0: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_[float].set_target_realtime_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Slow the simulation down to <em>approximately</em> synchronize with real time
when it would otherwise run too fast. Normally the Simulator takes
steps as quickly as it can. You can request that it slow down to
synchronize with real time by providing a realtime rate greater than
zero here.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">No guarantees can be made about how accurately the simulation can
be made to track real time, even if computation is fast enough.
That’s because the system utilities used to implement this do not
themselves provide such guarantees. So this is likely to work
nicely for visualization purposes where human perception is the
only concern. For any other uses you should consider whether
approximate real time is adequate for your purposes.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the full-speed simulation is already slower than real time you
can’t speed it up with this call! Instead consider requesting less
integration accuracy, using a faster integration method or fixed
time step, or using a simpler model.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">realtime_rate</span></code>:</dt>
<dd>Desired rate relative to real time. Set to 1 to track real time, 2
to run twice as fast as real time, 0.5 for half speed, etc. Zero
or negative restores the rate to its default of 0, meaning the
simulation will proceed as fast as possible.</dd>
</dl>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">Simulator_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for advancing the state of hybrid dynamic systems, represented
by <code class="docutils literal"><span class="pre">System&lt;T&gt;</span></code> objects, forward in time. Starting with an initial
Context for a given System, Simulator advances time and produces a
series of Context values that forms a trajectory satisfying the
system’s dynamic equations to a specified accuracy. Only the Context
is modified by a Simulator; the System is const.</p>
<p>A Drake System is a continuous/discrete/hybrid dynamic system where
the continuous part is a DAE, that is, it is expected to consist of a
set of differential equations and bilateral algebraic constraints. The
set of active constraints may change as a result of particular events,
such as contact.</p>
<p>Given a current Context, we expect a System to provide us with -
derivatives for the continuous differential equations that already
satisfy the differentiated form of the constraints (typically,
acceleration constraints), - a projection method for least-squares
correction of violated higher-level constraints (position and velocity
level), - a time-of-next-update method that can be used to adjust the
integrator step size in preparation for a discrete update, - methods
that can update discrete variables when their update time is reached,
- witness (guard) functions for event isolation, - event handlers
(reset functions) for making appropriate changes to state and mode
variables when an event has been isolated.</p>
<p>The continuous parts of the trajectory are advanced using a numerical
integrator. Different integrators have different properties; you can
choose the one that is most appropriate for your application or use
the default which is adequate for most systems.</p>
<p>&lt;h3&gt;How the simulation is stepped: simulation mechanics for authors of
discrete and hybrid systems&lt;/h3&gt;</p>
<p>This section is targeted toward users who have created a LeafSystem
implementing a discrete or hybrid system. For authors of such systems,
it can be useful to understand the simulation details in order to
attain the desired state behavior over time. This behavior is
dependent on the ordering in which discrete events and continuous
updates are processed. (By “discrete events” we mean to include any of
Drake’s event handlers.) The basic issues and terminology are
introduced in the discrete_systems module; please look there first
before proceeding.</p>
<p>As pictured in discrete_systems, when a continuous-time system has
discrete events, the state x can have two significant values at the
event time t. These are - x⁻(t), the value of x <em>before</em> the discrete
update occurs (○ markers), and - x⁺(t), the value of x <em>after</em> the
discrete update occurs (● markers).</p>
<p>Thus the value of the Context, which contains both time and state,
advances from {t, x⁻(t)} to {t, x⁺(t)} as a result of the update.
While those Context values are user-visible, the details of stepping
here require an intermediate value which we’ll denote {t, x*(t)}.</p>
<p>Recall that Drake’s state x is partitioned into continuous, discrete,
and abstract partitions xc, xd, and xa, so <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">xc,</span> <span class="pre">xd,</span> <span class="pre">xa</span> <span class="pre">}</span></code>.
Within a single step, these are updated in three stages: -</p>
<p>Unrestricted update (can change x) -</p>
<p>Discrete update (can change only xd) -</p>
<p>Continuous update (changes t and xc)</p>
<p>Where needed, we extend the above notation to xc⁻, xa⁺, etc. to
indicate the value of an individual partition at a particular stage of
the stepping algorithm.</p>
<p>The following pseudocode uses the above notation to describe the
algorithm “Step()” that the Simulator uses to incrementally advance
the system trajectory (time t and state x). The Simulator’s
AdvanceTo() method will be defined in terms of Step below. In general,
the length of a step is not known a priori and is determined by the
Step() algorithm. Each step consists of zero or more unrestricted
updates, followed by zero or more discrete updates, followed by
(possibly zero-length) continuous time and state advancement, followed
by zero or more publishes, and then a call to the monitor() function
if one has been defined. Updates, publishes, and the monitor can
report errors or detect a termination condition; that is not shown in
the pseudocode below.</p>
<p>The pseudocode will clarify the effects on time and state of each of
the update stages above. This algorithm is given a starting Context
value <code class="docutils literal"><span class="pre">{tₛ,</span> <span class="pre">x⁻(tₛ)}</span></code> and returns an end Context value <code class="docutils literal"><span class="pre">{tₑ,</span>
<span class="pre">x⁻(tₑ)}</span></code>, where tₑ is <em>no later</em> than a given tₘₐₓ.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Advance the trajectory (time and state) from start value {tₛ, x⁻(tₛ)} to an
// end value {tₑ, x⁻(tₑ)}, where tₛ ≤ tₑ ≤ tₘₐₓ.
procedure Step(tₛ, x⁻(tₛ), tₘₐₓ)

// Update any variables (no restrictions).
x*(tₛ) ← DoAnyUnrestrictedUpdates(tₛ, x⁻(tₛ))

// ----------------------------------
// Time and state are at {tₛ, x*(tₛ)}
// ----------------------------------

// Update discrete variables.
xd⁺(tₛ) ← DoAnyDiscreteUpdates(tₛ, x*(tₛ))

xc⁺(tₛ) ← xc*(tₛ)  // These values carry over from x*(tₛ).
xa⁺(tₛ) ← xa*(tₛ)

// ----------------------------------
// Time and state are at {tₛ, x⁺(tₛ)}
// ----------------------------------

// See how far it is safe to integrate without missing any events.
tₑᵥₑₙₜ ← CalcNextEventTime(tₛ, x⁺(tₛ))

// Integrate continuous variables forward in time. Integration may terminate
// before reaching tₛₜₒₚ due to witnessed events.
tₛₜₒₚ ← min(tₑᵥₑₙₜ, tₘₐₓ)
tₑ, xc⁻(tₑ) ← Integrate(tₛ, x⁺(tₛ), tₛₜₒₚ)

xd⁻(tₑ) ← xd⁺(tₛ)  // Discrete values are held from x⁺(tₛ).
xa⁻(tₑ) ← xa⁺(tₛ)

// ----------------------------------
// Time and state are at {tₑ, x⁻(tₑ)}
// ----------------------------------

DoAnyPublishes(tₑ, x⁻(tₑ))
CallMonitor(tₑ, x⁻(tₑ))

return {tₑ, x⁻(tₑ)}
</pre></div>
</div>
<p>We can use the notation and pseudocode to flesh out the AdvanceTo(),
AdvancePendingEvents(), and Initialize() functions. Termination and
error conditions detected by event handlers or the monitor are
reported as status returns from these methods.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Advance the simulation until time tₘₐₓ.
procedure AdvanceTo(tₘₐₓ) → status
t ← current_time
while t &lt; tₘₐₓ
{tₑ, x⁻(tₑ)} ← Step(t, x⁻(t), tₘₐₓ)
{t, x⁻(t)} ← {tₑ, x⁻(tₑ)}
endwhile

// AdvancePendingEvents() is an advanced method, not commonly used.
// Perform just the start-of-step update to advance from x⁻(t) to x⁺(t).
procedure AdvancePendingEvents() → status
t ≜ current_time, x⁻(t) ≜ current_state
x⁺(t) ← DoAnyPendingUpdates(t, x⁻(t)) as in Step()
x(t) ← x⁺(t)  // No continuous update needed.
DoAnyPublishes(t, x(t))
CallMonitor(t, x(t))

// Update time and state to {t₀, x⁻(t₀)}, which is the starting value of the
// trajectory, and thus the value the Context should contain at the start of the
// first simulation step.
procedure Initialize(t₀, x₀) → status
x⁺(t₀) ← DoAnyInitializationUpdates as in Step()
x⁻(t₀) ← x⁺(t₀)  // No continuous update needed.

// ----------------------------------
// Time and state are at {t₀, x⁻(t₀)}
// ----------------------------------

DoAnyPublishes(t₀, x⁻(t₀))
CallMonitor(t₀, x⁻(t₀))
</pre></div>
</div>
<p>Initialize() can be viewed as a “0ᵗʰ step” that occurs before the
first Step() call as described above. Like Step(), Initialize() first
performs pending updates (in this case only initialization events can
be “pending”). Time doesn’t advance so there is no continuous update
phase and witnesses cannot trigger. Finally, again like Step(), the
initial trajectory point <code class="docutils literal"><span class="pre">{t₀,</span> <span class="pre">x⁻(t₀)}</span></code> is provided to the handlers
for any triggered publish events. That includes initialization publish
events, per-step publish events, and periodic or timed publish events
that trigger at t₀, followed by a call to the monitor() function if
one has been defined (a monitor is semantically identical to a
per-step publish).</p>
<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd], system: pydrake.systems.framework.System_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd] = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Simulator that can advance a given System through time to
produce a trajectory consisting of a sequence of Context values. The
System must not have unresolved input ports if the values of those
ports are necessary for computations performed during simulation (see
class documentation).</p>
<p>The Simulator holds an internal, non-owned reference to the System
object so you must ensure that <code class="docutils literal"><span class="pre">system</span></code> has a longer lifetime than
the Simulator. It also owns a compatible Context internally that takes
on each of the trajectory values. You may optionally provide a Context
that will be used as the initial condition for the simulation;
otherwise the Simulator will obtain a default Context from <code class="docutils literal"><span class="pre">system</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].AdvancePendingEvents">
<code class="descname">AdvancePendingEvents</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.SimulatorStatus<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].AdvancePendingEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Handles discrete and abstract state update events that are
pending from the previous AdvanceTo() call, without advancing time.
See the Simulator class description for details about how Simulator
advances time and handles events. In the terminology used there, this
method advances the internal Context from <code class="docutils literal"><span class="pre">{t,</span> <span class="pre">x⁻(t)}</span></code> to <code class="docutils literal"><span class="pre">{t,</span>
<span class="pre">x⁺(t)}</span></code>.</p>
<p>Normally, these update events would be handled at the start of the
next AdvanceTo() call, so this method is rarely needed. It can be
useful at the end of a simulation or to get intermediate results when
you are specifically interested in the <code class="docutils literal"><span class="pre">x⁺(t)</span></code> result.</p>
<p>This method is equivalent to <code class="docutils literal"><span class="pre">AdvanceTo(current_time)</span></code>, where
<code class="docutils literal"><span class="pre">current_time=simulator.get_context().get_time())</span></code>. If there are no
pending events, nothing happens except possibly a final per-step
publish call (if enabled) followed by a call to the monitor() function
(if one has been provided).</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">status</span></code>:</dt>
<dd>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AdvanceTo(), Initialize(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].AdvanceTo">
<code class="descname">AdvanceTo</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd], boundary_time: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.SimulatorStatus<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].AdvanceTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Advances the System’s trajectory until <code class="docutils literal"><span class="pre">boundary_time</span></code> is reached in
the context or some other termination condition occurs. A variety of
<code class="docutils literal"><span class="pre">RuntimeError</span></code> conditions are possible here, as well as error
conditions that may be thrown by the System when it is asked to
perform computations. Be sure to enclose your simulation in a
<code class="docutils literal"><span class="pre">try-catch</span></code> block and display the <code class="docutils literal"><span class="pre">what()</span></code> message.</p>
<p>We recommend that you call Initialize() prior to making the first call
to AdvanceTo(). However, if you don’t it will be called for you the
first time that you attempt a step, possibly resulting in unexpected
error conditions. See documentation for <code class="docutils literal"><span class="pre">Initialize()</span></code> for the error
conditions it might produce.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You should consider calling Initialize() if you alter the the
Context or Simulator options between successive AdvanceTo() calls.
See Initialize() for more information.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">boundary_time</span></code>:</dt>
<dd>The maximum time to which the trajectory will be advanced by this
call to AdvanceTo(). The method may return earlier if an event or
the monitor function requests termination or reports an error
condition.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">status</span></code>:</dt>
<dd>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function. The time in the context will be set either to the
boundary_time or the time a termination or error was first
detected.</dd>
<dt>Precondition:</dt>
<dd>The internal Context satisfies all System constraints or will
after pending Context updates are performed.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Initialize(), AdvancePendingEvents(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].clear_monitor">
<code class="descname">clear_monitor</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].clear_monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the monitoring function if there is one.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_monitor()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_actual_realtime_rate">
<code class="descname">get_actual_realtime_rate</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].get_actual_realtime_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the rate that simulated time has progressed relative to real
time. A return of 1 means the simulation just matched real time, 2
means the simulation was twice as fast as real time, 0.5 means it was
running in 2X slow motion, etc.</p>
<p>The value returned here is calculated as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">simulated_time_now</span> <span class="o">-</span> <span class="n">initial_simulated_time</span>
  <span class="n">rate</span> <span class="o">=</span> <span class="o">-------------------------------------------</span>
               <span class="n">realtime_now</span> <span class="o">-</span> <span class="n">initial_realtime</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">initial</span></code> times are recorded when Initialize() or
ResetStatistics() is called. The returned rate is undefined if
Initialize() has not yet been called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rate achieved since the last Initialize() or ResetStatistics()
call.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_target_realtime_rate()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_context">
<code class="descname">get_context</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.Context_[AutoDiffXd]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].get_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the internally-maintained Context holding
the most recent step in the trajectory. This is suitable for
publishing or extracting information about this trajectory step. Do
not call this method if there is no Context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_integrator">
<code class="descname">get_integrator</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].get_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a reference to the integrator used to advance the continuous
aspects of the system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_monitor">
<code class="descname">get_monitor</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; Callable[[pydrake.systems.framework.Context_[AutoDiffXd]], pydrake.systems.framework.EventStatus]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].get_monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtains a reference to the monitoring function, which may be empty.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_monitor()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_mutable_context">
<code class="descname">get_mutable_context</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.Context_[AutoDiffXd]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].get_mutable_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a mutable reference to the internally-maintained Context
holding the most recent step in the trajectory. This is suitable for
use in updates, sampling operations, event handlers, and constraint
projection. You can also modify this prior to calling Initialize() to
set initial conditions. Do not call this method if there is no
Context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_mutable_integrator">
<code class="descname">get_mutable_integrator</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].get_mutable_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a reference to the mutable integrator used to advance the
continuous state of the system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_system">
<code class="descname">get_system</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.System_[AutoDiffXd]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].get_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a constant reference to the system.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">a mutable reference is not available.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_target_realtime_rate">
<code class="descname">get_target_realtime_rate</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].get_target_realtime_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real time rate target currently in effect. The default is
zero, meaning the Simulator runs as fast as possible. You can change
the target with set_target_realtime_rate().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].has_context">
<code class="descname">has_context</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].has_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if this Simulator has an internally-maintained
Context. This is always true unless <code class="docutils literal"><span class="pre">reset_context()</span></code> has been
called.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].Initialize">
<code class="descname">Initialize</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.SimulatorStatus<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].Initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepares the Simulator for a simulation. In order, the sequence of
actions taken here are: - The active integrator’s Initialize() method
is invoked. - Statistics are reset. - Initialization update events are
triggered and handled to produce the initial trajectory value <code class="docutils literal"><span class="pre">{t₀,</span>
<span class="pre">x(t₀)}</span></code>. - Then that initial value is provided to the handlers for
any publish events that have triggered, including initialization and
per-step publish events, periodic or other time-triggered publish
events that are scheduled for the initial time t₀, and finally a call
to the monitor() function if one has been defined.</p>
<p>See the class documentation for more information. We recommend calling
Initialize() explicitly prior to beginning a simulation so that error
conditions will be discovered early. However, Initialize() will be
called automatically by the first AdvanceTo() call if it hasn’t
already been called.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you make a change to the Context or to Simulator options
between AdvanceTo() calls you should consider whether to call
Initialize() before resuming; AdvanceTo() will not do that
automatically for you. Whether to do so depends on whether you
want the above initialization operations performed. For example,
if you changed the time you will likely want the time-triggered
events to be recalculated in case one is due at the new starting
time.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Initialize() does not automatically attempt to satisfy System
constraints – it is up to you to make sure that constraints are
satisfied by the initial conditions.</p>
</div>
<p>This method will throw <code class="docutils literal"><span class="pre">RuntimeError</span></code> if the combination of options
doesn’t make sense. Other failures are possible from the System and
integrator in use.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">status</span></code>:</dt>
<dd>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AdvanceTo(), AdvancePendingEvents(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].reset_context">
<code class="descname">reset_context</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].reset_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the internally-maintained Context with a different one. The
current Context is deleted. This is useful for supplying a new set of
initial conditions. You should invoke Initialize() after replacing the
Context.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The new context, which may be null. If the context is null, a new
context must be set before attempting to step the system forward.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].reset_integrator">
<code class="descname">reset_integrator</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd], integrator: pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].reset_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.) pydrake.systems.Simulator.reset_integrator is deprecated and will be removed from Drake on or after 2020-08-01. Use pydrake.systems.ResetIntegratorFromFlags instead.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].ResetStatistics">
<code class="descname">ResetStatistics</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].ResetStatistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Forget accumulated statistics. Statistics are reset to the values they
have post construction or immediately after <code class="docutils literal"><span class="pre">Initialize()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].set_monitor">
<code class="descname">set_monitor</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd], monitor: Callable[[pydrake.systems.framework.Context_[AutoDiffXd]], pydrake.systems.framework.EventStatus]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].set_monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a monitoring function that will be invoked at the end of
every step. (See the Simulator class documentation for a precise
definition of “step”.) A monitor() function can be used to capture the
trajectory, to terminate the simulation, or to detect error
conditions. The monitor() function is invoked by the Simulator with a
Context whose value is a point along the simulated trajectory. The
monitor can be any functor and should capture any System references it
needs to operate correctly.</p>
<p>A monitor() function behaves the same as would a per-step Publish
event handler included in the top-level System or Diagram being
simulated. As in the case of Publish(), the monitor is called at the
end of every step taken internally by AdvanceTo(), and also at the end
of Initialize() and AdvancePendingEvents(). (See the Simulator class
documentation for more detail about what happens when in these
methods.) The monitor receives the top-level (root) Context, from
which any sub-Context can be obtained using
<code class="docutils literal"><span class="pre">subsystem.GetMyContextFromRoot()</span></code>, provided the necessary subsystem
reference has been captured for use in the monitor.</p>
<p>** Examples Output time and continuous states whenever the trajectory
is advanced:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">root_context</span><span class="o">.</span><span class="n">get_time</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot; &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">root_context</span><span class="o">.</span><span class="n">get_continuous_state_vector</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Terminate early but successfully on a condition in a subsystem of the
System diagram being simulated:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([</span><span class="o">&amp;</span><span class="n">my_subsystem</span><span class="p">](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">subcontext</span> <span class="o">=</span>
      <span class="n">my_subsystem</span><span class="o">.</span><span class="n">GetMyContextFromRoot</span><span class="p">(</span><span class="n">root_context</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">my_subsystem</span><span class="o">.</span><span class="n">GoalReached</span><span class="p">(</span><span class="n">subcontext</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">ReachedTermination</span><span class="p">(</span><span class="n">my_subsystem</span><span class="p">,</span>
        <span class="s2">&quot;Simulation achieved the desired goal.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>In the above case, the Simulator’s AdvanceTo() method will return
early when the subsystem reports that it has reached its goal. The
returned status will indicate the termination reason, and a
human-readable termination message containing the message provided by
the monitor can be obtained with status.FormatMessage().</p>
<p>Failure due to plant center of mass falling below a threshold:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([</span><span class="o">&amp;</span><span class="n">plant</span><span class="p">](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">plant_context</span> <span class="o">=</span>
      <span class="n">plant</span><span class="o">.</span><span class="n">GetMyContextFromRoot</span><span class="p">(</span><span class="n">root_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">com</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">CalcCenterOfMassPosition</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">)</span> <span class="p">{</span>  <span class="o">//</span> <span class="n">Check</span> <span class="n">z</span> <span class="n">height</span> <span class="n">of</span> <span class="n">com</span><span class="o">.</span>
    <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Failed</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span> <span class="s2">&quot;System fell over.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>In the above case the Simulator’s AdvanceTo() method will throw an
RuntimeError containing a human-readable message including the text
provided in the monitor.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">monitor() is called every time the trajectory is advanced by a
step, which can mean it is called many times during a single
AdvanceTo() call.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The presence of a monitor has no effect on the step sizes taken,
so a termination or error condition will be discovered only when
first observed after a step is complete; it will not be further
localized. Use witness-triggered events instead if you need
precise isolation.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].set_publish_every_time_step">
<code class="descname">set_publish_every_time_step</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd], arg0: bool</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].set_publish_every_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets whether the simulation should trigger a forced-Publish event on
the System under simulation at the end of every trajectory-advancing
step. Specifically, that means the System::Publish() event dispatcher
will be invoked on each subsystem of the System and passed the current
Context and a forced-publish Event. If a subsystem has declared a
forced-publish event handler, that will be called. Otherwise, nothing
will happen unless the DoPublish() dispatcher has been overridden.</p>
<p>Enabling this option does not cause a forced-publish to be triggered
at initialization; if you want that you should also call
<code class="docutils literal"><span class="pre">set_publish_at_initialization(true)</span></code>. If you want a forced-publish
at the end of every step, you will usually also want one at the end of
initialization, requiring both options to be enabled.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">LeafSystem::DeclareForcedPublishEvent()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[AutoDiffXd].set_target_realtime_rate">
<code class="descname">set_target_realtime_rate</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[AutoDiffXd], arg0: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[AutoDiffXd].set_target_realtime_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Slow the simulation down to <em>approximately</em> synchronize with real time
when it would otherwise run too fast. Normally the Simulator takes
steps as quickly as it can. You can request that it slow down to
synchronize with real time by providing a realtime rate greater than
zero here.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">No guarantees can be made about how accurately the simulation can
be made to track real time, even if computation is fast enough.
That’s because the system utilities used to implement this do not
themselves provide such guarantees. So this is likely to work
nicely for visualization purposes where human perception is the
only concern. For any other uses you should consider whether
approximate real time is adequate for your purposes.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the full-speed simulation is already slower than real time you
can’t speed it up with this call! Instead consider requesting less
integration accuracy, using a faster integration method or fixed
time step, or using a simpler model.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">realtime_rate</span></code>:</dt>
<dd>Desired rate relative to real time. Set to 1 to track real time, 2
to run twice as fast as real time, 0.5 for half speed, etc. Zero
or negative restores the rate to its default of 0, meaning the
simulation will proceed as fast as possible.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.systems.analysis.Simulator_[float]">
<em class="property">class </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">Simulator_[float]</code><a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for advancing the state of hybrid dynamic systems, represented
by <code class="docutils literal"><span class="pre">System&lt;T&gt;</span></code> objects, forward in time. Starting with an initial
Context for a given System, Simulator advances time and produces a
series of Context values that forms a trajectory satisfying the
system’s dynamic equations to a specified accuracy. Only the Context
is modified by a Simulator; the System is const.</p>
<p>A Drake System is a continuous/discrete/hybrid dynamic system where
the continuous part is a DAE, that is, it is expected to consist of a
set of differential equations and bilateral algebraic constraints. The
set of active constraints may change as a result of particular events,
such as contact.</p>
<p>Given a current Context, we expect a System to provide us with -
derivatives for the continuous differential equations that already
satisfy the differentiated form of the constraints (typically,
acceleration constraints), - a projection method for least-squares
correction of violated higher-level constraints (position and velocity
level), - a time-of-next-update method that can be used to adjust the
integrator step size in preparation for a discrete update, - methods
that can update discrete variables when their update time is reached,
- witness (guard) functions for event isolation, - event handlers
(reset functions) for making appropriate changes to state and mode
variables when an event has been isolated.</p>
<p>The continuous parts of the trajectory are advanced using a numerical
integrator. Different integrators have different properties; you can
choose the one that is most appropriate for your application or use
the default which is adequate for most systems.</p>
<p>&lt;h3&gt;How the simulation is stepped: simulation mechanics for authors of
discrete and hybrid systems&lt;/h3&gt;</p>
<p>This section is targeted toward users who have created a LeafSystem
implementing a discrete or hybrid system. For authors of such systems,
it can be useful to understand the simulation details in order to
attain the desired state behavior over time. This behavior is
dependent on the ordering in which discrete events and continuous
updates are processed. (By “discrete events” we mean to include any of
Drake’s event handlers.) The basic issues and terminology are
introduced in the discrete_systems module; please look there first
before proceeding.</p>
<p>As pictured in discrete_systems, when a continuous-time system has
discrete events, the state x can have two significant values at the
event time t. These are - x⁻(t), the value of x <em>before</em> the discrete
update occurs (○ markers), and - x⁺(t), the value of x <em>after</em> the
discrete update occurs (● markers).</p>
<p>Thus the value of the Context, which contains both time and state,
advances from {t, x⁻(t)} to {t, x⁺(t)} as a result of the update.
While those Context values are user-visible, the details of stepping
here require an intermediate value which we’ll denote {t, x*(t)}.</p>
<p>Recall that Drake’s state x is partitioned into continuous, discrete,
and abstract partitions xc, xd, and xa, so <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">xc,</span> <span class="pre">xd,</span> <span class="pre">xa</span> <span class="pre">}</span></code>.
Within a single step, these are updated in three stages: -</p>
<p>Unrestricted update (can change x) -</p>
<p>Discrete update (can change only xd) -</p>
<p>Continuous update (changes t and xc)</p>
<p>Where needed, we extend the above notation to xc⁻, xa⁺, etc. to
indicate the value of an individual partition at a particular stage of
the stepping algorithm.</p>
<p>The following pseudocode uses the above notation to describe the
algorithm “Step()” that the Simulator uses to incrementally advance
the system trajectory (time t and state x). The Simulator’s
AdvanceTo() method will be defined in terms of Step below. In general,
the length of a step is not known a priori and is determined by the
Step() algorithm. Each step consists of zero or more unrestricted
updates, followed by zero or more discrete updates, followed by
(possibly zero-length) continuous time and state advancement, followed
by zero or more publishes, and then a call to the monitor() function
if one has been defined. Updates, publishes, and the monitor can
report errors or detect a termination condition; that is not shown in
the pseudocode below.</p>
<p>The pseudocode will clarify the effects on time and state of each of
the update stages above. This algorithm is given a starting Context
value <code class="docutils literal"><span class="pre">{tₛ,</span> <span class="pre">x⁻(tₛ)}</span></code> and returns an end Context value <code class="docutils literal"><span class="pre">{tₑ,</span>
<span class="pre">x⁻(tₑ)}</span></code>, where tₑ is <em>no later</em> than a given tₘₐₓ.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Advance the trajectory (time and state) from start value {tₛ, x⁻(tₛ)} to an
// end value {tₑ, x⁻(tₑ)}, where tₛ ≤ tₑ ≤ tₘₐₓ.
procedure Step(tₛ, x⁻(tₛ), tₘₐₓ)

// Update any variables (no restrictions).
x*(tₛ) ← DoAnyUnrestrictedUpdates(tₛ, x⁻(tₛ))

// ----------------------------------
// Time and state are at {tₛ, x*(tₛ)}
// ----------------------------------

// Update discrete variables.
xd⁺(tₛ) ← DoAnyDiscreteUpdates(tₛ, x*(tₛ))

xc⁺(tₛ) ← xc*(tₛ)  // These values carry over from x*(tₛ).
xa⁺(tₛ) ← xa*(tₛ)

// ----------------------------------
// Time and state are at {tₛ, x⁺(tₛ)}
// ----------------------------------

// See how far it is safe to integrate without missing any events.
tₑᵥₑₙₜ ← CalcNextEventTime(tₛ, x⁺(tₛ))

// Integrate continuous variables forward in time. Integration may terminate
// before reaching tₛₜₒₚ due to witnessed events.
tₛₜₒₚ ← min(tₑᵥₑₙₜ, tₘₐₓ)
tₑ, xc⁻(tₑ) ← Integrate(tₛ, x⁺(tₛ), tₛₜₒₚ)

xd⁻(tₑ) ← xd⁺(tₛ)  // Discrete values are held from x⁺(tₛ).
xa⁻(tₑ) ← xa⁺(tₛ)

// ----------------------------------
// Time and state are at {tₑ, x⁻(tₑ)}
// ----------------------------------

DoAnyPublishes(tₑ, x⁻(tₑ))
CallMonitor(tₑ, x⁻(tₑ))

return {tₑ, x⁻(tₑ)}
</pre></div>
</div>
<p>We can use the notation and pseudocode to flesh out the AdvanceTo(),
AdvancePendingEvents(), and Initialize() functions. Termination and
error conditions detected by event handlers or the monitor are
reported as status returns from these methods.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>// Advance the simulation until time tₘₐₓ.
procedure AdvanceTo(tₘₐₓ) → status
t ← current_time
while t &lt; tₘₐₓ
{tₑ, x⁻(tₑ)} ← Step(t, x⁻(t), tₘₐₓ)
{t, x⁻(t)} ← {tₑ, x⁻(tₑ)}
endwhile

// AdvancePendingEvents() is an advanced method, not commonly used.
// Perform just the start-of-step update to advance from x⁻(t) to x⁺(t).
procedure AdvancePendingEvents() → status
t ≜ current_time, x⁻(t) ≜ current_state
x⁺(t) ← DoAnyPendingUpdates(t, x⁻(t)) as in Step()
x(t) ← x⁺(t)  // No continuous update needed.
DoAnyPublishes(t, x(t))
CallMonitor(t, x(t))

// Update time and state to {t₀, x⁻(t₀)}, which is the starting value of the
// trajectory, and thus the value the Context should contain at the start of the
// first simulation step.
procedure Initialize(t₀, x₀) → status
x⁺(t₀) ← DoAnyInitializationUpdates as in Step()
x⁻(t₀) ← x⁺(t₀)  // No continuous update needed.

// ----------------------------------
// Time and state are at {t₀, x⁻(t₀)}
// ----------------------------------

DoAnyPublishes(t₀, x⁻(t₀))
CallMonitor(t₀, x⁻(t₀))
</pre></div>
</div>
<p>Initialize() can be viewed as a “0ᵗʰ step” that occurs before the
first Step() call as described above. Like Step(), Initialize() first
performs pending updates (in this case only initialization events can
be “pending”). Time doesn’t advance so there is no continuous update
phase and witnesses cannot trigger. Finally, again like Step(), the
initial trajectory point <code class="docutils literal"><span class="pre">{t₀,</span> <span class="pre">x⁻(t₀)}</span></code> is provided to the handlers
for any triggered publish events. That includes initialization publish
events, per-step publish events, and periodic or timed publish events
that trigger at t₀, followed by a call to the monitor() function if
one has been defined (a monitor is semantically identical to a
per-step publish).</p>
<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float], system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float] = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Simulator that can advance a given System through time to
produce a trajectory consisting of a sequence of Context values. The
System must not have unresolved input ports if the values of those
ports are necessary for computations performed during simulation (see
class documentation).</p>
<p>The Simulator holds an internal, non-owned reference to the System
object so you must ensure that <code class="docutils literal"><span class="pre">system</span></code> has a longer lifetime than
the Simulator. It also owns a compatible Context internally that takes
on each of the trajectory values. You may optionally provide a Context
that will be used as the initial condition for the simulation;
otherwise the Simulator will obtain a default Context from <code class="docutils literal"><span class="pre">system</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].AdvancePendingEvents">
<code class="descname">AdvancePendingEvents</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.SimulatorStatus<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].AdvancePendingEvents" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Handles discrete and abstract state update events that are
pending from the previous AdvanceTo() call, without advancing time.
See the Simulator class description for details about how Simulator
advances time and handles events. In the terminology used there, this
method advances the internal Context from <code class="docutils literal"><span class="pre">{t,</span> <span class="pre">x⁻(t)}</span></code> to <code class="docutils literal"><span class="pre">{t,</span>
<span class="pre">x⁺(t)}</span></code>.</p>
<p>Normally, these update events would be handled at the start of the
next AdvanceTo() call, so this method is rarely needed. It can be
useful at the end of a simulation or to get intermediate results when
you are specifically interested in the <code class="docutils literal"><span class="pre">x⁺(t)</span></code> result.</p>
<p>This method is equivalent to <code class="docutils literal"><span class="pre">AdvanceTo(current_time)</span></code>, where
<code class="docutils literal"><span class="pre">current_time=simulator.get_context().get_time())</span></code>. If there are no
pending events, nothing happens except possibly a final per-step
publish call (if enabled) followed by a call to the monitor() function
(if one has been provided).</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">status</span></code>:</dt>
<dd>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AdvanceTo(), Initialize(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].AdvanceTo">
<code class="descname">AdvanceTo</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float], boundary_time: float</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.SimulatorStatus<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].AdvanceTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Advances the System’s trajectory until <code class="docutils literal"><span class="pre">boundary_time</span></code> is reached in
the context or some other termination condition occurs. A variety of
<code class="docutils literal"><span class="pre">RuntimeError</span></code> conditions are possible here, as well as error
conditions that may be thrown by the System when it is asked to
perform computations. Be sure to enclose your simulation in a
<code class="docutils literal"><span class="pre">try-catch</span></code> block and display the <code class="docutils literal"><span class="pre">what()</span></code> message.</p>
<p>We recommend that you call Initialize() prior to making the first call
to AdvanceTo(). However, if you don’t it will be called for you the
first time that you attempt a step, possibly resulting in unexpected
error conditions. See documentation for <code class="docutils literal"><span class="pre">Initialize()</span></code> for the error
conditions it might produce.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You should consider calling Initialize() if you alter the the
Context or Simulator options between successive AdvanceTo() calls.
See Initialize() for more information.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">boundary_time</span></code>:</dt>
<dd>The maximum time to which the trajectory will be advanced by this
call to AdvanceTo(). The method may return earlier if an event or
the monitor function requests termination or reports an error
condition.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">status</span></code>:</dt>
<dd>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function. The time in the context will be set either to the
boundary_time or the time a termination or error was first
detected.</dd>
<dt>Precondition:</dt>
<dd>The internal Context satisfies all System constraints or will
after pending Context updates are performed.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Initialize(), AdvancePendingEvents(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].clear_monitor">
<code class="descname">clear_monitor</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].clear_monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the monitoring function if there is one.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_monitor()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].get_actual_realtime_rate">
<code class="descname">get_actual_realtime_rate</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].get_actual_realtime_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the rate that simulated time has progressed relative to real
time. A return of 1 means the simulation just matched real time, 2
means the simulation was twice as fast as real time, 0.5 means it was
running in 2X slow motion, etc.</p>
<p>The value returned here is calculated as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">simulated_time_now</span> <span class="o">-</span> <span class="n">initial_simulated_time</span>
  <span class="n">rate</span> <span class="o">=</span> <span class="o">-------------------------------------------</span>
               <span class="n">realtime_now</span> <span class="o">-</span> <span class="n">initial_realtime</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">initial</span></code> times are recorded when Initialize() or
ResetStatistics() is called. The returned rate is undefined if
Initialize() has not yet been called.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rate achieved since the last Initialize() or ResetStatistics()
call.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_target_realtime_rate()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].get_context">
<code class="descname">get_context</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.Context_[float]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].get_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the internally-maintained Context holding
the most recent step in the trajectory. This is suitable for
publishing or extracting information about this trajectory step. Do
not call this method if there is no Context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].get_integrator">
<code class="descname">get_integrator</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.IntegratorBase_[float]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].get_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a reference to the integrator used to advance the continuous
aspects of the system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].get_monitor">
<code class="descname">get_monitor</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; Callable[[pydrake.systems.framework.Context_[float]], pydrake.systems.framework.EventStatus]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].get_monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtains a reference to the monitoring function, which may be empty.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">set_monitor()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].get_mutable_context">
<code class="descname">get_mutable_context</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.Context_[float]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].get_mutable_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a mutable reference to the internally-maintained Context
holding the most recent step in the trajectory. This is suitable for
use in updates, sampling operations, event handlers, and constraint
projection. You can also modify this prior to calling Initialize() to
set initial conditions. Do not call this method if there is no
Context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].get_mutable_integrator">
<code class="descname">get_mutable_integrator</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.IntegratorBase_[float]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].get_mutable_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a reference to the mutable integrator used to advance the
continuous state of the system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].get_system">
<code class="descname">get_system</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.System_[float]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].get_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a constant reference to the system.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">a mutable reference is not available.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].get_target_realtime_rate">
<code class="descname">get_target_realtime_rate</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].get_target_realtime_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real time rate target currently in effect. The default is
zero, meaning the Simulator runs as fast as possible. You can change
the target with set_target_realtime_rate().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].has_context">
<code class="descname">has_context</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].has_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if this Simulator has an internally-maintained
Context. This is always true unless <code class="docutils literal"><span class="pre">reset_context()</span></code> has been
called.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].Initialize">
<code class="descname">Initialize</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.SimulatorStatus<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].Initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepares the Simulator for a simulation. In order, the sequence of
actions taken here are: - The active integrator’s Initialize() method
is invoked. - Statistics are reset. - Initialization update events are
triggered and handled to produce the initial trajectory value <code class="docutils literal"><span class="pre">{t₀,</span>
<span class="pre">x(t₀)}</span></code>. - Then that initial value is provided to the handlers for
any publish events that have triggered, including initialization and
per-step publish events, periodic or other time-triggered publish
events that are scheduled for the initial time t₀, and finally a call
to the monitor() function if one has been defined.</p>
<p>See the class documentation for more information. We recommend calling
Initialize() explicitly prior to beginning a simulation so that error
conditions will be discovered early. However, Initialize() will be
called automatically by the first AdvanceTo() call if it hasn’t
already been called.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you make a change to the Context or to Simulator options
between AdvanceTo() calls you should consider whether to call
Initialize() before resuming; AdvanceTo() will not do that
automatically for you. Whether to do so depends on whether you
want the above initialization operations performed. For example,
if you changed the time you will likely want the time-triggered
events to be recalculated in case one is due at the new starting
time.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Initialize() does not automatically attempt to satisfy System
constraints – it is up to you to make sure that constraints are
satisfied by the initial conditions.</p>
</div>
<p>This method will throw <code class="docutils literal"><span class="pre">RuntimeError</span></code> if the combination of options
doesn’t make sense. Other failures are possible from the System and
integrator in use.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">status</span></code>:</dt>
<dd>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AdvanceTo(), AdvancePendingEvents(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].reset_context">
<code class="descname">reset_context</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].reset_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the internally-maintained Context with a different one. The
current Context is deleted. This is useful for supplying a new set of
initial conditions. You should invoke Initialize() after replacing the
Context.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">context</span></code>:</dt>
<dd>The new context, which may be null. If the context is null, a new
context must be set before attempting to step the system forward.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].reset_integrator">
<code class="descname">reset_integrator</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float], integrator: pydrake.systems.analysis.IntegratorBase_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.IntegratorBase_[float]<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].reset_integrator" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.) pydrake.systems.Simulator.reset_integrator is deprecated and will be removed from Drake on or after 2020-08-01. Use pydrake.systems.ResetIntegratorFromFlags instead.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].ResetStatistics">
<code class="descname">ResetStatistics</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].ResetStatistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Forget accumulated statistics. Statistics are reset to the values they
have post construction or immediately after <code class="docutils literal"><span class="pre">Initialize()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].set_monitor">
<code class="descname">set_monitor</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float], monitor: Callable[[pydrake.systems.framework.Context_[float]], pydrake.systems.framework.EventStatus]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].set_monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a monitoring function that will be invoked at the end of
every step. (See the Simulator class documentation for a precise
definition of “step”.) A monitor() function can be used to capture the
trajectory, to terminate the simulation, or to detect error
conditions. The monitor() function is invoked by the Simulator with a
Context whose value is a point along the simulated trajectory. The
monitor can be any functor and should capture any System references it
needs to operate correctly.</p>
<p>A monitor() function behaves the same as would a per-step Publish
event handler included in the top-level System or Diagram being
simulated. As in the case of Publish(), the monitor is called at the
end of every step taken internally by AdvanceTo(), and also at the end
of Initialize() and AdvancePendingEvents(). (See the Simulator class
documentation for more detail about what happens when in these
methods.) The monitor receives the top-level (root) Context, from
which any sub-Context can be obtained using
<code class="docutils literal"><span class="pre">subsystem.GetMyContextFromRoot()</span></code>, provided the necessary subsystem
reference has been captured for use in the monitor.</p>
<p>** Examples Output time and continuous states whenever the trajectory
is advanced:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">root_context</span><span class="o">.</span><span class="n">get_time</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot; &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">root_context</span><span class="o">.</span><span class="n">get_continuous_state_vector</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Terminate early but successfully on a condition in a subsystem of the
System diagram being simulated:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([</span><span class="o">&amp;</span><span class="n">my_subsystem</span><span class="p">](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">subcontext</span> <span class="o">=</span>
      <span class="n">my_subsystem</span><span class="o">.</span><span class="n">GetMyContextFromRoot</span><span class="p">(</span><span class="n">root_context</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">my_subsystem</span><span class="o">.</span><span class="n">GoalReached</span><span class="p">(</span><span class="n">subcontext</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">ReachedTermination</span><span class="p">(</span><span class="n">my_subsystem</span><span class="p">,</span>
        <span class="s2">&quot;Simulation achieved the desired goal.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>In the above case, the Simulator’s AdvanceTo() method will return
early when the subsystem reports that it has reached its goal. The
returned status will indicate the termination reason, and a
human-readable termination message containing the message provided by
the monitor can be obtained with status.FormatMessage().</p>
<p>Failure due to plant center of mass falling below a threshold:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([</span><span class="o">&amp;</span><span class="n">plant</span><span class="p">](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">plant_context</span> <span class="o">=</span>
      <span class="n">plant</span><span class="o">.</span><span class="n">GetMyContextFromRoot</span><span class="p">(</span><span class="n">root_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">com</span> <span class="o">=</span> <span class="n">plant</span><span class="o">.</span><span class="n">CalcCenterOfMassPosition</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">)</span> <span class="p">{</span>  <span class="o">//</span> <span class="n">Check</span> <span class="n">z</span> <span class="n">height</span> <span class="n">of</span> <span class="n">com</span><span class="o">.</span>
    <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Failed</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span> <span class="s2">&quot;System fell over.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>In the above case the Simulator’s AdvanceTo() method will throw an
RuntimeError containing a human-readable message including the text
provided in the monitor.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">monitor() is called every time the trajectory is advanced by a
step, which can mean it is called many times during a single
AdvanceTo() call.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The presence of a monitor has no effect on the step sizes taken,
so a termination or error condition will be discovered only when
first observed after a step is complete; it will not be further
localized. Use witness-triggered events instead if you need
precise isolation.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].set_publish_every_time_step">
<code class="descname">set_publish_every_time_step</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float], arg0: bool</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].set_publish_every_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets whether the simulation should trigger a forced-Publish event on
the System under simulation at the end of every trajectory-advancing
step. Specifically, that means the System::Publish() event dispatcher
will be invoked on each subsystem of the System and passed the current
Context and a forced-publish Event. If a subsystem has declared a
forced-publish event handler, that will be called. Otherwise, nothing
will happen unless the DoPublish() dispatcher has been overridden.</p>
<p>Enabling this option does not cause a forced-publish to be triggered
at initialization; if you want that you should also call
<code class="docutils literal"><span class="pre">set_publish_at_initialization(true)</span></code>. If you want a forced-publish
at the end of every step, you will usually also want one at the end of
initialization, requiring both options to be enabled.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">LeafSystem::DeclareForcedPublishEvent()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.Simulator_[float].set_target_realtime_rate">
<code class="descname">set_target_realtime_rate</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.Simulator_[float], arg0: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.Simulator_[float].set_target_realtime_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Slow the simulation down to <em>approximately</em> synchronize with real time
when it would otherwise run too fast. Normally the Simulator takes
steps as quickly as it can. You can request that it slow down to
synchronize with real time by providing a realtime rate greater than
zero here.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">No guarantees can be made about how accurately the simulation can
be made to track real time, even if computation is fast enough.
That’s because the system utilities used to implement this do not
themselves provide such guarantees. So this is likely to work
nicely for visualization purposes where human perception is the
only concern. For any other uses you should consider whether
approximate real time is adequate for your purposes.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the full-speed simulation is already slower than real time you
can’t speed it up with this call! Instead consider requesting less
integration accuracy, using a faster integration method or fixed
time step, or using a simpler model.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">realtime_rate</span></code>:</dt>
<dd>Desired rate relative to real time. Set to 1 to track real time, 2
to run twice as fast as real time, 0.5 for half speed, etc. Zero
or negative restores the rate to its default of 0, meaning the
simulation will proceed as fast as possible.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.systems.analysis.SimulatorStatus">
<em class="property">class </em><code class="descclassname">pydrake.systems.analysis.</code><code class="descname">SimulatorStatus</code><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds the status return value from a call to Simulator::AdvanceTo()
and related methods. The argument t to AdvanceTo(t) is called the
boundary time, and represents the maximum time to which the simulation
trajectory will be advanced by a call to AdvanceTo(). (For methods
that don’t advance time, the current time is considered to be the
boundary time.) A normal, successful return means that simulated time
advanced successfully to the boundary time, without encountering a
termination condition or error condition. AdvanceTo() may return
earlier than the boundary time if one of those conditions is
encountered. In that case the return object holds a reference to the
subsystem that detected the condition and a human-friendly message
from that subsystem that hopefully explains what happened.</p>
<dl class="attribute">
<dt id="pydrake.systems.analysis.SimulatorStatus.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.SimulatorStatus.boundary_time">
<code class="descname">boundary_time</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.SimulatorStatus</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.boundary_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum time we could have reached with this call; whether
we actually got there depends on the status. This is the time supplied
in an AdvanceTo() call or the current time for methods that don’t
advance time, that is, Initialize() and AdvancePendingEvents().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.SimulatorStatus.FormatMessage">
<code class="descname">FormatMessage</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.SimulatorStatus</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.FormatMessage" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a human-readable message explaining the return result.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.SimulatorStatus.IsIdenticalStatus">
<code class="descname">IsIdenticalStatus</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.SimulatorStatus</em>, <em>other: pydrake.systems.analysis.SimulatorStatus</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.IsIdenticalStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the <code class="docutils literal"><span class="pre">other</span></code> status contains exactly the same
information as <code class="docutils literal"><span class="pre">this</span></code> status. This is likely only useful for unit
testing of SimulatorStatus.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.SimulatorStatus.message">
<code class="descname">message</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.SimulatorStatus</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.message" title="Permalink to this definition">¶</a></dt>
<dd><p>For termination or error conditions, returns a human-readable message
explaining what happened. This is the message from the subsystem that
detected the condition. FormatMessage() returns additional information
and also includes this message.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.SimulatorStatus.reason">
<code class="descname">reason</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.SimulatorStatus</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.analysis.SimulatorStatus.ReturnReason<a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.reason" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the reason that a Simulator call returned.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.SimulatorStatus.return_time">
<code class="descname">return_time</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.SimulatorStatus</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.return_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the time that was actually reached. This will be
boundary_time() if succeeded() returns true. Otherwise it is the time
at which a termination or error condition was detected and may be
earlier than boundary_time().</p>
</dd></dl>

<dl class="class">
<dt id="pydrake.systems.analysis.SimulatorStatus.ReturnReason">
<em class="property">class </em><code class="descname">ReturnReason</code><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.ReturnReason" title="Permalink to this definition">¶</a></dt>
<dd><p>Members:</p>
<blockquote>
<div>kReachedBoundaryTime : This is the normal return: no termination or error condition was</div></blockquote>
<p>encountered before reaching the boundary time. There is no message and
no saved System.</p>
<blockquote>
<div>kReachedTerminationCondition : An event handler or monitor function returned with a “reached</div></blockquote>
<p>termination condition” EventStatus (has message with details). For
AdvanceTo() the return time may be earlier than the boundary time.</p>
<blockquote>
<div>kEventHandlerFailed : An event handler or monitor function returned with a “failed”</div></blockquote>
<p>EventStatus (has message with details). For AdvanceTo() the return
time may be earlier than the boundary time.</p>
<dl class="method">
<dt id="pydrake.systems.analysis.SimulatorStatus.ReturnReason.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.SimulatorStatus.ReturnReason</em>, <em>arg0: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.ReturnReason.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.systems.analysis.SimulatorStatus.ReturnReason.kEventHandlerFailed">
<code class="descname">kEventHandlerFailed</code><em class="property"> = ReturnReason.kEventHandlerFailed</em><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.ReturnReason.kEventHandlerFailed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.systems.analysis.SimulatorStatus.ReturnReason.kReachedBoundaryTime">
<code class="descname">kReachedBoundaryTime</code><em class="property"> = ReturnReason.kReachedBoundaryTime</em><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.ReturnReason.kReachedBoundaryTime" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.systems.analysis.SimulatorStatus.ReturnReason.kReachedTerminationCondition">
<code class="descname">kReachedTerminationCondition</code><em class="property"> = ReturnReason.kReachedTerminationCondition</em><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.ReturnReason.kReachedTerminationCondition" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.systems.analysis.SimulatorStatus.ReturnReason.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.ReturnReason.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.SimulatorStatus.succeeded">
<code class="descname">succeeded</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.SimulatorStatus</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.succeeded" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if we reached the boundary time with no surprises.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.systems.analysis.SimulatorStatus.system">
<code class="descname">system</code><span class="sig-paren">(</span><em>self: pydrake.systems.analysis.SimulatorStatus</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.SystemBase<a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.system" title="Permalink to this definition">¶</a></dt>
<dd><p>Optionally, returns the subsystem to which the status and contained
message should be attributed. May be nullptr in which case the status
should be attributed to the System as a whole.</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pydrake.systems.controllers.html" class="btn btn-neutral float-right" title="pydrake.systems.controllers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pydrake.systems.all.html" class="btn btn-neutral" title="pydrake.systems.all" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>