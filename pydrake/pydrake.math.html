

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydrake.math &mdash; pydrake  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="pydrake  documentation" href="index.html"/>
        <link rel="next" title="pydrake.multibody" href="pydrake.multibody.html"/>
        <link rel="prev" title="pydrake.manipulation.simple_ui" href="pydrake.manipulation.simple_ui.html"/>
<header class="header--main black-back">
   <div class="wrap grid__2-col">
      <a href="https://drake.mit.edu" class="header__logo">
      <img src="_static/drake-logo-white.svg" class="header__logo__img">
      </a>
      <div class="menu__toggle js-menu-toggle">
         <div class="menu__toggle__icon"><span></span></div>
      </div>
      <nav class="header__menu">
         <div class="menu__wrap">
            <ul class="menu__list">
               <li class="menu__list__item menu__list__item__link button--text">
                  <a href="https://drake.mit.edu/quickstart.html" class="menu__list__item__link button--text">Quickstart</a>
               </li>
               <li class="menu__list__item menu__list__item__link button--text">
                  <a href="https://drake.mit.edu/gallery.html" class="menu__list__item__link button--text">Gallery</a>
               </li>
               <li class="menu__list__item menu__list__item__link button--text">
                  API Documentation
                  <div class="menu_sub">
                     <a href="https://drake.mit.edu/doxygen_cxx/index.html" class="menu__list__item__link button--text">C++</a>
                     <a href="https://drake.mit.edu/pydrake/index.html" class="menu__list__item__link button--text">Python</a>
                  </div>
               </li>
               <li class="menu__list__item menu__list__item__link button--text">
                  Resources
                  <div class="menu_sub">
                     <a href="https://drake.mit.edu/getting_help.html" class="menu__list__item__link button--text">Getting Help</a>
                     <a href="https://github.com/RobotLocomotion/drake/tree/master/tutorials" class="menu__list__item__link button--text">Tutorials</a>
                     <a href="https://drake.mit.edu/developers.html" class="menu__list__item__link button--text">For Developers</a>
                     <a href="https://drake.mit.edu/credits.html" class="menu__list__item__link button--text">Credits</a>
                  </div>
               </li>
               <li class="menu__list__item menu__list__item__link button--text github--link">
                  <a href="https://github.com/RobotLocomotion/drake" class="menu__list__item__link button--text">Github <img src="_static/github-white.svg"></a>
               </li>
            </ul>
         </div>
      </nav>
   </div>
</header>


  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> pydrake
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>pydrake.math</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pydrake.math">
<span id="pydrake-math"></span><h1>pydrake.math<a class="headerlink" href="#module-pydrake.math" title="Permalink to this headline">¶</a></h1>
<p>Bindings for <code class="docutils literal"><span class="pre">math</span></code>, including overloads for scalar types and basic SE(3)
representations.</p>
<p>Note that arrays of symbolic scalar types, such as <code class="docutils literal"><span class="pre">Variable</span></code> and
<code class="docutils literal"><span class="pre">Expression</span></code>, are exposed using <code class="docutils literal"><span class="pre">ndarray[object]</span></code>, and as such logical
operations are constrained to return boolean values given NumPy’s
implementation; this is not desirable, as one should really get a <code class="docutils literal"><span class="pre">Formula</span></code>
object. As a workaround, this module provides the following vectorized
operators, following suit with the <code class="docutils literal"><span class="pre">operator</span></code> builtin module:
<code class="docutils literal"><span class="pre">lt</span></code>, <code class="docutils literal"><span class="pre">le</span></code>, <code class="docutils literal"><span class="pre">eq</span></code>, <code class="docutils literal"><span class="pre">ne</span></code>, <code class="docutils literal"><span class="pre">ge</span></code>, and <code class="docutils literal"><span class="pre">gt</span></code>.</p>
<p>As an example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x0&quot;</span><span class="p">),</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x1&quot;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y0&quot;</span><span class="p">),</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y1&quot;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span>
<span class="go"># This should throw a RuntimeError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([&lt;Formula &quot;(x0 &gt;= y0)&quot;&gt;, &lt;Formula &quot;(x1 &gt;= y1)&quot;&gt;], dtype=object)</span>
</pre></div>
</div>
<dl class="function">
<dt id="pydrake.math.abs">
<code class="descclassname">pydrake.math.</code><code class="descname">abs</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>abs(arg0: float) -&gt; float</li>
<li>abs(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>abs(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.acos">
<code class="descclassname">pydrake.math.</code><code class="descname">acos</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.acos" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>acos(arg0: float) -&gt; float</li>
<li>acos(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>acos(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.asin">
<code class="descclassname">pydrake.math.</code><code class="descname">asin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.asin" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>asin(arg0: float) -&gt; float</li>
<li>asin(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>asin(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.atan">
<code class="descclassname">pydrake.math.</code><code class="descname">atan</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.atan" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>atan(arg0: float) -&gt; float</li>
<li>atan(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.atan2">
<code class="descclassname">pydrake.math.</code><code class="descname">atan2</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.atan2" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>atan2(y: float, x: float) -&gt; float</li>
<li>atan2(arg0: pydrake.autodiffutils.AutoDiffXd, arg1: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>atan2(arg0: pydrake.symbolic.Expression, arg1: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.BalanceQuadraticForms">
<code class="descclassname">pydrake.math.</code><code class="descname">BalanceQuadraticForms</code><span class="sig-paren">(</span><em>S: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], P: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.math.BalanceQuadraticForms" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two quadratic forms, x’Sx &gt; 0 and x’Px, (with P symmetric and
full rank), finds a change of variables x = Ty, which simultaneously
diagonalizes both forms (as inspired by “balanced truncation” in
model-order reduction [1]). In this note, we use abs(M) to indicate
the elementwise absolute value.</p>
<p>Adapting from [1], we observe that there is a family of coordinate
systems that can simultaneously diagonalize T’ST and T’PT. Using D to
denote a diagonal matrix, we call the result S-normal if T’ST = I and
abs(T’PT) = D⁻², call it P-normal if T’ST = D² and abs(T’PT) = I, and
call it “balanced” if T’ST = D and abs(T’PT) = D⁻¹. Note that if P &gt;
0, then T’PT = D⁻¹.</p>
<p>We find x=Ty such that T’ST = D and abs(T’PT) = D⁻¹, where D is
diagonal. The recipe is: - Factorize S = LL’, and choose R=L⁻¹. - Take
svd(RPR’) = UΣV’, and note that U=V for positive definite matrices,
and V is U up to a sign flip of the singular vectors for all symmetric
matrices. - Choose T = R’U Σ^{-1/4}, where the matrix exponent can be
taken elementwise because Σ is diagonal. This gives T’ST = Σ^{-1/2}
(by using U’U=I), and abs(T’PT) = Σ^{1/2}. If P &gt; 0, then T’PT =
Σ^{1/2}.</p>
<p>Note that the numerical “balancing” can address the absolute scaling
of the quadratic forms, but not the relative scaling. To understand
this, consider the scalar case: we have two quadratic functions, sx²
and px², with s&gt;0, p&gt;0. We’d like to choose x=Ty so that sT²y² and
pT²y² are “balanced” (we’d like them both to be close to y²). We’ll
choose T=p^{-1/4}s^{-1/4}, which gives sx² = sqrt(s/p)y², and px² =
sqrt(p/s)y². For instance if s=1e8 and p=1e8, then t=1e-4 and st^2 =
pt^2 = 1. But if s=10, p=1e7, then t=0.01, and st^2 = 1e-3, pt^2 =
1e3.</p>
<p>In the matrix case, the absolute scaling is important – it ensures
that the two quadratic forms have the same matrix condition number and
makes them as close as possible to 1. Besides absolute scaling, in the
matrix case the balancing transform diagonalizes both quadratic forms.</p>
<p>[1] B. Moore, “Principal component analysis in linear systems:
Controllability, observability, and model reduction,” IEEE Trans.
Automat. Contr., vol. 26, no. 1, pp. 17–32, Feb. 1981.</p>
</dd></dl>

<dl class="class">
<dt id="pydrake.math.BarycentricMesh">
<em class="property">class </em><code class="descclassname">pydrake.math.</code><code class="descname">BarycentricMesh</code><a class="headerlink" href="#pydrake.math.BarycentricMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a multi-linear function (from vector inputs to vector
outputs) by interpolating between points on a mesh using (triangular)
barycentric interpolation.</p>
<p>For a technical description of barycentric interpolation, see e.g.
Remi Munos and Andrew Moore, “Barycentric Interpolators for Continuous
Space and Time Reinforcement Learning”, NIPS 1998</p>
<dl class="method">
<dt id="pydrake.math.BarycentricMesh.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.math.BarycentricMesh, arg0: List[Set[float]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.BarycentricMesh.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the mesh.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.BarycentricMesh.Eval">
<code class="descname">Eval</code><span class="sig-paren">(</span><em>self: pydrake.math.BarycentricMesh, arg0: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], arg1: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.math.BarycentricMesh.Eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the function evaluated at <code class="docutils literal"><span class="pre">input</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.BarycentricMesh.EvalBarycentricWeights">
<code class="descname">EvalBarycentricWeights</code><span class="sig-paren">(</span><em>self: pydrake.math.BarycentricMesh, arg0: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; Tuple[numpy.ndarray[numpy.int32[m, 1]], numpy.ndarray[numpy.float64[m, 1]]]<a class="headerlink" href="#pydrake.math.BarycentricMesh.EvalBarycentricWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the mesh indices used for interpolation to <code class="docutils literal"><span class="pre">mesh_indices</span></code>,
and the interpolating coefficients to <code class="docutils literal"><span class="pre">weights</span></code>. Inputs that are
outside the bounding box of the input_grid are interpolated as though
they were projected (elementwise) to the closest face of the defined
mesh.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">input</span></code>:</dt>
<dd>must be a vector of length get_num_inputs().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">mesh_indices</span></code>:</dt>
<dd>is a pointer to a vector of length get_num_interpolants().</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">weights</span></code>:</dt>
<dd>is a vector of coefficients (which sum to 1) of length
get_num_interpolants().</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.BarycentricMesh.get_all_mesh_points">
<code class="descname">get_all_mesh_points</code><span class="sig-paren">(</span><em>self: pydrake.math.BarycentricMesh</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.math.BarycentricMesh.get_all_mesh_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a matrix with all of the mesh points, one per column.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.BarycentricMesh.get_input_grid">
<code class="descname">get_input_grid</code><span class="sig-paren">(</span><em>self: pydrake.math.BarycentricMesh</em><span class="sig-paren">)</span> &#x2192; List[Set[float]]<a class="headerlink" href="#pydrake.math.BarycentricMesh.get_input_grid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.math.BarycentricMesh.get_input_size">
<code class="descname">get_input_size</code><span class="sig-paren">(</span><em>self: pydrake.math.BarycentricMesh</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.math.BarycentricMesh.get_input_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.math.BarycentricMesh.get_mesh_point">
<code class="descname">get_mesh_point</code><span class="sig-paren">(</span><em>self: pydrake.math.BarycentricMesh</em>, <em>arg0: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.math.BarycentricMesh.get_mesh_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position of a mesh point in the input space referenced by
its scalar index to <code class="docutils literal"><span class="pre">point</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">index</span></code>:</dt>
<dd>must be in [0, get_num_mesh_points).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.BarycentricMesh.get_num_interpolants">
<code class="descname">get_num_interpolants</code><span class="sig-paren">(</span><em>self: pydrake.math.BarycentricMesh</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.math.BarycentricMesh.get_num_interpolants" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.math.BarycentricMesh.get_num_mesh_points">
<code class="descname">get_num_mesh_points</code><span class="sig-paren">(</span><em>self: pydrake.math.BarycentricMesh</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.math.BarycentricMesh.get_num_mesh_points" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.math.BarycentricMesh.MeshValuesFrom">
<code class="descname">MeshValuesFrom</code><span class="sig-paren">(</span><em>self: pydrake.math.BarycentricMesh, arg0: Callable[[numpy.ndarray[numpy.float64[m, 1]]], numpy.ndarray[numpy.float64[m, 1]]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.math.BarycentricMesh.MeshValuesFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates <code class="docutils literal"><span class="pre">vector_func</span></code> at all input mesh points and extracts the
mesh value matrix that should be used to approximate the function with
this barycentric interpolation.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MatrixXd</span> <span class="n">mesh_values</span> <span class="o">=</span> <span class="n">bary</span><span class="o">.</span><span class="n">MeshValuesFrom</span><span class="p">(</span>
    <span class="p">[](</span><span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Vector1d</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span> <span class="p">});</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.math.ceil">
<code class="descclassname">pydrake.math.</code><code class="descname">ceil</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>ceil(arg0: float) -&gt; float</li>
<li>ceil(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; float</li>
<li>ceil(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.ComputeBasisFromAxis">
<code class="descclassname">pydrake.math.</code><code class="descname">ComputeBasisFromAxis</code><span class="sig-paren">(</span><em>axis_index: int, axis_W: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 3]]<a class="headerlink" href="#pydrake.math.ComputeBasisFromAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a right-handed local basis from a given axis. Defines two
other arbitrary axes such that the basis is orthonormal. The basis is
R_WL, where W is the frame in which the input axis is expressed and L
is a local basis such that v_W = R_WL * v_L.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">axis_index</span></code>:</dt>
<dd>The index of the axis (in the range [0,2]), with 0 corresponding
to the x-axis, 1 corresponding to the y-axis, and z-corresponding
to the z-axis.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">axis_W</span></code>:</dt>
<dd>The vector defining the basis’s given axis expressed in frame W.
The vector need not be a unit vector: this routine will normalize
it.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">R_WL</span></code>:</dt>
<dd>The computed basis.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the norm of <code class="docutils literal"><span class="pre">axis_W</span></code> is within 1e-10 to zero or</li>
<li><code class="docutils literal"><span class="pre">axis_index</span></code> does not lie in the range [0,2].</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.ContinuousAlgebraicRiccatiEquation">
<code class="descclassname">pydrake.math.</code><code class="descname">ContinuousAlgebraicRiccatiEquation</code><span class="sig-paren">(</span><em>A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], B: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], R: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.math.ContinuousAlgebraicRiccatiEquation" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unique stabilizing solution S to the continuous-time
algebraic Riccati equation:</p>
<div class="math">
\[S A + A' S - S B R^{-1} B' S + Q = 0\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if R is not positive definite.</td>
</tr>
</tbody>
</table>
<p>Based on the Matrix Sign Function method outlined in this paper:
<a class="reference external" href="http://www.engr.iupui.edu/~skoskie/ECE684/Riccati_algorithms.pdf">http://www.engr.iupui.edu/~skoskie/ECE684/Riccati_algorithms.pdf</a></p>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.cos">
<code class="descclassname">pydrake.math.</code><code class="descname">cos</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>cos(arg0: float) -&gt; float</li>
<li>cos(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>cos(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.cosh">
<code class="descclassname">pydrake.math.</code><code class="descname">cosh</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.cosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>cosh(arg0: float) -&gt; float</li>
<li>cosh(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>cosh(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.DecomposePositiveQuadraticForm">
<code class="descclassname">pydrake.math.</code><code class="descname">DecomposePositiveQuadraticForm</code><span class="sig-paren">(</span><em>Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], c: float, tol: float = 0</em><span class="sig-paren">)</span> &#x2192; Tuple[numpy.ndarray[numpy.float64[m, n]], numpy.ndarray[numpy.float64[m, n]]]<a class="headerlink" href="#pydrake.math.DecomposePositiveQuadraticForm" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrite a quadratic form xᵀQx + bᵀx + c to (Rx+d)ᵀ(Rx+d) where RᵀR = Q
Rᵀd = b / 2 Notice that this decomposition is not unique. For example,
with any permutation matrix P, we can define R₁ = P*R d₁ = P*d Then
(R₁*x+d₁)ᵀ(R₁*x+d₁) gives the same quadratic form.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">Q</span></code>:</dt>
<dd>The square matrix.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">b</span></code>:</dt>
<dd>The vector containing the linear coefficients.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">c</span></code>:</dt>
<dd>The constatnt term.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">tol</span></code>:</dt>
<dd>We will determine if this quadratic form is always non-negative,
by checking the Eigen values of the matrix [Q b/2] [bᵀ/2 c] are
all greater than -tol. $*Default:* is 0.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">(R</span></code>:</dt>
<dd>, d). R and d have the same number of rows. R.cols() == x.rows().
The matrix X = [R d] has the same number of rows as the rank of</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Q</span>    <span class="n">b</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
   <span class="p">[</span><span class="n">bᵀ</span><span class="o">/</span><span class="mi">2</span>   <span class="n">c</span><span class="p">]</span>
</pre></div>
</div>
<p>Precondition:
1. The quadratic form is always non-negative, namely the matrix</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Q</span>    <span class="n">b</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">[</span><span class="n">bᵀ</span><span class="o">/</span><span class="mi">2</span>   <span class="n">c</span><span class="p">]</span>
</pre></div>
</div>
<p>is positive semidefinite. 2. <code class="docutils literal"><span class="pre">Q</span></code> and <code class="docutils literal"><span class="pre">b</span></code> are of the correct size.
3. <code class="docutils literal"><span class="pre">tol</span></code> is non-negative.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the precondition is not satisfied.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.DecomposePSDmatrixIntoXtransposeTimesX">
<code class="descclassname">pydrake.math.</code><code class="descname">DecomposePSDmatrixIntoXtransposeTimesX</code><span class="sig-paren">(</span><em>Y: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], zero_tol: float</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.math.DecomposePSDmatrixIntoXtransposeTimesX" title="Permalink to this definition">¶</a></dt>
<dd><p>For a symmetric positive semidefinite matrix Y, decompose it into XᵀX,
where the number of rows in X equals to the rank of Y. Notice that
this decomposition is not unique. For any orthonormal matrix U, s.t
UᵀU = identity, X_prime = UX also satisfies X_primeᵀX_prime = Y. Here
we only return one valid decomposition.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">Y</span></code>:</dt>
<dd>A symmetric positive semidefinite matrix.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">zero_tol</span></code>:</dt>
<dd>We will need to check if some value (for example, the absolute
value of Y’s eigenvalues) is smaller than zero_tol. If it is, then
we deem that value as 0.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">X</span></code>:</dt>
<dd>. The matrix X satisfies XᵀX = Y and X.rows() = rank(Y).</dd>
</dl>
<p>Precondition:
1. Y is positive semidefinite.</p>
<blockquote>
<div><blockquote>
<div><ol class="arabic simple" start="2">
<li>zero_tol is non-negative.</li>
</ol>
</div></blockquote>
<p>$Raises:</p>
</div></blockquote>
<p>RuntimeError when the pre-conditions are not satisfied.</p>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.DiscreteAlgebraicRiccatiEquation">
<code class="descclassname">pydrake.math.</code><code class="descname">DiscreteAlgebraicRiccatiEquation</code><span class="sig-paren">(</span><em>A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], B: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], R: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.math.DiscreteAlgebraicRiccatiEquation" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unique stabilizing solution X to the discrete-time
algebraic Riccati equation:</p>
<div class="math">
\[A'XA - X - A'XB(B'XB+R)^{-1}B'XA + Q = 0\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if Q is not positive semi-definite.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if R is not positive definite.</td>
</tr>
</tbody>
</table>
<p>Based on the Schur Vector approach outlined in this paper: “On the
Numerical Solution of the Discrete-Time Algebraic Riccati Equation” by
Thrasyvoulos Pappas, Alan J. Laub, and Nils R. Sandell</p>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.exp">
<code class="descclassname">pydrake.math.</code><code class="descname">exp</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>exp(arg0: float) -&gt; float</li>
<li>exp(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>exp(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.floor">
<code class="descclassname">pydrake.math.</code><code class="descname">floor</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>floor(arg0: float) -&gt; float</li>
<li>floor(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; float</li>
<li>floor(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.inv">
<code class="descclassname">pydrake.math.</code><code class="descname">inv</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>inv(arg0: numpy.ndarray[numpy.float64[m, n]]) -&gt; numpy.ndarray[numpy.float64[m, n]]</li>
<li>inv(arg0: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</li>
<li>inv(arg0: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.IsPositiveDefinite">
<code class="descclassname">pydrake.math.</code><code class="descname">IsPositiveDefinite</code><span class="sig-paren">(</span><em>matrix: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], tolerance: float = 0.0</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.math.IsPositiveDefinite" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if a matrix is symmetric (with tolerance <code class="docutils literal"><span class="pre">symmetry_tolerance</span></code>
–</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">IsSymmetric) and has all eigenvalues greater than
<code class="docutils literal"><span class="pre">eigenvalue_tolerance</span></code>. <code class="docutils literal"><span class="pre">eigenvalue_tolerance</span></code> must be &gt;= 0 –
where 0 implies positive semi-definite (but is of course subject
to all of the pitfalls of floating point).</p>
</div>
<p>To consider the numerical robustness of the eigenvalue estimation, we
specifically check that min_eigenvalue &gt;= eigenvalue_tolerance *
max(1, max_abs_eigenvalue).</p>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.IsSymmetric">
<code class="descclassname">pydrake.math.</code><code class="descname">IsSymmetric</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.IsSymmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>IsSymmetric(matrix: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; bool</li>
</ol>
<p>Determines if a matrix is symmetric. If std::equal_to&lt;&gt;()(matrix(i,
j), matrix(j, i)) is true for all i, j, then the matrix is symmetric.</p>
<ol class="arabic simple" start="2">
<li>IsSymmetric(matrix: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], precision: float) -&gt; bool</li>
</ol>
<p>Determines if a matrix is symmetric based on whether the difference
between matrix(i, j) and matrix(j, i) is smaller than <code class="docutils literal"><span class="pre">precision</span></code>
for all i, j. The precision is absolute. Matrix with nan or inf
entries is not allowed.</p>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.log">
<code class="descclassname">pydrake.math.</code><code class="descname">log</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>log(arg0: float) -&gt; float</li>
<li>log(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>log(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.max">
<code class="descclassname">pydrake.math.</code><code class="descname">max</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>max(arg0: float, arg1: float) -&gt; float</li>
<li>max(arg0: pydrake.autodiffutils.AutoDiffXd, arg1: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>max(arg0: pydrake.symbolic.Expression, arg1: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.min">
<code class="descclassname">pydrake.math.</code><code class="descname">min</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>min(arg0: float, arg1: float) -&gt; float</li>
<li>min(arg0: pydrake.autodiffutils.AutoDiffXd, arg1: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>min(arg0: pydrake.symbolic.Expression, arg1: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.pow">
<code class="descclassname">pydrake.math.</code><code class="descname">pow</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.pow" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>pow(arg0: float, arg1: float) -&gt; float</li>
<li>pow(arg0: pydrake.autodiffutils.AutoDiffXd, arg1: float) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>pow(arg0: pydrake.symbolic.Expression, arg1: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.RealContinuousLyapunovEquation">
<code class="descclassname">pydrake.math.</code><code class="descname">RealContinuousLyapunovEquation</code><span class="sig-paren">(</span><em>A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.math.RealContinuousLyapunovEquation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">A</span></code>:</dt>
<dd>A user defined real square matrix.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">Q</span></code>:</dt>
<dd>A user defined real symmetric matrix.</dd>
<dt>Precondition:</dt>
<dd>Q is a symmetric matrix.</dd>
</dl>
<p>Computes a unique solution X to the continuous Lyapunov equation:
<code class="docutils literal"><span class="pre">AᵀX</span> <span class="pre">+</span> <span class="pre">XA</span> <span class="pre">+</span> <span class="pre">Q</span> <span class="pre">=</span> <span class="pre">0</span></code>, where A is real and square, and Q is real,
symmetric and of equal size as A.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if A or Q are not square matrices or do not have the</li>
<li>same size.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Limitations: Given the Eigenvalues of A as λ₁, …, λₙ, there exists a
unique solution if and only if λᵢ + λ̅ⱼ ≠ 0 ∀ i,j, where λ̅ⱼ is the
complex conjugate of λⱼ.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the solution is not unique.</td>
</tr>
</tbody>
</table>
<p>There are no further limitations on the eigenvalues of A. Further, if
all λᵢ have negative real parts, and if Q is positive semi-definite,
then X is also positive semi-definite [1]. Therefore, if one searches
for a Lyapunov function V(z) = zᵀXz for the stable linear system ż =
Az, then the solution of the Lyapunov Equation <code class="docutils literal"><span class="pre">AᵀX</span> <span class="pre">+</span> <span class="pre">XA</span> <span class="pre">+</span> <span class="pre">Q</span> <span class="pre">=</span> <span class="pre">0</span></code>
only returns a valid Lyapunov function if Q is positive semi-definite.</p>
<p>The implementation is based on SLICOT routine SB03MD [2]. Note the
transformation Q = -C. The complexity of this routine is O(n³). If A
is larger than 2-by-2, then a Schur factorization is performed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if Schur factorization failed.</td>
</tr>
</tbody>
</table>
<p>A tolerance of ε is used to check if a double variable is equal to
zero, where the default value for ε is 1e-10. It has been used to
check (1) if λᵢ + λ̅ⱼ = 0, ∀ i,j; (2) if A is a 1-by-1 zero matrix;
(3) if A’s trace or determinant is 0 when A is a 2-by-2 matrix.</p>
<p>[1] Bartels, R.H. and G.W. Stewart, “Solution of the Matrix Equation
AX + XB = C,” Comm. of the ACM, Vol. 15, No. 9, 1972.</p>
<p>[2] <a class="reference external" href="http://slicot.org/objects/software/shared/doc/SB03MD.html">http://slicot.org/objects/software/shared/doc/SB03MD.html</a></p>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.RealDiscreteLyapunovEquation">
<code class="descclassname">pydrake.math.</code><code class="descname">RealDiscreteLyapunovEquation</code><span class="sig-paren">(</span><em>A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.math.RealDiscreteLyapunovEquation" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">A</span></code>:</dt>
<dd>A user defined real square matrix.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">Q</span></code>:</dt>
<dd>A user defined real symmetric matrix.</dd>
<dt>Precondition:</dt>
<dd>Q is a symmetric matrix.</dd>
</dl>
<p>Computes the unique solution X to the discrete Lyapunov equation:
<code class="docutils literal"><span class="pre">AᵀXA</span> <span class="pre">-</span> <span class="pre">X</span> <span class="pre">+</span> <span class="pre">Q</span> <span class="pre">=</span> <span class="pre">0</span></code>, where A is real and square, and Q is real,
symmetric and of equal size as A.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if A or Q are not square matrices or do not have the</li>
<li>same size.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Limitations: Given the Eigenvalues of A as λ₁, …, λₙ, there exists a
unique solution if and only if λᵢ * λⱼ ≠ 1 ∀ i,j and λᵢ ≠ ±1, ∀ i [1].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the solution is not unique.[3]</td>
</tr>
</tbody>
</table>
<p>There are no further limitations on the eigenvalues of A. Further, if
<a href="#id1"><span class="problematic" id="id2">|</span></a>λᵢ|&lt;1, ∀ i, and if Q is positive semi-definite, then X is also
positive semi-definite [2]. Therefore, if one searches for a Lyapunov
function V(z) = zᵀXz for the stable linear system zₙ₊₁ = Azₙ, then the
solution of the Lyapunov Equation <code class="docutils literal"><span class="pre">AᵀXA</span> <span class="pre">-</span> <span class="pre">X</span> <span class="pre">+</span> <span class="pre">Q</span> <span class="pre">=</span> <span class="pre">0</span></code> only returns a
valid Lyapunov function if Q is positive semi-definite.</p>
<p>The implementation is based on SLICOT routine SB03MD [2]. Note the
transformation Q = -C. The complexity of this routine is O(n³). If A
is larger than 2-by-2, then a Schur factorization is performed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if Schur factorization fails.</td>
</tr>
</tbody>
</table>
<p>A tolerance of ε is used to check if a double variable is equal to
zero, where the default value for ε is 1e-10. It has been used to
check (1) if λᵢ = ±1 ∀ i; (2) if λᵢ * λⱼ = 1, i ≠ j.</p>
<p>[1] Barraud, A.Y., “A numerical algorithm to solve AᵀXA - X = Q,”
IEEE® Trans. Auto. Contr., AC-22, pp. 883-885, 1977.</p>
<p>[2] <a class="reference external" href="http://slicot.org/objects/software/shared/doc/SB03MD.html">http://slicot.org/objects/software/shared/doc/SB03MD.html</a></p>
<p>[3] <a class="reference external" href="https://www.mathworks.com/help/control/ref/dlyap.html">https://www.mathworks.com/help/control/ref/dlyap.html</a></p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.math.RigidTransform">
<code class="descclassname">pydrake.math.</code><code class="descname">RigidTransform</code><a class="headerlink" href="#pydrake.math.RigidTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.math.RigidTransform_[float]" title="pydrake.math.RigidTransform_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.math.RigidTransform_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.math.RigidTransform_">
<em class="property">template </em><code class="descclassname">pydrake.math.</code><code class="descname">RigidTransform_</code><a class="headerlink" href="#pydrake.math.RigidTransform_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.math.RigidTransform_[float]" title="pydrake.math.RigidTransform_[float]"><code class="xref py py-class docutils literal"><span class="pre">RigidTransform_[float]</span></code></a>, <a class="reference internal" href="#pydrake.math.RigidTransform_[AutoDiffXd]" title="pydrake.math.RigidTransform_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">RigidTransform_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.math.RigidTransform_[Expression]" title="pydrake.math.RigidTransform_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">RigidTransform_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float]">
<em class="property">class </em><code class="descname">RigidTransform_[float]</code><a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a proper rigid transform between two frames
which can be regarded in two ways. A rigid transform describes the
“pose” between two frames A and B (i.e., the relative orientation and
position of A to B). Alternately, it can be regarded as a
distance-preserving operator that can rotate and/or translate a rigid
body without changing its shape or size (rigid) and without
mirroring/reflecting the body (proper), e.g., it can add one position
vector to another and express the result in a particular basis as
<code class="docutils literal"><span class="pre">p_AoQ_A</span> <span class="pre">=</span> <span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">p_BoQ_B</span></code> (Q is any point). In many ways, this
rigid transform class is conceptually similar to using a homogeneous
matrix as a linear operator. See operator* documentation for an
exception.</p>
<p>The class stores a RotationMatrix that relates right-handed orthogonal
unit vectors Ax, Ay, Az fixed in frame A to right-handed orthogonal
unit vectors Bx, By, Bz fixed in frame B. The class also stores a
position vector from Ao (the origin of frame A) to Bo (the origin of
frame B). The position vector is expressed in frame A. The monogram
notation for the transform relating frame A to B is <code class="docutils literal"><span class="pre">X_AB</span></code>. The
monogram notation for the rotation matrix relating A to B is <code class="docutils literal"><span class="pre">R_AB</span></code>.
The monogram notation for the position vector from Ao to Bo is
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>. See multibody_quantities for monogram notation for
dynamics.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the frames associated with the transform
and cannot enforce correct usage of this class. For example, it
makes sense to multiply RigidTransforms as <code class="docutils literal"><span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">X_BC</span></code>, but
not <code class="docutils literal"><span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">X_CB</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class is not a 4x4 transformation matrix – even though its
operator*() methods act mostly like 4x4 matrix multiplication.
Instead, this class contains a 3x3 rotation matrix class and a 3x1
position vector. To convert this to a 3x4 matrix, use
GetAsMatrix34(). To convert this to a 4x4 matrix, use
GetAsMatrix4(). To convert this to an Eigen::Isometry, use
GetAsIsometry().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An isometry is sometimes regarded as synonymous with rigid
transform. The RigidTransform class has important advantages over
Eigen::Isometry. - RigidTransform is built on an underlying
rigorous 3x3 RotationMatrix class that has significant
functionality for 3D orientation. - In Debug builds,
RigidTransform requires a valid 3x3 rotation matrix and a valid
(non-NAN) position vector. Eigen::Isometry does not. -
RigidTransform catches bugs that are undetected by
Eigen::Isometry. - RigidTransform has additional functionality and
ease-of-use, resulting in shorter, easier to write, and easier to
read code. - The name Isometry is unfamiliar to many roboticists
and dynamicists and for them Isometry.linear() is (for example) a
counter-intuitive method name to return a rotation matrix.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">One of the constructors in this class provides an implicit
conversion from an Eigen Translation to RigidTransform.</p>
</div>
<dl class="docutils">
<dt>Authors:</dt>
<dd>Paul Mitiguy (2018) Original author.</dd>
<dt>Authors:</dt>
<dd>Drake team (see <a class="reference external" href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</dd>
</dl>
<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Constructs the RigidTransform that corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, the constructed RigidTransform contains an
identity RotationMatrix and a zero position vector.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.math.RigidTransform_[float], other: pydrake.math.RigidTransform_[float]) -&gt; None</li>
<li>__init__(self: pydrake.math.RigidTransform_[float], R: drake::math::RotationMatrix&lt;double&gt;, p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from a rotation matrix and a position
vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.math.RigidTransform_[float], rpy: drake::math::RollPitchYaw&lt;double&gt;, p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from a RollPitchYaw and a position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
with “roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> or equivalently a Body-
fixed (intrinsic) Z-Y-X rotation with “yaw-pitch-roll” angles
<code class="docutils literal"><span class="pre">[y,</span> <span class="pre">p,</span> <span class="pre">r]</span></code>.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;)</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.math.RigidTransform_[float], quaternion: Eigen::Quaternion&lt;double, 0&gt;, p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from a Quaternion and a position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>a non-zero, finite quaternion which may or may not have unit
length [i.e., <code class="docutils literal"><span class="pre">quaternion.norm()</span></code> does not have to be 1].</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix that is built</li>
<li>from <code class="docutils literal"><span class="pre">quaternion</span></code> is invalid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;)</p>
</div>
<ol class="arabic simple" start="6">
<li>__init__(self: pydrake.math.RigidTransform_[float], theta_lambda: Eigen::AngleAxis&lt;double&gt;, p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from an AngleAxis and a position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta_lambda</span></code>:</dt>
<dd>an Eigen::AngleAxis whose associated axis (vector direction herein
called <code class="docutils literal"><span class="pre">lambda</span></code>) is non-zero and finite, but which may or may
not have unit length [i.e., <code class="docutils literal"><span class="pre">lambda.norm()</span></code> does not have to be
1].</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted <a href="#id3"><span class="problematic" id="id4">``</span></a>p_AoBo_A</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix that is built</li>
<li>from <cite>theta_lambda`</cite> is invalid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;)</p>
</div>
<ol class="arabic simple" start="7">
<li>__init__(self: pydrake.math.RigidTransform_[float], R: drake::math::RotationMatrix&lt;double&gt;) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform with a given RotationMatrix and a zero
position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
</dl>
<ol class="arabic simple" start="8">
<li>__init__(self: pydrake.math.RigidTransform_[float], p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform that contains an identity RotationMatrix
and a given position vector <code class="docutils literal"><span class="pre">p</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<ol class="arabic simple" start="9">
<li>__init__(self: pydrake.math.RigidTransform_[float], pose: Eigen::Transform&lt;double, 3, 1, 0&gt;) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from an Eigen Isometry3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">pose</span></code>:</dt>
<dd>Isometry3 that contains an allegedly valid rotation matrix
<code class="docutils literal"><span class="pre">R_AB</span></code> and also contains a position vector <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> from
frame A’s origin to frame B’s origin. <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> must be
expressed in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if R_AB is not a proper orthonormal</li>
<li>3x3 rotation matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
<ol class="arabic simple" start="10">
<li>__init__(self: pydrake.math.RigidTransform_[float], pose: numpy.ndarray[numpy.float64[m, n]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from an appropriate Eigen <strong>expression</strong>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">pose</span></code>:</dt>
<dd>Generic Eigen matrix <strong>expression</strong>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the Eigen <strong>expression</strong> in pose does not resolve</li>
<li>to a Vector3 or 3x4 matrix or 4x4 matrix or if the rotational part</li>
<li>of <code class="docutils literal"><span class="pre">pose</span></code> is not a proper orthonormal 3x3 rotation matrix or if</li>
<li><code class="docutils literal"><span class="pre">pose</span></code> is a 4x4 matrix whose final row is not <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1]</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This constructor prevents ambiguity that would otherwise exist for
a RigidTransform constructor whose argument is an Eigen
<strong>expression</strong>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">Vector3</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">position</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X1</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">position</span><span class="p">);</span>
<span class="o">----------------------------------------------</span>
<span class="n">const</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">R</span><span class="p">(</span><span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">pose34</span><span class="p">;</span>
<span class="n">pose34</span> <span class="o">&lt;&lt;</span> <span class="n">R</span><span class="o">.</span><span class="n">matrix</span><span class="p">(),</span> <span class="n">position</span><span class="p">;</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X2</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">pose34</span><span class="p">);</span>
<span class="o">----------------------------------------------</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">pose4</span><span class="p">;</span>
<span class="n">pose4</span> <span class="o">&lt;&lt;</span> <span class="n">R</span><span class="o">.</span><span class="n">matrix</span><span class="p">(),</span> <span class="n">position</span><span class="p">,</span>
         <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X3</span><span class="p">(</span><span class="n">pose4</span> <span class="o">*</span> <span class="n">pose4</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="template">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].cast">
<em class="property">template </em><code class="descname">cast</code><a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.math.RigidTransform_.RigidTransform_[float].cast.cast[float]" title="pydrake.math.RigidTransform_.RigidTransform_[float].cast.cast[float]"><code class="xref py py-class docutils literal"><span class="pre">cast[float]</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">cast[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal"><span class="pre">cast[Expression]</span></code></p>
<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].cast.cast[float]">
<code class="descname">cast[float]</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].cast.cast[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RigidTransform is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].cast[AutoDiffXd]">
<code class="descname">cast[AutoDiffXd]</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; drake::math::RigidTransform&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].cast[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RigidTransform is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].cast[Expression]">
<code class="descname">cast[Expression]</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; drake::math::RigidTransform&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].cast[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RigidTransform is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].cast[float]">
<code class="descname">cast[float]</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].cast[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RigidTransform is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].GetAsIsometry3">
<code class="descname">GetAsIsometry3</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; Eigen::Transform&lt;double, 3, 1, 0&gt;<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].GetAsIsometry3" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the isometry in ℜ³ that is equivalent to a RigidTransform.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].GetAsMatrix34">
<code class="descname">GetAsMatrix34</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 4]]<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].GetAsMatrix34" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 3x4 matrix associated with this RigidTransform, i.e.,
X_AB.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].GetAsMatrix4">
<code class="descname">GetAsMatrix4</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[4, 4]]<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].GetAsMatrix4" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 4x4 matrix associated with this RigidTransform, i.e.,
X_AB.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 │                │
 │   0      1     │
 └                ┘
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].Identity">
<em class="property">static </em><code class="descname">Identity</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].Identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the identity RigidTransform (corresponds to coincident
frames).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the RigidTransform that corresponds to aligning the two frames so
unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident
with Bo. Hence, the returned RigidTransform contains a 3x3
identity matrix and a zero position vector.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns X_BA = X_AB⁻¹, the inverse of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The inverse of RigidTransform X_AB is X_BA, which contains the
rotation matrix R_BA = R_AB⁻¹ = R_ABᵀ and the position vector
<code class="docutils literal"><span class="pre">p_BoAo_B_</span></code> (position from B’s origin Bo to A’s origin Ao,
expressed in frame B).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">: The square-root of a RigidTransform’s condition number is
roughly the magnitude of the position vector. The accuracy of the
calculation for the inverse of a RigidTransform drops off with the
sqrt condition number.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].linear">
<code class="descname">linear</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 3]]<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].linear" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The RigidTransform::linear() method was added for compatibility
with Eigen::Isometry3, and is now deprecated. Use
RigidTransform::rotation().matrix() instead. This will be removed
from Drake on or after 2020-10-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].matrix">
<code class="descname">matrix</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[4, 4]]<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The RigidTransform::matrix() method was added for compatibility
with Eigen::Isometry3, and is now deprecated. Use
RigidTransform::GetAsMatrix4() instead. This will be removed from
Drake on or after 2020-10-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].multiply">
<code class="descname">multiply</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>multiply(self: pydrake.math.RigidTransform_[float], other: pydrake.math.RigidTransform_[float]) -&gt; pydrake.math.RigidTransform_[float]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RigidTransform <code class="docutils literal"><span class="pre">X_AB</span></code> by the <code class="docutils literal"><span class="pre">other</span></code>
RigidTransform <code class="docutils literal"><span class="pre">X_BC</span></code> and returns the RigidTransform <code class="docutils literal"><span class="pre">X_AC</span> <span class="pre">=</span> <span class="pre">X_AB</span> <span class="pre">*</span>
<span class="pre">X_BC</span></code>.</p>
<ol class="arabic simple" start="2">
<li>multiply(self: pydrake.math.RigidTransform_[float], p_BoQ_B: numpy.ndarray[numpy.float64[3, 1]]) -&gt; numpy.ndarray[numpy.float64[3, 1]]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RigidTransform <code class="docutils literal"><span class="pre">X_AB</span></code> by the position vector
<code class="docutils literal"><span class="pre">p_BoQ_B</span></code> which is from Bo (B’s origin) to an arbitrary point Q.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoQ_B</span></code>:</dt>
<dd>position vector from Bo to Q, expressed in frame B.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">p_AoQ_A</span></code>:</dt>
<dd>position vector from Ao to Q, expressed in frame A.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>multiply(self: pydrake.math.RigidTransform_[float], p_BoQ_B: numpy.ndarray[numpy.float64[3, n]]) -&gt; numpy.ndarray[numpy.float64[3, n]]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RigidTransform <code class="docutils literal"><span class="pre">X_AB</span></code> by the n position vectors
<code class="docutils literal"><span class="pre">p_BoQ1_B</span></code> … <cite>p_BoQn_B</cite>, where <code class="docutils literal"><span class="pre">p_BoQi_B</span></code> is the iᵗʰ position
vector from Bo (frame B’s origin) to an arbitrary point Qi, expressed
in frame B.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoQ_B</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix with n position vectors <code class="docutils literal"><span class="pre">p_BoQi_B</span></code> or an
expression that resolves to a <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix of position
vectors.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">p_AoQ_A</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix with n position vectors <code class="docutils literal"><span class="pre">p_AoQi_A</span></code>, i.e., n
position vectors from Ao (frame A’s origin) to Qi, expressed in
frame A. Specifically, this operator* is defined so that <code class="docutils literal"><span class="pre">X_AB</span> <span class="pre">*</span>
<span class="pre">p_BoQ_B</span></code> returns <code class="docutils literal"><span class="pre">p_AoQ_A</span> <span class="pre">=</span> <span class="pre">p_AoBo_A</span> <span class="pre">+</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">p_BoQ_B</span></code>, where
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code> is the position vector from Ao to Bo expressed in A
and <code class="docutils literal"><span class="pre">R_AB</span></code> is the rotation matrix relating the orientation of
frames A and B.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As needed, use parentheses. This operator* is not associative. To
see this, let <code class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">p_AoBo_A</span></code>, <cite>q = p_BoQ_B</cite> and note (X_AB * q)
* 7 = (p + R_AB * q) * 7 ≠ X_AB * (q * 7) = p + R_AB * (q * 7).</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">rpy</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">);</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X_AB</span><span class="p">(</span><span class="n">rpy</span><span class="p">,</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">p_BoQ_B</span><span class="p">;</span>
<span class="n">p_BoQ_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">p_BoQ_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">const</span> <span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">p_AoQ_A</span> <span class="o">=</span> <span class="n">X_AB</span> <span class="o">*</span> <span class="n">p_BoQ_B</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].rotation">
<code class="descname">rotation</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; drake::math::RotationMatrix&lt;double&gt;<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns R_AB, the rotation matrix portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">R_AB</span></code>:</dt>
<dd>the rotation matrix portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].set">
<code class="descname">set</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float], R: drake::math::RotationMatrix&lt;double&gt;, p: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from a RotationMatrix and a position
vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].set_rotation">
<code class="descname">set_rotation</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].set_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>set_rotation(self: pydrake.math.RigidTransform_[float], R: drake::math::RotationMatrix&lt;double&gt;) -&gt; None</li>
</ol>
<p>Sets the RotationMatrix portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
</dl>
<ol class="arabic simple" start="2">
<li>set_rotation(self: pydrake.math.RigidTransform_[float], rpy: drake::math::RollPitchYaw&lt;double&gt;) -&gt; None</li>
</ol>
<p>Sets the rotation part of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from a RollPitchYaw.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>“roll-pitch-yaw” angles.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;) which
describes the parameter, preconditions, etc.</p>
</div>
<ol class="arabic simple" start="3">
<li>set_rotation(self: pydrake.math.RigidTransform_[float], quaternion: Eigen::Quaternion&lt;double, 0&gt;) -&gt; None</li>
</ol>
<p>Sets the rotation part of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from a Quaternion.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>a quaternion which may or may not have unit length.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;) which
describes the parameter, preconditions, exception conditions, etc.</p>
</div>
<ol class="arabic simple" start="4">
<li>set_rotation(self: pydrake.math.RigidTransform_[float], theta_lambda: Eigen::AngleAxis&lt;double&gt;) -&gt; None</li>
</ol>
<p>Sets the rotation part of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from an AngleAxis.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta_lambda</span></code>:</dt>
<dd>an angle <code class="docutils literal"><span class="pre">theta</span></code> (in radians) and vector <code class="docutils literal"><span class="pre">lambda</span></code>.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;) which
describes the parameter, preconditions, exception conditions, etc.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float], p: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the position vector portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from Ao (frame A’s origin) to Bo (frame B’s
origin) expressed in frame A. In monogram notation p is denoted
p_AoBo_A.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].SetFromIsometry3">
<code class="descname">SetFromIsometry3</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float], pose: Eigen::Transform&lt;double, 3, 1, 0&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].SetFromIsometry3" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from an Eigen Isometry3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">pose</span></code>:</dt>
<dd>Isometry3 that contains an allegedly valid rotation matrix
<code class="docutils literal"><span class="pre">R_AB</span></code> and also contains a position vector <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> from
frame A’s origin to frame B’s origin. <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> must be
expressed in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if R_AB is not a proper orthonormal</li>
<li>3x3 rotation matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].SetIdentity">
<code class="descname">SetIdentity</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].SetIdentity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RigidTransform so it corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, <code class="docutils literal"><span class="pre">this</span></code> RigidTransform contains a 3x3
identity matrix and a zero position vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_.RigidTransform_[float].translation">
<code class="descname">translation</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RigidTransform_.RigidTransform_[float].translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">p_AoBo_A</span></code>, the position vector portion of <code class="docutils literal"><span class="pre">this</span></code>
RigidTransform, i.e., position vector from Ao (frame A’s origin) to Bo
(frame B’s origin).</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.math.</code><code class="descname">RigidTransform_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a proper rigid transform between two frames
which can be regarded in two ways. A rigid transform describes the
“pose” between two frames A and B (i.e., the relative orientation and
position of A to B). Alternately, it can be regarded as a
distance-preserving operator that can rotate and/or translate a rigid
body without changing its shape or size (rigid) and without
mirroring/reflecting the body (proper), e.g., it can add one position
vector to another and express the result in a particular basis as
<code class="docutils literal"><span class="pre">p_AoQ_A</span> <span class="pre">=</span> <span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">p_BoQ_B</span></code> (Q is any point). In many ways, this
rigid transform class is conceptually similar to using a homogeneous
matrix as a linear operator. See operator* documentation for an
exception.</p>
<p>The class stores a RotationMatrix that relates right-handed orthogonal
unit vectors Ax, Ay, Az fixed in frame A to right-handed orthogonal
unit vectors Bx, By, Bz fixed in frame B. The class also stores a
position vector from Ao (the origin of frame A) to Bo (the origin of
frame B). The position vector is expressed in frame A. The monogram
notation for the transform relating frame A to B is <code class="docutils literal"><span class="pre">X_AB</span></code>. The
monogram notation for the rotation matrix relating A to B is <code class="docutils literal"><span class="pre">R_AB</span></code>.
The monogram notation for the position vector from Ao to Bo is
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>. See multibody_quantities for monogram notation for
dynamics.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the frames associated with the transform
and cannot enforce correct usage of this class. For example, it
makes sense to multiply RigidTransforms as <code class="docutils literal"><span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">X_BC</span></code>, but
not <code class="docutils literal"><span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">X_CB</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class is not a 4x4 transformation matrix – even though its
operator*() methods act mostly like 4x4 matrix multiplication.
Instead, this class contains a 3x3 rotation matrix class and a 3x1
position vector. To convert this to a 3x4 matrix, use
GetAsMatrix34(). To convert this to a 4x4 matrix, use
GetAsMatrix4(). To convert this to an Eigen::Isometry, use
GetAsIsometry().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An isometry is sometimes regarded as synonymous with rigid
transform. The RigidTransform class has important advantages over
Eigen::Isometry. - RigidTransform is built on an underlying
rigorous 3x3 RotationMatrix class that has significant
functionality for 3D orientation. - In Debug builds,
RigidTransform requires a valid 3x3 rotation matrix and a valid
(non-NAN) position vector. Eigen::Isometry does not. -
RigidTransform catches bugs that are undetected by
Eigen::Isometry. - RigidTransform has additional functionality and
ease-of-use, resulting in shorter, easier to write, and easier to
read code. - The name Isometry is unfamiliar to many roboticists
and dynamicists and for them Isometry.linear() is (for example) a
counter-intuitive method name to return a rotation matrix.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">One of the constructors in this class provides an implicit
conversion from an Eigen Translation to RigidTransform.</p>
</div>
<dl class="docutils">
<dt>Authors:</dt>
<dd>Paul Mitiguy (2018) Original author.</dd>
<dt>Authors:</dt>
<dd>Drake team (see <a class="reference external" href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</dd>
</dl>
<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Constructs the RigidTransform that corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, the constructed RigidTransform contains an
identity RotationMatrix and a zero position vector.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], other: pydrake.math.RigidTransform_[AutoDiffXd]) -&gt; None</li>
<li>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], R: drake::math::RotationMatrix&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;, p: numpy.ndarray[object[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from a rotation matrix and a position
vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], rpy: drake::math::RollPitchYaw&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;, p: numpy.ndarray[object[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from a RollPitchYaw and a position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
with “roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> or equivalently a Body-
fixed (intrinsic) Z-Y-X rotation with “yaw-pitch-roll” angles
<code class="docutils literal"><span class="pre">[y,</span> <span class="pre">p,</span> <span class="pre">r]</span></code>.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;)</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], quaternion: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd], p: numpy.ndarray[object[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from a Quaternion and a position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>a non-zero, finite quaternion which may or may not have unit
length [i.e., <code class="docutils literal"><span class="pre">quaternion.norm()</span></code> does not have to be 1].</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix that is built</li>
<li>from <code class="docutils literal"><span class="pre">quaternion</span></code> is invalid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;)</p>
</div>
<ol class="arabic simple" start="6">
<li>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], theta_lambda: pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd], p: numpy.ndarray[object[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from an AngleAxis and a position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta_lambda</span></code>:</dt>
<dd>an Eigen::AngleAxis whose associated axis (vector direction herein
called <code class="docutils literal"><span class="pre">lambda</span></code>) is non-zero and finite, but which may or may
not have unit length [i.e., <code class="docutils literal"><span class="pre">lambda.norm()</span></code> does not have to be
1].</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted <a href="#id5"><span class="problematic" id="id6">``</span></a>p_AoBo_A</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix that is built</li>
<li>from <cite>theta_lambda`</cite> is invalid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;)</p>
</div>
<ol class="arabic simple" start="7">
<li>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], R: drake::math::RotationMatrix&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform with a given RotationMatrix and a zero
position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
</dl>
<ol class="arabic simple" start="8">
<li>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], p: numpy.ndarray[object[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform that contains an identity RotationMatrix
and a given position vector <code class="docutils literal"><span class="pre">p</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<ol class="arabic simple" start="9">
<li>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], pose: pydrake.common.eigen_geometry.Isometry3_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from an Eigen Isometry3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">pose</span></code>:</dt>
<dd>Isometry3 that contains an allegedly valid rotation matrix
<code class="docutils literal"><span class="pre">R_AB</span></code> and also contains a position vector <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> from
frame A’s origin to frame B’s origin. <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> must be
expressed in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if R_AB is not a proper orthonormal</li>
<li>3x3 rotation matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
<ol class="arabic simple" start="10">
<li>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], pose: numpy.ndarray[object[m, n]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from an appropriate Eigen <strong>expression</strong>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">pose</span></code>:</dt>
<dd>Generic Eigen matrix <strong>expression</strong>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the Eigen <strong>expression</strong> in pose does not resolve</li>
<li>to a Vector3 or 3x4 matrix or 4x4 matrix or if the rotational part</li>
<li>of <code class="docutils literal"><span class="pre">pose</span></code> is not a proper orthonormal 3x3 rotation matrix or if</li>
<li><code class="docutils literal"><span class="pre">pose</span></code> is a 4x4 matrix whose final row is not <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1]</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This constructor prevents ambiguity that would otherwise exist for
a RigidTransform constructor whose argument is an Eigen
<strong>expression</strong>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">Vector3</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">position</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X1</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">position</span><span class="p">);</span>
<span class="o">----------------------------------------------</span>
<span class="n">const</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">R</span><span class="p">(</span><span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">pose34</span><span class="p">;</span>
<span class="n">pose34</span> <span class="o">&lt;&lt;</span> <span class="n">R</span><span class="o">.</span><span class="n">matrix</span><span class="p">(),</span> <span class="n">position</span><span class="p">;</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X2</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">pose34</span><span class="p">);</span>
<span class="o">----------------------------------------------</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">pose4</span><span class="p">;</span>
<span class="n">pose4</span> <span class="o">&lt;&lt;</span> <span class="n">R</span><span class="o">.</span><span class="n">matrix</span><span class="p">(),</span> <span class="n">position</span><span class="p">,</span>
         <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X3</span><span class="p">(</span><span class="n">pose4</span> <span class="o">*</span> <span class="n">pose4</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="template">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].cast">
<em class="property">template </em><code class="descname">cast</code><a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.math.RigidTransform_[AutoDiffXd].cast.cast[AutoDiffXd]" title="pydrake.math.RigidTransform_[AutoDiffXd].cast.cast[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">cast[AutoDiffXd]</span></code></a></p>
<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].cast.cast[AutoDiffXd]">
<code class="descname">cast[AutoDiffXd]</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].cast.cast[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RigidTransform is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].cast[AutoDiffXd]">
<code class="descname">cast[AutoDiffXd]</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].cast[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RigidTransform is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].GetAsIsometry3">
<code class="descname">GetAsIsometry3</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.common.eigen_geometry.Isometry3_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].GetAsIsometry3" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the isometry in ℜ³ that is equivalent to a RigidTransform.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].GetAsMatrix34">
<code class="descname">GetAsMatrix34</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 4]]<a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].GetAsMatrix34" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 3x4 matrix associated with this RigidTransform, i.e.,
X_AB.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].GetAsMatrix4">
<code class="descname">GetAsMatrix4</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[4, 4]]<a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].GetAsMatrix4" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 4x4 matrix associated with this RigidTransform, i.e.,
X_AB.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 │                │
 │   0      1     │
 └                ┘
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].Identity">
<em class="property">static </em><code class="descname">Identity</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].Identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the identity RigidTransform (corresponds to coincident
frames).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the RigidTransform that corresponds to aligning the two frames so
unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident
with Bo. Hence, the returned RigidTransform contains a 3x3
identity matrix and a zero position vector.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns X_BA = X_AB⁻¹, the inverse of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The inverse of RigidTransform X_AB is X_BA, which contains the
rotation matrix R_BA = R_AB⁻¹ = R_ABᵀ and the position vector
<code class="docutils literal"><span class="pre">p_BoAo_B_</span></code> (position from B’s origin Bo to A’s origin Ao,
expressed in frame B).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">: The square-root of a RigidTransform’s condition number is
roughly the magnitude of the position vector. The accuracy of the
calculation for the inverse of a RigidTransform drops off with the
sqrt condition number.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].linear">
<code class="descname">linear</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 3]]<a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].linear" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The RigidTransform::linear() method was added for compatibility
with Eigen::Isometry3, and is now deprecated. Use
RigidTransform::rotation().matrix() instead. This will be removed
from Drake on or after 2020-10-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].matrix">
<code class="descname">matrix</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[4, 4]]<a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The RigidTransform::matrix() method was added for compatibility
with Eigen::Isometry3, and is now deprecated. Use
RigidTransform::GetAsMatrix4() instead. This will be removed from
Drake on or after 2020-10-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].multiply">
<code class="descname">multiply</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>multiply(self: pydrake.math.RigidTransform_[AutoDiffXd], other: pydrake.math.RigidTransform_[AutoDiffXd]) -&gt; pydrake.math.RigidTransform_[AutoDiffXd]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RigidTransform <code class="docutils literal"><span class="pre">X_AB</span></code> by the <code class="docutils literal"><span class="pre">other</span></code>
RigidTransform <code class="docutils literal"><span class="pre">X_BC</span></code> and returns the RigidTransform <code class="docutils literal"><span class="pre">X_AC</span> <span class="pre">=</span> <span class="pre">X_AB</span> <span class="pre">*</span>
<span class="pre">X_BC</span></code>.</p>
<ol class="arabic simple" start="2">
<li>multiply(self: pydrake.math.RigidTransform_[AutoDiffXd], p_BoQ_B: numpy.ndarray[object[3, 1]]) -&gt; numpy.ndarray[object[3, 1]]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RigidTransform <code class="docutils literal"><span class="pre">X_AB</span></code> by the position vector
<code class="docutils literal"><span class="pre">p_BoQ_B</span></code> which is from Bo (B’s origin) to an arbitrary point Q.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoQ_B</span></code>:</dt>
<dd>position vector from Bo to Q, expressed in frame B.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">p_AoQ_A</span></code>:</dt>
<dd>position vector from Ao to Q, expressed in frame A.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>multiply(self: pydrake.math.RigidTransform_[AutoDiffXd], p_BoQ_B: numpy.ndarray[object[3, n]]) -&gt; numpy.ndarray[object[3, n]]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RigidTransform <code class="docutils literal"><span class="pre">X_AB</span></code> by the n position vectors
<code class="docutils literal"><span class="pre">p_BoQ1_B</span></code> … <cite>p_BoQn_B</cite>, where <code class="docutils literal"><span class="pre">p_BoQi_B</span></code> is the iᵗʰ position
vector from Bo (frame B’s origin) to an arbitrary point Qi, expressed
in frame B.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoQ_B</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix with n position vectors <code class="docutils literal"><span class="pre">p_BoQi_B</span></code> or an
expression that resolves to a <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix of position
vectors.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">p_AoQ_A</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix with n position vectors <code class="docutils literal"><span class="pre">p_AoQi_A</span></code>, i.e., n
position vectors from Ao (frame A’s origin) to Qi, expressed in
frame A. Specifically, this operator* is defined so that <code class="docutils literal"><span class="pre">X_AB</span> <span class="pre">*</span>
<span class="pre">p_BoQ_B</span></code> returns <code class="docutils literal"><span class="pre">p_AoQ_A</span> <span class="pre">=</span> <span class="pre">p_AoBo_A</span> <span class="pre">+</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">p_BoQ_B</span></code>, where
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code> is the position vector from Ao to Bo expressed in A
and <code class="docutils literal"><span class="pre">R_AB</span></code> is the rotation matrix relating the orientation of
frames A and B.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As needed, use parentheses. This operator* is not associative. To
see this, let <code class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">p_AoBo_A</span></code>, <cite>q = p_BoQ_B</cite> and note (X_AB * q)
* 7 = (p + R_AB * q) * 7 ≠ X_AB * (q * 7) = p + R_AB * (q * 7).</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">rpy</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">);</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X_AB</span><span class="p">(</span><span class="n">rpy</span><span class="p">,</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">p_BoQ_B</span><span class="p">;</span>
<span class="n">p_BoQ_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">p_BoQ_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">const</span> <span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">p_AoQ_A</span> <span class="o">=</span> <span class="n">X_AB</span> <span class="o">*</span> <span class="n">p_BoQ_B</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].rotation">
<code class="descname">rotation</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; drake::math::RotationMatrix&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns R_AB, the rotation matrix portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">R_AB</span></code>:</dt>
<dd>the rotation matrix portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].set">
<code class="descname">set</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[AutoDiffXd], R: drake::math::RotationMatrix&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;, p: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from a RotationMatrix and a position
vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].set_rotation">
<code class="descname">set_rotation</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].set_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>set_rotation(self: pydrake.math.RigidTransform_[AutoDiffXd], R: drake::math::RotationMatrix&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;) -&gt; None</li>
</ol>
<p>Sets the RotationMatrix portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
</dl>
<ol class="arabic simple" start="2">
<li>set_rotation(self: pydrake.math.RigidTransform_[AutoDiffXd], rpy: drake::math::RollPitchYaw&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;) -&gt; None</li>
</ol>
<p>Sets the rotation part of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from a RollPitchYaw.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>“roll-pitch-yaw” angles.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;) which
describes the parameter, preconditions, etc.</p>
</div>
<ol class="arabic simple" start="3">
<li>set_rotation(self: pydrake.math.RigidTransform_[AutoDiffXd], quaternion: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Sets the rotation part of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from a Quaternion.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>a quaternion which may or may not have unit length.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;) which
describes the parameter, preconditions, exception conditions, etc.</p>
</div>
<ol class="arabic simple" start="4">
<li>set_rotation(self: pydrake.math.RigidTransform_[AutoDiffXd], theta_lambda: pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Sets the rotation part of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from an AngleAxis.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta_lambda</span></code>:</dt>
<dd>an angle <code class="docutils literal"><span class="pre">theta</span></code> (in radians) and vector <code class="docutils literal"><span class="pre">lambda</span></code>.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;) which
describes the parameter, preconditions, exception conditions, etc.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[AutoDiffXd], p: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the position vector portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from Ao (frame A’s origin) to Bo (frame B’s
origin) expressed in frame A. In monogram notation p is denoted
p_AoBo_A.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].SetFromIsometry3">
<code class="descname">SetFromIsometry3</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[AutoDiffXd], pose: pydrake.common.eigen_geometry.Isometry3_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].SetFromIsometry3" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from an Eigen Isometry3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">pose</span></code>:</dt>
<dd>Isometry3 that contains an allegedly valid rotation matrix
<code class="docutils literal"><span class="pre">R_AB</span></code> and also contains a position vector <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> from
frame A’s origin to frame B’s origin. <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> must be
expressed in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if R_AB is not a proper orthonormal</li>
<li>3x3 rotation matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].SetIdentity">
<code class="descname">SetIdentity</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].SetIdentity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RigidTransform so it corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, <code class="docutils literal"><span class="pre">this</span></code> RigidTransform contains a 3x3
identity matrix and a zero position vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[AutoDiffXd].translation">
<code class="descname">translation</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RigidTransform_[AutoDiffXd].translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">p_AoBo_A</span></code>, the position vector portion of <code class="docutils literal"><span class="pre">this</span></code>
RigidTransform, i.e., position vector from Ao (frame A’s origin) to Bo
(frame B’s origin).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.math.RigidTransform_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.math.</code><code class="descname">RigidTransform_[Expression]</code><a class="headerlink" href="#pydrake.math.RigidTransform_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a proper rigid transform between two frames
which can be regarded in two ways. A rigid transform describes the
“pose” between two frames A and B (i.e., the relative orientation and
position of A to B). Alternately, it can be regarded as a
distance-preserving operator that can rotate and/or translate a rigid
body without changing its shape or size (rigid) and without
mirroring/reflecting the body (proper), e.g., it can add one position
vector to another and express the result in a particular basis as
<code class="docutils literal"><span class="pre">p_AoQ_A</span> <span class="pre">=</span> <span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">p_BoQ_B</span></code> (Q is any point). In many ways, this
rigid transform class is conceptually similar to using a homogeneous
matrix as a linear operator. See operator* documentation for an
exception.</p>
<p>The class stores a RotationMatrix that relates right-handed orthogonal
unit vectors Ax, Ay, Az fixed in frame A to right-handed orthogonal
unit vectors Bx, By, Bz fixed in frame B. The class also stores a
position vector from Ao (the origin of frame A) to Bo (the origin of
frame B). The position vector is expressed in frame A. The monogram
notation for the transform relating frame A to B is <code class="docutils literal"><span class="pre">X_AB</span></code>. The
monogram notation for the rotation matrix relating A to B is <code class="docutils literal"><span class="pre">R_AB</span></code>.
The monogram notation for the position vector from Ao to Bo is
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>. See multibody_quantities for monogram notation for
dynamics.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the frames associated with the transform
and cannot enforce correct usage of this class. For example, it
makes sense to multiply RigidTransforms as <code class="docutils literal"><span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">X_BC</span></code>, but
not <code class="docutils literal"><span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">X_CB</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class is not a 4x4 transformation matrix – even though its
operator*() methods act mostly like 4x4 matrix multiplication.
Instead, this class contains a 3x3 rotation matrix class and a 3x1
position vector. To convert this to a 3x4 matrix, use
GetAsMatrix34(). To convert this to a 4x4 matrix, use
GetAsMatrix4(). To convert this to an Eigen::Isometry, use
GetAsIsometry().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An isometry is sometimes regarded as synonymous with rigid
transform. The RigidTransform class has important advantages over
Eigen::Isometry. - RigidTransform is built on an underlying
rigorous 3x3 RotationMatrix class that has significant
functionality for 3D orientation. - In Debug builds,
RigidTransform requires a valid 3x3 rotation matrix and a valid
(non-NAN) position vector. Eigen::Isometry does not. -
RigidTransform catches bugs that are undetected by
Eigen::Isometry. - RigidTransform has additional functionality and
ease-of-use, resulting in shorter, easier to write, and easier to
read code. - The name Isometry is unfamiliar to many roboticists
and dynamicists and for them Isometry.linear() is (for example) a
counter-intuitive method name to return a rotation matrix.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">One of the constructors in this class provides an implicit
conversion from an Eigen Translation to RigidTransform.</p>
</div>
<dl class="docutils">
<dt>Authors:</dt>
<dd>Paul Mitiguy (2018) Original author.</dd>
<dt>Authors:</dt>
<dd>Drake team (see <a class="reference external" href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</dd>
</dl>
<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.math.RigidTransform_[Expression]) -&gt; None</li>
</ol>
<p>Constructs the RigidTransform that corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, the constructed RigidTransform contains an
identity RotationMatrix and a zero position vector.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.math.RigidTransform_[Expression], other: pydrake.math.RigidTransform_[Expression]) -&gt; None</li>
<li>__init__(self: pydrake.math.RigidTransform_[Expression], R: drake::math::RotationMatrix&lt;drake::symbolic::Expression&gt;, p: numpy.ndarray[object[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from a rotation matrix and a position
vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.math.RigidTransform_[Expression], rpy: drake::math::RollPitchYaw&lt;drake::symbolic::Expression&gt;, p: numpy.ndarray[object[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from a RollPitchYaw and a position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
with “roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> or equivalently a Body-
fixed (intrinsic) Z-Y-X rotation with “yaw-pitch-roll” angles
<code class="docutils literal"><span class="pre">[y,</span> <span class="pre">p,</span> <span class="pre">r]</span></code>.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;)</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.math.RigidTransform_[Expression], quaternion: pydrake.common.eigen_geometry.Quaternion_[Expression], p: numpy.ndarray[object[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from a Quaternion and a position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>a non-zero, finite quaternion which may or may not have unit
length [i.e., <code class="docutils literal"><span class="pre">quaternion.norm()</span></code> does not have to be 1].</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix that is built</li>
<li>from <code class="docutils literal"><span class="pre">quaternion</span></code> is invalid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;)</p>
</div>
<ol class="arabic simple" start="6">
<li>__init__(self: pydrake.math.RigidTransform_[Expression], theta_lambda: pydrake.common.eigen_geometry.AngleAxis_[Expression], p: numpy.ndarray[object[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from an AngleAxis and a position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta_lambda</span></code>:</dt>
<dd>an Eigen::AngleAxis whose associated axis (vector direction herein
called <code class="docutils literal"><span class="pre">lambda</span></code>) is non-zero and finite, but which may or may
not have unit length [i.e., <code class="docutils literal"><span class="pre">lambda.norm()</span></code> does not have to be
1].</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted <a href="#id7"><span class="problematic" id="id8">``</span></a>p_AoBo_A</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix that is built</li>
<li>from <cite>theta_lambda`</cite> is invalid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;)</p>
</div>
<ol class="arabic simple" start="7">
<li>__init__(self: pydrake.math.RigidTransform_[Expression], R: drake::math::RotationMatrix&lt;drake::symbolic::Expression&gt;) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform with a given RotationMatrix and a zero
position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
</dl>
<ol class="arabic simple" start="8">
<li>__init__(self: pydrake.math.RigidTransform_[Expression], p: numpy.ndarray[object[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform that contains an identity RotationMatrix
and a given position vector <code class="docutils literal"><span class="pre">p</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<ol class="arabic simple" start="9">
<li>__init__(self: pydrake.math.RigidTransform_[Expression], pose: pydrake.common.eigen_geometry.Isometry3_[Expression]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from an Eigen Isometry3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">pose</span></code>:</dt>
<dd>Isometry3 that contains an allegedly valid rotation matrix
<code class="docutils literal"><span class="pre">R_AB</span></code> and also contains a position vector <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> from
frame A’s origin to frame B’s origin. <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> must be
expressed in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if R_AB is not a proper orthonormal</li>
<li>3x3 rotation matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
<ol class="arabic simple" start="10">
<li>__init__(self: pydrake.math.RigidTransform_[Expression], pose: numpy.ndarray[object[m, n]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from an appropriate Eigen <strong>expression</strong>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">pose</span></code>:</dt>
<dd>Generic Eigen matrix <strong>expression</strong>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the Eigen <strong>expression</strong> in pose does not resolve</li>
<li>to a Vector3 or 3x4 matrix or 4x4 matrix or if the rotational part</li>
<li>of <code class="docutils literal"><span class="pre">pose</span></code> is not a proper orthonormal 3x3 rotation matrix or if</li>
<li><code class="docutils literal"><span class="pre">pose</span></code> is a 4x4 matrix whose final row is not <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1]</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This constructor prevents ambiguity that would otherwise exist for
a RigidTransform constructor whose argument is an Eigen
<strong>expression</strong>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">Vector3</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">position</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X1</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">position</span><span class="p">);</span>
<span class="o">----------------------------------------------</span>
<span class="n">const</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">R</span><span class="p">(</span><span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">pose34</span><span class="p">;</span>
<span class="n">pose34</span> <span class="o">&lt;&lt;</span> <span class="n">R</span><span class="o">.</span><span class="n">matrix</span><span class="p">(),</span> <span class="n">position</span><span class="p">;</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X2</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">pose34</span><span class="p">);</span>
<span class="o">----------------------------------------------</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">pose4</span><span class="p">;</span>
<span class="n">pose4</span> <span class="o">&lt;&lt;</span> <span class="n">R</span><span class="o">.</span><span class="n">matrix</span><span class="p">(),</span> <span class="n">position</span><span class="p">,</span>
         <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X3</span><span class="p">(</span><span class="n">pose4</span> <span class="o">*</span> <span class="n">pose4</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="template">
<dt id="pydrake.math.RigidTransform_[Expression].cast">
<em class="property">template </em><code class="descname">cast</code><a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.math.RigidTransform_[Expression].cast.cast[Expression]" title="pydrake.math.RigidTransform_[Expression].cast.cast[Expression]"><code class="xref py py-class docutils literal"><span class="pre">cast[Expression]</span></code></a></p>
<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].cast.cast[Expression]">
<code class="descname">cast[Expression]</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[Expression]<a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].cast.cast[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RigidTransform is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].cast[Expression]">
<code class="descname">cast[Expression]</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[Expression]<a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].cast[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RigidTransform is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].GetAsIsometry3">
<code class="descname">GetAsIsometry3</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.common.eigen_geometry.Isometry3_[Expression]<a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].GetAsIsometry3" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the isometry in ℜ³ that is equivalent to a RigidTransform.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].GetAsMatrix34">
<code class="descname">GetAsMatrix34</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 4]]<a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].GetAsMatrix34" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 3x4 matrix associated with this RigidTransform, i.e.,
X_AB.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].GetAsMatrix4">
<code class="descname">GetAsMatrix4</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[4, 4]]<a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].GetAsMatrix4" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 4x4 matrix associated with this RigidTransform, i.e.,
X_AB.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 │                │
 │   0      1     │
 └                ┘
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RigidTransform_[Expression].Identity">
<em class="property">static </em><code class="descname">Identity</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[Expression]<a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].Identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the identity RigidTransform (corresponds to coincident
frames).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the RigidTransform that corresponds to aligning the two frames so
unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident
with Bo. Hence, the returned RigidTransform contains a 3x3
identity matrix and a zero position vector.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[Expression]<a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns X_BA = X_AB⁻¹, the inverse of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The inverse of RigidTransform X_AB is X_BA, which contains the
rotation matrix R_BA = R_AB⁻¹ = R_ABᵀ and the position vector
<code class="docutils literal"><span class="pre">p_BoAo_B_</span></code> (position from B’s origin Bo to A’s origin Ao,
expressed in frame B).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">: The square-root of a RigidTransform’s condition number is
roughly the magnitude of the position vector. The accuracy of the
calculation for the inverse of a RigidTransform drops off with the
sqrt condition number.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].linear">
<code class="descname">linear</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 3]]<a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].linear" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The RigidTransform::linear() method was added for compatibility
with Eigen::Isometry3, and is now deprecated. Use
RigidTransform::rotation().matrix() instead. This will be removed
from Drake on or after 2020-10-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].matrix">
<code class="descname">matrix</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[4, 4]]<a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The RigidTransform::matrix() method was added for compatibility
with Eigen::Isometry3, and is now deprecated. Use
RigidTransform::GetAsMatrix4() instead. This will be removed from
Drake on or after 2020-10-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].multiply">
<code class="descname">multiply</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>multiply(self: pydrake.math.RigidTransform_[Expression], other: pydrake.math.RigidTransform_[Expression]) -&gt; pydrake.math.RigidTransform_[Expression]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RigidTransform <code class="docutils literal"><span class="pre">X_AB</span></code> by the <code class="docutils literal"><span class="pre">other</span></code>
RigidTransform <code class="docutils literal"><span class="pre">X_BC</span></code> and returns the RigidTransform <code class="docutils literal"><span class="pre">X_AC</span> <span class="pre">=</span> <span class="pre">X_AB</span> <span class="pre">*</span>
<span class="pre">X_BC</span></code>.</p>
<ol class="arabic simple" start="2">
<li>multiply(self: pydrake.math.RigidTransform_[Expression], p_BoQ_B: numpy.ndarray[object[3, 1]]) -&gt; numpy.ndarray[object[3, 1]]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RigidTransform <code class="docutils literal"><span class="pre">X_AB</span></code> by the position vector
<code class="docutils literal"><span class="pre">p_BoQ_B</span></code> which is from Bo (B’s origin) to an arbitrary point Q.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoQ_B</span></code>:</dt>
<dd>position vector from Bo to Q, expressed in frame B.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">p_AoQ_A</span></code>:</dt>
<dd>position vector from Ao to Q, expressed in frame A.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>multiply(self: pydrake.math.RigidTransform_[Expression], p_BoQ_B: numpy.ndarray[object[3, n]]) -&gt; numpy.ndarray[object[3, n]]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RigidTransform <code class="docutils literal"><span class="pre">X_AB</span></code> by the n position vectors
<code class="docutils literal"><span class="pre">p_BoQ1_B</span></code> … <cite>p_BoQn_B</cite>, where <code class="docutils literal"><span class="pre">p_BoQi_B</span></code> is the iᵗʰ position
vector from Bo (frame B’s origin) to an arbitrary point Qi, expressed
in frame B.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoQ_B</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix with n position vectors <code class="docutils literal"><span class="pre">p_BoQi_B</span></code> or an
expression that resolves to a <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix of position
vectors.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">p_AoQ_A</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix with n position vectors <code class="docutils literal"><span class="pre">p_AoQi_A</span></code>, i.e., n
position vectors from Ao (frame A’s origin) to Qi, expressed in
frame A. Specifically, this operator* is defined so that <code class="docutils literal"><span class="pre">X_AB</span> <span class="pre">*</span>
<span class="pre">p_BoQ_B</span></code> returns <code class="docutils literal"><span class="pre">p_AoQ_A</span> <span class="pre">=</span> <span class="pre">p_AoBo_A</span> <span class="pre">+</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">p_BoQ_B</span></code>, where
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code> is the position vector from Ao to Bo expressed in A
and <code class="docutils literal"><span class="pre">R_AB</span></code> is the rotation matrix relating the orientation of
frames A and B.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As needed, use parentheses. This operator* is not associative. To
see this, let <code class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">p_AoBo_A</span></code>, <cite>q = p_BoQ_B</cite> and note (X_AB * q)
* 7 = (p + R_AB * q) * 7 ≠ X_AB * (q * 7) = p + R_AB * (q * 7).</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">rpy</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">);</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X_AB</span><span class="p">(</span><span class="n">rpy</span><span class="p">,</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">p_BoQ_B</span><span class="p">;</span>
<span class="n">p_BoQ_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">p_BoQ_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">const</span> <span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">p_AoQ_A</span> <span class="o">=</span> <span class="n">X_AB</span> <span class="o">*</span> <span class="n">p_BoQ_B</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].rotation">
<code class="descname">rotation</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[Expression]</em><span class="sig-paren">)</span> &#x2192; drake::math::RotationMatrix&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns R_AB, the rotation matrix portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">R_AB</span></code>:</dt>
<dd>the rotation matrix portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].set">
<code class="descname">set</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[Expression], R: drake::math::RotationMatrix&lt;drake::symbolic::Expression&gt;, p: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from a RotationMatrix and a position
vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].set_rotation">
<code class="descname">set_rotation</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].set_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>set_rotation(self: pydrake.math.RigidTransform_[Expression], R: drake::math::RotationMatrix&lt;drake::symbolic::Expression&gt;) -&gt; None</li>
</ol>
<p>Sets the RotationMatrix portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
</dl>
<ol class="arabic simple" start="2">
<li>set_rotation(self: pydrake.math.RigidTransform_[Expression], rpy: drake::math::RollPitchYaw&lt;drake::symbolic::Expression&gt;) -&gt; None</li>
</ol>
<p>Sets the rotation part of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from a RollPitchYaw.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>“roll-pitch-yaw” angles.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;) which
describes the parameter, preconditions, etc.</p>
</div>
<ol class="arabic simple" start="3">
<li>set_rotation(self: pydrake.math.RigidTransform_[Expression], quaternion: pydrake.common.eigen_geometry.Quaternion_[Expression]) -&gt; None</li>
</ol>
<p>Sets the rotation part of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from a Quaternion.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>a quaternion which may or may not have unit length.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;) which
describes the parameter, preconditions, exception conditions, etc.</p>
</div>
<ol class="arabic simple" start="4">
<li>set_rotation(self: pydrake.math.RigidTransform_[Expression], theta_lambda: pydrake.common.eigen_geometry.AngleAxis_[Expression]) -&gt; None</li>
</ol>
<p>Sets the rotation part of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from an AngleAxis.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta_lambda</span></code>:</dt>
<dd>an angle <code class="docutils literal"><span class="pre">theta</span></code> (in radians) and vector <code class="docutils literal"><span class="pre">lambda</span></code>.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;) which
describes the parameter, preconditions, exception conditions, etc.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[Expression], p: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the position vector portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from Ao (frame A’s origin) to Bo (frame B’s
origin) expressed in frame A. In monogram notation p is denoted
p_AoBo_A.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].SetFromIsometry3">
<code class="descname">SetFromIsometry3</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[Expression], pose: pydrake.common.eigen_geometry.Isometry3_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].SetFromIsometry3" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from an Eigen Isometry3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">pose</span></code>:</dt>
<dd>Isometry3 that contains an allegedly valid rotation matrix
<code class="docutils literal"><span class="pre">R_AB</span></code> and also contains a position vector <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> from
frame A’s origin to frame B’s origin. <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> must be
expressed in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if R_AB is not a proper orthonormal</li>
<li>3x3 rotation matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].SetIdentity">
<code class="descname">SetIdentity</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[Expression]<a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].SetIdentity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RigidTransform so it corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, <code class="docutils literal"><span class="pre">this</span></code> RigidTransform contains a 3x3
identity matrix and a zero position vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[Expression].translation">
<code class="descname">translation</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RigidTransform_[Expression].translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">p_AoBo_A</span></code>, the position vector portion of <code class="docutils literal"><span class="pre">this</span></code>
RigidTransform, i.e., position vector from Ao (frame A’s origin) to Bo
(frame B’s origin).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.math.RigidTransform_[float]">
<em class="property">class </em><code class="descclassname">pydrake.math.</code><code class="descname">RigidTransform_[float]</code><a class="headerlink" href="#pydrake.math.RigidTransform_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a proper rigid transform between two frames
which can be regarded in two ways. A rigid transform describes the
“pose” between two frames A and B (i.e., the relative orientation and
position of A to B). Alternately, it can be regarded as a
distance-preserving operator that can rotate and/or translate a rigid
body without changing its shape or size (rigid) and without
mirroring/reflecting the body (proper), e.g., it can add one position
vector to another and express the result in a particular basis as
<code class="docutils literal"><span class="pre">p_AoQ_A</span> <span class="pre">=</span> <span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">p_BoQ_B</span></code> (Q is any point). In many ways, this
rigid transform class is conceptually similar to using a homogeneous
matrix as a linear operator. See operator* documentation for an
exception.</p>
<p>The class stores a RotationMatrix that relates right-handed orthogonal
unit vectors Ax, Ay, Az fixed in frame A to right-handed orthogonal
unit vectors Bx, By, Bz fixed in frame B. The class also stores a
position vector from Ao (the origin of frame A) to Bo (the origin of
frame B). The position vector is expressed in frame A. The monogram
notation for the transform relating frame A to B is <code class="docutils literal"><span class="pre">X_AB</span></code>. The
monogram notation for the rotation matrix relating A to B is <code class="docutils literal"><span class="pre">R_AB</span></code>.
The monogram notation for the position vector from Ao to Bo is
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>. See multibody_quantities for monogram notation for
dynamics.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the frames associated with the transform
and cannot enforce correct usage of this class. For example, it
makes sense to multiply RigidTransforms as <code class="docutils literal"><span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">X_BC</span></code>, but
not <code class="docutils literal"><span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">X_CB</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class is not a 4x4 transformation matrix – even though its
operator*() methods act mostly like 4x4 matrix multiplication.
Instead, this class contains a 3x3 rotation matrix class and a 3x1
position vector. To convert this to a 3x4 matrix, use
GetAsMatrix34(). To convert this to a 4x4 matrix, use
GetAsMatrix4(). To convert this to an Eigen::Isometry, use
GetAsIsometry().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">An isometry is sometimes regarded as synonymous with rigid
transform. The RigidTransform class has important advantages over
Eigen::Isometry. - RigidTransform is built on an underlying
rigorous 3x3 RotationMatrix class that has significant
functionality for 3D orientation. - In Debug builds,
RigidTransform requires a valid 3x3 rotation matrix and a valid
(non-NAN) position vector. Eigen::Isometry does not. -
RigidTransform catches bugs that are undetected by
Eigen::Isometry. - RigidTransform has additional functionality and
ease-of-use, resulting in shorter, easier to write, and easier to
read code. - The name Isometry is unfamiliar to many roboticists
and dynamicists and for them Isometry.linear() is (for example) a
counter-intuitive method name to return a rotation matrix.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">One of the constructors in this class provides an implicit
conversion from an Eigen Translation to RigidTransform.</p>
</div>
<dl class="docutils">
<dt>Authors:</dt>
<dd>Paul Mitiguy (2018) Original author.</dd>
<dt>Authors:</dt>
<dd>Drake team (see <a class="reference external" href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</dd>
</dl>
<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Constructs the RigidTransform that corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, the constructed RigidTransform contains an
identity RotationMatrix and a zero position vector.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.math.RigidTransform_[float], other: pydrake.math.RigidTransform_[float]) -&gt; None</li>
<li>__init__(self: pydrake.math.RigidTransform_[float], R: drake::math::RotationMatrix&lt;double&gt;, p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from a rotation matrix and a position
vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.math.RigidTransform_[float], rpy: drake::math::RollPitchYaw&lt;double&gt;, p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from a RollPitchYaw and a position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
with “roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> or equivalently a Body-
fixed (intrinsic) Z-Y-X rotation with “yaw-pitch-roll” angles
<code class="docutils literal"><span class="pre">[y,</span> <span class="pre">p,</span> <span class="pre">r]</span></code>.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;)</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.math.RigidTransform_[float], quaternion: Eigen::Quaternion&lt;double, 0&gt;, p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from a Quaternion and a position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>a non-zero, finite quaternion which may or may not have unit
length [i.e., <code class="docutils literal"><span class="pre">quaternion.norm()</span></code> does not have to be 1].</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix that is built</li>
<li>from <code class="docutils literal"><span class="pre">quaternion</span></code> is invalid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;)</p>
</div>
<ol class="arabic simple" start="6">
<li>__init__(self: pydrake.math.RigidTransform_[float], theta_lambda: Eigen::AngleAxis&lt;double&gt;, p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from an AngleAxis and a position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta_lambda</span></code>:</dt>
<dd>an Eigen::AngleAxis whose associated axis (vector direction herein
called <code class="docutils literal"><span class="pre">lambda</span></code>) is non-zero and finite, but which may or may
not have unit length [i.e., <code class="docutils literal"><span class="pre">lambda.norm()</span></code> does not have to be
1].</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted <a href="#id9"><span class="problematic" id="id10">``</span></a>p_AoBo_A</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix that is built</li>
<li>from <cite>theta_lambda`</cite> is invalid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;)</p>
</div>
<ol class="arabic simple" start="7">
<li>__init__(self: pydrake.math.RigidTransform_[float], R: drake::math::RotationMatrix&lt;double&gt;) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform with a given RotationMatrix and a zero
position vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
</dl>
<ol class="arabic simple" start="8">
<li>__init__(self: pydrake.math.RigidTransform_[float], p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform that contains an identity RotationMatrix
and a given position vector <code class="docutils literal"><span class="pre">p</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
<ol class="arabic simple" start="9">
<li>__init__(self: pydrake.math.RigidTransform_[float], pose: Eigen::Transform&lt;double, 3, 1, 0&gt;) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from an Eigen Isometry3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">pose</span></code>:</dt>
<dd>Isometry3 that contains an allegedly valid rotation matrix
<code class="docutils literal"><span class="pre">R_AB</span></code> and also contains a position vector <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> from
frame A’s origin to frame B’s origin. <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> must be
expressed in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if R_AB is not a proper orthonormal</li>
<li>3x3 rotation matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
<ol class="arabic simple" start="10">
<li>__init__(self: pydrake.math.RigidTransform_[float], pose: numpy.ndarray[numpy.float64[m, n]]) -&gt; None</li>
</ol>
<p>Constructs a RigidTransform from an appropriate Eigen <strong>expression</strong>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">pose</span></code>:</dt>
<dd>Generic Eigen matrix <strong>expression</strong>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the Eigen <strong>expression</strong> in pose does not resolve</li>
<li>to a Vector3 or 3x4 matrix or 4x4 matrix or if the rotational part</li>
<li>of <code class="docutils literal"><span class="pre">pose</span></code> is not a proper orthonormal 3x3 rotation matrix or if</li>
<li><code class="docutils literal"><span class="pre">pose</span></code> is a 4x4 matrix whose final row is not <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1]</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This constructor prevents ambiguity that would otherwise exist for
a RigidTransform constructor whose argument is an Eigen
<strong>expression</strong>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">Vector3</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">position</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X1</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">position</span><span class="p">);</span>
<span class="o">----------------------------------------------</span>
<span class="n">const</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">R</span><span class="p">(</span><span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">pose34</span><span class="p">;</span>
<span class="n">pose34</span> <span class="o">&lt;&lt;</span> <span class="n">R</span><span class="o">.</span><span class="n">matrix</span><span class="p">(),</span> <span class="n">position</span><span class="p">;</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X2</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">pose34</span><span class="p">);</span>
<span class="o">----------------------------------------------</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">pose4</span><span class="p">;</span>
<span class="n">pose4</span> <span class="o">&lt;&lt;</span> <span class="n">R</span><span class="o">.</span><span class="n">matrix</span><span class="p">(),</span> <span class="n">position</span><span class="p">,</span>
         <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X3</span><span class="p">(</span><span class="n">pose4</span> <span class="o">*</span> <span class="n">pose4</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="template">
<dt id="pydrake.math.RigidTransform_[float].cast">
<em class="property">template </em><code class="descname">cast</code><a class="headerlink" href="#pydrake.math.RigidTransform_[float].cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.math.RigidTransform_[float].cast.cast[float]" title="pydrake.math.RigidTransform_[float].cast.cast[float]"><code class="xref py py-class docutils literal"><span class="pre">cast[float]</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">cast[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal"><span class="pre">cast[Expression]</span></code></p>
<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].cast.cast[float]">
<code class="descname">cast[float]</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.math.RigidTransform_[float].cast.cast[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RigidTransform is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].cast[AutoDiffXd]">
<code class="descname">cast[AutoDiffXd]</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; drake::math::RigidTransform&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.math.RigidTransform_[float].cast[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RigidTransform is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].cast[Expression]">
<code class="descname">cast[Expression]</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; drake::math::RigidTransform&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.math.RigidTransform_[float].cast[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RigidTransform is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].cast[float]">
<code class="descname">cast[float]</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.math.RigidTransform_[float].cast[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RigidTransform is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].GetAsIsometry3">
<code class="descname">GetAsIsometry3</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; Eigen::Transform&lt;double, 3, 1, 0&gt;<a class="headerlink" href="#pydrake.math.RigidTransform_[float].GetAsIsometry3" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the isometry in ℜ³ that is equivalent to a RigidTransform.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].GetAsMatrix34">
<code class="descname">GetAsMatrix34</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 4]]<a class="headerlink" href="#pydrake.math.RigidTransform_[float].GetAsMatrix34" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 3x4 matrix associated with this RigidTransform, i.e.,
X_AB.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].GetAsMatrix4">
<code class="descname">GetAsMatrix4</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[4, 4]]<a class="headerlink" href="#pydrake.math.RigidTransform_[float].GetAsMatrix4" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the 4x4 matrix associated with this RigidTransform, i.e.,
X_AB.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 │                │
 │   0      1     │
 └                ┘
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RigidTransform_[float].Identity">
<em class="property">static </em><code class="descname">Identity</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.math.RigidTransform_[float].Identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the identity RigidTransform (corresponds to coincident
frames).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the RigidTransform that corresponds to aligning the two frames so
unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident
with Bo. Hence, the returned RigidTransform contains a 3x3
identity matrix and a zero position vector.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.math.RigidTransform_[float].inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns X_BA = X_AB⁻¹, the inverse of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The inverse of RigidTransform X_AB is X_BA, which contains the
rotation matrix R_BA = R_AB⁻¹ = R_ABᵀ and the position vector
<code class="docutils literal"><span class="pre">p_BoAo_B_</span></code> (position from B’s origin Bo to A’s origin Ao,
expressed in frame B).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">: The square-root of a RigidTransform’s condition number is
roughly the magnitude of the position vector. The accuracy of the
calculation for the inverse of a RigidTransform drops off with the
sqrt condition number.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].linear">
<code class="descname">linear</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 3]]<a class="headerlink" href="#pydrake.math.RigidTransform_[float].linear" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The RigidTransform::linear() method was added for compatibility
with Eigen::Isometry3, and is now deprecated. Use
RigidTransform::rotation().matrix() instead. This will be removed
from Drake on or after 2020-10-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].matrix">
<code class="descname">matrix</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[4, 4]]<a class="headerlink" href="#pydrake.math.RigidTransform_[float].matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The RigidTransform::matrix() method was added for compatibility
with Eigen::Isometry3, and is now deprecated. Use
RigidTransform::GetAsMatrix4() instead. This will be removed from
Drake on or after 2020-10-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].multiply">
<code class="descname">multiply</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_[float].multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>multiply(self: pydrake.math.RigidTransform_[float], other: pydrake.math.RigidTransform_[float]) -&gt; pydrake.math.RigidTransform_[float]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RigidTransform <code class="docutils literal"><span class="pre">X_AB</span></code> by the <code class="docutils literal"><span class="pre">other</span></code>
RigidTransform <code class="docutils literal"><span class="pre">X_BC</span></code> and returns the RigidTransform <code class="docutils literal"><span class="pre">X_AC</span> <span class="pre">=</span> <span class="pre">X_AB</span> <span class="pre">*</span>
<span class="pre">X_BC</span></code>.</p>
<ol class="arabic simple" start="2">
<li>multiply(self: pydrake.math.RigidTransform_[float], p_BoQ_B: numpy.ndarray[numpy.float64[3, 1]]) -&gt; numpy.ndarray[numpy.float64[3, 1]]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RigidTransform <code class="docutils literal"><span class="pre">X_AB</span></code> by the position vector
<code class="docutils literal"><span class="pre">p_BoQ_B</span></code> which is from Bo (B’s origin) to an arbitrary point Q.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoQ_B</span></code>:</dt>
<dd>position vector from Bo to Q, expressed in frame B.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">p_AoQ_A</span></code>:</dt>
<dd>position vector from Ao to Q, expressed in frame A.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>multiply(self: pydrake.math.RigidTransform_[float], p_BoQ_B: numpy.ndarray[numpy.float64[3, n]]) -&gt; numpy.ndarray[numpy.float64[3, n]]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RigidTransform <code class="docutils literal"><span class="pre">X_AB</span></code> by the n position vectors
<code class="docutils literal"><span class="pre">p_BoQ1_B</span></code> … <cite>p_BoQn_B</cite>, where <code class="docutils literal"><span class="pre">p_BoQi_B</span></code> is the iᵗʰ position
vector from Bo (frame B’s origin) to an arbitrary point Qi, expressed
in frame B.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p_BoQ_B</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix with n position vectors <code class="docutils literal"><span class="pre">p_BoQi_B</span></code> or an
expression that resolves to a <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix of position
vectors.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">p_AoQ_A</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix with n position vectors <code class="docutils literal"><span class="pre">p_AoQi_A</span></code>, i.e., n
position vectors from Ao (frame A’s origin) to Qi, expressed in
frame A. Specifically, this operator* is defined so that <code class="docutils literal"><span class="pre">X_AB</span> <span class="pre">*</span>
<span class="pre">p_BoQ_B</span></code> returns <code class="docutils literal"><span class="pre">p_AoQ_A</span> <span class="pre">=</span> <span class="pre">p_AoBo_A</span> <span class="pre">+</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">p_BoQ_B</span></code>, where
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code> is the position vector from Ao to Bo expressed in A
and <code class="docutils literal"><span class="pre">R_AB</span></code> is the rotation matrix relating the orientation of
frames A and B.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As needed, use parentheses. This operator* is not associative. To
see this, let <code class="docutils literal"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">p_AoBo_A</span></code>, <cite>q = p_BoQ_B</cite> and note (X_AB * q)
* 7 = (p + R_AB * q) * 7 ≠ X_AB * (q * 7) = p + R_AB * (q * 7).</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">rpy</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">);</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">X_AB</span><span class="p">(</span><span class="n">rpy</span><span class="p">,</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">p_BoQ_B</span><span class="p">;</span>
<span class="n">p_BoQ_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">p_BoQ_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">const</span> <span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">p_AoQ_A</span> <span class="o">=</span> <span class="n">X_AB</span> <span class="o">*</span> <span class="n">p_BoQ_B</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].rotation">
<code class="descname">rotation</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; drake::math::RotationMatrix&lt;double&gt;<a class="headerlink" href="#pydrake.math.RigidTransform_[float].rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns R_AB, the rotation matrix portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">R_AB</span></code>:</dt>
<dd>the rotation matrix portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].set">
<code class="descname">set</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float], R: drake::math::RotationMatrix&lt;double&gt;, p: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RigidTransform_[float].set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from a RotationMatrix and a position
vector.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal"><span class="pre">p_AoBo_A</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].set_rotation">
<code class="descname">set_rotation</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_[float].set_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>set_rotation(self: pydrake.math.RigidTransform_[float], R: drake::math::RotationMatrix&lt;double&gt;) -&gt; None</li>
</ol>
<p>Sets the RotationMatrix portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>rotation matrix relating frames A and B (e.g., <code class="docutils literal"><span class="pre">R_AB</span></code>).</dd>
</dl>
<ol class="arabic simple" start="2">
<li>set_rotation(self: pydrake.math.RigidTransform_[float], rpy: drake::math::RollPitchYaw&lt;double&gt;) -&gt; None</li>
</ol>
<p>Sets the rotation part of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from a RollPitchYaw.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>“roll-pitch-yaw” angles.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;) which
describes the parameter, preconditions, etc.</p>
</div>
<ol class="arabic simple" start="3">
<li>set_rotation(self: pydrake.math.RigidTransform_[float], quaternion: Eigen::Quaternion&lt;double, 0&gt;) -&gt; None</li>
</ol>
<p>Sets the rotation part of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from a Quaternion.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>a quaternion which may or may not have unit length.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;) which
describes the parameter, preconditions, exception conditions, etc.</p>
</div>
<ol class="arabic simple" start="4">
<li>set_rotation(self: pydrake.math.RigidTransform_[float], theta_lambda: Eigen::AngleAxis&lt;double&gt;) -&gt; None</li>
</ol>
<p>Sets the rotation part of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from an AngleAxis.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta_lambda</span></code>:</dt>
<dd>an angle <code class="docutils literal"><span class="pre">theta</span></code> (in radians) and vector <code class="docutils literal"><span class="pre">lambda</span></code>.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;) which
describes the parameter, preconditions, exception conditions, etc.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float], p: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RigidTransform_[float].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the position vector portion of <code class="docutils literal"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>position vector from Ao (frame A’s origin) to Bo (frame B’s
origin) expressed in frame A. In monogram notation p is denoted
p_AoBo_A.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].SetFromIsometry3">
<code class="descname">SetFromIsometry3</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float], pose: Eigen::Transform&lt;double, 3, 1, 0&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RigidTransform_[float].SetFromIsometry3" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RigidTransform from an Eigen Isometry3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">pose</span></code>:</dt>
<dd>Isometry3 that contains an allegedly valid rotation matrix
<code class="docutils literal"><span class="pre">R_AB</span></code> and also contains a position vector <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> from
frame A’s origin to frame B’s origin. <code class="docutils literal"><span class="pre">p_AoBo_A</span></code> must be
expressed in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if R_AB is not a proper orthonormal</li>
<li>3x3 rotation matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].SetIdentity">
<code class="descname">SetIdentity</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.math.RigidTransform_[float].SetIdentity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RigidTransform so it corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, <code class="docutils literal"><span class="pre">this</span></code> RigidTransform contains a 3x3
identity matrix and a zero position vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RigidTransform_[float].translation">
<code class="descname">translation</code><span class="sig-paren">(</span><em>self: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RigidTransform_[float].translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">p_AoBo_A</span></code>, the position vector portion of <code class="docutils literal"><span class="pre">this</span></code>
RigidTransform, i.e., position vector from Ao (frame A’s origin) to Bo
(frame B’s origin).</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.math.RollPitchYaw">
<code class="descclassname">pydrake.math.</code><code class="descname">RollPitchYaw</code><a class="headerlink" href="#pydrake.math.RollPitchYaw" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.math.RollPitchYaw_[float]" title="pydrake.math.RollPitchYaw_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.math.RollPitchYaw_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.math.RollPitchYaw_">
<em class="property">template </em><code class="descclassname">pydrake.math.</code><code class="descname">RollPitchYaw_</code><a class="headerlink" href="#pydrake.math.RollPitchYaw_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.math.RollPitchYaw_[float]" title="pydrake.math.RollPitchYaw_[float]"><code class="xref py py-class docutils literal"><span class="pre">RollPitchYaw_[float]</span></code></a>, <a class="reference internal" href="#pydrake.math.RollPitchYaw_[AutoDiffXd]" title="pydrake.math.RollPitchYaw_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">RollPitchYaw_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.math.RollPitchYaw_[Expression]" title="pydrake.math.RollPitchYaw_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">RollPitchYaw_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.math.RollPitchYaw_.RollPitchYaw_[float]">
<em class="property">class </em><code class="descname">RollPitchYaw_[float]</code><a class="headerlink" href="#pydrake.math.RollPitchYaw_.RollPitchYaw_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents the orientation between two arbitrary frames A
and D associated with a Space-fixed (extrinsic) X-Y-Z rotation by
“roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code>, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by “yaw-pitch-roll” angles <code class="docutils literal"><span class="pre">[y,</span>
<span class="pre">p,</span> <span class="pre">r]</span></code>. The rotation matrix <code class="docutils literal"><span class="pre">R_AD</span></code> associated with this
roll-pitch-yaw <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> rotation sequence is equal to the matrix
multiplication shown below.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
       ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
     =       R_AB          *        R_BC          *        R_CD
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this discussion, A is the Space frame and D is the Body frame.
One way to visualize this rotation sequence is by introducing
intermediate frames B and C (useful constructs to understand this
rotation sequence). Initially, the frames are aligned so <code class="docutils literal"><span class="pre">Di</span> <span class="pre">=</span> <span class="pre">Ci</span>
<span class="pre">=</span> <span class="pre">Bi</span> <span class="pre">=</span> <span class="pre">Ai</span> <span class="pre">(i</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> where Dx, Dy, Dz and Ax, Ay, Az are
orthogonal unit vectors fixed in frames D and A respectively.
Similarly for Bx, By, Bz and Cx, Cy, Cz in frame B, C. Then D is
subjected to successive right-handed rotations relative to A.</p>
</div>
<ul class="simple">
<li>1st rotation R_CD: Frame D rotates relative to frames C, B, A by a</li>
</ul>
<p>roll angle <code class="docutils literal"><span class="pre">r</span></code> about <code class="docutils literal"><span class="pre">Dx</span> <span class="pre">=</span> <span class="pre">Cx</span></code>.  Note: D and C are no longer aligned.</p>
<ul class="simple">
<li>2nd rotation R_BC: Frames D, C (collectively – as if welded together)</li>
</ul>
<p>rotate relative to frame B, A by a pitch angle <code class="docutils literal"><span class="pre">p</span></code> about <code class="docutils literal"><span class="pre">Cy</span> <span class="pre">=</span> <span class="pre">By</span></code>.
Note: C and B are no longer aligned.</p>
<ul class="simple">
<li>3rd rotation R_AB: Frames D, C, B (collectively – as if welded)</li>
</ul>
<p>rotate relative to frame A by a roll angle <code class="docutils literal"><span class="pre">y</span></code> about <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>.
Note: B and A are no longer aligned.
The monogram notation for the rotation matrix relating A to D is <code class="docutils literal"><span class="pre">R_AD</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">multibody_quantities for monogram notation for dynamics and
orientation_discussion “a discussion on rotation matrices”.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the frames associated with this rotation
sequence.</p>
</div>
<dl class="method">
<dt id="pydrake.math.RollPitchYaw_.RollPitchYaw_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RollPitchYaw_.RollPitchYaw_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.math.RollPitchYaw_[float], other: pydrake.math.RollPitchYaw_[float]) -&gt; None</li>
<li>__init__(self: pydrake.math.RollPitchYaw_[float], rpy: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RollPitchYaw from a 3x1 array of angles.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>3x1 array with roll, pitch, yaw angles (units of radians).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if !IsValid(rpy).</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.math.RollPitchYaw_[float], roll: float, pitch: float, yaw: float) -&gt; None</li>
</ol>
<p>Constructs a RollPitchYaw from roll, pitch, yaw angles (radian units).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">roll</span></code>:</dt>
<dd>x-directed angle in SpaceXYZ rotation sequence.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">pitch</span></code>:</dt>
<dd>y-directed angle in SpaceXYZ rotation sequence.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">yaw</span></code>:</dt>
<dd>z-directed angle in SpaceXYZ rotation sequence.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if !IsValid(Vector3&lt;T&gt;(roll, pitch,</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">yaw)).</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.math.RollPitchYaw_[float], R: pydrake.math.RotationMatrix_[float]) -&gt; None</li>
</ol>
<p>Uses a RotationMatrix to construct a RollPitchYaw with roll-pitch-yaw
angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>, <cite>-π/2 &lt;= p &lt;=
π/2</cite>, <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>a RotationMatrix.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.math.RollPitchYaw_[float], quaternion: Eigen::Quaternion&lt;double, 0&gt;) -&gt; None</li>
</ol>
<p>Uses a Quaternion to construct a RollPitchYaw with roll-pitch-yaw
angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>, <cite>-π/2 &lt;= p &lt;=
π/2</cite>, <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>unit Quaternion.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if !IsValid(rpy).</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="6">
<li>__init__(self: pydrake.math.RollPitchYaw_[float], matrix: numpy.ndarray[numpy.float64[3, 3]]) -&gt; None</li>
</ol>
<p>Construct from raw rotation matrix. See RotationMatrix overload for more information.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_.RollPitchYaw_[float].CalcAngularVelocityInChildFromRpyDt">
<code class="descname">CalcAngularVelocityInChildFromRpyDt</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float], rpyDt: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_.RollPitchYaw_[float].CalcAngularVelocityInChildFromRpyDt" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates angular velocity from <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose
roll-pitch-yaw angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> relate the orientation of two
generic frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>Time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">w_AD_D, frame D’s angular velocity in frame A, expressed in D.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_.RollPitchYaw_[float].CalcAngularVelocityInParentFromRpyDt">
<code class="descname">CalcAngularVelocityInParentFromRpyDt</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float], rpyDt: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_.RollPitchYaw_[float].CalcAngularVelocityInParentFromRpyDt" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates angular velocity from <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose
roll-pitch-yaw angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> relate the orientation of two
generic frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>Time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">w_AD_A, frame D’s angular velocity in frame A, expressed in A.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_.RollPitchYaw_[float].CalcRotationMatrixDt">
<code class="descname">CalcRotationMatrixDt</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float], rpyDt: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 3]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_.RollPitchYaw_[float].CalcRotationMatrixDt" title="Permalink to this definition">¶</a></dt>
<dd><p>Forms Ṙ, the ordinary derivative of the RotationMatrix <code class="docutils literal"><span class="pre">R</span></code> with
respect to an independent variable <code class="docutils literal"><span class="pre">t</span></code> (<cite>t</cite> usually denotes time)
and <code class="docutils literal"><span class="pre">R</span></code> is the RotationMatrix formed by <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw. The
roll-pitch-yaw angles r, p, y are regarded as functions of <code class="docutils literal"><span class="pre">t</span></code>
[i.e., r(t), p(t), y(t)].</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>Ordinary derivative of rpy with respect to an independent variable
<code class="docutils literal"><span class="pre">t</span></code> (<cite>t</cite> usually denotes time, but not necessarily).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Ṙ, the ordinary derivative of <code class="docutils literal"><span class="pre">R</span></code> with respect to <code class="docutils literal"><span class="pre">t</span></code>,
calculated as Ṙ = ∂R/∂r * ṙ + ∂R/∂p * ṗ + ∂R/∂y * ẏ. In other
words, the returned (i, j) element is ∂Rij/∂r * ṙ + ∂Rij/∂p * ṗ
+ ∂Rij/∂y * ẏ.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_.RollPitchYaw_[float].CalcRpyDDtFromAngularAccelInChild">
<code class="descname">CalcRpyDDtFromAngularAccelInChild</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float], rpyDt: numpy.ndarray[numpy.float64[3, 1]], alpha_AD_D: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_.RollPitchYaw_[float].CalcRpyDDtFromAngularAccelInChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
<code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic
frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">alpha_AD_D</span></code>:</dt>
<dd>, frame D’s angular acceleration in frame A, expressed in frame D.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">[r̈,</span> <span class="pre">p̈,</span> <span class="pre">ÿ]</span></code>, the 2ⁿᵈ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code> (<cite>p</cite> is near gimbal-lock).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_.RollPitchYaw_[float].CalcRpyDDtFromRpyDtAndAngularAccelInParent">
<code class="descname">CalcRpyDDtFromRpyDtAndAngularAccelInParent</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float], rpyDt: numpy.ndarray[numpy.float64[3, 1]], alpha_AD_A: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_.RollPitchYaw_[float].CalcRpyDDtFromRpyDtAndAngularAccelInParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
<code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic
frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">alpha_AD_A</span></code>:</dt>
<dd>, frame D’s angular acceleration in frame A, expressed in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">[r̈,</span> <span class="pre">p̈,</span> <span class="pre">ÿ]</span></code>, the 2ⁿᵈ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code> (<cite>p</cite> is near gimbal-lock).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_.RollPitchYaw_[float].CalcRpyDtFromAngularVelocityInParent">
<code class="descname">CalcRpyDtFromAngularVelocityInParent</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float], w_AD_A: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_.RollPitchYaw_[float].CalcRpyDtFromAngularVelocityInParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses angular velocity to compute the 1ˢᵗ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw whose angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic frames A
and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">w_AD_A</span></code>:</dt>
<dd>, frame D’s angular velocity in frame A, expressed in A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>, the 1ˢᵗ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code> (<cite>p</cite> is near gimbal-lock).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_.RollPitchYaw_[float].pitch_angle">
<code class="descname">pitch_angle</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.math.RollPitchYaw_.RollPitchYaw_[float].pitch_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pitch-angle underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_.RollPitchYaw_[float].roll_angle">
<code class="descname">roll_angle</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.math.RollPitchYaw_.RollPitchYaw_[float].roll_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the roll-angle underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_.RollPitchYaw_[float].ToQuaternion">
<code class="descname">ToQuaternion</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; Eigen::Quaternion&lt;double, 0&gt;<a class="headerlink" href="#pydrake.math.RollPitchYaw_.RollPitchYaw_[float].ToQuaternion" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a quaternion representation of <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_.RollPitchYaw_[float].ToRotationMatrix">
<code class="descname">ToRotationMatrix</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RollPitchYaw_.RollPitchYaw_[float].ToRotationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RotationMatrix representation of <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_.RollPitchYaw_[float].vector">
<code class="descname">vector</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_.RollPitchYaw_[float].vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Vector3 underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_.RollPitchYaw_[float].yaw_angle">
<code class="descname">yaw_angle</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.math.RollPitchYaw_.RollPitchYaw_[float].yaw_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the yaw-angle underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.math.RollPitchYaw_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.math.</code><code class="descname">RollPitchYaw_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.math.RollPitchYaw_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents the orientation between two arbitrary frames A
and D associated with a Space-fixed (extrinsic) X-Y-Z rotation by
“roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code>, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by “yaw-pitch-roll” angles <code class="docutils literal"><span class="pre">[y,</span>
<span class="pre">p,</span> <span class="pre">r]</span></code>. The rotation matrix <code class="docutils literal"><span class="pre">R_AD</span></code> associated with this
roll-pitch-yaw <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> rotation sequence is equal to the matrix
multiplication shown below.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
       ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
     =       R_AB          *        R_BC          *        R_CD
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this discussion, A is the Space frame and D is the Body frame.
One way to visualize this rotation sequence is by introducing
intermediate frames B and C (useful constructs to understand this
rotation sequence). Initially, the frames are aligned so <code class="docutils literal"><span class="pre">Di</span> <span class="pre">=</span> <span class="pre">Ci</span>
<span class="pre">=</span> <span class="pre">Bi</span> <span class="pre">=</span> <span class="pre">Ai</span> <span class="pre">(i</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> where Dx, Dy, Dz and Ax, Ay, Az are
orthogonal unit vectors fixed in frames D and A respectively.
Similarly for Bx, By, Bz and Cx, Cy, Cz in frame B, C. Then D is
subjected to successive right-handed rotations relative to A.</p>
</div>
<ul class="simple">
<li>1st rotation R_CD: Frame D rotates relative to frames C, B, A by a</li>
</ul>
<p>roll angle <code class="docutils literal"><span class="pre">r</span></code> about <code class="docutils literal"><span class="pre">Dx</span> <span class="pre">=</span> <span class="pre">Cx</span></code>.  Note: D and C are no longer aligned.</p>
<ul class="simple">
<li>2nd rotation R_BC: Frames D, C (collectively – as if welded together)</li>
</ul>
<p>rotate relative to frame B, A by a pitch angle <code class="docutils literal"><span class="pre">p</span></code> about <code class="docutils literal"><span class="pre">Cy</span> <span class="pre">=</span> <span class="pre">By</span></code>.
Note: C and B are no longer aligned.</p>
<ul class="simple">
<li>3rd rotation R_AB: Frames D, C, B (collectively – as if welded)</li>
</ul>
<p>rotate relative to frame A by a roll angle <code class="docutils literal"><span class="pre">y</span></code> about <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>.
Note: B and A are no longer aligned.
The monogram notation for the rotation matrix relating A to D is <code class="docutils literal"><span class="pre">R_AD</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">multibody_quantities for monogram notation for dynamics and
orientation_discussion “a discussion on rotation matrices”.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the frames associated with this rotation
sequence.</p>
</div>
<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RollPitchYaw_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.math.RollPitchYaw_[AutoDiffXd], other: pydrake.math.RollPitchYaw_[AutoDiffXd]) -&gt; None</li>
<li>__init__(self: pydrake.math.RollPitchYaw_[AutoDiffXd], rpy: numpy.ndarray[object[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RollPitchYaw from a 3x1 array of angles.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>3x1 array with roll, pitch, yaw angles (units of radians).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if !IsValid(rpy).</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.math.RollPitchYaw_[AutoDiffXd], roll: pydrake.autodiffutils.AutoDiffXd, pitch: pydrake.autodiffutils.AutoDiffXd, yaw: pydrake.autodiffutils.AutoDiffXd) -&gt; None</li>
</ol>
<p>Constructs a RollPitchYaw from roll, pitch, yaw angles (radian units).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">roll</span></code>:</dt>
<dd>x-directed angle in SpaceXYZ rotation sequence.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">pitch</span></code>:</dt>
<dd>y-directed angle in SpaceXYZ rotation sequence.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">yaw</span></code>:</dt>
<dd>z-directed angle in SpaceXYZ rotation sequence.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if !IsValid(Vector3&lt;T&gt;(roll, pitch,</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">yaw)).</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.math.RollPitchYaw_[AutoDiffXd], R: pydrake.math.RotationMatrix_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Uses a RotationMatrix to construct a RollPitchYaw with roll-pitch-yaw
angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>, <cite>-π/2 &lt;= p &lt;=
π/2</cite>, <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>a RotationMatrix.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.math.RollPitchYaw_[AutoDiffXd], quaternion: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Uses a Quaternion to construct a RollPitchYaw with roll-pitch-yaw
angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>, <cite>-π/2 &lt;= p &lt;=
π/2</cite>, <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>unit Quaternion.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if !IsValid(rpy).</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="6">
<li>__init__(self: pydrake.math.RollPitchYaw_[AutoDiffXd], matrix: numpy.ndarray[object[3, 3]]) -&gt; None</li>
</ol>
<p>Construct from raw rotation matrix. See RotationMatrix overload for more information.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[AutoDiffXd].CalcAngularVelocityInChildFromRpyDt">
<code class="descname">CalcAngularVelocityInChildFromRpyDt</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[AutoDiffXd], rpyDt: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[AutoDiffXd].CalcAngularVelocityInChildFromRpyDt" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates angular velocity from <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose
roll-pitch-yaw angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> relate the orientation of two
generic frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>Time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">w_AD_D, frame D’s angular velocity in frame A, expressed in D.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[AutoDiffXd].CalcAngularVelocityInParentFromRpyDt">
<code class="descname">CalcAngularVelocityInParentFromRpyDt</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[AutoDiffXd], rpyDt: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[AutoDiffXd].CalcAngularVelocityInParentFromRpyDt" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates angular velocity from <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose
roll-pitch-yaw angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> relate the orientation of two
generic frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>Time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">w_AD_A, frame D’s angular velocity in frame A, expressed in A.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[AutoDiffXd].CalcRotationMatrixDt">
<code class="descname">CalcRotationMatrixDt</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[AutoDiffXd], rpyDt: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 3]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[AutoDiffXd].CalcRotationMatrixDt" title="Permalink to this definition">¶</a></dt>
<dd><p>Forms Ṙ, the ordinary derivative of the RotationMatrix <code class="docutils literal"><span class="pre">R</span></code> with
respect to an independent variable <code class="docutils literal"><span class="pre">t</span></code> (<cite>t</cite> usually denotes time)
and <code class="docutils literal"><span class="pre">R</span></code> is the RotationMatrix formed by <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw. The
roll-pitch-yaw angles r, p, y are regarded as functions of <code class="docutils literal"><span class="pre">t</span></code>
[i.e., r(t), p(t), y(t)].</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>Ordinary derivative of rpy with respect to an independent variable
<code class="docutils literal"><span class="pre">t</span></code> (<cite>t</cite> usually denotes time, but not necessarily).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Ṙ, the ordinary derivative of <code class="docutils literal"><span class="pre">R</span></code> with respect to <code class="docutils literal"><span class="pre">t</span></code>,
calculated as Ṙ = ∂R/∂r * ṙ + ∂R/∂p * ṗ + ∂R/∂y * ẏ. In other
words, the returned (i, j) element is ∂Rij/∂r * ṙ + ∂Rij/∂p * ṗ
+ ∂Rij/∂y * ẏ.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[AutoDiffXd].CalcRpyDDtFromAngularAccelInChild">
<code class="descname">CalcRpyDDtFromAngularAccelInChild</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[AutoDiffXd], rpyDt: numpy.ndarray[object[3, 1]], alpha_AD_D: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[AutoDiffXd].CalcRpyDDtFromAngularAccelInChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
<code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic
frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">alpha_AD_D</span></code>:</dt>
<dd>, frame D’s angular acceleration in frame A, expressed in frame D.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">[r̈,</span> <span class="pre">p̈,</span> <span class="pre">ÿ]</span></code>, the 2ⁿᵈ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code> (<cite>p</cite> is near gimbal-lock).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[AutoDiffXd].CalcRpyDDtFromRpyDtAndAngularAccelInParent">
<code class="descname">CalcRpyDDtFromRpyDtAndAngularAccelInParent</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[AutoDiffXd], rpyDt: numpy.ndarray[object[3, 1]], alpha_AD_A: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[AutoDiffXd].CalcRpyDDtFromRpyDtAndAngularAccelInParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
<code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic
frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">alpha_AD_A</span></code>:</dt>
<dd>, frame D’s angular acceleration in frame A, expressed in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">[r̈,</span> <span class="pre">p̈,</span> <span class="pre">ÿ]</span></code>, the 2ⁿᵈ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code> (<cite>p</cite> is near gimbal-lock).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[AutoDiffXd].CalcRpyDtFromAngularVelocityInParent">
<code class="descname">CalcRpyDtFromAngularVelocityInParent</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[AutoDiffXd], w_AD_A: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[AutoDiffXd].CalcRpyDtFromAngularVelocityInParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses angular velocity to compute the 1ˢᵗ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw whose angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic frames A
and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">w_AD_A</span></code>:</dt>
<dd>, frame D’s angular velocity in frame A, expressed in A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>, the 1ˢᵗ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code> (<cite>p</cite> is near gimbal-lock).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[AutoDiffXd].pitch_angle">
<code class="descname">pitch_angle</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.math.RollPitchYaw_[AutoDiffXd].pitch_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pitch-angle underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[AutoDiffXd].roll_angle">
<code class="descname">roll_angle</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.math.RollPitchYaw_[AutoDiffXd].roll_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the roll-angle underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[AutoDiffXd].ToQuaternion">
<code class="descname">ToQuaternion</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[AutoDiffXd].ToQuaternion" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a quaternion representation of <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[AutoDiffXd].ToRotationMatrix">
<code class="descname">ToRotationMatrix</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[AutoDiffXd].ToRotationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RotationMatrix representation of <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[AutoDiffXd].vector">
<code class="descname">vector</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[AutoDiffXd].vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Vector3 underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[AutoDiffXd].yaw_angle">
<code class="descname">yaw_angle</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.math.RollPitchYaw_[AutoDiffXd].yaw_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the yaw-angle underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.math.RollPitchYaw_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.math.</code><code class="descname">RollPitchYaw_[Expression]</code><a class="headerlink" href="#pydrake.math.RollPitchYaw_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents the orientation between two arbitrary frames A
and D associated with a Space-fixed (extrinsic) X-Y-Z rotation by
“roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code>, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by “yaw-pitch-roll” angles <code class="docutils literal"><span class="pre">[y,</span>
<span class="pre">p,</span> <span class="pre">r]</span></code>. The rotation matrix <code class="docutils literal"><span class="pre">R_AD</span></code> associated with this
roll-pitch-yaw <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> rotation sequence is equal to the matrix
multiplication shown below.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
       ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
     =       R_AB          *        R_BC          *        R_CD
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this discussion, A is the Space frame and D is the Body frame.
One way to visualize this rotation sequence is by introducing
intermediate frames B and C (useful constructs to understand this
rotation sequence). Initially, the frames are aligned so <code class="docutils literal"><span class="pre">Di</span> <span class="pre">=</span> <span class="pre">Ci</span>
<span class="pre">=</span> <span class="pre">Bi</span> <span class="pre">=</span> <span class="pre">Ai</span> <span class="pre">(i</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> where Dx, Dy, Dz and Ax, Ay, Az are
orthogonal unit vectors fixed in frames D and A respectively.
Similarly for Bx, By, Bz and Cx, Cy, Cz in frame B, C. Then D is
subjected to successive right-handed rotations relative to A.</p>
</div>
<ul class="simple">
<li>1st rotation R_CD: Frame D rotates relative to frames C, B, A by a</li>
</ul>
<p>roll angle <code class="docutils literal"><span class="pre">r</span></code> about <code class="docutils literal"><span class="pre">Dx</span> <span class="pre">=</span> <span class="pre">Cx</span></code>.  Note: D and C are no longer aligned.</p>
<ul class="simple">
<li>2nd rotation R_BC: Frames D, C (collectively – as if welded together)</li>
</ul>
<p>rotate relative to frame B, A by a pitch angle <code class="docutils literal"><span class="pre">p</span></code> about <code class="docutils literal"><span class="pre">Cy</span> <span class="pre">=</span> <span class="pre">By</span></code>.
Note: C and B are no longer aligned.</p>
<ul class="simple">
<li>3rd rotation R_AB: Frames D, C, B (collectively – as if welded)</li>
</ul>
<p>rotate relative to frame A by a roll angle <code class="docutils literal"><span class="pre">y</span></code> about <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>.
Note: B and A are no longer aligned.
The monogram notation for the rotation matrix relating A to D is <code class="docutils literal"><span class="pre">R_AD</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">multibody_quantities for monogram notation for dynamics and
orientation_discussion “a discussion on rotation matrices”.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the frames associated with this rotation
sequence.</p>
</div>
<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RollPitchYaw_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.math.RollPitchYaw_[Expression], other: pydrake.math.RollPitchYaw_[Expression]) -&gt; None</li>
<li>__init__(self: pydrake.math.RollPitchYaw_[Expression], rpy: numpy.ndarray[object[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RollPitchYaw from a 3x1 array of angles.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>3x1 array with roll, pitch, yaw angles (units of radians).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if !IsValid(rpy).</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.math.RollPitchYaw_[Expression], roll: pydrake.symbolic.Expression, pitch: pydrake.symbolic.Expression, yaw: pydrake.symbolic.Expression) -&gt; None</li>
</ol>
<p>Constructs a RollPitchYaw from roll, pitch, yaw angles (radian units).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">roll</span></code>:</dt>
<dd>x-directed angle in SpaceXYZ rotation sequence.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">pitch</span></code>:</dt>
<dd>y-directed angle in SpaceXYZ rotation sequence.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">yaw</span></code>:</dt>
<dd>z-directed angle in SpaceXYZ rotation sequence.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if !IsValid(Vector3&lt;T&gt;(roll, pitch,</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">yaw)).</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.math.RollPitchYaw_[Expression], R: pydrake.math.RotationMatrix_[Expression]) -&gt; None</li>
</ol>
<p>Uses a RotationMatrix to construct a RollPitchYaw with roll-pitch-yaw
angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>, <cite>-π/2 &lt;= p &lt;=
π/2</cite>, <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>a RotationMatrix.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.math.RollPitchYaw_[Expression], quaternion: pydrake.common.eigen_geometry.Quaternion_[Expression]) -&gt; None</li>
</ol>
<p>Uses a Quaternion to construct a RollPitchYaw with roll-pitch-yaw
angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>, <cite>-π/2 &lt;= p &lt;=
π/2</cite>, <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>unit Quaternion.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if !IsValid(rpy).</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="6">
<li>__init__(self: pydrake.math.RollPitchYaw_[Expression], matrix: numpy.ndarray[object[3, 3]]) -&gt; None</li>
</ol>
<p>Construct from raw rotation matrix. See RotationMatrix overload for more information.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[Expression].CalcAngularVelocityInChildFromRpyDt">
<code class="descname">CalcAngularVelocityInChildFromRpyDt</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[Expression], rpyDt: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[Expression].CalcAngularVelocityInChildFromRpyDt" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates angular velocity from <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose
roll-pitch-yaw angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> relate the orientation of two
generic frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>Time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">w_AD_D, frame D’s angular velocity in frame A, expressed in D.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[Expression].CalcAngularVelocityInParentFromRpyDt">
<code class="descname">CalcAngularVelocityInParentFromRpyDt</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[Expression], rpyDt: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[Expression].CalcAngularVelocityInParentFromRpyDt" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates angular velocity from <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose
roll-pitch-yaw angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> relate the orientation of two
generic frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>Time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">w_AD_A, frame D’s angular velocity in frame A, expressed in A.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[Expression].CalcRotationMatrixDt">
<code class="descname">CalcRotationMatrixDt</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[Expression], rpyDt: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 3]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[Expression].CalcRotationMatrixDt" title="Permalink to this definition">¶</a></dt>
<dd><p>Forms Ṙ, the ordinary derivative of the RotationMatrix <code class="docutils literal"><span class="pre">R</span></code> with
respect to an independent variable <code class="docutils literal"><span class="pre">t</span></code> (<cite>t</cite> usually denotes time)
and <code class="docutils literal"><span class="pre">R</span></code> is the RotationMatrix formed by <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw. The
roll-pitch-yaw angles r, p, y are regarded as functions of <code class="docutils literal"><span class="pre">t</span></code>
[i.e., r(t), p(t), y(t)].</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>Ordinary derivative of rpy with respect to an independent variable
<code class="docutils literal"><span class="pre">t</span></code> (<cite>t</cite> usually denotes time, but not necessarily).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Ṙ, the ordinary derivative of <code class="docutils literal"><span class="pre">R</span></code> with respect to <code class="docutils literal"><span class="pre">t</span></code>,
calculated as Ṙ = ∂R/∂r * ṙ + ∂R/∂p * ṗ + ∂R/∂y * ẏ. In other
words, the returned (i, j) element is ∂Rij/∂r * ṙ + ∂Rij/∂p * ṗ
+ ∂Rij/∂y * ẏ.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[Expression].CalcRpyDDtFromAngularAccelInChild">
<code class="descname">CalcRpyDDtFromAngularAccelInChild</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[Expression], rpyDt: numpy.ndarray[object[3, 1]], alpha_AD_D: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[Expression].CalcRpyDDtFromAngularAccelInChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
<code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic
frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">alpha_AD_D</span></code>:</dt>
<dd>, frame D’s angular acceleration in frame A, expressed in frame D.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">[r̈,</span> <span class="pre">p̈,</span> <span class="pre">ÿ]</span></code>, the 2ⁿᵈ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code> (<cite>p</cite> is near gimbal-lock).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[Expression].CalcRpyDDtFromRpyDtAndAngularAccelInParent">
<code class="descname">CalcRpyDDtFromRpyDtAndAngularAccelInParent</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[Expression], rpyDt: numpy.ndarray[object[3, 1]], alpha_AD_A: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[Expression].CalcRpyDDtFromRpyDtAndAngularAccelInParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
<code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic
frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">alpha_AD_A</span></code>:</dt>
<dd>, frame D’s angular acceleration in frame A, expressed in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">[r̈,</span> <span class="pre">p̈,</span> <span class="pre">ÿ]</span></code>, the 2ⁿᵈ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code> (<cite>p</cite> is near gimbal-lock).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[Expression].CalcRpyDtFromAngularVelocityInParent">
<code class="descname">CalcRpyDtFromAngularVelocityInParent</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[Expression], w_AD_A: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[Expression].CalcRpyDtFromAngularVelocityInParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses angular velocity to compute the 1ˢᵗ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw whose angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic frames A
and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">w_AD_A</span></code>:</dt>
<dd>, frame D’s angular velocity in frame A, expressed in A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>, the 1ˢᵗ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code> (<cite>p</cite> is near gimbal-lock).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[Expression].pitch_angle">
<code class="descname">pitch_angle</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.math.RollPitchYaw_[Expression].pitch_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pitch-angle underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[Expression].roll_angle">
<code class="descname">roll_angle</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.math.RollPitchYaw_[Expression].roll_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the roll-angle underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[Expression].ToQuaternion">
<code class="descname">ToQuaternion</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.common.eigen_geometry.Quaternion_[Expression]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[Expression].ToQuaternion" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a quaternion representation of <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[Expression].ToRotationMatrix">
<code class="descname">ToRotationMatrix</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[Expression].ToRotationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RotationMatrix representation of <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[Expression].vector">
<code class="descname">vector</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[Expression].vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Vector3 underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[Expression].yaw_angle">
<code class="descname">yaw_angle</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.math.RollPitchYaw_[Expression].yaw_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the yaw-angle underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.math.RollPitchYaw_[float]">
<em class="property">class </em><code class="descclassname">pydrake.math.</code><code class="descname">RollPitchYaw_[float]</code><a class="headerlink" href="#pydrake.math.RollPitchYaw_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents the orientation between two arbitrary frames A
and D associated with a Space-fixed (extrinsic) X-Y-Z rotation by
“roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code>, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by “yaw-pitch-roll” angles <code class="docutils literal"><span class="pre">[y,</span>
<span class="pre">p,</span> <span class="pre">r]</span></code>. The rotation matrix <code class="docutils literal"><span class="pre">R_AD</span></code> associated with this
roll-pitch-yaw <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> rotation sequence is equal to the matrix
multiplication shown below.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
       ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
     =       R_AB          *        R_BC          *        R_CD
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this discussion, A is the Space frame and D is the Body frame.
One way to visualize this rotation sequence is by introducing
intermediate frames B and C (useful constructs to understand this
rotation sequence). Initially, the frames are aligned so <code class="docutils literal"><span class="pre">Di</span> <span class="pre">=</span> <span class="pre">Ci</span>
<span class="pre">=</span> <span class="pre">Bi</span> <span class="pre">=</span> <span class="pre">Ai</span> <span class="pre">(i</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> where Dx, Dy, Dz and Ax, Ay, Az are
orthogonal unit vectors fixed in frames D and A respectively.
Similarly for Bx, By, Bz and Cx, Cy, Cz in frame B, C. Then D is
subjected to successive right-handed rotations relative to A.</p>
</div>
<ul class="simple">
<li>1st rotation R_CD: Frame D rotates relative to frames C, B, A by a</li>
</ul>
<p>roll angle <code class="docutils literal"><span class="pre">r</span></code> about <code class="docutils literal"><span class="pre">Dx</span> <span class="pre">=</span> <span class="pre">Cx</span></code>.  Note: D and C are no longer aligned.</p>
<ul class="simple">
<li>2nd rotation R_BC: Frames D, C (collectively – as if welded together)</li>
</ul>
<p>rotate relative to frame B, A by a pitch angle <code class="docutils literal"><span class="pre">p</span></code> about <code class="docutils literal"><span class="pre">Cy</span> <span class="pre">=</span> <span class="pre">By</span></code>.
Note: C and B are no longer aligned.</p>
<ul class="simple">
<li>3rd rotation R_AB: Frames D, C, B (collectively – as if welded)</li>
</ul>
<p>rotate relative to frame A by a roll angle <code class="docutils literal"><span class="pre">y</span></code> about <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>.
Note: B and A are no longer aligned.
The monogram notation for the rotation matrix relating A to D is <code class="docutils literal"><span class="pre">R_AD</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">multibody_quantities for monogram notation for dynamics and
orientation_discussion “a discussion on rotation matrices”.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the frames associated with this rotation
sequence.</p>
</div>
<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RollPitchYaw_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.math.RollPitchYaw_[float], other: pydrake.math.RollPitchYaw_[float]) -&gt; None</li>
<li>__init__(self: pydrake.math.RollPitchYaw_[float], rpy: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a RollPitchYaw from a 3x1 array of angles.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>3x1 array with roll, pitch, yaw angles (units of radians).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if !IsValid(rpy).</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.math.RollPitchYaw_[float], roll: float, pitch: float, yaw: float) -&gt; None</li>
</ol>
<p>Constructs a RollPitchYaw from roll, pitch, yaw angles (radian units).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">roll</span></code>:</dt>
<dd>x-directed angle in SpaceXYZ rotation sequence.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">pitch</span></code>:</dt>
<dd>y-directed angle in SpaceXYZ rotation sequence.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">yaw</span></code>:</dt>
<dd>z-directed angle in SpaceXYZ rotation sequence.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if !IsValid(Vector3&lt;T&gt;(roll, pitch,</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">yaw)).</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.math.RollPitchYaw_[float], R: pydrake.math.RotationMatrix_[float]) -&gt; None</li>
</ol>
<p>Uses a RotationMatrix to construct a RollPitchYaw with roll-pitch-yaw
angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>, <cite>-π/2 &lt;= p &lt;=
π/2</cite>, <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>a RotationMatrix.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.math.RollPitchYaw_[float], quaternion: Eigen::Quaternion&lt;double, 0&gt;) -&gt; None</li>
</ol>
<p>Uses a Quaternion to construct a RollPitchYaw with roll-pitch-yaw
angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>, <cite>-π/2 &lt;= p &lt;=
π/2</cite>, <code class="docutils literal"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>unit Quaternion.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if !IsValid(rpy).</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="6">
<li>__init__(self: pydrake.math.RollPitchYaw_[float], matrix: numpy.ndarray[numpy.float64[3, 3]]) -&gt; None</li>
</ol>
<p>Construct from raw rotation matrix. See RotationMatrix overload for more information.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[float].CalcAngularVelocityInChildFromRpyDt">
<code class="descname">CalcAngularVelocityInChildFromRpyDt</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float], rpyDt: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[float].CalcAngularVelocityInChildFromRpyDt" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates angular velocity from <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose
roll-pitch-yaw angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> relate the orientation of two
generic frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>Time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">w_AD_D, frame D’s angular velocity in frame A, expressed in D.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[float].CalcAngularVelocityInParentFromRpyDt">
<code class="descname">CalcAngularVelocityInParentFromRpyDt</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float], rpyDt: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[float].CalcAngularVelocityInParentFromRpyDt" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates angular velocity from <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose
roll-pitch-yaw angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> relate the orientation of two
generic frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>Time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">w_AD_A, frame D’s angular velocity in frame A, expressed in A.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[float].CalcRotationMatrixDt">
<code class="descname">CalcRotationMatrixDt</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float], rpyDt: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 3]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[float].CalcRotationMatrixDt" title="Permalink to this definition">¶</a></dt>
<dd><p>Forms Ṙ, the ordinary derivative of the RotationMatrix <code class="docutils literal"><span class="pre">R</span></code> with
respect to an independent variable <code class="docutils literal"><span class="pre">t</span></code> (<cite>t</cite> usually denotes time)
and <code class="docutils literal"><span class="pre">R</span></code> is the RotationMatrix formed by <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw. The
roll-pitch-yaw angles r, p, y are regarded as functions of <code class="docutils literal"><span class="pre">t</span></code>
[i.e., r(t), p(t), y(t)].</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>Ordinary derivative of rpy with respect to an independent variable
<code class="docutils literal"><span class="pre">t</span></code> (<cite>t</cite> usually denotes time, but not necessarily).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Ṙ, the ordinary derivative of <code class="docutils literal"><span class="pre">R</span></code> with respect to <code class="docutils literal"><span class="pre">t</span></code>,
calculated as Ṙ = ∂R/∂r * ṙ + ∂R/∂p * ṗ + ∂R/∂y * ẏ. In other
words, the returned (i, j) element is ∂Rij/∂r * ṙ + ∂Rij/∂p * ṗ
+ ∂Rij/∂y * ẏ.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[float].CalcRpyDDtFromAngularAccelInChild">
<code class="descname">CalcRpyDDtFromAngularAccelInChild</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float], rpyDt: numpy.ndarray[numpy.float64[3, 1]], alpha_AD_D: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[float].CalcRpyDDtFromAngularAccelInChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
<code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic
frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">alpha_AD_D</span></code>:</dt>
<dd>, frame D’s angular acceleration in frame A, expressed in frame D.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">[r̈,</span> <span class="pre">p̈,</span> <span class="pre">ÿ]</span></code>, the 2ⁿᵈ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code> (<cite>p</cite> is near gimbal-lock).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[float].CalcRpyDDtFromRpyDtAndAngularAccelInParent">
<code class="descname">CalcRpyDDtFromRpyDtAndAngularAccelInParent</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float], rpyDt: numpy.ndarray[numpy.float64[3, 1]], alpha_AD_A: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[float].CalcRpyDDtFromRpyDtAndAngularAccelInParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
<code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw whose angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic
frames A and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpyDt</span></code>:</dt>
<dd>time-derivative of <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">alpha_AD_A</span></code>:</dt>
<dd>, frame D’s angular acceleration in frame A, expressed in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">[r̈,</span> <span class="pre">p̈,</span> <span class="pre">ÿ]</span></code>, the 2ⁿᵈ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code> (<cite>p</cite> is near gimbal-lock).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[float].CalcRpyDtFromAngularVelocityInParent">
<code class="descname">CalcRpyDtFromAngularVelocityInParent</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float], w_AD_A: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[float].CalcRpyDtFromAngularVelocityInParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses angular velocity to compute the 1ˢᵗ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw whose angles <code class="docutils literal"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic frames A
and D.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">w_AD_A</span></code>:</dt>
<dd>, frame D’s angular velocity in frame A, expressed in A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>, the 1ˢᵗ time-derivative of <code class="docutils literal"><span class="pre">this</span></code>
RollPitchYaw.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code> (<cite>p</cite> is near gimbal-lock).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[float].pitch_angle">
<code class="descname">pitch_angle</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.math.RollPitchYaw_[float].pitch_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pitch-angle underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[float].roll_angle">
<code class="descname">roll_angle</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.math.RollPitchYaw_[float].roll_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the roll-angle underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[float].ToQuaternion">
<code class="descname">ToQuaternion</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; Eigen::Quaternion&lt;double, 0&gt;<a class="headerlink" href="#pydrake.math.RollPitchYaw_[float].ToQuaternion" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a quaternion representation of <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[float].ToRotationMatrix">
<code class="descname">ToRotationMatrix</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[float].ToRotationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the RotationMatrix representation of <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[float].vector">
<code class="descname">vector</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RollPitchYaw_[float].vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Vector3 underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RollPitchYaw_[float].yaw_angle">
<code class="descname">yaw_angle</code><span class="sig-paren">(</span><em>self: pydrake.math.RollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.math.RollPitchYaw_[float].yaw_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the yaw-angle underlying <code class="docutils literal"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.math.RotationMatrix">
<code class="descclassname">pydrake.math.</code><code class="descname">RotationMatrix</code><a class="headerlink" href="#pydrake.math.RotationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.math.RotationMatrix_[float]" title="pydrake.math.RotationMatrix_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.math.RotationMatrix_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.math.RotationMatrix_">
<em class="property">template </em><code class="descclassname">pydrake.math.</code><code class="descname">RotationMatrix_</code><a class="headerlink" href="#pydrake.math.RotationMatrix_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.math.RotationMatrix_[float]" title="pydrake.math.RotationMatrix_[float]"><code class="xref py py-class docutils literal"><span class="pre">RotationMatrix_[float]</span></code></a>, <a class="reference internal" href="#pydrake.math.RotationMatrix_[AutoDiffXd]" title="pydrake.math.RotationMatrix_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">RotationMatrix_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.math.RotationMatrix_[Expression]" title="pydrake.math.RotationMatrix_[Expression]"><code class="xref py py-class docutils literal"><span class="pre">RotationMatrix_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float]">
<em class="property">class </em><code class="descname">RotationMatrix_[float]</code><a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a 3x3 rotation matrix between two arbitrary
frames A and B and helps ensure users create valid rotation matrices.
This class relates right-handed orthogonal unit vectors Ax, Ay, Az
fixed in frame A to right-handed orthogonal unit vectors Bx, By, Bz
fixed in frame B. The monogram notation for the rotation matrix
relating A to B is <code class="docutils literal"><span class="pre">R_AB</span></code>. An example that gives context to this
rotation matrix is <code class="docutils literal"><span class="pre">v_A</span> <span class="pre">=</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">v_B</span></code>, where <code class="docutils literal"><span class="pre">v_B</span></code> denotes an
arbitrary vector v expressed in terms of Bx, By, Bz and <code class="docutils literal"><span class="pre">v_A</span></code>
denotes vector v expressed in terms of Ax, Ay, Az. See
multibody_quantities for monogram notation for dynamics. See
orientation_discussion “a discussion on rotation matrices”.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the frames associated with a rotation
matrix nor does it enforce strict proper usage of this class with
vectors.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When assertions are enabled, several methods in this class do a
validity check and throw an exception (RuntimeError) if the
rotation matrix is invalid. When assertions are disabled, many of
these validity checks are skipped (which helps improve speed). In
addition, these validity tests are only performed for scalar types
for which drake::scalar_predicate&lt;T&gt;::is_bool is <code class="docutils literal"><span class="pre">True</span></code>. For
instance, validity checks are not performed when T is
symbolic::Expression.</p>
</div>
<dl class="docutils">
<dt>Authors:</dt>
<dd>Paul Mitiguy (2018) Original author.</dd>
<dt>Authors:</dt>
<dd>Drake team (see <a class="reference external" href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</dd>
</dl>
<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.math.RotationMatrix_[float]) -&gt; None</li>
</ol>
<p>Constructs a 3x3 identity RotationMatrix – which corresponds to
aligning two frames (so that unit vectors Ax = Bx, Ay = By, Az = Bz).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.math.RotationMatrix_[float], other: pydrake.math.RotationMatrix_[float]) -&gt; None</li>
<li>__init__(self: pydrake.math.RotationMatrix_[float], R: numpy.ndarray[numpy.float64[3, 3]]) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from a Matrix3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>an allegedly valid rotation matrix.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if R fails IsValid(R).</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.math.RotationMatrix_[float], quaternion: Eigen::Quaternion&lt;double, 0&gt;) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from an Eigen::Quaternion.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>a non-zero, finite quaternion which may or may not have unit
length [i.e., <code class="docutils literal"><span class="pre">quaternion.norm()</span></code> does not have to be 1].</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix R that is</li>
<li>built from <code class="docutils literal"><span class="pre">quaternion</span></code> fails IsValid(R). For example, an</li>
<li>exception is thrown if <code class="docutils literal"><span class="pre">quaternion</span></code> is zero or contains a NaN or</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">infinity.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has the effect of normalizing its <code class="docutils literal"><span class="pre">quaternion</span></code>
argument, without the inefficiency of the square-root associated
with normalization.</p>
</div>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.math.RotationMatrix_[float], theta_lambda: Eigen::AngleAxis&lt;double&gt;) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from an Eigen::AngleAxis.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta_lambda</span></code>:</dt>
<dd>an Eigen::AngleAxis whose associated axis (vector direction herein
called <code class="docutils literal"><span class="pre">lambda</span></code>) is non-zero and finite, but which may or may
not have unit length [i.e., <code class="docutils literal"><span class="pre">lambda.norm()</span></code> does not have to be
1].</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix R that is</li>
<li>built from <code class="docutils literal"><span class="pre">theta_lambda</span></code> fails IsValid(R). For example, an</li>
<li>exception is thrown if <code class="docutils literal"><span class="pre">lambda</span></code> is zero or contains a NaN or</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">infinity.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="6">
<li>__init__(self: pydrake.math.RotationMatrix_[float], rpy: drake::math::RollPitchYaw&lt;double&gt;) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from an RollPitchYaw. In other words,
makes the RotationMatrix for a Space-fixed (extrinsic) X-Y-Z rotation
by “roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code>, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by “yaw-pitch-roll” angles <code class="docutils literal"><span class="pre">[y,</span>
<span class="pre">p,</span> <span class="pre">r]</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>radian measures of three angles [roll, pitch, yaw].</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
with “roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> or equivalently a Body-
fixed (intrinsic) Z-Y-X rotation with “yaw-pitch-roll” angles
<code class="docutils literal"><span class="pre">[y,</span> <span class="pre">p,</span> <span class="pre">r]</span></code>.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Denoting roll <code class="docutils literal"><span class="pre">r</span></code>, pitch <code class="docutils literal"><span class="pre">p</span></code>, yaw <code class="docutils literal"><span class="pre">y</span></code>, this method returns a
rotation matrix <code class="docutils literal"><span class="pre">R_AD</span></code> equal to the matrix multiplication shown
below.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
       ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
     =       R_AB          *        R_BC          *        R_CD
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this discussion, A is the Space frame and D is the Body frame.
One way to visualize this rotation sequence is by introducing
intermediate frames B and C (useful constructs to understand this
rotation sequence). Initially, the frames are aligned so <code class="docutils literal"><span class="pre">Di</span> <span class="pre">=</span> <span class="pre">Ci</span>
<span class="pre">=</span> <span class="pre">Bi</span> <span class="pre">=</span> <span class="pre">Ai</span> <span class="pre">(i</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>. Then D is subjected to successive
right-handed rotations relative to A.</p>
</div>
<ul class="simple">
<li>1st rotation R_CD: Frame D rotates relative to frames C, B, A by a</li>
</ul>
<p>roll angle <code class="docutils literal"><span class="pre">r</span></code> about <code class="docutils literal"><span class="pre">Dx</span> <span class="pre">=</span> <span class="pre">Cx</span></code>.  Note: D and C are no longer aligned.</p>
<ul class="simple">
<li>2nd rotation R_BC: Frames D, C (collectively – as if welded together)</li>
</ul>
<p>rotate relative to frame B, A by a pitch angle <code class="docutils literal"><span class="pre">p</span></code> about <code class="docutils literal"><span class="pre">Cy</span> <span class="pre">=</span> <span class="pre">By</span></code>.
Note: C and B are no longer aligned.</p>
<ul class="simple">
<li>3rd rotation R_AB: Frames D, C, B (collectively – as if welded)</li>
</ul>
<p>rotate relative to frame A by a roll angle <code class="docutils literal"><span class="pre">y</span></code> about <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>.
Note: B and A are no longer aligned.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method constructs a RotationMatrix from a RollPitchYaw.
Vice-versa, there are high-accuracy RollPitchYaw
constructor/methods that form a RollPitchYaw from a rotation
matrix.</p>
</div>
</dd></dl>

<dl class="template">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].cast">
<em class="property">template </em><code class="descname">cast</code><a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].cast.cast[float]" title="pydrake.math.RotationMatrix_.RotationMatrix_[float].cast.cast[float]"><code class="xref py py-class docutils literal"><span class="pre">cast[float]</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">cast[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal"><span class="pre">cast[Expression]</span></code></p>
<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].cast.cast[float]">
<code class="descname">cast[float]</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].cast.cast[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RotationMatrix is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].cast[AutoDiffXd]">
<code class="descname">cast[AutoDiffXd]</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; drake::math::RotationMatrix&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].cast[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RotationMatrix is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].cast[Expression]">
<code class="descname">cast[Expression]</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; drake::math::RotationMatrix&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].cast[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RotationMatrix is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].cast[float]">
<code class="descname">cast[float]</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].cast[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RotationMatrix is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].col">
<code class="descname">col</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float], index: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].col" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> rotation matrix’s iᵗʰ column (i = 0, 1, 2). For
<code class="docutils literal"><span class="pre">this</span></code> rotation matrix R_AB (which relates right-handed sets of
orthogonal unit vectors Ax, Ay, Az to Bx, By, Bz), - col(0) returns
Bx_A (Bx expressed in terms of Ax, Ay, Az). - col(1) returns By_A (By
expressed in terms of Ax, Ay, Az). - col(2) returns Bz_A (Bz expressed
in terms of Ax, Ay, Az).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">index</span></code>:</dt>
<dd>requested column index (0 &lt;= index &lt;= 2).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">row(), matrix()</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">In debug builds, asserts (0 &lt;= index &lt;= 2).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For efficiency and consistency with Eigen, this method returns the
same quantity returned by Eigen’s col() operator. The returned
quantity can be assigned in various ways, e.g., as <code class="docutils literal"><span class="pre">const</span> <span class="pre">auto&amp;</span>
<span class="pre">Bz_A</span> <span class="pre">=</span> <span class="pre">col(2);</span></code> or <code class="docutils literal"><span class="pre">Vector3&lt;T&gt;</span> <span class="pre">Bz_A</span> <span class="pre">=</span> <span class="pre">col(2);</span></code></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].Identity">
<em class="property">static </em><code class="descname">Identity</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].Identity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].IsExactlyIdentity">
<code class="descname">IsExactlyIdentity</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].IsExactlyIdentity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> is exactly equal to the identity matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].IsIdentityToInternalTolerance">
<code class="descname">IsIdentityToInternalTolerance</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].IsIdentityToInternalTolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal"><span class="pre">this</span></code> is equal to the identity matrix to within the
threshold of get_internal_tolerance_for_orthonormality().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].IsValid">
<code class="descname">IsValid</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].IsValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if <code class="docutils literal"><span class="pre">this</span></code> rotation matrix R is a proper orthonormal rotation
matrix to within the threshold of
get_internal_tolerance_for_orthonormality().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> is a valid rotation matrix.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].MakeXRotation">
<em class="property">static </em><code class="descname">MakeXRotation</code><span class="sig-paren">(</span><em>theta: float</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].MakeXRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal"><span class="pre">theta</span></code> about unit vector <code class="docutils literal"><span class="pre">Ax</span> <span class="pre">=</span>
<span class="pre">Bx</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta</span></code>:</dt>
<dd>radian measure of rotation angle about Ax.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitX().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal"><span class="pre">theta</span></code> about <code class="docutils literal"><span class="pre">Ax</span> <span class="pre">=</span> <span class="pre">Bx</span></code>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡ 1       0                 0  ⎤
R_AB = ⎢ 0   cos(theta)   -sin(theta) ⎥
       ⎣ 0   sin(theta)    cos(theta) ⎦
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].MakeYRotation">
<em class="property">static </em><code class="descname">MakeYRotation</code><span class="sig-paren">(</span><em>theta: float</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].MakeYRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal"><span class="pre">theta</span></code> about unit vector <code class="docutils literal"><span class="pre">Ay</span> <span class="pre">=</span>
<span class="pre">By</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta</span></code>:</dt>
<dd>radian measure of rotation angle about Ay.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitY().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal"><span class="pre">theta</span></code> about <code class="docutils literal"><span class="pre">Ay</span> <span class="pre">=</span> <span class="pre">By</span></code>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡  cos(theta)   0   sin(theta) ⎤
R_AB = ⎢          0    1           0  ⎥
       ⎣ -sin(theta)   0   cos(theta) ⎦
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].MakeZRotation">
<em class="property">static </em><code class="descname">MakeZRotation</code><span class="sig-paren">(</span><em>theta: float</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].MakeZRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal"><span class="pre">theta</span></code> about unit vector <code class="docutils literal"><span class="pre">Az</span> <span class="pre">=</span>
<span class="pre">Bz</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta</span></code>:</dt>
<dd>radian measure of rotation angle about Az.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitZ().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal"><span class="pre">theta</span></code> about <code class="docutils literal"><span class="pre">Az</span> <span class="pre">=</span> <span class="pre">Bz</span></code>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡ cos(theta)  -sin(theta)   0 ⎤
R_AB = ⎢ sin(theta)   cos(theta)   0 ⎥
       ⎣         0            0    1 ⎦
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].matrix">
<code class="descname">matrix</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 3]]<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Matrix3 underlying a RotationMatrix.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">col(), row()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].multiply">
<code class="descname">multiply</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>multiply(self: pydrake.math.RotationMatrix_[float], other: pydrake.math.RotationMatrix_[float]) -&gt; pydrake.math.RotationMatrix_[float]</li>
</ol>
<p>Calculates <code class="docutils literal"><span class="pre">this</span></code> rotation matrix <code class="docutils literal"><span class="pre">R_AB</span></code> multiplied by <code class="docutils literal"><span class="pre">other</span></code>
rotation matrix <code class="docutils literal"><span class="pre">R_BC</span></code>, returning the composition <code class="docutils literal"><span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">R_BC</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">other</span></code>:</dt>
<dd>RotationMatrix that post-multiplies <code class="docutils literal"><span class="pre">this</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">rotation matrix that results from <code class="docutils literal"><span class="pre">this</span></code> multiplied by
<code class="docutils literal"><span class="pre">other</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is possible (albeit improbable) to create an invalid rotation
matrix by accumulating round-off error with a large number of
multiplies.</p>
</div>
<ol class="arabic simple" start="2">
<li>multiply(self: pydrake.math.RotationMatrix_[float], v_B: numpy.ndarray[numpy.float64[3, 1]]) -&gt; numpy.ndarray[numpy.float64[3, 1]]</li>
</ol>
<p>Calculates <code class="docutils literal"><span class="pre">this</span></code> rotation matrix <code class="docutils literal"><span class="pre">R_AB</span></code> multiplied by an
arbitrary Vector3 expressed in the B frame.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">v_B</span></code>:</dt>
<dd>3x1 vector that post-multiplies <code class="docutils literal"><span class="pre">this</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">3x1 vector <code class="docutils literal"><span class="pre">v_A</span> <span class="pre">=</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">v_B</span></code>.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>multiply(self: pydrake.math.RotationMatrix_[float], v_B: numpy.ndarray[numpy.float64[3, n]]) -&gt; numpy.ndarray[numpy.float64[3, n]]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> by the n vectors <code class="docutils literal"><span class="pre">v1</span></code>,
… <cite>vn</cite>, where each vector has 3 elements and is expressed in frame
B.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">v_B</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix whose n columns are regarded as arbitrary vectors
<code class="docutils literal"><span class="pre">v1</span></code>, … <cite>vn</cite> expressed in frame B.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">v_A</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix whose n columns are vectors <code class="docutils literal"><span class="pre">v1</span></code>, … <cite>vn</cite>
expressed in frame A.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">rpy</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">);</span>
<span class="n">const</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">R_AB</span><span class="p">(</span><span class="n">rpy</span><span class="p">);</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">v_B</span><span class="p">;</span>
<span class="n">v_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">v_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">const</span> <span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">v_A</span> <span class="o">=</span> <span class="n">R_AB</span> <span class="o">*</span> <span class="n">v_B</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].ProjectToRotationMatrix">
<em class="property">static </em><code class="descname">ProjectToRotationMatrix</code><span class="sig-paren">(</span><em>M: numpy.ndarray[numpy.float64[3, 3]]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].ProjectToRotationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an approximate rotation matrix M, finds the RotationMatrix R
closest to M. Closeness is measured with a matrix-2 norm (or
equivalently with a Frobenius norm). Hence, this method creates a
RotationMatrix R from a 3x3 matrix M by minimizing <code class="docutils literal"><span class="pre">‖R</span> <span class="pre">-</span> <span class="pre">M‖₂</span></code> (the
matrix-2 norm of (R-M)) subject to <code class="docutils literal"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">Rᵀ</span> <span class="pre">=</span> <span class="pre">I</span></code>, where I is the 3x3
identity matrix. For this problem, closeness can also be measured by
forming the orthonormal matrix R whose elements minimize the
double-summation <code class="docutils literal"><span class="pre">∑ᵢ</span> <span class="pre">∑ⱼ</span> <span class="pre">(R(i,j)</span> <span class="pre">-</span> <span class="pre">M(i,j))²</span></code> where <code class="docutils literal"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">1:3,</span> <span class="pre">j</span> <span class="pre">=</span>
<span class="pre">1:3</span></code>, subject to <code class="docutils literal"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">Rᵀ</span> <span class="pre">=</span> <span class="pre">I</span></code>. The square-root of this
double-summation is called the Frobenius norm.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">M</span></code>:</dt>
<dd>a 3x3 matrix.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">quality_factor</span></code>:</dt>
<dd>. The quality of M as a rotation matrix. <code class="docutils literal"><span class="pre">quality_factor</span></code> = 1 is
perfect (M = R). <code class="docutils literal"><span class="pre">quality_factor</span></code> = 1.25 means that when M
multiplies a unit vector (magnitude 1), a vector of magnitude as
large as 1.25 may result. <code class="docutils literal"><span class="pre">quality_factor</span></code> = 0.8 means that when
M multiplies a unit vector, a vector of magnitude as small as 0.8
may result. <code class="docutils literal"><span class="pre">quality_factor</span></code> = 0 means M is singular, so at
least one of the bases related by matrix M does not span 3D space
(when M multiples a unit vector, a vector of magnitude as small as
0 may result).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">proper orthonormal matrix R that is closest to M.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if R fails IsValid(R).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">William Kahan (UC Berkeley) and Hongkai Dai (Toyota Research
Institute) proved that for this problem, the same R that minimizes
the Frobenius norm also minimizes the matrix-2 norm (a.k.a an
induced-2 norm), which is defined [Dahleh, Section 4.2] as the
column matrix u which maximizes <code class="docutils literal"><span class="pre">‖(R</span> <span class="pre">-</span> <span class="pre">M)</span> <span class="pre">u‖</span> <span class="pre">/</span> <span class="pre">‖u‖</span></code>, where <code class="docutils literal"><span class="pre">u</span> <span class="pre">≠</span>
<span class="pre">0</span></code>. Since the matrix-2 norm of any matrix A is equal to the
maximum singular value of A, minimizing the matrix-2 norm of (R -
M) is equivalent to minimizing the maximum singular value of (R -
M).</p>
</div>
<ul class="simple">
<li>[Dahleh] “Lectures on Dynamic Systems and Controls: Electrical</li>
</ul>
<p>Engineering and Computer Science, Massachusetts Institute of Technology”
<a class="reference external" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf</a></p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].row">
<code class="descname">row</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float], index: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[1, 3]]<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].row" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> rotation matrix’s iᵗʰ row (i = 0, 1, 2). For <code class="docutils literal"><span class="pre">this</span></code>
rotation matrix R_AB (which relates right-handed sets of orthogonal
unit vectors Ax, Ay, Az to Bx, By, Bz), - row(0) returns Ax_B (Ax
expressed in terms of Bx, By, Bz). - row(1) returns Ay_B (Ay expressed
in terms of Bx, By, Bz). - row(2) returns Az_B (Az expressed in terms
of Bx, By, Bz).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">index</span></code>:</dt>
<dd>requested row index (0 &lt;= index &lt;= 2).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">col(), matrix()</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">In debug builds, asserts (0 &lt;= index &lt;= 2).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For efficiency and consistency with Eigen, this method returns the
same quantity returned by Eigen’s row() operator. The returned
quantity can be assigned in various ways, e.g., as <code class="docutils literal"><span class="pre">const</span> <span class="pre">auto&amp;</span>
<span class="pre">Az_B</span> <span class="pre">=</span> <span class="pre">row(2);</span></code> or <code class="docutils literal"><span class="pre">RowVector3&lt;T&gt;</span> <span class="pre">Az_B</span> <span class="pre">=</span> <span class="pre">row(2);</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].set">
<code class="descname">set</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float], R: numpy.ndarray[numpy.float64[3, 3]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RotationMatrix from a Matrix3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>an allegedly valid rotation matrix.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if R fails IsValid(R).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].ToAngleAxis">
<code class="descname">ToAngleAxis</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; Eigen::AngleAxis&lt;double&gt;<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].ToAngleAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an AngleAxis <code class="docutils literal"><span class="pre">theta_lambda</span></code> containing an angle <code class="docutils literal"><span class="pre">theta</span></code>
and unit vector (axis direction) <code class="docutils literal"><span class="pre">lambda</span></code> that represents <code class="docutils literal"><span class="pre">this</span></code>
RotationMatrix.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The orientation and RotationMatrix associated with <code class="docutils literal"><span class="pre">theta</span> <span class="pre">*</span>
<span class="pre">lambda</span></code> is identical to that of <code class="docutils literal"><span class="pre">(-theta)</span> <span class="pre">*</span> <span class="pre">(-lambda)</span></code>. The
AngleAxis returned by this method chooses to have <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">theta</span> <span class="pre">&lt;=</span>
<span class="pre">pi</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an AngleAxis with <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">theta</span> <span class="pre">&lt;=</span> <span class="pre">pi</span></code> and a unit vector
<code class="docutils literal"><span class="pre">lambda</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].ToQuaternion">
<code class="descname">ToQuaternion</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; Eigen::Quaternion&lt;double, 0&gt;<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].ToQuaternion" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a quaternion q that represents <code class="docutils literal"><span class="pre">this</span></code> RotationMatrix. Since
the quaternion <code class="docutils literal"><span class="pre">q</span></code> and <code class="docutils literal"><span class="pre">-q</span></code> represent the same RotationMatrix,
this method chooses to return a canonical quaternion, i.e., with q(0)
&gt;= 0.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is a constructor in the RollPitchYaw class that converts a
rotation matrix to roll-pitch-yaw angles.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_.RotationMatrix_[float].transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_.RotationMatrix_[float].transpose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.math.</code><code class="descname">RotationMatrix_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a 3x3 rotation matrix between two arbitrary
frames A and B and helps ensure users create valid rotation matrices.
This class relates right-handed orthogonal unit vectors Ax, Ay, Az
fixed in frame A to right-handed orthogonal unit vectors Bx, By, Bz
fixed in frame B. The monogram notation for the rotation matrix
relating A to B is <code class="docutils literal"><span class="pre">R_AB</span></code>. An example that gives context to this
rotation matrix is <code class="docutils literal"><span class="pre">v_A</span> <span class="pre">=</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">v_B</span></code>, where <code class="docutils literal"><span class="pre">v_B</span></code> denotes an
arbitrary vector v expressed in terms of Bx, By, Bz and <code class="docutils literal"><span class="pre">v_A</span></code>
denotes vector v expressed in terms of Ax, Ay, Az. See
multibody_quantities for monogram notation for dynamics. See
orientation_discussion “a discussion on rotation matrices”.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the frames associated with a rotation
matrix nor does it enforce strict proper usage of this class with
vectors.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When assertions are enabled, several methods in this class do a
validity check and throw an exception (RuntimeError) if the
rotation matrix is invalid. When assertions are disabled, many of
these validity checks are skipped (which helps improve speed). In
addition, these validity tests are only performed for scalar types
for which drake::scalar_predicate&lt;T&gt;::is_bool is <code class="docutils literal"><span class="pre">True</span></code>. For
instance, validity checks are not performed when T is
symbolic::Expression.</p>
</div>
<dl class="docutils">
<dt>Authors:</dt>
<dd>Paul Mitiguy (2018) Original author.</dd>
<dt>Authors:</dt>
<dd>Drake team (see <a class="reference external" href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</dd>
</dl>
<dl class="method">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.math.RotationMatrix_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Constructs a 3x3 identity RotationMatrix – which corresponds to
aligning two frames (so that unit vectors Ax = Bx, Ay = By, Az = Bz).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.math.RotationMatrix_[AutoDiffXd], other: pydrake.math.RotationMatrix_[AutoDiffXd]) -&gt; None</li>
<li>__init__(self: pydrake.math.RotationMatrix_[AutoDiffXd], R: numpy.ndarray[object[3, 3]]) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from a Matrix3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>an allegedly valid rotation matrix.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if R fails IsValid(R).</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.math.RotationMatrix_[AutoDiffXd], quaternion: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from an Eigen::Quaternion.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>a non-zero, finite quaternion which may or may not have unit
length [i.e., <code class="docutils literal"><span class="pre">quaternion.norm()</span></code> does not have to be 1].</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix R that is</li>
<li>built from <code class="docutils literal"><span class="pre">quaternion</span></code> fails IsValid(R). For example, an</li>
<li>exception is thrown if <code class="docutils literal"><span class="pre">quaternion</span></code> is zero or contains a NaN or</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">infinity.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has the effect of normalizing its <code class="docutils literal"><span class="pre">quaternion</span></code>
argument, without the inefficiency of the square-root associated
with normalization.</p>
</div>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.math.RotationMatrix_[AutoDiffXd], theta_lambda: pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from an Eigen::AngleAxis.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta_lambda</span></code>:</dt>
<dd>an Eigen::AngleAxis whose associated axis (vector direction herein
called <code class="docutils literal"><span class="pre">lambda</span></code>) is non-zero and finite, but which may or may
not have unit length [i.e., <code class="docutils literal"><span class="pre">lambda.norm()</span></code> does not have to be
1].</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix R that is</li>
<li>built from <code class="docutils literal"><span class="pre">theta_lambda</span></code> fails IsValid(R). For example, an</li>
<li>exception is thrown if <code class="docutils literal"><span class="pre">lambda</span></code> is zero or contains a NaN or</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">infinity.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="6">
<li>__init__(self: pydrake.math.RotationMatrix_[AutoDiffXd], rpy: drake::math::RollPitchYaw&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from an RollPitchYaw. In other words,
makes the RotationMatrix for a Space-fixed (extrinsic) X-Y-Z rotation
by “roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code>, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by “yaw-pitch-roll” angles <code class="docutils literal"><span class="pre">[y,</span>
<span class="pre">p,</span> <span class="pre">r]</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>radian measures of three angles [roll, pitch, yaw].</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
with “roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> or equivalently a Body-
fixed (intrinsic) Z-Y-X rotation with “yaw-pitch-roll” angles
<code class="docutils literal"><span class="pre">[y,</span> <span class="pre">p,</span> <span class="pre">r]</span></code>.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Denoting roll <code class="docutils literal"><span class="pre">r</span></code>, pitch <code class="docutils literal"><span class="pre">p</span></code>, yaw <code class="docutils literal"><span class="pre">y</span></code>, this method returns a
rotation matrix <code class="docutils literal"><span class="pre">R_AD</span></code> equal to the matrix multiplication shown
below.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
       ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
     =       R_AB          *        R_BC          *        R_CD
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this discussion, A is the Space frame and D is the Body frame.
One way to visualize this rotation sequence is by introducing
intermediate frames B and C (useful constructs to understand this
rotation sequence). Initially, the frames are aligned so <code class="docutils literal"><span class="pre">Di</span> <span class="pre">=</span> <span class="pre">Ci</span>
<span class="pre">=</span> <span class="pre">Bi</span> <span class="pre">=</span> <span class="pre">Ai</span> <span class="pre">(i</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>. Then D is subjected to successive
right-handed rotations relative to A.</p>
</div>
<ul class="simple">
<li>1st rotation R_CD: Frame D rotates relative to frames C, B, A by a</li>
</ul>
<p>roll angle <code class="docutils literal"><span class="pre">r</span></code> about <code class="docutils literal"><span class="pre">Dx</span> <span class="pre">=</span> <span class="pre">Cx</span></code>.  Note: D and C are no longer aligned.</p>
<ul class="simple">
<li>2nd rotation R_BC: Frames D, C (collectively – as if welded together)</li>
</ul>
<p>rotate relative to frame B, A by a pitch angle <code class="docutils literal"><span class="pre">p</span></code> about <code class="docutils literal"><span class="pre">Cy</span> <span class="pre">=</span> <span class="pre">By</span></code>.
Note: C and B are no longer aligned.</p>
<ul class="simple">
<li>3rd rotation R_AB: Frames D, C, B (collectively – as if welded)</li>
</ul>
<p>rotate relative to frame A by a roll angle <code class="docutils literal"><span class="pre">y</span></code> about <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>.
Note: B and A are no longer aligned.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method constructs a RotationMatrix from a RollPitchYaw.
Vice-versa, there are high-accuracy RollPitchYaw
constructor/methods that form a RollPitchYaw from a rotation
matrix.</p>
</div>
</dd></dl>

<dl class="template">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].cast">
<em class="property">template </em><code class="descname">cast</code><a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.math.RotationMatrix_[AutoDiffXd].cast.cast[AutoDiffXd]" title="pydrake.math.RotationMatrix_[AutoDiffXd].cast.cast[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">cast[AutoDiffXd]</span></code></a></p>
<dl class="method">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].cast.cast[AutoDiffXd]">
<code class="descname">cast[AutoDiffXd]</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].cast.cast[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RotationMatrix is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].cast[AutoDiffXd]">
<code class="descname">cast[AutoDiffXd]</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].cast[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RotationMatrix is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].col">
<code class="descname">col</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[AutoDiffXd], index: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].col" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> rotation matrix’s iᵗʰ column (i = 0, 1, 2). For
<code class="docutils literal"><span class="pre">this</span></code> rotation matrix R_AB (which relates right-handed sets of
orthogonal unit vectors Ax, Ay, Az to Bx, By, Bz), - col(0) returns
Bx_A (Bx expressed in terms of Ax, Ay, Az). - col(1) returns By_A (By
expressed in terms of Ax, Ay, Az). - col(2) returns Bz_A (Bz expressed
in terms of Ax, Ay, Az).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">index</span></code>:</dt>
<dd>requested column index (0 &lt;= index &lt;= 2).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">row(), matrix()</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">In debug builds, asserts (0 &lt;= index &lt;= 2).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For efficiency and consistency with Eigen, this method returns the
same quantity returned by Eigen’s col() operator. The returned
quantity can be assigned in various ways, e.g., as <code class="docutils literal"><span class="pre">const</span> <span class="pre">auto&amp;</span>
<span class="pre">Bz_A</span> <span class="pre">=</span> <span class="pre">col(2);</span></code> or <code class="docutils literal"><span class="pre">Vector3&lt;T&gt;</span> <span class="pre">Bz_A</span> <span class="pre">=</span> <span class="pre">col(2);</span></code></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].Identity">
<em class="property">static </em><code class="descname">Identity</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].Identity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].IsExactlyIdentity">
<code class="descname">IsExactlyIdentity</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].IsExactlyIdentity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> is exactly equal to the identity matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].IsIdentityToInternalTolerance">
<code class="descname">IsIdentityToInternalTolerance</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].IsIdentityToInternalTolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal"><span class="pre">this</span></code> is equal to the identity matrix to within the
threshold of get_internal_tolerance_for_orthonormality().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].IsValid">
<code class="descname">IsValid</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].IsValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if <code class="docutils literal"><span class="pre">this</span></code> rotation matrix R is a proper orthonormal rotation
matrix to within the threshold of
get_internal_tolerance_for_orthonormality().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> is a valid rotation matrix.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].MakeXRotation">
<em class="property">static </em><code class="descname">MakeXRotation</code><span class="sig-paren">(</span><em>theta: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].MakeXRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal"><span class="pre">theta</span></code> about unit vector <code class="docutils literal"><span class="pre">Ax</span> <span class="pre">=</span>
<span class="pre">Bx</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta</span></code>:</dt>
<dd>radian measure of rotation angle about Ax.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitX().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal"><span class="pre">theta</span></code> about <code class="docutils literal"><span class="pre">Ax</span> <span class="pre">=</span> <span class="pre">Bx</span></code>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡ 1       0                 0  ⎤
R_AB = ⎢ 0   cos(theta)   -sin(theta) ⎥
       ⎣ 0   sin(theta)    cos(theta) ⎦
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].MakeYRotation">
<em class="property">static </em><code class="descname">MakeYRotation</code><span class="sig-paren">(</span><em>theta: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].MakeYRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal"><span class="pre">theta</span></code> about unit vector <code class="docutils literal"><span class="pre">Ay</span> <span class="pre">=</span>
<span class="pre">By</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta</span></code>:</dt>
<dd>radian measure of rotation angle about Ay.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitY().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal"><span class="pre">theta</span></code> about <code class="docutils literal"><span class="pre">Ay</span> <span class="pre">=</span> <span class="pre">By</span></code>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡  cos(theta)   0   sin(theta) ⎤
R_AB = ⎢          0    1           0  ⎥
       ⎣ -sin(theta)   0   cos(theta) ⎦
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].MakeZRotation">
<em class="property">static </em><code class="descname">MakeZRotation</code><span class="sig-paren">(</span><em>theta: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].MakeZRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal"><span class="pre">theta</span></code> about unit vector <code class="docutils literal"><span class="pre">Az</span> <span class="pre">=</span>
<span class="pre">Bz</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta</span></code>:</dt>
<dd>radian measure of rotation angle about Az.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitZ().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal"><span class="pre">theta</span></code> about <code class="docutils literal"><span class="pre">Az</span> <span class="pre">=</span> <span class="pre">Bz</span></code>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡ cos(theta)  -sin(theta)   0 ⎤
R_AB = ⎢ sin(theta)   cos(theta)   0 ⎥
       ⎣         0            0    1 ⎦
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].matrix">
<code class="descname">matrix</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 3]]<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Matrix3 underlying a RotationMatrix.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">col(), row()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].multiply">
<code class="descname">multiply</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>multiply(self: pydrake.math.RotationMatrix_[AutoDiffXd], other: pydrake.math.RotationMatrix_[AutoDiffXd]) -&gt; pydrake.math.RotationMatrix_[AutoDiffXd]</li>
</ol>
<p>Calculates <code class="docutils literal"><span class="pre">this</span></code> rotation matrix <code class="docutils literal"><span class="pre">R_AB</span></code> multiplied by <code class="docutils literal"><span class="pre">other</span></code>
rotation matrix <code class="docutils literal"><span class="pre">R_BC</span></code>, returning the composition <code class="docutils literal"><span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">R_BC</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">other</span></code>:</dt>
<dd>RotationMatrix that post-multiplies <code class="docutils literal"><span class="pre">this</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">rotation matrix that results from <code class="docutils literal"><span class="pre">this</span></code> multiplied by
<code class="docutils literal"><span class="pre">other</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is possible (albeit improbable) to create an invalid rotation
matrix by accumulating round-off error with a large number of
multiplies.</p>
</div>
<ol class="arabic simple" start="2">
<li>multiply(self: pydrake.math.RotationMatrix_[AutoDiffXd], v_B: numpy.ndarray[object[3, 1]]) -&gt; numpy.ndarray[object[3, 1]]</li>
</ol>
<p>Calculates <code class="docutils literal"><span class="pre">this</span></code> rotation matrix <code class="docutils literal"><span class="pre">R_AB</span></code> multiplied by an
arbitrary Vector3 expressed in the B frame.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">v_B</span></code>:</dt>
<dd>3x1 vector that post-multiplies <code class="docutils literal"><span class="pre">this</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">3x1 vector <code class="docutils literal"><span class="pre">v_A</span> <span class="pre">=</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">v_B</span></code>.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>multiply(self: pydrake.math.RotationMatrix_[AutoDiffXd], v_B: numpy.ndarray[object[3, n]]) -&gt; numpy.ndarray[object[3, n]]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> by the n vectors <code class="docutils literal"><span class="pre">v1</span></code>,
… <cite>vn</cite>, where each vector has 3 elements and is expressed in frame
B.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">v_B</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix whose n columns are regarded as arbitrary vectors
<code class="docutils literal"><span class="pre">v1</span></code>, … <cite>vn</cite> expressed in frame B.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">v_A</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix whose n columns are vectors <code class="docutils literal"><span class="pre">v1</span></code>, … <cite>vn</cite>
expressed in frame A.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">rpy</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">);</span>
<span class="n">const</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">R_AB</span><span class="p">(</span><span class="n">rpy</span><span class="p">);</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">v_B</span><span class="p">;</span>
<span class="n">v_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">v_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">const</span> <span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">v_A</span> <span class="o">=</span> <span class="n">R_AB</span> <span class="o">*</span> <span class="n">v_B</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].ProjectToRotationMatrix">
<em class="property">static </em><code class="descname">ProjectToRotationMatrix</code><span class="sig-paren">(</span><em>M: numpy.ndarray[object[3, 3]]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].ProjectToRotationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an approximate rotation matrix M, finds the RotationMatrix R
closest to M. Closeness is measured with a matrix-2 norm (or
equivalently with a Frobenius norm). Hence, this method creates a
RotationMatrix R from a 3x3 matrix M by minimizing <code class="docutils literal"><span class="pre">‖R</span> <span class="pre">-</span> <span class="pre">M‖₂</span></code> (the
matrix-2 norm of (R-M)) subject to <code class="docutils literal"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">Rᵀ</span> <span class="pre">=</span> <span class="pre">I</span></code>, where I is the 3x3
identity matrix. For this problem, closeness can also be measured by
forming the orthonormal matrix R whose elements minimize the
double-summation <code class="docutils literal"><span class="pre">∑ᵢ</span> <span class="pre">∑ⱼ</span> <span class="pre">(R(i,j)</span> <span class="pre">-</span> <span class="pre">M(i,j))²</span></code> where <code class="docutils literal"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">1:3,</span> <span class="pre">j</span> <span class="pre">=</span>
<span class="pre">1:3</span></code>, subject to <code class="docutils literal"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">Rᵀ</span> <span class="pre">=</span> <span class="pre">I</span></code>. The square-root of this
double-summation is called the Frobenius norm.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">M</span></code>:</dt>
<dd>a 3x3 matrix.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">quality_factor</span></code>:</dt>
<dd>. The quality of M as a rotation matrix. <code class="docutils literal"><span class="pre">quality_factor</span></code> = 1 is
perfect (M = R). <code class="docutils literal"><span class="pre">quality_factor</span></code> = 1.25 means that when M
multiplies a unit vector (magnitude 1), a vector of magnitude as
large as 1.25 may result. <code class="docutils literal"><span class="pre">quality_factor</span></code> = 0.8 means that when
M multiplies a unit vector, a vector of magnitude as small as 0.8
may result. <code class="docutils literal"><span class="pre">quality_factor</span></code> = 0 means M is singular, so at
least one of the bases related by matrix M does not span 3D space
(when M multiples a unit vector, a vector of magnitude as small as
0 may result).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">proper orthonormal matrix R that is closest to M.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if R fails IsValid(R).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">William Kahan (UC Berkeley) and Hongkai Dai (Toyota Research
Institute) proved that for this problem, the same R that minimizes
the Frobenius norm also minimizes the matrix-2 norm (a.k.a an
induced-2 norm), which is defined [Dahleh, Section 4.2] as the
column matrix u which maximizes <code class="docutils literal"><span class="pre">‖(R</span> <span class="pre">-</span> <span class="pre">M)</span> <span class="pre">u‖</span> <span class="pre">/</span> <span class="pre">‖u‖</span></code>, where <code class="docutils literal"><span class="pre">u</span> <span class="pre">≠</span>
<span class="pre">0</span></code>. Since the matrix-2 norm of any matrix A is equal to the
maximum singular value of A, minimizing the matrix-2 norm of (R -
M) is equivalent to minimizing the maximum singular value of (R -
M).</p>
</div>
<ul class="simple">
<li>[Dahleh] “Lectures on Dynamic Systems and Controls: Electrical</li>
</ul>
<p>Engineering and Computer Science, Massachusetts Institute of Technology”
<a class="reference external" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf</a></p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].row">
<code class="descname">row</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[AutoDiffXd], index: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[1, 3]]<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].row" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> rotation matrix’s iᵗʰ row (i = 0, 1, 2). For <code class="docutils literal"><span class="pre">this</span></code>
rotation matrix R_AB (which relates right-handed sets of orthogonal
unit vectors Ax, Ay, Az to Bx, By, Bz), - row(0) returns Ax_B (Ax
expressed in terms of Bx, By, Bz). - row(1) returns Ay_B (Ay expressed
in terms of Bx, By, Bz). - row(2) returns Az_B (Az expressed in terms
of Bx, By, Bz).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">index</span></code>:</dt>
<dd>requested row index (0 &lt;= index &lt;= 2).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">col(), matrix()</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">In debug builds, asserts (0 &lt;= index &lt;= 2).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For efficiency and consistency with Eigen, this method returns the
same quantity returned by Eigen’s row() operator. The returned
quantity can be assigned in various ways, e.g., as <code class="docutils literal"><span class="pre">const</span> <span class="pre">auto&amp;</span>
<span class="pre">Az_B</span> <span class="pre">=</span> <span class="pre">row(2);</span></code> or <code class="docutils literal"><span class="pre">RowVector3&lt;T&gt;</span> <span class="pre">Az_B</span> <span class="pre">=</span> <span class="pre">row(2);</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].set">
<code class="descname">set</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[AutoDiffXd], R: numpy.ndarray[object[3, 3]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RotationMatrix from a Matrix3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>an allegedly valid rotation matrix.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if R fails IsValid(R).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].ToAngleAxis">
<code class="descname">ToAngleAxis</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].ToAngleAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an AngleAxis <code class="docutils literal"><span class="pre">theta_lambda</span></code> containing an angle <code class="docutils literal"><span class="pre">theta</span></code>
and unit vector (axis direction) <code class="docutils literal"><span class="pre">lambda</span></code> that represents <code class="docutils literal"><span class="pre">this</span></code>
RotationMatrix.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The orientation and RotationMatrix associated with <code class="docutils literal"><span class="pre">theta</span> <span class="pre">*</span>
<span class="pre">lambda</span></code> is identical to that of <code class="docutils literal"><span class="pre">(-theta)</span> <span class="pre">*</span> <span class="pre">(-lambda)</span></code>. The
AngleAxis returned by this method chooses to have <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">theta</span> <span class="pre">&lt;=</span>
<span class="pre">pi</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an AngleAxis with <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">theta</span> <span class="pre">&lt;=</span> <span class="pre">pi</span></code> and a unit vector
<code class="docutils literal"><span class="pre">lambda</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].ToQuaternion">
<code class="descname">ToQuaternion</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].ToQuaternion" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a quaternion q that represents <code class="docutils literal"><span class="pre">this</span></code> RotationMatrix. Since
the quaternion <code class="docutils literal"><span class="pre">q</span></code> and <code class="docutils literal"><span class="pre">-q</span></code> represent the same RotationMatrix,
this method chooses to return a canonical quaternion, i.e., with q(0)
&gt;= 0.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is a constructor in the RollPitchYaw class that converts a
rotation matrix to roll-pitch-yaw angles.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[AutoDiffXd].transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.math.RotationMatrix_[AutoDiffXd].transpose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.math.RotationMatrix_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.math.</code><code class="descname">RotationMatrix_[Expression]</code><a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a 3x3 rotation matrix between two arbitrary
frames A and B and helps ensure users create valid rotation matrices.
This class relates right-handed orthogonal unit vectors Ax, Ay, Az
fixed in frame A to right-handed orthogonal unit vectors Bx, By, Bz
fixed in frame B. The monogram notation for the rotation matrix
relating A to B is <code class="docutils literal"><span class="pre">R_AB</span></code>. An example that gives context to this
rotation matrix is <code class="docutils literal"><span class="pre">v_A</span> <span class="pre">=</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">v_B</span></code>, where <code class="docutils literal"><span class="pre">v_B</span></code> denotes an
arbitrary vector v expressed in terms of Bx, By, Bz and <code class="docutils literal"><span class="pre">v_A</span></code>
denotes vector v expressed in terms of Ax, Ay, Az. See
multibody_quantities for monogram notation for dynamics. See
orientation_discussion “a discussion on rotation matrices”.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the frames associated with a rotation
matrix nor does it enforce strict proper usage of this class with
vectors.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When assertions are enabled, several methods in this class do a
validity check and throw an exception (RuntimeError) if the
rotation matrix is invalid. When assertions are disabled, many of
these validity checks are skipped (which helps improve speed). In
addition, these validity tests are only performed for scalar types
for which drake::scalar_predicate&lt;T&gt;::is_bool is <code class="docutils literal"><span class="pre">True</span></code>. For
instance, validity checks are not performed when T is
symbolic::Expression.</p>
</div>
<dl class="docutils">
<dt>Authors:</dt>
<dd>Paul Mitiguy (2018) Original author.</dd>
<dt>Authors:</dt>
<dd>Drake team (see <a class="reference external" href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</dd>
</dl>
<dl class="method">
<dt id="pydrake.math.RotationMatrix_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.math.RotationMatrix_[Expression]) -&gt; None</li>
</ol>
<p>Constructs a 3x3 identity RotationMatrix – which corresponds to
aligning two frames (so that unit vectors Ax = Bx, Ay = By, Az = Bz).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.math.RotationMatrix_[Expression], other: pydrake.math.RotationMatrix_[Expression]) -&gt; None</li>
<li>__init__(self: pydrake.math.RotationMatrix_[Expression], R: numpy.ndarray[object[3, 3]]) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from a Matrix3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>an allegedly valid rotation matrix.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if R fails IsValid(R).</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.math.RotationMatrix_[Expression], quaternion: pydrake.common.eigen_geometry.Quaternion_[Expression]) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from an Eigen::Quaternion.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>a non-zero, finite quaternion which may or may not have unit
length [i.e., <code class="docutils literal"><span class="pre">quaternion.norm()</span></code> does not have to be 1].</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix R that is</li>
<li>built from <code class="docutils literal"><span class="pre">quaternion</span></code> fails IsValid(R). For example, an</li>
<li>exception is thrown if <code class="docutils literal"><span class="pre">quaternion</span></code> is zero or contains a NaN or</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">infinity.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has the effect of normalizing its <code class="docutils literal"><span class="pre">quaternion</span></code>
argument, without the inefficiency of the square-root associated
with normalization.</p>
</div>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.math.RotationMatrix_[Expression], theta_lambda: pydrake.common.eigen_geometry.AngleAxis_[Expression]) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from an Eigen::AngleAxis.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta_lambda</span></code>:</dt>
<dd>an Eigen::AngleAxis whose associated axis (vector direction herein
called <code class="docutils literal"><span class="pre">lambda</span></code>) is non-zero and finite, but which may or may
not have unit length [i.e., <code class="docutils literal"><span class="pre">lambda.norm()</span></code> does not have to be
1].</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix R that is</li>
<li>built from <code class="docutils literal"><span class="pre">theta_lambda</span></code> fails IsValid(R). For example, an</li>
<li>exception is thrown if <code class="docutils literal"><span class="pre">lambda</span></code> is zero or contains a NaN or</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">infinity.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="6">
<li>__init__(self: pydrake.math.RotationMatrix_[Expression], rpy: drake::math::RollPitchYaw&lt;drake::symbolic::Expression&gt;) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from an RollPitchYaw. In other words,
makes the RotationMatrix for a Space-fixed (extrinsic) X-Y-Z rotation
by “roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code>, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by “yaw-pitch-roll” angles <code class="docutils literal"><span class="pre">[y,</span>
<span class="pre">p,</span> <span class="pre">r]</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>radian measures of three angles [roll, pitch, yaw].</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
with “roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> or equivalently a Body-
fixed (intrinsic) Z-Y-X rotation with “yaw-pitch-roll” angles
<code class="docutils literal"><span class="pre">[y,</span> <span class="pre">p,</span> <span class="pre">r]</span></code>.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Denoting roll <code class="docutils literal"><span class="pre">r</span></code>, pitch <code class="docutils literal"><span class="pre">p</span></code>, yaw <code class="docutils literal"><span class="pre">y</span></code>, this method returns a
rotation matrix <code class="docutils literal"><span class="pre">R_AD</span></code> equal to the matrix multiplication shown
below.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
       ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
     =       R_AB          *        R_BC          *        R_CD
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this discussion, A is the Space frame and D is the Body frame.
One way to visualize this rotation sequence is by introducing
intermediate frames B and C (useful constructs to understand this
rotation sequence). Initially, the frames are aligned so <code class="docutils literal"><span class="pre">Di</span> <span class="pre">=</span> <span class="pre">Ci</span>
<span class="pre">=</span> <span class="pre">Bi</span> <span class="pre">=</span> <span class="pre">Ai</span> <span class="pre">(i</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>. Then D is subjected to successive
right-handed rotations relative to A.</p>
</div>
<ul class="simple">
<li>1st rotation R_CD: Frame D rotates relative to frames C, B, A by a</li>
</ul>
<p>roll angle <code class="docutils literal"><span class="pre">r</span></code> about <code class="docutils literal"><span class="pre">Dx</span> <span class="pre">=</span> <span class="pre">Cx</span></code>.  Note: D and C are no longer aligned.</p>
<ul class="simple">
<li>2nd rotation R_BC: Frames D, C (collectively – as if welded together)</li>
</ul>
<p>rotate relative to frame B, A by a pitch angle <code class="docutils literal"><span class="pre">p</span></code> about <code class="docutils literal"><span class="pre">Cy</span> <span class="pre">=</span> <span class="pre">By</span></code>.
Note: C and B are no longer aligned.</p>
<ul class="simple">
<li>3rd rotation R_AB: Frames D, C, B (collectively – as if welded)</li>
</ul>
<p>rotate relative to frame A by a roll angle <code class="docutils literal"><span class="pre">y</span></code> about <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>.
Note: B and A are no longer aligned.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method constructs a RotationMatrix from a RollPitchYaw.
Vice-versa, there are high-accuracy RollPitchYaw
constructor/methods that form a RollPitchYaw from a rotation
matrix.</p>
</div>
</dd></dl>

<dl class="template">
<dt id="pydrake.math.RotationMatrix_[Expression].cast">
<em class="property">template </em><code class="descname">cast</code><a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.math.RotationMatrix_[Expression].cast.cast[Expression]" title="pydrake.math.RotationMatrix_[Expression].cast.cast[Expression]"><code class="xref py py-class docutils literal"><span class="pre">cast[Expression]</span></code></a></p>
<dl class="method">
<dt id="pydrake.math.RotationMatrix_[Expression].cast.cast[Expression]">
<code class="descname">cast[Expression]</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].cast.cast[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RotationMatrix is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[Expression].cast[Expression]">
<code class="descname">cast[Expression]</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].cast[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RotationMatrix is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[Expression].col">
<code class="descname">col</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[Expression], index: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].col" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> rotation matrix’s iᵗʰ column (i = 0, 1, 2). For
<code class="docutils literal"><span class="pre">this</span></code> rotation matrix R_AB (which relates right-handed sets of
orthogonal unit vectors Ax, Ay, Az to Bx, By, Bz), - col(0) returns
Bx_A (Bx expressed in terms of Ax, Ay, Az). - col(1) returns By_A (By
expressed in terms of Ax, Ay, Az). - col(2) returns Bz_A (Bz expressed
in terms of Ax, Ay, Az).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">index</span></code>:</dt>
<dd>requested column index (0 &lt;= index &lt;= 2).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">row(), matrix()</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">In debug builds, asserts (0 &lt;= index &lt;= 2).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For efficiency and consistency with Eigen, this method returns the
same quantity returned by Eigen’s col() operator. The returned
quantity can be assigned in various ways, e.g., as <code class="docutils literal"><span class="pre">const</span> <span class="pre">auto&amp;</span>
<span class="pre">Bz_A</span> <span class="pre">=</span> <span class="pre">col(2);</span></code> or <code class="docutils literal"><span class="pre">Vector3&lt;T&gt;</span> <span class="pre">Bz_A</span> <span class="pre">=</span> <span class="pre">col(2);</span></code></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_[Expression].Identity">
<em class="property">static </em><code class="descname">Identity</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].Identity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[Expression].inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[Expression].IsExactlyIdentity">
<code class="descname">IsExactlyIdentity</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].IsExactlyIdentity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> is exactly equal to the identity matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[Expression].IsIdentityToInternalTolerance">
<code class="descname">IsIdentityToInternalTolerance</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].IsIdentityToInternalTolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal"><span class="pre">this</span></code> is equal to the identity matrix to within the
threshold of get_internal_tolerance_for_orthonormality().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[Expression].IsValid">
<code class="descname">IsValid</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].IsValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if <code class="docutils literal"><span class="pre">this</span></code> rotation matrix R is a proper orthonormal rotation
matrix to within the threshold of
get_internal_tolerance_for_orthonormality().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> is a valid rotation matrix.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_[Expression].MakeXRotation">
<em class="property">static </em><code class="descname">MakeXRotation</code><span class="sig-paren">(</span><em>theta: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].MakeXRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal"><span class="pre">theta</span></code> about unit vector <code class="docutils literal"><span class="pre">Ax</span> <span class="pre">=</span>
<span class="pre">Bx</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta</span></code>:</dt>
<dd>radian measure of rotation angle about Ax.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitX().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal"><span class="pre">theta</span></code> about <code class="docutils literal"><span class="pre">Ax</span> <span class="pre">=</span> <span class="pre">Bx</span></code>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡ 1       0                 0  ⎤
R_AB = ⎢ 0   cos(theta)   -sin(theta) ⎥
       ⎣ 0   sin(theta)    cos(theta) ⎦
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_[Expression].MakeYRotation">
<em class="property">static </em><code class="descname">MakeYRotation</code><span class="sig-paren">(</span><em>theta: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].MakeYRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal"><span class="pre">theta</span></code> about unit vector <code class="docutils literal"><span class="pre">Ay</span> <span class="pre">=</span>
<span class="pre">By</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta</span></code>:</dt>
<dd>radian measure of rotation angle about Ay.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitY().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal"><span class="pre">theta</span></code> about <code class="docutils literal"><span class="pre">Ay</span> <span class="pre">=</span> <span class="pre">By</span></code>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡  cos(theta)   0   sin(theta) ⎤
R_AB = ⎢          0    1           0  ⎥
       ⎣ -sin(theta)   0   cos(theta) ⎦
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_[Expression].MakeZRotation">
<em class="property">static </em><code class="descname">MakeZRotation</code><span class="sig-paren">(</span><em>theta: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].MakeZRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal"><span class="pre">theta</span></code> about unit vector <code class="docutils literal"><span class="pre">Az</span> <span class="pre">=</span>
<span class="pre">Bz</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta</span></code>:</dt>
<dd>radian measure of rotation angle about Az.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitZ().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal"><span class="pre">theta</span></code> about <code class="docutils literal"><span class="pre">Az</span> <span class="pre">=</span> <span class="pre">Bz</span></code>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡ cos(theta)  -sin(theta)   0 ⎤
R_AB = ⎢ sin(theta)   cos(theta)   0 ⎥
       ⎣         0            0    1 ⎦
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[Expression].matrix">
<code class="descname">matrix</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 3]]<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Matrix3 underlying a RotationMatrix.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">col(), row()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[Expression].multiply">
<code class="descname">multiply</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>multiply(self: pydrake.math.RotationMatrix_[Expression], other: pydrake.math.RotationMatrix_[Expression]) -&gt; pydrake.math.RotationMatrix_[Expression]</li>
</ol>
<p>Calculates <code class="docutils literal"><span class="pre">this</span></code> rotation matrix <code class="docutils literal"><span class="pre">R_AB</span></code> multiplied by <code class="docutils literal"><span class="pre">other</span></code>
rotation matrix <code class="docutils literal"><span class="pre">R_BC</span></code>, returning the composition <code class="docutils literal"><span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">R_BC</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">other</span></code>:</dt>
<dd>RotationMatrix that post-multiplies <code class="docutils literal"><span class="pre">this</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">rotation matrix that results from <code class="docutils literal"><span class="pre">this</span></code> multiplied by
<code class="docutils literal"><span class="pre">other</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is possible (albeit improbable) to create an invalid rotation
matrix by accumulating round-off error with a large number of
multiplies.</p>
</div>
<ol class="arabic simple" start="2">
<li>multiply(self: pydrake.math.RotationMatrix_[Expression], v_B: numpy.ndarray[object[3, 1]]) -&gt; numpy.ndarray[object[3, 1]]</li>
</ol>
<p>Calculates <code class="docutils literal"><span class="pre">this</span></code> rotation matrix <code class="docutils literal"><span class="pre">R_AB</span></code> multiplied by an
arbitrary Vector3 expressed in the B frame.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">v_B</span></code>:</dt>
<dd>3x1 vector that post-multiplies <code class="docutils literal"><span class="pre">this</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">3x1 vector <code class="docutils literal"><span class="pre">v_A</span> <span class="pre">=</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">v_B</span></code>.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>multiply(self: pydrake.math.RotationMatrix_[Expression], v_B: numpy.ndarray[object[3, n]]) -&gt; numpy.ndarray[object[3, n]]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> by the n vectors <code class="docutils literal"><span class="pre">v1</span></code>,
… <cite>vn</cite>, where each vector has 3 elements and is expressed in frame
B.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">v_B</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix whose n columns are regarded as arbitrary vectors
<code class="docutils literal"><span class="pre">v1</span></code>, … <cite>vn</cite> expressed in frame B.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">v_A</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix whose n columns are vectors <code class="docutils literal"><span class="pre">v1</span></code>, … <cite>vn</cite>
expressed in frame A.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">rpy</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">);</span>
<span class="n">const</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">R_AB</span><span class="p">(</span><span class="n">rpy</span><span class="p">);</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">v_B</span><span class="p">;</span>
<span class="n">v_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">v_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">const</span> <span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">v_A</span> <span class="o">=</span> <span class="n">R_AB</span> <span class="o">*</span> <span class="n">v_B</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_[Expression].ProjectToRotationMatrix">
<em class="property">static </em><code class="descname">ProjectToRotationMatrix</code><span class="sig-paren">(</span><em>M: numpy.ndarray[object[3, 3]]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].ProjectToRotationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an approximate rotation matrix M, finds the RotationMatrix R
closest to M. Closeness is measured with a matrix-2 norm (or
equivalently with a Frobenius norm). Hence, this method creates a
RotationMatrix R from a 3x3 matrix M by minimizing <code class="docutils literal"><span class="pre">‖R</span> <span class="pre">-</span> <span class="pre">M‖₂</span></code> (the
matrix-2 norm of (R-M)) subject to <code class="docutils literal"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">Rᵀ</span> <span class="pre">=</span> <span class="pre">I</span></code>, where I is the 3x3
identity matrix. For this problem, closeness can also be measured by
forming the orthonormal matrix R whose elements minimize the
double-summation <code class="docutils literal"><span class="pre">∑ᵢ</span> <span class="pre">∑ⱼ</span> <span class="pre">(R(i,j)</span> <span class="pre">-</span> <span class="pre">M(i,j))²</span></code> where <code class="docutils literal"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">1:3,</span> <span class="pre">j</span> <span class="pre">=</span>
<span class="pre">1:3</span></code>, subject to <code class="docutils literal"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">Rᵀ</span> <span class="pre">=</span> <span class="pre">I</span></code>. The square-root of this
double-summation is called the Frobenius norm.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">M</span></code>:</dt>
<dd>a 3x3 matrix.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">quality_factor</span></code>:</dt>
<dd>. The quality of M as a rotation matrix. <code class="docutils literal"><span class="pre">quality_factor</span></code> = 1 is
perfect (M = R). <code class="docutils literal"><span class="pre">quality_factor</span></code> = 1.25 means that when M
multiplies a unit vector (magnitude 1), a vector of magnitude as
large as 1.25 may result. <code class="docutils literal"><span class="pre">quality_factor</span></code> = 0.8 means that when
M multiplies a unit vector, a vector of magnitude as small as 0.8
may result. <code class="docutils literal"><span class="pre">quality_factor</span></code> = 0 means M is singular, so at
least one of the bases related by matrix M does not span 3D space
(when M multiples a unit vector, a vector of magnitude as small as
0 may result).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">proper orthonormal matrix R that is closest to M.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if R fails IsValid(R).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">William Kahan (UC Berkeley) and Hongkai Dai (Toyota Research
Institute) proved that for this problem, the same R that minimizes
the Frobenius norm also minimizes the matrix-2 norm (a.k.a an
induced-2 norm), which is defined [Dahleh, Section 4.2] as the
column matrix u which maximizes <code class="docutils literal"><span class="pre">‖(R</span> <span class="pre">-</span> <span class="pre">M)</span> <span class="pre">u‖</span> <span class="pre">/</span> <span class="pre">‖u‖</span></code>, where <code class="docutils literal"><span class="pre">u</span> <span class="pre">≠</span>
<span class="pre">0</span></code>. Since the matrix-2 norm of any matrix A is equal to the
maximum singular value of A, minimizing the matrix-2 norm of (R -
M) is equivalent to minimizing the maximum singular value of (R -
M).</p>
</div>
<ul class="simple">
<li>[Dahleh] “Lectures on Dynamic Systems and Controls: Electrical</li>
</ul>
<p>Engineering and Computer Science, Massachusetts Institute of Technology”
<a class="reference external" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf</a></p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[Expression].row">
<code class="descname">row</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[Expression], index: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[1, 3]]<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].row" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> rotation matrix’s iᵗʰ row (i = 0, 1, 2). For <code class="docutils literal"><span class="pre">this</span></code>
rotation matrix R_AB (which relates right-handed sets of orthogonal
unit vectors Ax, Ay, Az to Bx, By, Bz), - row(0) returns Ax_B (Ax
expressed in terms of Bx, By, Bz). - row(1) returns Ay_B (Ay expressed
in terms of Bx, By, Bz). - row(2) returns Az_B (Az expressed in terms
of Bx, By, Bz).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">index</span></code>:</dt>
<dd>requested row index (0 &lt;= index &lt;= 2).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">col(), matrix()</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">In debug builds, asserts (0 &lt;= index &lt;= 2).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For efficiency and consistency with Eigen, this method returns the
same quantity returned by Eigen’s row() operator. The returned
quantity can be assigned in various ways, e.g., as <code class="docutils literal"><span class="pre">const</span> <span class="pre">auto&amp;</span>
<span class="pre">Az_B</span> <span class="pre">=</span> <span class="pre">row(2);</span></code> or <code class="docutils literal"><span class="pre">RowVector3&lt;T&gt;</span> <span class="pre">Az_B</span> <span class="pre">=</span> <span class="pre">row(2);</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[Expression].set">
<code class="descname">set</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[Expression], R: numpy.ndarray[object[3, 3]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RotationMatrix from a Matrix3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>an allegedly valid rotation matrix.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if R fails IsValid(R).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[Expression].ToAngleAxis">
<code class="descname">ToAngleAxis</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.common.eigen_geometry.AngleAxis_[Expression]<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].ToAngleAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an AngleAxis <code class="docutils literal"><span class="pre">theta_lambda</span></code> containing an angle <code class="docutils literal"><span class="pre">theta</span></code>
and unit vector (axis direction) <code class="docutils literal"><span class="pre">lambda</span></code> that represents <code class="docutils literal"><span class="pre">this</span></code>
RotationMatrix.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The orientation and RotationMatrix associated with <code class="docutils literal"><span class="pre">theta</span> <span class="pre">*</span>
<span class="pre">lambda</span></code> is identical to that of <code class="docutils literal"><span class="pre">(-theta)</span> <span class="pre">*</span> <span class="pre">(-lambda)</span></code>. The
AngleAxis returned by this method chooses to have <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">theta</span> <span class="pre">&lt;=</span>
<span class="pre">pi</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an AngleAxis with <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">theta</span> <span class="pre">&lt;=</span> <span class="pre">pi</span></code> and a unit vector
<code class="docutils literal"><span class="pre">lambda</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[Expression].ToQuaternion">
<code class="descname">ToQuaternion</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.common.eigen_geometry.Quaternion_[Expression]<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].ToQuaternion" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a quaternion q that represents <code class="docutils literal"><span class="pre">this</span></code> RotationMatrix. Since
the quaternion <code class="docutils literal"><span class="pre">q</span></code> and <code class="docutils literal"><span class="pre">-q</span></code> represent the same RotationMatrix,
this method chooses to return a canonical quaternion, i.e., with q(0)
&gt;= 0.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is a constructor in the RollPitchYaw class that converts a
rotation matrix to roll-pitch-yaw angles.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[Expression].transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.math.RotationMatrix_[Expression].transpose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.math.RotationMatrix_[float]">
<em class="property">class </em><code class="descclassname">pydrake.math.</code><code class="descname">RotationMatrix_[float]</code><a class="headerlink" href="#pydrake.math.RotationMatrix_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents a 3x3 rotation matrix between two arbitrary
frames A and B and helps ensure users create valid rotation matrices.
This class relates right-handed orthogonal unit vectors Ax, Ay, Az
fixed in frame A to right-handed orthogonal unit vectors Bx, By, Bz
fixed in frame B. The monogram notation for the rotation matrix
relating A to B is <code class="docutils literal"><span class="pre">R_AB</span></code>. An example that gives context to this
rotation matrix is <code class="docutils literal"><span class="pre">v_A</span> <span class="pre">=</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">v_B</span></code>, where <code class="docutils literal"><span class="pre">v_B</span></code> denotes an
arbitrary vector v expressed in terms of Bx, By, Bz and <code class="docutils literal"><span class="pre">v_A</span></code>
denotes vector v expressed in terms of Ax, Ay, Az. See
multibody_quantities for monogram notation for dynamics. See
orientation_discussion “a discussion on rotation matrices”.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the frames associated with a rotation
matrix nor does it enforce strict proper usage of this class with
vectors.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When assertions are enabled, several methods in this class do a
validity check and throw an exception (RuntimeError) if the
rotation matrix is invalid. When assertions are disabled, many of
these validity checks are skipped (which helps improve speed). In
addition, these validity tests are only performed for scalar types
for which drake::scalar_predicate&lt;T&gt;::is_bool is <code class="docutils literal"><span class="pre">True</span></code>. For
instance, validity checks are not performed when T is
symbolic::Expression.</p>
</div>
<dl class="docutils">
<dt>Authors:</dt>
<dd>Paul Mitiguy (2018) Original author.</dd>
<dt>Authors:</dt>
<dd>Drake team (see <a class="reference external" href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</dd>
</dl>
<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RotationMatrix_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.math.RotationMatrix_[float]) -&gt; None</li>
</ol>
<p>Constructs a 3x3 identity RotationMatrix – which corresponds to
aligning two frames (so that unit vectors Ax = Bx, Ay = By, Az = Bz).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.math.RotationMatrix_[float], other: pydrake.math.RotationMatrix_[float]) -&gt; None</li>
<li>__init__(self: pydrake.math.RotationMatrix_[float], R: numpy.ndarray[numpy.float64[3, 3]]) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from a Matrix3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>an allegedly valid rotation matrix.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if R fails IsValid(R).</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.math.RotationMatrix_[float], quaternion: Eigen::Quaternion&lt;double, 0&gt;) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from an Eigen::Quaternion.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">quaternion</span></code>:</dt>
<dd>a non-zero, finite quaternion which may or may not have unit
length [i.e., <code class="docutils literal"><span class="pre">quaternion.norm()</span></code> does not have to be 1].</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix R that is</li>
<li>built from <code class="docutils literal"><span class="pre">quaternion</span></code> fails IsValid(R). For example, an</li>
<li>exception is thrown if <code class="docutils literal"><span class="pre">quaternion</span></code> is zero or contains a NaN or</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">infinity.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method has the effect of normalizing its <code class="docutils literal"><span class="pre">quaternion</span></code>
argument, without the inefficiency of the square-root associated
with normalization.</p>
</div>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.math.RotationMatrix_[float], theta_lambda: Eigen::AngleAxis&lt;double&gt;) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from an Eigen::AngleAxis.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta_lambda</span></code>:</dt>
<dd>an Eigen::AngleAxis whose associated axis (vector direction herein
called <code class="docutils literal"><span class="pre">lambda</span></code>) is non-zero and finite, but which may or may
not have unit length [i.e., <code class="docutils literal"><span class="pre">lambda.norm()</span></code> does not have to be
1].</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in debug builds if the rotation matrix R that is</li>
<li>built from <code class="docutils literal"><span class="pre">theta_lambda</span></code> fails IsValid(R). For example, an</li>
<li>exception is thrown if <code class="docutils literal"><span class="pre">lambda</span></code> is zero or contains a NaN or</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">infinity.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="6">
<li>__init__(self: pydrake.math.RotationMatrix_[float], rpy: drake::math::RollPitchYaw&lt;double&gt;) -&gt; None</li>
</ol>
<p>Constructs a RotationMatrix from an RollPitchYaw. In other words,
makes the RotationMatrix for a Space-fixed (extrinsic) X-Y-Z rotation
by “roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code>, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by “yaw-pitch-roll” angles <code class="docutils literal"><span class="pre">[y,</span>
<span class="pre">p,</span> <span class="pre">r]</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>radian measures of three angles [roll, pitch, yaw].</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">rpy</span></code>:</dt>
<dd>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
with “roll-pitch-yaw” angles <code class="docutils literal"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> or equivalently a Body-
fixed (intrinsic) Z-Y-X rotation with “yaw-pitch-roll” angles
<code class="docutils literal"><span class="pre">[y,</span> <span class="pre">p,</span> <span class="pre">r]</span></code>.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Denoting roll <code class="docutils literal"><span class="pre">r</span></code>, pitch <code class="docutils literal"><span class="pre">p</span></code>, yaw <code class="docutils literal"><span class="pre">y</span></code>, this method returns a
rotation matrix <code class="docutils literal"><span class="pre">R_AD</span></code> equal to the matrix multiplication shown
below.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
       ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
     =       R_AB          *        R_BC          *        R_CD
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this discussion, A is the Space frame and D is the Body frame.
One way to visualize this rotation sequence is by introducing
intermediate frames B and C (useful constructs to understand this
rotation sequence). Initially, the frames are aligned so <code class="docutils literal"><span class="pre">Di</span> <span class="pre">=</span> <span class="pre">Ci</span>
<span class="pre">=</span> <span class="pre">Bi</span> <span class="pre">=</span> <span class="pre">Ai</span> <span class="pre">(i</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>. Then D is subjected to successive
right-handed rotations relative to A.</p>
</div>
<ul class="simple">
<li>1st rotation R_CD: Frame D rotates relative to frames C, B, A by a</li>
</ul>
<p>roll angle <code class="docutils literal"><span class="pre">r</span></code> about <code class="docutils literal"><span class="pre">Dx</span> <span class="pre">=</span> <span class="pre">Cx</span></code>.  Note: D and C are no longer aligned.</p>
<ul class="simple">
<li>2nd rotation R_BC: Frames D, C (collectively – as if welded together)</li>
</ul>
<p>rotate relative to frame B, A by a pitch angle <code class="docutils literal"><span class="pre">p</span></code> about <code class="docutils literal"><span class="pre">Cy</span> <span class="pre">=</span> <span class="pre">By</span></code>.
Note: C and B are no longer aligned.</p>
<ul class="simple">
<li>3rd rotation R_AB: Frames D, C, B (collectively – as if welded)</li>
</ul>
<p>rotate relative to frame A by a roll angle <code class="docutils literal"><span class="pre">y</span></code> about <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>.
Note: B and A are no longer aligned.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method constructs a RotationMatrix from a RollPitchYaw.
Vice-versa, there are high-accuracy RollPitchYaw
constructor/methods that form a RollPitchYaw from a rotation
matrix.</p>
</div>
</dd></dl>

<dl class="template">
<dt id="pydrake.math.RotationMatrix_[float].cast">
<em class="property">template </em><code class="descname">cast</code><a class="headerlink" href="#pydrake.math.RotationMatrix_[float].cast" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.math.RotationMatrix_[float].cast.cast[float]" title="pydrake.math.RotationMatrix_[float].cast.cast[float]"><code class="xref py py-class docutils literal"><span class="pre">cast[float]</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">cast[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal"><span class="pre">cast[Expression]</span></code></p>
<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].cast.cast[float]">
<code class="descname">cast[float]</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].cast.cast[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RotationMatrix is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].cast[AutoDiffXd]">
<code class="descname">cast[AutoDiffXd]</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; drake::math::RotationMatrix&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].cast[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RotationMatrix is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].cast[Expression]">
<code class="descname">cast[Expression]</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; drake::math::RotationMatrix&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].cast[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RotationMatrix is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].cast[float]">
<code class="descname">cast[float]</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].cast[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">U</span></code>:</dt>
<dd>Scalar type on which the returned RotationMatrix is templated.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal"><span class="pre">To</span></code> is constructible from type <code class="docutils literal"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].col">
<code class="descname">col</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float], index: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].col" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> rotation matrix’s iᵗʰ column (i = 0, 1, 2). For
<code class="docutils literal"><span class="pre">this</span></code> rotation matrix R_AB (which relates right-handed sets of
orthogonal unit vectors Ax, Ay, Az to Bx, By, Bz), - col(0) returns
Bx_A (Bx expressed in terms of Ax, Ay, Az). - col(1) returns By_A (By
expressed in terms of Ax, Ay, Az). - col(2) returns Bz_A (Bz expressed
in terms of Ax, Ay, Az).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">index</span></code>:</dt>
<dd>requested column index (0 &lt;= index &lt;= 2).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">row(), matrix()</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">In debug builds, asserts (0 &lt;= index &lt;= 2).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For efficiency and consistency with Eigen, this method returns the
same quantity returned by Eigen’s col() operator. The returned
quantity can be assigned in various ways, e.g., as <code class="docutils literal"><span class="pre">const</span> <span class="pre">auto&amp;</span>
<span class="pre">Bz_A</span> <span class="pre">=</span> <span class="pre">col(2);</span></code> or <code class="docutils literal"><span class="pre">Vector3&lt;T&gt;</span> <span class="pre">Bz_A</span> <span class="pre">=</span> <span class="pre">col(2);</span></code></p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_[float].Identity">
<em class="property">static </em><code class="descname">Identity</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].Identity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].IsExactlyIdentity">
<code class="descname">IsExactlyIdentity</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].IsExactlyIdentity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> is exactly equal to the identity matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].IsIdentityToInternalTolerance">
<code class="descname">IsIdentityToInternalTolerance</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].IsIdentityToInternalTolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal"><span class="pre">this</span></code> is equal to the identity matrix to within the
threshold of get_internal_tolerance_for_orthonormality().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].IsValid">
<code class="descname">IsValid</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].IsValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if <code class="docutils literal"><span class="pre">this</span></code> rotation matrix R is a proper orthonormal rotation
matrix to within the threshold of
get_internal_tolerance_for_orthonormality().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if <code class="docutils literal"><span class="pre">this</span></code> is a valid rotation matrix.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_[float].MakeXRotation">
<em class="property">static </em><code class="descname">MakeXRotation</code><span class="sig-paren">(</span><em>theta: float</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].MakeXRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal"><span class="pre">theta</span></code> about unit vector <code class="docutils literal"><span class="pre">Ax</span> <span class="pre">=</span>
<span class="pre">Bx</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta</span></code>:</dt>
<dd>radian measure of rotation angle about Ax.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitX().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal"><span class="pre">theta</span></code> about <code class="docutils literal"><span class="pre">Ax</span> <span class="pre">=</span> <span class="pre">Bx</span></code>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡ 1       0                 0  ⎤
R_AB = ⎢ 0   cos(theta)   -sin(theta) ⎥
       ⎣ 0   sin(theta)    cos(theta) ⎦
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_[float].MakeYRotation">
<em class="property">static </em><code class="descname">MakeYRotation</code><span class="sig-paren">(</span><em>theta: float</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].MakeYRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal"><span class="pre">theta</span></code> about unit vector <code class="docutils literal"><span class="pre">Ay</span> <span class="pre">=</span>
<span class="pre">By</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta</span></code>:</dt>
<dd>radian measure of rotation angle about Ay.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitY().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal"><span class="pre">theta</span></code> about <code class="docutils literal"><span class="pre">Ay</span> <span class="pre">=</span> <span class="pre">By</span></code>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡  cos(theta)   0   sin(theta) ⎤
R_AB = ⎢          0    1           0  ⎥
       ⎣ -sin(theta)   0   cos(theta) ⎦
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_[float].MakeZRotation">
<em class="property">static </em><code class="descname">MakeZRotation</code><span class="sig-paren">(</span><em>theta: float</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].MakeZRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal"><span class="pre">theta</span></code> about unit vector <code class="docutils literal"><span class="pre">Az</span> <span class="pre">=</span>
<span class="pre">Bz</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">theta</span></code>:</dt>
<dd>radian measure of rotation angle about Az.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitZ().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal"><span class="pre">theta</span></code> about <code class="docutils literal"><span class="pre">Az</span> <span class="pre">=</span> <span class="pre">Bz</span></code>.</p>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>⎡ cos(theta)  -sin(theta)   0 ⎤
R_AB = ⎢ sin(theta)   cos(theta)   0 ⎥
       ⎣         0            0    1 ⎦
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].matrix">
<code class="descname">matrix</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 3]]<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Matrix3 underlying a RotationMatrix.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">col(), row()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].multiply">
<code class="descname">multiply</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RotationMatrix_[float].multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>multiply(self: pydrake.math.RotationMatrix_[float], other: pydrake.math.RotationMatrix_[float]) -&gt; pydrake.math.RotationMatrix_[float]</li>
</ol>
<p>Calculates <code class="docutils literal"><span class="pre">this</span></code> rotation matrix <code class="docutils literal"><span class="pre">R_AB</span></code> multiplied by <code class="docutils literal"><span class="pre">other</span></code>
rotation matrix <code class="docutils literal"><span class="pre">R_BC</span></code>, returning the composition <code class="docutils literal"><span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">R_BC</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">other</span></code>:</dt>
<dd>RotationMatrix that post-multiplies <code class="docutils literal"><span class="pre">this</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">rotation matrix that results from <code class="docutils literal"><span class="pre">this</span></code> multiplied by
<code class="docutils literal"><span class="pre">other</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is possible (albeit improbable) to create an invalid rotation
matrix by accumulating round-off error with a large number of
multiplies.</p>
</div>
<ol class="arabic simple" start="2">
<li>multiply(self: pydrake.math.RotationMatrix_[float], v_B: numpy.ndarray[numpy.float64[3, 1]]) -&gt; numpy.ndarray[numpy.float64[3, 1]]</li>
</ol>
<p>Calculates <code class="docutils literal"><span class="pre">this</span></code> rotation matrix <code class="docutils literal"><span class="pre">R_AB</span></code> multiplied by an
arbitrary Vector3 expressed in the B frame.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">v_B</span></code>:</dt>
<dd>3x1 vector that post-multiplies <code class="docutils literal"><span class="pre">this</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">3x1 vector <code class="docutils literal"><span class="pre">v_A</span> <span class="pre">=</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">v_B</span></code>.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>multiply(self: pydrake.math.RotationMatrix_[float], v_B: numpy.ndarray[numpy.float64[3, n]]) -&gt; numpy.ndarray[numpy.float64[3, n]]</li>
</ol>
<p>Multiplies <code class="docutils literal"><span class="pre">this</span></code> RotationMatrix <code class="docutils literal"><span class="pre">R_AB</span></code> by the n vectors <code class="docutils literal"><span class="pre">v1</span></code>,
… <cite>vn</cite>, where each vector has 3 elements and is expressed in frame
B.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">v_B</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix whose n columns are regarded as arbitrary vectors
<code class="docutils literal"><span class="pre">v1</span></code>, … <cite>vn</cite> expressed in frame B.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">v_A</span></code>:</dt>
<dd><code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix whose n columns are vectors <code class="docutils literal"><span class="pre">v1</span></code>, … <cite>vn</cite>
expressed in frame A.</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">rpy</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">);</span>
<span class="n">const</span> <span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">R_AB</span><span class="p">(</span><span class="n">rpy</span><span class="p">);</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">v_B</span><span class="p">;</span>
<span class="n">v_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">v_B</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Vector3d</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">const</span> <span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">v_A</span> <span class="o">=</span> <span class="n">R_AB</span> <span class="o">*</span> <span class="n">v_B</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.math.RotationMatrix_[float].ProjectToRotationMatrix">
<em class="property">static </em><code class="descname">ProjectToRotationMatrix</code><span class="sig-paren">(</span><em>M: numpy.ndarray[numpy.float64[3, 3]]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].ProjectToRotationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an approximate rotation matrix M, finds the RotationMatrix R
closest to M. Closeness is measured with a matrix-2 norm (or
equivalently with a Frobenius norm). Hence, this method creates a
RotationMatrix R from a 3x3 matrix M by minimizing <code class="docutils literal"><span class="pre">‖R</span> <span class="pre">-</span> <span class="pre">M‖₂</span></code> (the
matrix-2 norm of (R-M)) subject to <code class="docutils literal"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">Rᵀ</span> <span class="pre">=</span> <span class="pre">I</span></code>, where I is the 3x3
identity matrix. For this problem, closeness can also be measured by
forming the orthonormal matrix R whose elements minimize the
double-summation <code class="docutils literal"><span class="pre">∑ᵢ</span> <span class="pre">∑ⱼ</span> <span class="pre">(R(i,j)</span> <span class="pre">-</span> <span class="pre">M(i,j))²</span></code> where <code class="docutils literal"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">1:3,</span> <span class="pre">j</span> <span class="pre">=</span>
<span class="pre">1:3</span></code>, subject to <code class="docutils literal"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">Rᵀ</span> <span class="pre">=</span> <span class="pre">I</span></code>. The square-root of this
double-summation is called the Frobenius norm.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">M</span></code>:</dt>
<dd>a 3x3 matrix.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">quality_factor</span></code>:</dt>
<dd>. The quality of M as a rotation matrix. <code class="docutils literal"><span class="pre">quality_factor</span></code> = 1 is
perfect (M = R). <code class="docutils literal"><span class="pre">quality_factor</span></code> = 1.25 means that when M
multiplies a unit vector (magnitude 1), a vector of magnitude as
large as 1.25 may result. <code class="docutils literal"><span class="pre">quality_factor</span></code> = 0.8 means that when
M multiplies a unit vector, a vector of magnitude as small as 0.8
may result. <code class="docutils literal"><span class="pre">quality_factor</span></code> = 0 means M is singular, so at
least one of the bases related by matrix M does not span 3D space
(when M multiples a unit vector, a vector of magnitude as small as
0 may result).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">proper orthonormal matrix R that is closest to M.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if R fails IsValid(R).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">William Kahan (UC Berkeley) and Hongkai Dai (Toyota Research
Institute) proved that for this problem, the same R that minimizes
the Frobenius norm also minimizes the matrix-2 norm (a.k.a an
induced-2 norm), which is defined [Dahleh, Section 4.2] as the
column matrix u which maximizes <code class="docutils literal"><span class="pre">‖(R</span> <span class="pre">-</span> <span class="pre">M)</span> <span class="pre">u‖</span> <span class="pre">/</span> <span class="pre">‖u‖</span></code>, where <code class="docutils literal"><span class="pre">u</span> <span class="pre">≠</span>
<span class="pre">0</span></code>. Since the matrix-2 norm of any matrix A is equal to the
maximum singular value of A, minimizing the matrix-2 norm of (R -
M) is equivalent to minimizing the maximum singular value of (R -
M).</p>
</div>
<ul class="simple">
<li>[Dahleh] “Lectures on Dynamic Systems and Controls: Electrical</li>
</ul>
<p>Engineering and Computer Science, Massachusetts Institute of Technology”
<a class="reference external" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf</a></p>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].row">
<code class="descname">row</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float], index: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[1, 3]]<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].row" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">this</span></code> rotation matrix’s iᵗʰ row (i = 0, 1, 2). For <code class="docutils literal"><span class="pre">this</span></code>
rotation matrix R_AB (which relates right-handed sets of orthogonal
unit vectors Ax, Ay, Az to Bx, By, Bz), - row(0) returns Ax_B (Ax
expressed in terms of Bx, By, Bz). - row(1) returns Ay_B (Ay expressed
in terms of Bx, By, Bz). - row(2) returns Az_B (Az expressed in terms
of Bx, By, Bz).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">index</span></code>:</dt>
<dd>requested row index (0 &lt;= index &lt;= 2).</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">col(), matrix()</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">In debug builds, asserts (0 &lt;= index &lt;= 2).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For efficiency and consistency with Eigen, this method returns the
same quantity returned by Eigen’s row() operator. The returned
quantity can be assigned in various ways, e.g., as <code class="docutils literal"><span class="pre">const</span> <span class="pre">auto&amp;</span>
<span class="pre">Az_B</span> <span class="pre">=</span> <span class="pre">row(2);</span></code> or <code class="docutils literal"><span class="pre">RowVector3&lt;T&gt;</span> <span class="pre">Az_B</span> <span class="pre">=</span> <span class="pre">row(2);</span></code></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].set">
<code class="descname">set</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float], R: numpy.ndarray[numpy.float64[3, 3]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal"><span class="pre">this</span></code> RotationMatrix from a Matrix3.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">R</span></code>:</dt>
<dd>an allegedly valid rotation matrix.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError in debug builds if R fails IsValid(R).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].ToAngleAxis">
<code class="descname">ToAngleAxis</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; Eigen::AngleAxis&lt;double&gt;<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].ToAngleAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an AngleAxis <code class="docutils literal"><span class="pre">theta_lambda</span></code> containing an angle <code class="docutils literal"><span class="pre">theta</span></code>
and unit vector (axis direction) <code class="docutils literal"><span class="pre">lambda</span></code> that represents <code class="docutils literal"><span class="pre">this</span></code>
RotationMatrix.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The orientation and RotationMatrix associated with <code class="docutils literal"><span class="pre">theta</span> <span class="pre">*</span>
<span class="pre">lambda</span></code> is identical to that of <code class="docutils literal"><span class="pre">(-theta)</span> <span class="pre">*</span> <span class="pre">(-lambda)</span></code>. The
AngleAxis returned by this method chooses to have <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">theta</span> <span class="pre">&lt;=</span>
<span class="pre">pi</span></code>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an AngleAxis with <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">theta</span> <span class="pre">&lt;=</span> <span class="pre">pi</span></code> and a unit vector
<code class="docutils literal"><span class="pre">lambda</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].ToQuaternion">
<code class="descname">ToQuaternion</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; Eigen::Quaternion&lt;double, 0&gt;<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].ToQuaternion" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a quaternion q that represents <code class="docutils literal"><span class="pre">this</span></code> RotationMatrix. Since
the quaternion <code class="docutils literal"><span class="pre">q</span></code> and <code class="docutils literal"><span class="pre">-q</span></code> represent the same RotationMatrix,
this method chooses to return a canonical quaternion, i.e., with q(0)
&gt;= 0.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is a constructor in the RollPitchYaw class that converts a
rotation matrix to roll-pitch-yaw angles.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.math.RotationMatrix_[float].transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><em>self: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.math.RotationMatrix_[float].transpose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.math.sin">
<code class="descclassname">pydrake.math.</code><code class="descname">sin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>sin(arg0: float) -&gt; float</li>
<li>sin(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>sin(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.sinh">
<code class="descclassname">pydrake.math.</code><code class="descname">sinh</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.sinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>sinh(arg0: float) -&gt; float</li>
<li>sinh(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>sinh(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.sqrt">
<code class="descclassname">pydrake.math.</code><code class="descname">sqrt</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>sqrt(arg0: float) -&gt; float</li>
<li>sqrt(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>sqrt(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.tan">
<code class="descclassname">pydrake.math.</code><code class="descname">tan</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.tan" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>tan(arg0: float) -&gt; float</li>
<li>tan(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>tan(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.tanh">
<code class="descclassname">pydrake.math.</code><code class="descname">tanh</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.tanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>tanh(arg0: float) -&gt; float</li>
<li>tanh(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
<li>tanh(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="pydrake.math.wrap_to">
<code class="descclassname">pydrake.math.</code><code class="descname">wrap_to</code><span class="sig-paren">(</span><em>value: float</em>, <em>low: float</em>, <em>high: float</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.math.wrap_to" title="Permalink to this definition">¶</a></dt>
<dd><p>For variables that are meant to be periodic, (e.g. over a 2π
interval), wraps <code class="docutils literal"><span class="pre">value</span></code> into the interval <code class="docutils literal"><span class="pre">[low,</span> <span class="pre">high)</span></code>.
Precisely, <code class="docutils literal"><span class="pre">wrap_to</span></code> returns: value + k*(high-low) for the unique
integer value <code class="docutils literal"><span class="pre">k</span></code> that lands the output in the desired interval.
<code class="docutils literal"><span class="pre">low</span></code> and <code class="docutils literal"><span class="pre">high</span></code> must be finite, and low &lt; high.</p>
</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pydrake.multibody.html" class="btn btn-neutral float-right" title="pydrake.multibody" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pydrake.manipulation.simple_ui.html" class="btn btn-neutral" title="pydrake.manipulation.simple_ui" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
<footer class="footer">
   <div class="wrap grid">
      <a href="/" class="footer__logo">
      <img src="_static/drake-logo.svg" class="footer__logo__img">
      </a>
      <div class="menu__wrap">
         <ul class="menu__list">
            <li class="menu__list__item menu__list__item__link button--text">
               <a href="https://drake.mit.edu/doxygen_cxx/index.html" class="menu__list__item__link button--text">C++</a>
            </li>
            <li class="menu__list__item menu__list__item__link button--text">
               <a href="https://drake.mit.edu/pydrake/index.html" class="menu__list__item__link button--text">Python</a>
            </li>
            <li class="menu__list__item menu__list__item__link button--text github--link">
               <a href="https://github.com/RobotLocomotion/drake" class="menu__list__item__link button--text">
               Github <img src="_static/github.svg">
               </a>
            </li>
         </ul>
      </div>
   </div>
   <div class="footer__copyright wrap">
      <span class="footnote">© 2020 Drake - Robot Locomotion Group (MIT)</span>
   </div>
</footer>


</body>
</html>