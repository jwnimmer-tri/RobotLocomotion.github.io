

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydrake.geometry &mdash; pydrake  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="pydrake  documentation" href="index.html"/>
        <link rel="next" title="pydrake.geometry.all" href="pydrake.geometry.all.html"/>
        <link rel="prev" title="pydrake.forwarddiff" href="pydrake.forwarddiff.html"/>
<header class="header--main black-back">
   <div class="wrap grid__2-col">
      <a href="https://drake.mit.edu" class="header__logo">
      <img src="_static/drake-logo-white.svg" class="header__logo__img">
      </a>
      <div class="menu__toggle js-menu-toggle">
         <div class="menu__toggle__icon"><span></span></div>
      </div>
      <nav class="header__menu">
         <div class="menu__wrap">
            <ul class="menu__list">
               <li class="menu__list__item menu__list__item__link button--text">
                  <!-- TODO(jwnimmer-tri) Change to quickstart.html once that page exists. -->
                  <a href="https://drake.mit.edu/installation.html" class="menu__list__item__link button--text">Quickstart</a>
               </li>
               <li class="menu__list__item menu__list__item__link button--text">
                  <a href="https://drake.mit.edu/gallery.html" class="menu__list__item__link button--text">Gallery</a>
               </li>
               <li class="menu__list__item menu__list__item__link button--text">
                  API Documentation
                  <div class="menu_sub">
                     <a href="https://drake.mit.edu/doxygen_cxx/index.html" class="menu__list__item__link button--text">C++</a>
                     <a href="https://drake.mit.edu/pydrake/index.html" class="menu__list__item__link button--text">Python</a>
                  </div>
               </li>
               <li class="menu__list__item menu__list__item__link button--text">
                  Resources
                  <div class="menu_sub">
                     <a href="https://drake.mit.edu/getting_help.html" class="menu__list__item__link button--text">Getting Help</a>
                     <a href="https://github.com/RobotLocomotion/drake/tree/master/tutorials" class="menu__list__item__link button--text">Tutorials</a>
                     <a href="https://drake.mit.edu/developers.html" class="menu__list__item__link button--text">For Developers</a>
                     <a href="https://drake.mit.edu/credits.html" class="menu__list__item__link button--text">Credits</a>
                  </div>
               </li>
               <li class="menu__list__item menu__list__item__link button--text github--link">
                  <a href="https://github.com/RobotLocomotion/drake" class="menu__list__item__link button--text">Github <img src="_static/github-white.svg"></a>
               </li>
            </ul>
         </div>
      </nav>
   </div>
</header>


  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> pydrake
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">pydrake.geometry</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pydrake.geometry.all.html">pydrake.geometry.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.geometry.render.html">pydrake.geometry.render</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>pydrake.geometry</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pydrake-geometry">
<h1>pydrake.geometry<a class="headerlink" href="#pydrake-geometry" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.all.html">pydrake.geometry.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.render.html">pydrake.geometry.render</a></li>
</ul>
</div>
<span class="target" id="module-pydrake.geometry"></span><dl class="class">
<dt id="pydrake.geometry.Box">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">Box</code><a class="headerlink" href="#pydrake.geometry.Box" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.Shape</span></code></a></p>
<p>Definition of a box. The box is centered on the origin of its
canonical frame with its dimensions aligned with the frame’s axes. The
size of the box is given by three sizes.</p>
<dl class="method">
<dt id="pydrake.geometry.Box.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Box</em>, <em>width: float</em>, <em>depth: float</em>, <em>height: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.Box.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a box with the given <code class="docutils literal"><span class="pre">width</span></code>, <cite>depth</cite>, and <code class="docutils literal"><span class="pre">height</span></code>,
which specify the box’s dimension along the canonical x-, y-, and
z-axes, respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">width</span></code>, <cite>depth</cite> or <code class="docutils literal"><span class="pre">height</span></code> are not strictly</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">positive.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Box.depth">
<code class="descname">depth</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Box</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Box.depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the box’s dimension along the y axis.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Box.height">
<code class="descname">height</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Box</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Box.height" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the box’s dimension along the z axis.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Box.size">
<code class="descname">size</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Box</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.geometry.Box.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the box’s dimensions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Box.width">
<code class="descname">width</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Box</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Box.width" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the box’s dimension along the x axis.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.Capsule">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">Capsule</code><a class="headerlink" href="#pydrake.geometry.Capsule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.Shape</span></code></a></p>
<p>Definition of a capsule. It is centered in its canonical frame with
the length of the capsule parallel with the frame’s z-axis.</p>
<dl class="method">
<dt id="pydrake.geometry.Capsule.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Capsule</em>, <em>radius: float</em>, <em>length: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.Capsule.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a capsule with the given <code class="docutils literal"><span class="pre">radius</span></code> and <code class="docutils literal"><span class="pre">length</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">radius</span></code> or <code class="docutils literal"><span class="pre">length</span></code> are not strictly</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">positive.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Capsule.length">
<code class="descname">length</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Capsule</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Capsule.length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Capsule.radius">
<code class="descname">radius</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Capsule</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Capsule.radius" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.geometry.ConnectDrakeVisualizer">
<code class="descclassname">pydrake.geometry.</code><code class="descname">ConnectDrakeVisualizer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.ConnectDrakeVisualizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>ConnectDrakeVisualizer(builder: pydrake.systems.framework.DiagramBuilder_[float], scene_graph: drake::geometry::SceneGraph&lt;double&gt;, lcm: pydrake.lcm.DrakeLcmInterface = None, role: pydrake.geometry.Role = Role.kIllustration) -&gt; pydrake.systems.lcm.LcmPublisherSystem</li>
</ol>
<p>Extends a Diagram with the required components to interface with
drake_visualizer. This must be called <em>during</em> Diagram building and
uses the given <code class="docutils literal"><span class="pre">builder</span></code> to add relevant subsystems and connections.</p>
<p>This is a convenience method to simplify some common boilerplate for
adding visualization capability to a Diagram. What it does is:</p>
<ul class="simple">
<li>adds an initialization event that sends the required load message to set up</li>
</ul>
<p>the visualizer with the relevant geometry,
- adds systems PoseBundleToDrawMessage and LcmPublisherSystem to
the Diagram and connects the draw message output to the publisher input,
- connects the <code class="docutils literal"><span class="pre">scene_graph</span></code> pose bundle output to the PoseBundleToDrawMessage
system, and
- sets the publishing rate to 1/60 of a second (simulated time).</p>
<p>The visualization mechanism depends on the illustration role (see
geometry_roles for details). Specifically, only geometries with the
illustration role assigned will be included. The visualization
function looks for the following properties in the
IllustrationProperties instance.</p>
<div class="line-block">
<div class="line">Group name | Required | Property Name | Property Type | Property</div>
</div>
<p>Description | | :——–: | :——: | :———–: |
:————-: | :——————- | | phong | no | diffuse |
Eigen::Vector4d | The rgba value of the object surface |</p>
<p>See MakePhongIllustrationProperties() to facilitate making a compliant
set of illustration properties.</p>
<p>You can then connect source output ports for visualization like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">builder</span><span class="o">-&gt;</span><span class="n">Connect</span><span class="p">(</span><span class="n">pose_output_port</span><span class="p">,</span>
<span class="n">scene_graph</span><span class="o">.</span><span class="n">get_source_pose_port</span><span class="p">(</span><span class="n">source_id</span><span class="p">));</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The initialization event occurs when Simulator::Initialize() is
called (explicitly or implicitly at the start of a simulation). If
you aren’t going to be using a Simulator, use
DispatchLoadMessage() to send the message yourself.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">builder</span></code>:</dt>
<dd>The diagram builder being used to construct the Diagram.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">scene_graph</span></code>:</dt>
<dd>The System in <code class="docutils literal"><span class="pre">builder</span></code> containing the geometry to be
visualized.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">lcm</span></code>:</dt>
<dd>An optional lcm interface through which lcm messages will be
dispatched. Will be allocated internally if none is supplied.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">role</span></code>:</dt>
<dd>An optional flag to indicate the role of the geometries to be
visualized; defaults to the illustration role.</dd>
<dt>Precondition:</dt>
<dd>This method has not been previously called while building the
builder’s current Diagram.</dd>
<dt>Precondition:</dt>
<dd>The given <code class="docutils literal"><span class="pre">scene_graph</span></code> must be contained within the supplied
DiagramBuilder.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the LcmPublisherSystem (in case callers, e.g., need to change the
default publishing rate).</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">geometry::DispatchLoadMessage()</p>
</div>
<ol class="arabic simple" start="2">
<li>ConnectDrakeVisualizer(builder: pydrake.systems.framework.DiagramBuilder_[float], scene_graph: drake::geometry::SceneGraph&lt;double&gt;, pose_bundle_output_port: pydrake.systems.framework.OutputPort_[float], lcm: pydrake.lcm.DrakeLcmInterface = None, role: pydrake.geometry.Role = Role.kIllustration) -&gt; pydrake.systems.lcm.LcmPublisherSystem</li>
</ol>
<p>Implements ConnectDrakeVisualizer, but using
<code class="docutils literal"><span class="pre">pose_bundle_output_port</span></code> to explicitly specify the output port used
to get pose bundles for <code class="docutils literal"><span class="pre">scene_graph</span></code>. This is required, for
instance, when the SceneGraph is inside a Diagram, and the Diagram
exports the pose bundle port.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>pose_bundle_output_port must be connected directly to the
pose_bundle_output_port of <code class="docutils literal"><span class="pre">scene_graph</span></code>.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ConnectDrakeVisualizer().</p>
</div>
</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.Convex">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">Convex</code><a class="headerlink" href="#pydrake.geometry.Convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.Shape</span></code></a></p>
<p>Support for convex shapes.</p>
<dl class="method">
<dt id="pydrake.geometry.Convex.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Convex</em>, <em>absolute_filename: str</em>, <em>scale: float = 1.0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.Convex.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a convex shape specification from the file located at the
given <em>absolute</em> file path. Optionally uniformly scaled by the given
scale factor.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">absolute_filename</span></code>:</dt>
<dd>The file name with absolute path. We only support an .obj file
with only one polyhedron. We assume that the polyhedron is convex.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">scale</span></code>:</dt>
<dd>An optional scale to coordinates.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the .obj file doesn’t define a single object. This</li>
<li>can happen if it is empty, if there are multiple object-name</li>
<li>statements (e.g., “o object_name”), or if there are faces defined</li>
<li>outside a single object-name statement.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <a href="#id4"><span class="problematic" id="id5">|scale|</span></a> &lt; 1e-8. Note that a negative scale is</li>
<li>considered valid. We want to preclude scales near zero but</li>
<li>recognise that scale is a convenience tool for “tweaking” models.</li>
<li>8 orders of magnitude should be plenty without considering</li>
<li>revisiting the model itself.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Convex.filename">
<code class="descname">filename</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Convex</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.Convex.filename" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Convex.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Convex</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Convex.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.Cylinder">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">Cylinder</code><a class="headerlink" href="#pydrake.geometry.Cylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.Shape</span></code></a></p>
<p>Definition of a cylinder. It is centered in its canonical frame with
the length of the cylinder parallel with the frame’s z-axis.</p>
<dl class="method">
<dt id="pydrake.geometry.Cylinder.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Cylinder</em>, <em>radius: float</em>, <em>length: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.Cylinder.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a cylinder with the given <code class="docutils literal"><span class="pre">radius</span></code> and <code class="docutils literal"><span class="pre">length</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">radius</span></code> or <code class="docutils literal"><span class="pre">length</span></code> are not strictly</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">positive.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Cylinder.length">
<code class="descname">length</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Cylinder</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Cylinder.length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Cylinder.radius">
<code class="descname">radius</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Cylinder</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Cylinder.radius" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.geometry.DispatchLoadMessage">
<code class="descclassname">pydrake.geometry.</code><code class="descname">DispatchLoadMessage</code><span class="sig-paren">(</span><em>scene_graph: drake::geometry::SceneGraph&lt;double&gt;</em>, <em>lcm: pydrake.lcm.DrakeLcmInterface</em>, <em>role: pydrake.geometry.Role = Role.kIllustration</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.DispatchLoadMessage" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Explicitly dispatches an LCM load message based on the
registered geometry. Normally this is done automatically at Simulator
initialization. But if you have to do it yourself (likely because you
are not using a Simulator), it should be invoked <em>after</em> registration
is complete. Typically this is used after ConnectDrakeVisualizer() has
been used to add visualization to the Diagram that contains the given
<code class="docutils literal"><span class="pre">scene_graph</span></code>. The message goes to LCM channel
“DRAKE_VIEWER_LOAD_ROBOT”.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">geometry::ConnectDrakeVisualizer()</p>
</div>
</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.Ellipsoid">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">Ellipsoid</code><a class="headerlink" href="#pydrake.geometry.Ellipsoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.Shape</span></code></a></p>
<p>Definition of an ellipsoid. It is centered on the origin of its
canonical frame with its dimensions aligned with the frame’s axes. The
standard equation for the ellipsoid is:</p>
<p>x²/a² + y²/b² + z²/c² = 1, where a,b,c are the lengths of the
principal semi-axes of the ellipsoid. The bounding box of the
ellipsoid is [-a,a]x[-b,b]x[-c,c].</p>
<dl class="method">
<dt id="pydrake.geometry.Ellipsoid.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Ellipsoid</em>, <em>a: float</em>, <em>b: float</em>, <em>c: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.Ellipsoid.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an ellipsoid with the given lengths of its principal
semi-axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">a</span></code>, <cite>b</cite>, or <code class="docutils literal"><span class="pre">c</span></code> are not strictly positive.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Ellipsoid.a">
<code class="descname">a</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Ellipsoid</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Ellipsoid.a" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Ellipsoid.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Ellipsoid</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Ellipsoid.b" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Ellipsoid.c">
<code class="descname">c</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Ellipsoid</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Ellipsoid.c" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.FrameId">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">FrameId</code><a class="headerlink" href="#pydrake.geometry.FrameId" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify geometry frames in SceneGraph.</p>
<dl class="attribute">
<dt id="pydrake.geometry.FrameId.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.geometry.FrameId.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.FrameId.get_new_id">
<em class="property">static </em><code class="descname">get_new_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.geometry.FrameId<a class="headerlink" href="#pydrake.geometry.FrameId.get_new_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a new identifier for this id type. This new identifier will
be different from all previous identifiers created. This method does
<em>not</em> make any guarantees about the values of ids from successive
invocations. This method is guaranteed to be thread safe.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FrameId.get_value">
<code class="descname">get_value</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.FrameId.get_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the underlying representation from the identifier. This is
considered invalid for invalid ids and is strictly enforced in Debug
builds.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FrameId.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.FrameId.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the id is valid.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.FramePoseVector">
<code class="descclassname">pydrake.geometry.</code><code class="descname">FramePoseVector</code><a class="headerlink" href="#pydrake.geometry.FramePoseVector" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.geometry.FramePoseVector_[float]" title="pydrake.geometry.FramePoseVector_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.FramePoseVector_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.geometry.FramePoseVector_">
<em class="property">template </em><code class="descclassname">pydrake.geometry.</code><code class="descname">FramePoseVector_</code><a class="headerlink" href="#pydrake.geometry.FramePoseVector_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.geometry.FramePoseVector_[float]" title="pydrake.geometry.FramePoseVector_[float]"><code class="xref py py-class docutils literal"><span class="pre">FramePoseVector_[float]</span></code></a>, <a class="reference internal" href="#pydrake.geometry.FramePoseVector_[AutoDiffXd]" title="pydrake.geometry.FramePoseVector_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">FramePoseVector_[AutoDiffXd]</span></code></a></p>
<dl class="class">
<dt id="pydrake.geometry.FramePoseVector_.FramePoseVector_[float]">
<em class="property">class </em><code class="descname">FramePoseVector_[float]</code><a class="headerlink" href="#pydrake.geometry.FramePoseVector_.FramePoseVector_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A FrameKinematicsVector is used to report kinematics data for
registered frames (identified by unique FrameId values) to SceneGraph.
It serves as the basis of FramePoseVector, FrameVelocityVector, and
FrameAccelerationVector.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MySystem</span> <span class="p">:</span> <span class="n">public</span> <span class="n">LeafSystem</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="n">MySystem</span><span class="p">()</span> <span class="p">{</span>
<span class="o">...</span>
<span class="n">this</span><span class="o">-&gt;</span><span class="n">DeclareAbstractOutputPort</span><span class="p">(</span>
<span class="o">&amp;</span><span class="n">AllocInConstructorSystem</span><span class="p">::</span><span class="n">CalcFramePoseOutput</span><span class="p">);</span>
<span class="o">...</span>
<span class="p">}</span>

<span class="n">private</span><span class="p">:</span>
<span class="n">void</span> <span class="n">CalcFramePoseOutput</span><span class="p">(</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">context</span><span class="p">,</span>
<span class="n">geometry</span><span class="p">::</span><span class="n">FramePoseVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">poses</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
<span class="n">poses</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">frame_ids_</span><span class="o">.</span><span class="n">size</span><span class="p">());</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="n">poses</span><span class="o">-&gt;</span><span class="n">set_value</span><span class="p">(</span><span class="n">frame_ids_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">poses_</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FrameId</span><span class="o">&gt;</span> <span class="n">frame_ids_</span><span class="p">;</span>
<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">poses_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If a System only ever emits a single frame (or small-constant-number
of frames), then there’s a shorter alternative way to write a Calc
method, using an initializer_list:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">CalcFramePoseOutput</span><span class="p">(</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">context</span><span class="p">,</span>
<span class="n">geometry</span><span class="p">::</span><span class="n">FramePoseVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">poses</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">pose</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="n">poses</span> <span class="o">=</span> <span class="p">{{</span><span class="n">frame_id_</span><span class="p">,</span> <span class="n">pose</span><span class="p">}};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>N.B. When the systems framework calls the <code class="docutils literal"><span class="pre">Calc</span></code> method, the value
pointed to by <code class="docutils literal"><span class="pre">poses</span></code> is in an unspecified state. The implementation
of <code class="docutils literal"><span class="pre">Calc</span></code> must always ensure that <code class="docutils literal"><span class="pre">poses</span></code> contains the correct
value upon return, no matter what value it started with. The easy ways
to do this are to call either <code class="docutils literal"><span class="pre">poses-&gt;clear()</span></code> or the assignment
operator <code class="docutils literal"><span class="pre">*poses</span> <span class="pre">=</span> <span class="pre">...</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">KinematicsValue</span></code>:</dt>
<dd>The underlying data type of for the order of kinematics data
(e.g., pose, velocity, or acceleration).</dd>
</dl>
<p>One should never interact with the FrameKinematicsVector class
directly. Instead, the FramePoseVector, FrameVelocityVector, and
FrameAccelerationVector classes are aliases of the
FrameKinematicsVector instantiated on specific data types
(RigidTransform, SpatialVector, and SpatialAcceleration,
respectively). Each of these data types are templated on Eigen
scalars. All supported combinations of data type and scalar type are
already available to link against in the containing library. No other
values for KinematicsValue are supported.</p>
<p>Currently, the following data types with the following scalar types
are supported:</p>
<p>Alias | Instantiation | Scalar types
—————–<a href="#id6"><span class="problematic" id="id7">|-----------------------------------------------|</span></a>————-
FramePoseVector | FrameKinematicsVector&lt;RigidTransform&lt;Scalar&gt;&gt; |
double FramePoseVector | FrameKinematicsVector&lt;RigidTransform&lt;Scalar&gt;&gt;
| AutoDiffXd FramePoseVector |
FrameKinematicsVector&lt;RigidTransform&lt;Scalar&gt;&gt; | Expression</p>
<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_.FramePoseVector_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.FramePoseVector_.FramePoseVector_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the vector using an invalid SourceId with no frames .</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_.FramePoseVector_[float].clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.FramePoseVector_.FramePoseVector_[float].clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears all values, resetting the size to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_.FramePoseVector_[float].frame_ids">
<code class="descname">frame_ids</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[float]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.FrameId]<a class="headerlink" href="#pydrake.geometry.FramePoseVector_.FramePoseVector_[float].frame_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a range object for all of the frame ids in the vector. This
is intended to be used as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>for (FrameId id : this_vector.frame_ids()) {
...
// Obtain the KinematicsValue of an id by ``this_vector.value(id)``
...
}
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_.FramePoseVector_[float].has_id">
<code class="descname">has_id</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[float], id: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.FramePoseVector_.FramePoseVector_[float].has_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports true if the given id is a member of this data.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_.FramePoseVector_[float].set_value">
<code class="descname">set_value</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[float], id: pydrake.geometry.FrameId, value: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.FramePoseVector_.FramePoseVector_[float].set_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the kinematics <code class="docutils literal"><span class="pre">value</span></code> for the frame indicated by the given
<code class="docutils literal"><span class="pre">id</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_.FramePoseVector_[float].size">
<code class="descname">size</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.FramePoseVector_.FramePoseVector_[float].size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of frame_ids().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_.FramePoseVector_[float].value">
<code class="descname">value</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[float], id: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.FramePoseVector_.FramePoseVector_[float].value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value associated with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> is not in the specified set of ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.FramePoseVector_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">FramePoseVector_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.geometry.FramePoseVector_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>A FrameKinematicsVector is used to report kinematics data for
registered frames (identified by unique FrameId values) to SceneGraph.
It serves as the basis of FramePoseVector, FrameVelocityVector, and
FrameAccelerationVector.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MySystem</span> <span class="p">:</span> <span class="n">public</span> <span class="n">LeafSystem</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="n">MySystem</span><span class="p">()</span> <span class="p">{</span>
<span class="o">...</span>
<span class="n">this</span><span class="o">-&gt;</span><span class="n">DeclareAbstractOutputPort</span><span class="p">(</span>
<span class="o">&amp;</span><span class="n">AllocInConstructorSystem</span><span class="p">::</span><span class="n">CalcFramePoseOutput</span><span class="p">);</span>
<span class="o">...</span>
<span class="p">}</span>

<span class="n">private</span><span class="p">:</span>
<span class="n">void</span> <span class="n">CalcFramePoseOutput</span><span class="p">(</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">context</span><span class="p">,</span>
<span class="n">geometry</span><span class="p">::</span><span class="n">FramePoseVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">poses</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
<span class="n">poses</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">frame_ids_</span><span class="o">.</span><span class="n">size</span><span class="p">());</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="n">poses</span><span class="o">-&gt;</span><span class="n">set_value</span><span class="p">(</span><span class="n">frame_ids_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">poses_</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FrameId</span><span class="o">&gt;</span> <span class="n">frame_ids_</span><span class="p">;</span>
<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">poses_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If a System only ever emits a single frame (or small-constant-number
of frames), then there’s a shorter alternative way to write a Calc
method, using an initializer_list:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">CalcFramePoseOutput</span><span class="p">(</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">context</span><span class="p">,</span>
<span class="n">geometry</span><span class="p">::</span><span class="n">FramePoseVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">poses</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">pose</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="n">poses</span> <span class="o">=</span> <span class="p">{{</span><span class="n">frame_id_</span><span class="p">,</span> <span class="n">pose</span><span class="p">}};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>N.B. When the systems framework calls the <code class="docutils literal"><span class="pre">Calc</span></code> method, the value
pointed to by <code class="docutils literal"><span class="pre">poses</span></code> is in an unspecified state. The implementation
of <code class="docutils literal"><span class="pre">Calc</span></code> must always ensure that <code class="docutils literal"><span class="pre">poses</span></code> contains the correct
value upon return, no matter what value it started with. The easy ways
to do this are to call either <code class="docutils literal"><span class="pre">poses-&gt;clear()</span></code> or the assignment
operator <code class="docutils literal"><span class="pre">*poses</span> <span class="pre">=</span> <span class="pre">...</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">KinematicsValue</span></code>:</dt>
<dd>The underlying data type of for the order of kinematics data
(e.g., pose, velocity, or acceleration).</dd>
</dl>
<p>One should never interact with the FrameKinematicsVector class
directly. Instead, the FramePoseVector, FrameVelocityVector, and
FrameAccelerationVector classes are aliases of the
FrameKinematicsVector instantiated on specific data types
(RigidTransform, SpatialVector, and SpatialAcceleration,
respectively). Each of these data types are templated on Eigen
scalars. All supported combinations of data type and scalar type are
already available to link against in the containing library. No other
values for KinematicsValue are supported.</p>
<p>Currently, the following data types with the following scalar types
are supported:</p>
<p>Alias | Instantiation | Scalar types
—————–<a href="#id8"><span class="problematic" id="id9">|-----------------------------------------------|</span></a>————-
FramePoseVector | FrameKinematicsVector&lt;RigidTransform&lt;Scalar&gt;&gt; |
double FramePoseVector | FrameKinematicsVector&lt;RigidTransform&lt;Scalar&gt;&gt;
| AutoDiffXd FramePoseVector |
FrameKinematicsVector&lt;RigidTransform&lt;Scalar&gt;&gt; | Expression</p>
<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.FramePoseVector_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the vector using an invalid SourceId with no frames .</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_[AutoDiffXd].clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.FramePoseVector_[AutoDiffXd].clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears all values, resetting the size to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_[AutoDiffXd].frame_ids">
<code class="descname">frame_ids</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.FrameId]<a class="headerlink" href="#pydrake.geometry.FramePoseVector_[AutoDiffXd].frame_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a range object for all of the frame ids in the vector. This
is intended to be used as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>for (FrameId id : this_vector.frame_ids()) {
...
// Obtain the KinematicsValue of an id by ``this_vector.value(id)``
...
}
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_[AutoDiffXd].has_id">
<code class="descname">has_id</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[AutoDiffXd], id: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.FramePoseVector_[AutoDiffXd].has_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports true if the given id is a member of this data.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_[AutoDiffXd].set_value">
<code class="descname">set_value</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[AutoDiffXd], id: pydrake.geometry.FrameId, value: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.FramePoseVector_[AutoDiffXd].set_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the kinematics <code class="docutils literal"><span class="pre">value</span></code> for the frame indicated by the given
<code class="docutils literal"><span class="pre">id</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_[AutoDiffXd].size">
<code class="descname">size</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.FramePoseVector_[AutoDiffXd].size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of frame_ids().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_[AutoDiffXd].value">
<code class="descname">value</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[AutoDiffXd], id: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.geometry.FramePoseVector_[AutoDiffXd].value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value associated with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> is not in the specified set of ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.FramePoseVector_[float]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">FramePoseVector_[float]</code><a class="headerlink" href="#pydrake.geometry.FramePoseVector_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A FrameKinematicsVector is used to report kinematics data for
registered frames (identified by unique FrameId values) to SceneGraph.
It serves as the basis of FramePoseVector, FrameVelocityVector, and
FrameAccelerationVector.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MySystem</span> <span class="p">:</span> <span class="n">public</span> <span class="n">LeafSystem</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
<span class="n">MySystem</span><span class="p">()</span> <span class="p">{</span>
<span class="o">...</span>
<span class="n">this</span><span class="o">-&gt;</span><span class="n">DeclareAbstractOutputPort</span><span class="p">(</span>
<span class="o">&amp;</span><span class="n">AllocInConstructorSystem</span><span class="p">::</span><span class="n">CalcFramePoseOutput</span><span class="p">);</span>
<span class="o">...</span>
<span class="p">}</span>

<span class="n">private</span><span class="p">:</span>
<span class="n">void</span> <span class="n">CalcFramePoseOutput</span><span class="p">(</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">context</span><span class="p">,</span>
<span class="n">geometry</span><span class="p">::</span><span class="n">FramePoseVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">poses</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
<span class="n">poses</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">frame_ids_</span><span class="o">.</span><span class="n">size</span><span class="p">());</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="n">poses</span><span class="o">-&gt;</span><span class="n">set_value</span><span class="p">(</span><span class="n">frame_ids_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">poses_</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FrameId</span><span class="o">&gt;</span> <span class="n">frame_ids_</span><span class="p">;</span>
<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">poses_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If a System only ever emits a single frame (or small-constant-number
of frames), then there’s a shorter alternative way to write a Calc
method, using an initializer_list:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">CalcFramePoseOutput</span><span class="p">(</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">context</span><span class="p">,</span>
<span class="n">geometry</span><span class="p">::</span><span class="n">FramePoseVector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">poses</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
<span class="n">const</span> <span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">pose</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
<span class="n">poses</span> <span class="o">=</span> <span class="p">{{</span><span class="n">frame_id_</span><span class="p">,</span> <span class="n">pose</span><span class="p">}};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>N.B. When the systems framework calls the <code class="docutils literal"><span class="pre">Calc</span></code> method, the value
pointed to by <code class="docutils literal"><span class="pre">poses</span></code> is in an unspecified state. The implementation
of <code class="docutils literal"><span class="pre">Calc</span></code> must always ensure that <code class="docutils literal"><span class="pre">poses</span></code> contains the correct
value upon return, no matter what value it started with. The easy ways
to do this are to call either <code class="docutils literal"><span class="pre">poses-&gt;clear()</span></code> or the assignment
operator <code class="docutils literal"><span class="pre">*poses</span> <span class="pre">=</span> <span class="pre">...</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">KinematicsValue</span></code>:</dt>
<dd>The underlying data type of for the order of kinematics data
(e.g., pose, velocity, or acceleration).</dd>
</dl>
<p>One should never interact with the FrameKinematicsVector class
directly. Instead, the FramePoseVector, FrameVelocityVector, and
FrameAccelerationVector classes are aliases of the
FrameKinematicsVector instantiated on specific data types
(RigidTransform, SpatialVector, and SpatialAcceleration,
respectively). Each of these data types are templated on Eigen
scalars. All supported combinations of data type and scalar type are
already available to link against in the containing library. No other
values for KinematicsValue are supported.</p>
<p>Currently, the following data types with the following scalar types
are supported:</p>
<p>Alias | Instantiation | Scalar types
—————–<a href="#id10"><span class="problematic" id="id11">|-----------------------------------------------|</span></a>————-
FramePoseVector | FrameKinematicsVector&lt;RigidTransform&lt;Scalar&gt;&gt; |
double FramePoseVector | FrameKinematicsVector&lt;RigidTransform&lt;Scalar&gt;&gt;
| AutoDiffXd FramePoseVector |
FrameKinematicsVector&lt;RigidTransform&lt;Scalar&gt;&gt; | Expression</p>
<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.FramePoseVector_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the vector using an invalid SourceId with no frames .</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_[float].clear">
<code class="descname">clear</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.FramePoseVector_[float].clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears all values, resetting the size to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_[float].frame_ids">
<code class="descname">frame_ids</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[float]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.FrameId]<a class="headerlink" href="#pydrake.geometry.FramePoseVector_[float].frame_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a range object for all of the frame ids in the vector. This
is intended to be used as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>for (FrameId id : this_vector.frame_ids()) {
...
// Obtain the KinematicsValue of an id by ``this_vector.value(id)``
...
}
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_[float].has_id">
<code class="descname">has_id</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[float], id: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.FramePoseVector_[float].has_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports true if the given id is a member of this data.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_[float].set_value">
<code class="descname">set_value</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[float], id: pydrake.geometry.FrameId, value: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.FramePoseVector_[float].set_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the kinematics <code class="docutils literal"><span class="pre">value</span></code> for the frame indicated by the given
<code class="docutils literal"><span class="pre">id</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_[float].size">
<code class="descname">size</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.FramePoseVector_[float].size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of frame_ids().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.FramePoseVector_[float].value">
<code class="descname">value</code><span class="sig-paren">(</span><em>self: pydrake.geometry.FramePoseVector_[float], id: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.FramePoseVector_[float].value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value associated with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> is not in the specified set of ids.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.GeometryFrame">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">GeometryFrame</code><a class="headerlink" href="#pydrake.geometry.GeometryFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>This simple class carries the definition of a frame used in the
SceneGraph. To register moving frames with SceneGraph (see
SceneGraph::RegisterFrame()), a geometry source (see
SceneGraph::RegisterSource()) instantiates a frame and passes
ownership over to SceneGraph.</p>
<p>A frame is defined by two pieces of information:</p>
<ul class="simple">
<li>the name, which must be unique within a single geometry source and</li>
<li>the “frame group”, an integer identifier that can be used to group frames</li>
</ul>
<p>together within a geometry source.</p>
<p>The “frame group” is intended as a generic synonym for the model
instance id defined by the RigidBodyTree.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SceneGraph</p>
</div>
<dl class="method">
<dt id="pydrake.geometry.GeometryFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryFrame</em>, <em>frame_name: str</em>, <em>frame_group_id: int = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.GeometryFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">frame_name</span></code>:</dt>
<dd>The name of the frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_group_id</span></code>:</dt>
<dd>The optional frame group identifier. If unspecified, defaults to
the common, 0 group. Must be non-negative.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryFrame.frame_group">
<code class="descname">frame_group</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryFrame</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.GeometryFrame.frame_group" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryFrame.id">
<code class="descname">id</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryFrame</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.FrameId<a class="headerlink" href="#pydrake.geometry.GeometryFrame.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the globally unique id for this geometry specification. Every
instantiation of FrameInstance will contain a unique id value. The id
value is preserved across copies. After successfully registering this
FrameInstance, this id will serve as the identifier for the registered
representation as well.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryFrame.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryFrame</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.GeometryFrame.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.GeometryId">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">GeometryId</code><a class="headerlink" href="#pydrake.geometry.GeometryId" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify geometry instances in SceneGraph.</p>
<dl class="attribute">
<dt id="pydrake.geometry.GeometryId.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.geometry.GeometryId.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.GeometryId.get_new_id">
<em class="property">static </em><code class="descname">get_new_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.geometry.GeometryId<a class="headerlink" href="#pydrake.geometry.GeometryId.get_new_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a new identifier for this id type. This new identifier will
be different from all previous identifiers created. This method does
<em>not</em> make any guarantees about the values of ids from successive
invocations. This method is guaranteed to be thread safe.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryId.get_value">
<code class="descname">get_value</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.GeometryId.get_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the underlying representation from the identifier. This is
considered invalid for invalid ids and is strictly enforced in Debug
builds.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryId.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.GeometryId.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the id is valid.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.GeometryInstance">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">GeometryInstance</code><a class="headerlink" href="#pydrake.geometry.GeometryInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>A geometry instance combines a geometry definition (i.e., a shape of
some sort), a pose (relative to a parent “frame” P), material
information, and an opaque collection of metadata. The parent frame
can be a registered frame or another registered geometry.</p>
<p>Every GeometryInstance must be named. The naming convention mirrors
that of valid names in SDF files. Specifically, any user-specified
name will have all leading and trailing space and tab characters
trimmed off. The trimmed name will have to satisfy the following
requirements:</p>
<ul class="simple">
<li>cannot be empty, and</li>
<li>the name should be unique in the scope of its frame and role. For example,</li>
</ul>
<p>two GeometryInstances can both be called “ball” as long as they are
affixed to different frames or if one is a collision geometry and the
other is an illustration geometry. This is enforced when a role is assigned
to the geometry.</p>
<p>If valid, the trimmed name will be assigned to the instance.</p>
<p>Names <em>can</em> have internal whitespace (e.g., “my geometry name”).</p>
<p><strong>Canonicalized names</strong></p>
<p>The silent transformation of a user-defined name to canonical name
mirrors that of specifying geometry names in an SDF file. Consider the
following SDF snippet:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">xml</span><span class="p">}</span>
<span class="o">...</span>
<span class="o">&lt;</span><span class="n">visual</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;  visual&quot;</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">geometry</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">sphere</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">radius</span><span class="o">&gt;</span><span class="mf">1.0</span><span class="o">&lt;/</span><span class="n">radius</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">sphere</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">geometry</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">visual</span><span class="o">&gt;</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The name has two leading whitespace characters. The parsing process
will consider this name as equivalent to “visual” and tests for
uniqueness and non-emptiness will be applied to that trimmed result.
The following code has an analogous effect:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">scene_graph</span><span class="o">-&gt;</span><span class="n">RegisterGeometry</span><span class="p">(</span>
<span class="n">source_id</span><span class="p">,</span> <span class="n">frame_id</span><span class="p">,</span>
<span class="n">make_unique</span><span class="o">&lt;</span><span class="n">GeometryInstance</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pose</span><span class="p">,</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Sphere</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="s2">&quot;  visual&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>The specified name includes leading whitespace. That name will be
trimmed and the <em>result</em> will be stored in the GeometryInstance (to be
later validated by SceneGraph as part of geometry registration).
Querying the instance of its name will return this <em>canonicalized</em>
name.</p>
<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance, X_PG: pydrake.math.RigidTransform_[float], shape: pydrake.geometry.Shape, name: str</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.GeometryInstance.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a geometry instance specification.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">X_PG</span></code>:</dt>
<dd>The pose of this geometry (<code class="docutils literal"><span class="pre">G</span></code>) in its parent’s frame (<code class="docutils literal"><span class="pre">P</span></code>).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">shape</span></code>:</dt>
<dd>The underlying shape for this geometry instance.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The name of the geometry (must satisfy the name requirements).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the canonicalized version of <code class="docutils literal"><span class="pre">name</span></code> is empty.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.id">
<code class="descname">id</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.GeometryId<a class="headerlink" href="#pydrake.geometry.GeometryInstance.id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the globally unique id for this geometry specification. Every
instantiation of GeometryInstance will contain a unique id value. The
id value is preserved across copies. After successfully registering
this GeometryInstance, this id will serve as the identifier for the
registered representation as well.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.illustration_properties">
<code class="descname">illustration_properties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance</em><span class="sig-paren">)</span> &#x2192; drake::geometry::IllustrationProperties<a class="headerlink" href="#pydrake.geometry.GeometryInstance.illustration_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the geometry’s const illustration properties (if
they are defined). Nullptr otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.mutable_illustration_properties">
<code class="descname">mutable_illustration_properties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance</em><span class="sig-paren">)</span> &#x2192; drake::geometry::IllustrationProperties<a class="headerlink" href="#pydrake.geometry.GeometryInstance.mutable_illustration_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the geometry’s mutable illustration properties
(if they are defined). Nullptr otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.mutable_perception_properties">
<code class="descname">mutable_perception_properties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance</em><span class="sig-paren">)</span> &#x2192; drake::geometry::PerceptionProperties<a class="headerlink" href="#pydrake.geometry.GeometryInstance.mutable_perception_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the geometry’s mutable perception properties (if
they are defined). Nullptr otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.mutable_proximity_properties">
<code class="descname">mutable_proximity_properties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance</em><span class="sig-paren">)</span> &#x2192; drake::geometry::ProximityProperties<a class="headerlink" href="#pydrake.geometry.GeometryInstance.mutable_proximity_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the geometry’s mutable proximity properties (if
they are defined). Nullptr otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.GeometryInstance.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <em>canonicalized</em> name for the instance.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">canonicalized_geometry_names “Canonicalized names”</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.perception_properties">
<code class="descname">perception_properties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance</em><span class="sig-paren">)</span> &#x2192; drake::geometry::PerceptionProperties<a class="headerlink" href="#pydrake.geometry.GeometryInstance.perception_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the geometry’s const perception properties (if
they are defined). Nullptr otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.pose">
<code class="descname">pose</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.GeometryInstance.pose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the instance geometry’s pose in its parent frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.proximity_properties">
<code class="descname">proximity_properties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance</em><span class="sig-paren">)</span> &#x2192; drake::geometry::ProximityProperties<a class="headerlink" href="#pydrake.geometry.GeometryInstance.proximity_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the geometry’s const proximity properties (if
they are defined). Nullptr otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.release_shape">
<code class="descname">release_shape</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.Shape<a class="headerlink" href="#pydrake.geometry.GeometryInstance.release_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Releases the shape from the instance.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.set_illustration_properties">
<code class="descname">set_illustration_properties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance</em>, <em>properties: drake::geometry::IllustrationProperties</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.GeometryInstance.set_illustration_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the illustration properties for the given instance.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.set_name">
<code class="descname">set_name</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance</em>, <em>arg0: str</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.GeometryInstance.set_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <em>canonicalized</em> name for the instance.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">canonicalized_geometry_names “Canonicalized names”</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.set_perception_properties">
<code class="descname">set_perception_properties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance</em>, <em>properties: drake::geometry::PerceptionProperties</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.GeometryInstance.set_perception_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the perception properties for the given instance.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.set_pose">
<code class="descname">set_pose</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance, X_PG: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.GeometryInstance.set_pose" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the pose of this instance in its parent’s frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.set_proximity_properties">
<code class="descname">set_proximity_properties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance</em>, <em>properties: drake::geometry::ProximityProperties</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.GeometryInstance.set_proximity_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the proximity properties for the given instance.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryInstance.shape">
<code class="descname">shape</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryInstance</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.Shape<a class="headerlink" href="#pydrake.geometry.GeometryInstance.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.GeometryProperties">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">GeometryProperties</code><a class="headerlink" href="#pydrake.geometry.GeometryProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>The base class for defining a set of geometry properties.</p>
<p>Each property consists of a <code class="docutils literal"><span class="pre">(group,</span> <span class="pre">property)</span></code> name-pair and a
typed value. The name pair allows for reuse of common property names
(e.g., “diffuse”) to be differentiated in interpretation by
associating them with different groups. The only restriction on the
value type is that it must be either cloneable or copy-constructible.</p>
<p>A set of geometry property values are defined when geometry is
registered with SceneGraph by an instantiator and accessed by some
downstream consumer entity. Each consumer specifies what properties it
expects to find and what default values (if any) it provides. For
example, the consumer could document that a particular property is
always required and its absence would throw an exception.
Alternatively, it could indicate that a property is optional and a
default value will be used in its absence. It is the responsibility of
the instantiator to make sure that the geometry property values are
<em>correctly</em> defined according to the expected consumer’s
specification. Correctness includes such issues as key-value pairs
placed into a <em>correctly</em>-spelled group, property keys being likewise
correctly spelled, and values of the expected type. Correct spelling
includes correct case. The instantiator uses the AddProperty() method
to add new properties to the set.</p>
<p>To read the property (<code class="docutils literal"><span class="pre">some_group</span></code>, <cite>some_property</cite>) from a property
set:</p>
<p>1. Optionally test to see if the property exists by confirming the group
<code class="docutils literal"><span class="pre">some_group</span></code> is in the set via HasGroup() and that the property
<code class="docutils literal"><span class="pre">some_property</span></code> is in <code class="docutils literal"><span class="pre">some_group</span></code> via HasProperty(). Attempting to access
a property with a non-existent (group, property) pair may lead to an
exception (see API documentation below).
2. Acquire a property value via the GetProperty() or GetPropertyOrDefault()
methods.
NOTE: Reading a property requires a compile-time declaration of the <em>type</em>
of value being read. If the stored value is of a different type, an
exception will be thrown.</p>
<p>The following examples outline a number of ways to create and consume
geometry properties. By design, GeometryProperties cannot be
constructed, copied, or moved directly. Only derived classes can do
so. This facilitates <em>strongly typed</em> sets of properties associated
with particular geometry roles. So, for these examples we’ll exercise
the derived class associated with proximity queries:
ProximityProperties.</p>
<p>The string-based structure of GeometryProperties provides a great deal
of flexibility at the cost of spelling sensitivity. It would be easy
to introduce typos that would then “hide” property values in some
group a consumer wouldn’t look. In these examples, we avoid using
string literals as group or property names (at least in the cases
where the same name is used multiple times) to help avoid the
possibility of typo-induced errors. That is not required and certainly
not the only way to avoid such bugs.</p>
<p><strong>Creating properties</strong></p>
<p><em>Creating properties in a new group</em></p>
<p>This is a simple example in which a single group is added with
properties of various types.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">group_name</span><span class="p">(</span><span class="s2">&quot;my_group&quot;</span><span class="p">);</span>
<span class="n">ProximityProperties</span> <span class="n">properties</span><span class="p">;</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">first</span> <span class="n">invocation</span> <span class="n">implicitly</span> <span class="n">creates</span> <span class="n">the</span> <span class="n">group</span> <span class="s2">&quot;my_group&quot;</span><span class="o">.</span>
<span class="n">properties</span><span class="o">.</span><span class="n">AddProperty</span><span class="p">(</span><span class="n">group_name</span><span class="p">,</span> <span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>     <span class="o">//</span> <span class="nb">int</span> <span class="nb">type</span>
<span class="n">properties</span><span class="o">.</span><span class="n">AddProperty</span><span class="p">(</span><span class="n">group_name</span><span class="p">,</span> <span class="s2">&quot;length&quot;</span><span class="p">,</span> <span class="mf">7.</span><span class="p">);</span>   <span class="o">//</span> <span class="n">double</span> <span class="nb">type</span>
<span class="n">properties</span><span class="o">.</span><span class="n">AddProperty</span><span class="p">(</span><span class="n">group_name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">);</span>    <span class="o">//</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="nb">type</span>
</pre></div>
</div>
<p><em>Creating properties in the default group</em></p>
<p>Similar to the previous examples, the properties are added to the
default group. Just be aware that if multiple sites in your code add
properties to the default group, the possibility that names get
repeated increases. Property names <em>must</em> be unique within a single
group, including the default group.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">ProximityProperties</span> <span class="n">properties</span><span class="p">;</span>
<span class="n">properties</span><span class="o">.</span><span class="n">AddProperty</span><span class="p">(</span><span class="n">ProximityProperties</span><span class="p">::</span><span class="n">default_group_name</span><span class="p">(),</span> <span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="n">properties</span><span class="o">.</span><span class="n">AddProperty</span><span class="p">(</span><span class="n">ProximityProperties</span><span class="p">::</span><span class="n">default_group_name</span><span class="p">(),</span> <span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="mf">7.</span><span class="p">);</span>
<span class="n">properties</span><span class="o">.</span><span class="n">AddProperty</span><span class="p">(</span><span class="n">ProximityProperties</span><span class="p">::</span><span class="n">default_group_name</span><span class="p">(),</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p><em>Aggregate properties in a struct</em></p>
<p>In some cases, there is a set of values that will <em>always</em> be accessed
together (specified with coordinated semantics). In these cases, it
makes sense to aggregate them into a struct and store that as a single
value. This reduces the number of lookups required.</p>
<p>It’s worth noting, that if the data value is a struct, calls to
GetPropertyOrDefault() still operate as an “all-or-nothing” basis. If
the property <em>struct</em> exists, it will be returned, if it’s missing the
default struct will be returned. There is no concept of a “partial”
struct in which some undefined values in the struct will be replaced
with their corresponding values in the default struct.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">MyData</span> <span class="p">{</span>
<span class="nb">int</span> <span class="n">i</span><span class="p">{};</span>
<span class="n">double</span> <span class="n">d</span><span class="p">{};</span>
<span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">ProximityProperties</span> <span class="n">properties</span><span class="p">;</span>
<span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span> <span class="n">group_name</span><span class="p">(</span><span class="s2">&quot;my_group&quot;</span><span class="p">);</span>
<span class="n">MyData</span> <span class="n">data</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">};</span>
<span class="n">properties</span><span class="o">.</span><span class="n">AddProperty</span><span class="p">(</span><span class="n">group_name</span><span class="p">,</span> <span class="s2">&quot;data1&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="o">//</span> <span class="n">These</span> <span class="n">alternate</span> <span class="n">forms</span> <span class="n">are</span> <span class="n">also</span> <span class="n">acceptable</span> <span class="p">(</span><span class="n">but</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">succession</span><span class="p">,</span> <span class="k">as</span> <span class="n">the</span>
<span class="o">//</span> <span class="nb">property</span> <span class="n">name</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">used</span> <span class="n">by</span> <span class="n">the</span> <span class="n">first</span> <span class="n">invocation</span><span class="p">)</span><span class="o">.</span>
<span class="n">properties</span><span class="o">.</span><span class="n">AddProperty</span><span class="p">(</span><span class="n">group_name</span><span class="p">,</span> <span class="s2">&quot;data2&quot;</span><span class="p">,</span> <span class="n">MyData</span><span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">});</span>
<span class="n">properties</span><span class="o">.</span><span class="n">AddProperty</span><span class="o">&lt;</span><span class="n">MyData</span><span class="o">&gt;</span><span class="p">(</span><span class="n">group_name</span><span class="p">,</span> <span class="s2">&quot;data2&quot;</span><span class="p">,</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">});</span>
</pre></div>
</div>
<p><strong>Reading properties</strong></p>
<p>This section describes how to read properties under several different
scenarios: (a) when specific properties are required, (b) when the
consumer provides a default value for missing properties, and (c) when
the consumer needs to inspect what properties are available.</p>
<p><em>Look up specific, *required</em> properties*</p>
<p>In this case, the consumer of the properties is looking for one or
more specific properties. It will ignore any other properties. More
particularly, if those properties are missing, it is considered a
runtime error and an exception is thrown.</p>
<p>The error can be handled in one of two ways: simply let the generic
exception generated by GeometryProperties propagate upward, or detect
the missing property and throw an exception with a custom message. The
example below shows both approaches.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>const IllustrationProperties&amp; properties = FunctionThatReturnsProperties();
// Looking for a Rgba of rgba colors named &quot;rgba&quot; - send generic error that
// the property set is missing the required property.
const Rgba rgba =
properties.GetProperty&lt;Rgba&gt;(&quot;MyGroup&quot;, &quot;rgba&quot;);

// Explicitly detect missing property and throw exception with custom message.
if (!properties.HasProperty(&quot;MyGroup&quot;, &quot;rgba&quot;)) {
throw RuntimeError(
&quot;ThisClass: Missing the necessary &#39;rgba&#39; property; the object cannot be &quot;
&quot;rendered&quot;);
}
// Otherwise acquire value, confident that no exception will be thrown.
const Rgba rgba =
properties.GetProperty&lt;Rgba&gt;(&quot;MyGroup&quot;, &quot;rgba&quot;);
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">calls to <code class="docutils literal"><span class="pre">GetProperty()</span></code> always require the return type template
value (e.g., <code class="docutils literal"><span class="pre">Rgba</span></code>) to be specified in the call.</p>
</div>
<p><em>Look up specific properties with default property values</em></p>
<p>As with the previous case, the consumer is looking for one or more
specific properties. However, in this case, the consumer provides a
default value to use in case the target property is not defined. In
this invocation, the template parameter need not be explicitly
declared – the inferred return type will be the same as the default
value.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">IllustrationProperties</span><span class="o">&amp;</span> <span class="n">properties</span> <span class="o">=</span> <span class="n">FunctionThatReturnsProperties</span><span class="p">();</span>
<span class="o">//</span> <span class="n">Looking</span> <span class="k">for</span> <span class="n">a</span> <span class="n">Rgba</span> <span class="n">of</span> <span class="n">rgba</span> <span class="n">colors</span> <span class="n">named</span> <span class="s2">&quot;rgba&quot;</span><span class="o">.</span>
<span class="n">const</span> <span class="n">Rgba</span> <span class="n">default_color</span><span class="p">{</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">};</span>
<span class="n">const</span> <span class="n">Rgba</span> <span class="n">rgba</span> <span class="o">=</span>
<span class="n">properties</span><span class="o">.</span><span class="n">GetPropertyOrDefault</span><span class="p">(</span><span class="s2">&quot;MyGroup&quot;</span><span class="p">,</span> <span class="s2">&quot;rgba&quot;</span><span class="p">,</span> <span class="n">default_color</span><span class="p">);</span>
</pre></div>
</div>
<p>Alternatively, the default value can be provided in one of the
following forms:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">properties</span><span class="o">.</span><span class="n">GetPropertyOrDefault</span><span class="p">(</span><span class="s2">&quot;MyGroup&quot;</span><span class="p">,</span> <span class="s2">&quot;rgba&quot;</span><span class="p">,</span>
<span class="n">Rgba</span><span class="p">{</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">});</span>
<span class="n">properties</span><span class="o">.</span><span class="n">GetPropertyOrDefault</span><span class="o">&lt;</span><span class="n">Rgba</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;MyGroup&quot;</span><span class="p">,</span> <span class="s2">&quot;rgba&quot;</span><span class="p">,</span>
<span class="p">{</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">});</span>
</pre></div>
</div>
<p><em>Iterating through provided properties</em></p>
<p>Another alternative is to iterate through the properties that <em>have</em>
been provided. This might be done for several reasons, e.g.:</p>
<ul class="simple">
<li>the consumer wants to validate the set of properties, giving the user</li>
</ul>
<p>feedback if an unsupported property has been provided, and/or
- the consumer has a default value for every property and allows the
registering code to define only those properties that deviate from the
specified default.</p>
<p>Working with properties in this manner requires knowledge of how to
work with AbstractValue.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">IllustrationProperties</span><span class="o">&amp;</span> <span class="n">properties</span> <span class="o">=</span> <span class="n">FunctionThatReturnsProperties</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="n">const</span> <span class="n">auto</span><span class="o">&amp;</span> <span class="n">pair</span> <span class="p">:</span> <span class="n">properties</span><span class="o">.</span><span class="n">GetGroupProperties</span><span class="p">(</span><span class="s2">&quot;MyGroup&quot;</span><span class="p">)</span> <span class="p">{</span>
<span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">first</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;rgba&quot;</span><span class="p">)</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">Throws</span> <span class="n">an</span> <span class="n">exception</span> <span class="k">if</span> <span class="n">the</span> <span class="n">named</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="n">of</span> <span class="n">the</span> <span class="n">wrong</span> <span class="nb">type</span><span class="o">.</span>
<span class="n">const</span> <span class="n">Rgba</span><span class="o">&amp;</span> <span class="n">rgba</span> <span class="o">=</span>
<span class="n">pair</span><span class="o">.</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">GetValueOrThrow</span><span class="o">&lt;</span><span class="n">Rgba</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="pydrake.geometry.GeometryProperties.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.geometry.GeometryProperties.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryProperties.AddProperty">
<code class="descname">AddProperty</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryProperties</em>, <em>group_name: str</em>, <em>name: str</em>, <em>value: object</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.GeometryProperties.AddProperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the named property (<code class="docutils literal"><span class="pre">group_name</span></code>, <cite>name</cite>) with the given
<code class="docutils literal"><span class="pre">value</span></code>. Adds the group if it doesn’t already exist.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">group_name</span></code>:</dt>
<dd>The group name.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The name of the property – must be unique in the group.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">value</span></code>:</dt>
<dd>The value to assign to the property.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the property already exists.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">ValueType</span></code>:</dt>
<dd>The type of data to store with the attribute – must be copy
constructible or cloneable (see Value).</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.GeometryProperties.default_group_name">
<em class="property">static </em><code class="descname">default_group_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.GeometryProperties.default_group_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default group name. There is no guarantee as to <em>what</em>
string corresponds to the default group. Therefore it should always be
accessed via this method.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryProperties.GetGroupNames">
<code class="descname">GetGroupNames</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryProperties</em><span class="sig-paren">)</span> &#x2192; Set[str]<a class="headerlink" href="#pydrake.geometry.GeometryProperties.GetGroupNames" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all of the defined group names.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryProperties.GetPropertiesInGroup">
<code class="descname">GetPropertiesInGroup</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryProperties</em>, <em>group_name: str</em><span class="sig-paren">)</span> &#x2192; dict<a class="headerlink" href="#pydrake.geometry.GeometryProperties.GetPropertiesInGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the indicated property group. The returned group is valid
for as long as this instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no group with the given name.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryProperties.GetProperty">
<code class="descname">GetProperty</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryProperties</em>, <em>group_name: str</em>, <em>name: str</em><span class="sig-paren">)</span> &#x2192; object<a class="headerlink" href="#pydrake.geometry.GeometryProperties.GetProperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the typed value for the property (<code class="docutils literal"><span class="pre">group_name</span></code>, <cite>name</cite>)
from this set of properties.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">group_name</span></code>:</dt>
<dd>The name of the group to which the property belongs.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The name of the desired property.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the group name is invalid, b) the property name</li>
<li>is invalid, or c) the property type is not that specified.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">ValueType</span></code>:</dt>
<dd>The expected type of the desired property.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">const ValueType&amp; of stored value. If ValueType is Eigen::Vector4d,
the return type will be a copy translated from Rgba.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryProperties.GetPropertyOrDefault">
<code class="descname">GetPropertyOrDefault</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryProperties</em>, <em>group_name: str</em>, <em>name: str</em>, <em>default_value: object</em><span class="sig-paren">)</span> &#x2192; object<a class="headerlink" href="#pydrake.geometry.GeometryProperties.GetPropertyOrDefault" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the typed value for the property (<code class="docutils literal"><span class="pre">group_name</span></code>, <cite>name</cite>)
from the set of properties (if it exists), otherwise returns the given
default value. The given <code class="docutils literal"><span class="pre">default_value</span></code> is returned only if the
property is missing. If the property exists and is of a <em>different</em>
type, an exception will be thrown. If it is of the expected type, the
stored value will be returned.</p>
<p>Generally, it is unnecessary to explicitly declare the <code class="docutils literal"><span class="pre">ValueType</span></code>
of the property value; it will be inferred from the provided default
value. Sometimes it is convenient to provide the default value in a
form that can be implicitly converted to the final type. In that case,
it is necessary to explicitly declare the desired <code class="docutils literal"><span class="pre">ValueType</span></code> so the
compiler does not infer the wrong type, e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Note</span> <span class="n">the</span> <span class="o">*</span><span class="n">integer</span><span class="o">*</span> <span class="n">value</span> <span class="k">as</span> <span class="n">default</span> <span class="n">value</span><span class="o">.</span>
<span class="n">const</span> <span class="n">double</span> <span class="n">my_value</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="n">GetPropertyOrDefault</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">group_name</span></code>:</dt>
<dd>The name of the group to which the property belongs.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The name of the desired property.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">default_value</span></code>:</dt>
<dd>The alternate value to return if the property cannot be acquired.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a property of the given name exists but is not of</li>
<li><code class="docutils literal"><span class="pre">ValueType</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryProperties.HasGroup">
<code class="descname">HasGroup</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryProperties</em>, <em>group_name: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.GeometryProperties.HasGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the given named group is part of this property set.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryProperties.HasProperty">
<code class="descname">HasProperty</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryProperties</em>, <em>group_name: str</em>, <em>name: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.GeometryProperties.HasProperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the property (<code class="docutils literal"><span class="pre">group_name</span></code>, <cite>name</cite>) exists in the group.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">group_name</span></code>:</dt>
<dd>The name of the group to which the tested property should belong.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The name of the property under question.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true iff the group exists and a property with the given <code class="docutils literal"><span class="pre">name</span></code>
exists in that group.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryProperties.num_groups">
<code class="descname">num_groups</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryProperties</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.GeometryProperties.num_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the number of property groups in this set.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryProperties.RemoveProperty">
<code class="descname">RemoveProperty</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryProperties</em>, <em>group_name: str</em>, <em>name: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.GeometryProperties.RemoveProperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the (<code class="docutils literal"><span class="pre">group_name</span></code>, <cite>name</cite>) property (if it exists). Upon
completion the property will not be in the set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal"><span class="pre">True</span></code> if the property existed prior to the call.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.GeometryProperties.UpdateProperty">
<code class="descname">UpdateProperty</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometryProperties</em>, <em>group_name: str</em>, <em>name: str</em>, <em>value: object</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.GeometryProperties.UpdateProperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the named property (<code class="docutils literal"><span class="pre">group_name</span></code>, <cite>name</cite>) with the given
<code class="docutils literal"><span class="pre">value</span></code>. If the property doesn’t already exist, it is equivalent to
calling <code class="docutils literal"><span class="pre">AddProperty</span></code>. If the property does exist, its value (which
must have the same type as <code class="docutils literal"><span class="pre">value</span></code>) will be replaced.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">group_name</span></code>:</dt>
<dd>The group name.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The name of the property – must be unique in the group.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">value</span></code>:</dt>
<dd>The value to assign to the property.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the property exists with a different type.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">ValueType</span></code>:</dt>
<dd>The type of data to store with the attribute – must be copy
constructible or cloneable (see Value).</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.GeometrySet">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">GeometrySet</code><a class="headerlink" href="#pydrake.geometry.GeometrySet" title="Permalink to this definition">¶</a></dt>
<dd><p>The GeometrySet, as its name implies, is a convenience class for
defining a set of geometries. What makes it unique from a simple
<code class="docutils literal"><span class="pre">std::set&lt;GeometryId&gt;</span></code> instance is that membership doesn’t require
explicit GeometryId enumeration; GeometryId values can be added to the
set by adding the <code class="docutils literal"><span class="pre">FrameId</span></code> for the frame to which the geometries
are rigidly affixed.</p>
<p>This class does no validation; it is a simple collection. Ultimately,
it serves as the operand of SceneGraph operations (e.g.,
SceneGraph::ExcludeCollisionsWithin()). If the <em>operation</em> has a
particular prerequisite on the members of a GeometrySet, it is the
operation’s responsibility to enforce that requirement.</p>
<p>More formally, the SceneGraph consists of a set of geometries, each
associated with a unique identifier. As such, we can consider the set
of all identifiers <code class="docutils literal"><span class="pre">SG</span> <span class="pre">=</span> <span class="pre">{g₀,</span> <span class="pre">g₁,</span> <span class="pre">...,</span> <span class="pre">gₙ}</span></code> that belong to a
SceneGraph. A GeometrySet should represent a subset of those
identifiers, <code class="docutils literal"><span class="pre">Gₛ</span> <span class="pre">⊆</span> <span class="pre">SG</span></code>. The convenience of the GeometrySet class is
<em>how</em> the subset is defined. Given a set of frame ids <code class="docutils literal"><span class="pre">F</span> <span class="pre">=</span> <span class="pre">{f₀,</span> <span class="pre">f₁,</span>
<span class="pre">...,</span> <span class="pre">fₙ}</span></code> and geometry ids <code class="docutils literal"><span class="pre">G</span> <span class="pre">=</span> <span class="pre">{g₀,</span> <span class="pre">g₁,</span> <span class="pre">...,</span> <span class="pre">gₘ}</span></code>, <cite>Gₛ = G ⋃
geometry(f₀) ⋃ … ⋃ geometry(fₙ)</cite> (where <code class="docutils literal"><span class="pre">geometry(f)</span></code> is the set
of geometries rigidly affixed to frame f).</p>
<dl class="method">
<dt id="pydrake.geometry.GeometrySet.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.GeometrySet</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.GeometrySet.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.HalfSpace">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">HalfSpace</code><a class="headerlink" href="#pydrake.geometry.HalfSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.Shape</span></code></a></p>
<p>Definition of a half space. In its canonical frame, the plane defining
the boundary of the half space is that frame’s z = 0 plane. By
implication, the plane’s normal points in the +z direction and the
origin lies on the plane. Other shapes are considered to be
penetrating the half space if there exists a point on the test shape
that lies on the side of the plane opposite the normal.</p>
<dl class="method">
<dt id="pydrake.geometry.HalfSpace.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.HalfSpace</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.HalfSpace.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.HalfSpace.MakePose">
<em class="property">static </em><code class="descname">MakePose</code><span class="sig-paren">(</span><em>Hz_dir_F: numpy.ndarray[numpy.float64[3, 1]], p_FB: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.HalfSpace.MakePose" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the pose of a canonical half space in frame F. The half
space’s normal is aligned to the positive z-axis of its canonical
frame H. Given a vector that points in the same direction, measured in
the F frame (Hz_dir_F) and a position vector to a point on the half
space’s boundary* expressed in the same frame, <code class="docutils literal"><span class="pre">p_FB</span></code>, creates the
pose of the half space in frame F: <code class="docutils literal"><span class="pre">X_FH</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">Hz_dir_F</span></code>:</dt>
<dd>A vector in the direction of the positive z-axis of the canonical
frame expressed in frame F. It must be a non-zero vector but need
not be unit length.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_FB</span></code>:</dt>
<dd>A point B lying on the half space’s boundary measured and
expressed in frame F.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">X_FH</span></code>:</dt>
<dd>The pose of the canonical half-space in frame F.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the normal is <em>close</em> to a zero-vector (e.g.,</li>
<li>‖normal_F‖₂ &lt; ε).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.IllustrationProperties">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">IllustrationProperties</code><a class="headerlink" href="#pydrake.geometry.IllustrationProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.GeometryProperties" title="pydrake.geometry.GeometryProperties"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.GeometryProperties</span></code></a></p>
<p>The set of properties for geometry used in an “illustration” role.</p>
<p>Examples of functionality that depends on the illustration role: -
geometry_visualization_role_dependency
“drake::geometry::ConnectDrakeVisualizer()”</p>
<dl class="method">
<dt id="pydrake.geometry.IllustrationProperties.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.IllustrationProperties</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.IllustrationProperties.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.geometry.MakePhongIllustrationProperties">
<code class="descclassname">pydrake.geometry.</code><code class="descname">MakePhongIllustrationProperties</code><span class="sig-paren">(</span><em>diffuse: numpy.ndarray[numpy.float64[4, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.IllustrationProperties<a class="headerlink" href="#pydrake.geometry.MakePhongIllustrationProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an IllustrationProperties instance compatible with a simple
“phong” material using only the given <code class="docutils literal"><span class="pre">diffuse</span></code> color.</p>
</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.Mesh">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">Mesh</code><a class="headerlink" href="#pydrake.geometry.Mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.Shape</span></code></a></p>
<p>Limited support for meshes. Meshes are supported in Rendering and
Illustration roles. For Proximity role, Meshes are supported in
ComputeContactSurfaces() query only. No other proximity queries are
supported.</p>
<dl class="method">
<dt id="pydrake.geometry.Mesh.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Mesh</em>, <em>absolute_filename: str</em>, <em>scale: float = 1.0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.Mesh.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a mesh specification from the mesh file located at the
given <em>absolute</em> file path. Optionally uniformly scaled by the given
scale factor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <a href="#id12"><span class="problematic" id="id13">|scale|</span></a> &lt; 1e-8. Note that a negative scale is</li>
<li>considered valid. We want to preclude scales near zero but</li>
<li>recognise that scale is a convenience tool for “tweaking” models.</li>
<li>8 orders of magnitude should be plenty without considering</li>
<li>revisiting the model itself.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Mesh.filename">
<code class="descname">filename</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Mesh</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.Mesh.filename" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Mesh.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Mesh</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Mesh.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair">
<code class="descclassname">pydrake.geometry.</code><code class="descname">PenetrationAsPointPair</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.geometry.PenetrationAsPointPair_[float]" title="pydrake.geometry.PenetrationAsPointPair_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.PenetrationAsPointPair_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.geometry.PenetrationAsPointPair_">
<em class="property">template </em><code class="descclassname">pydrake.geometry.</code><code class="descname">PenetrationAsPointPair_</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.geometry.PenetrationAsPointPair_[float]" title="pydrake.geometry.PenetrationAsPointPair_[float]"><code class="xref py py-class docutils literal"><span class="pre">PenetrationAsPointPair_[float]</span></code></a>, <a class="reference internal" href="#pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd]" title="pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">PenetrationAsPointPair_[AutoDiffXd]</span></code></a></p>
<dl class="class">
<dt id="pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float]">
<em class="property">class </em><code class="descname">PenetrationAsPointPair_[float]</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A characterization of the intersection of two penetrating geometries.
The characterization consists of a pair of points and a normal. The
points represent a point on each geometry that most deeply penetrates
the other geometry (in the normal direction). For convenience, the
penetration depth is provided and is equal to:</p>
<p>depth = <code class="docutils literal"><span class="pre">(p_WCb</span> <span class="pre">-</span> <span class="pre">p_WCa)</span> <span class="pre">⋅</span> <span class="pre">nhat_BA_W</span></code></p>
<p>(<cite>depth</cite> is strictly positive when there is penetration and otherwise
not defined.)</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type. Must be a valid Eigen scalar.</dd>
</dl>
<dl class="method">
<dt id="pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.PenetrationAsPointPair_[float], **kwargs</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float].depth">
<code class="descname">depth</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float].depth" title="Permalink to this definition">¶</a></dt>
<dd><p>The penetration depth.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float].id_A">
<code class="descname">id_A</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float].id_A" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the first geometry in the contact.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float].id_B">
<code class="descname">id_B</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float].id_B" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the second geometry in the contact.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float].nhat_BA_W">
<code class="descname">nhat_BA_W</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float].nhat_BA_W" title="Permalink to this definition">¶</a></dt>
<dd><p>The unit-length normal which defines the penetration direction,
pointing from geometry B into geometry A, measured and expressed in
the world frame. It <em>approximates</em> the normal to the plane on which
the contact patch lies.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float].p_WCa">
<code class="descname">p_WCa</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float].p_WCa" title="Permalink to this definition">¶</a></dt>
<dd><p>The point on A that most deeply penetrates B, measured and expressed
in the world frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float].p_WCb">
<code class="descname">p_WCb</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_.PenetrationAsPointPair_[float].p_WCb" title="Permalink to this definition">¶</a></dt>
<dd><p>The point on B that most deeply penetrates A, measured and expressed
in the world frame.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">PenetrationAsPointPair_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>A characterization of the intersection of two penetrating geometries.
The characterization consists of a pair of points and a normal. The
points represent a point on each geometry that most deeply penetrates
the other geometry (in the normal direction). For convenience, the
penetration depth is provided and is equal to:</p>
<p>depth = <code class="docutils literal"><span class="pre">(p_WCb</span> <span class="pre">-</span> <span class="pre">p_WCa)</span> <span class="pre">⋅</span> <span class="pre">nhat_BA_W</span></code></p>
<p>(<cite>depth</cite> is strictly positive when there is penetration and otherwise
not defined.)</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type. Must be a valid Eigen scalar.</dd>
</dl>
<dl class="method">
<dt id="pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd], **kwargs</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd].depth">
<code class="descname">depth</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd].depth" title="Permalink to this definition">¶</a></dt>
<dd><p>The penetration depth.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd].id_A">
<code class="descname">id_A</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd].id_A" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the first geometry in the contact.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd].id_B">
<code class="descname">id_B</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd].id_B" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the second geometry in the contact.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd].nhat_BA_W">
<code class="descname">nhat_BA_W</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd].nhat_BA_W" title="Permalink to this definition">¶</a></dt>
<dd><p>The unit-length normal which defines the penetration direction,
pointing from geometry B into geometry A, measured and expressed in
the world frame. It <em>approximates</em> the normal to the plane on which
the contact patch lies.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd].p_WCa">
<code class="descname">p_WCa</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd].p_WCa" title="Permalink to this definition">¶</a></dt>
<dd><p>The point on A that most deeply penetrates B, measured and expressed
in the world frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd].p_WCb">
<code class="descname">p_WCb</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[AutoDiffXd].p_WCb" title="Permalink to this definition">¶</a></dt>
<dd><p>The point on B that most deeply penetrates A, measured and expressed
in the world frame.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.PenetrationAsPointPair_[float]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">PenetrationAsPointPair_[float]</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A characterization of the intersection of two penetrating geometries.
The characterization consists of a pair of points and a normal. The
points represent a point on each geometry that most deeply penetrates
the other geometry (in the normal direction). For convenience, the
penetration depth is provided and is equal to:</p>
<p>depth = <code class="docutils literal"><span class="pre">(p_WCb</span> <span class="pre">-</span> <span class="pre">p_WCa)</span> <span class="pre">⋅</span> <span class="pre">nhat_BA_W</span></code></p>
<p>(<cite>depth</cite> is strictly positive when there is penetration and otherwise
not defined.)</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type. Must be a valid Eigen scalar.</dd>
</dl>
<dl class="method">
<dt id="pydrake.geometry.PenetrationAsPointPair_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.PenetrationAsPointPair_[float], **kwargs</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_[float].depth">
<code class="descname">depth</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[float].depth" title="Permalink to this definition">¶</a></dt>
<dd><p>The penetration depth.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_[float].id_A">
<code class="descname">id_A</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[float].id_A" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the first geometry in the contact.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_[float].id_B">
<code class="descname">id_B</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[float].id_B" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the second geometry in the contact.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_[float].nhat_BA_W">
<code class="descname">nhat_BA_W</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[float].nhat_BA_W" title="Permalink to this definition">¶</a></dt>
<dd><p>The unit-length normal which defines the penetration direction,
pointing from geometry B into geometry A, measured and expressed in
the world frame. It <em>approximates</em> the normal to the plane on which
the contact patch lies.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_[float].p_WCa">
<code class="descname">p_WCa</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[float].p_WCa" title="Permalink to this definition">¶</a></dt>
<dd><p>The point on A that most deeply penetrates B, measured and expressed
in the world frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.PenetrationAsPointPair_[float].p_WCb">
<code class="descname">p_WCb</code><a class="headerlink" href="#pydrake.geometry.PenetrationAsPointPair_[float].p_WCb" title="Permalink to this definition">¶</a></dt>
<dd><p>The point on B that most deeply penetrates A, measured and expressed
in the world frame.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.PerceptionProperties">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">PerceptionProperties</code><a class="headerlink" href="#pydrake.geometry.PerceptionProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.GeometryProperties" title="pydrake.geometry.GeometryProperties"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.GeometryProperties</span></code></a></p>
<p>The set of properties for geometry used in a “perception” role.</p>
<p>Examples of functionality that depends on the perception role: -
render::RenderEngineVtk - render::RenderEngineOspray</p>
<dl class="method">
<dt id="pydrake.geometry.PerceptionProperties.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.PerceptionProperties</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.PerceptionProperties.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.ProximityProperties">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">ProximityProperties</code><a class="headerlink" href="#pydrake.geometry.ProximityProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.GeometryProperties" title="pydrake.geometry.GeometryProperties"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.GeometryProperties</span></code></a></p>
<p>The set of properties for geometry used in a <em>proximity</em> role.</p>
<p>Examples of functionality that depends on the proximity role:</p>
<dl class="method">
<dt id="pydrake.geometry.ProximityProperties.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.ProximityProperties</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.ProximityProperties.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.QueryObject">
<code class="descclassname">pydrake.geometry.</code><code class="descname">QueryObject</code><a class="headerlink" href="#pydrake.geometry.QueryObject" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.geometry.QueryObject_[float]" title="pydrake.geometry.QueryObject_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.QueryObject_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.geometry.QueryObject_">
<em class="property">template </em><code class="descclassname">pydrake.geometry.</code><code class="descname">QueryObject_</code><a class="headerlink" href="#pydrake.geometry.QueryObject_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.geometry.QueryObject_[float]" title="pydrake.geometry.QueryObject_[float]"><code class="xref py py-class docutils literal"><span class="pre">QueryObject_[float]</span></code></a>, <a class="reference internal" href="#pydrake.geometry.QueryObject_[AutoDiffXd]" title="pydrake.geometry.QueryObject_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">QueryObject_[AutoDiffXd]</span></code></a></p>
<dl class="class">
<dt id="pydrake.geometry.QueryObject_.QueryObject_[float]">
<em class="property">class </em><code class="descname">QueryObject_[float]</code><a class="headerlink" href="#pydrake.geometry.QueryObject_.QueryObject_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>The QueryObject serves as a mechanism to perform geometry queries on
the world’s geometry. The SceneGraph has an abstract-valued port that
contains a QueryObject (i.e., a QueryObject-valued output port).</p>
<p>To perform geometry queries on SceneGraph: - a LeafSystem must have a
QueryObject-valued input port and connect it to the corresponding
query output port on SceneGraph, - the querying LeafSystem can
evaluate the input port, retrieving a <code class="docutils literal"><span class="pre">const</span> <span class="pre">QueryObject&amp;</span></code> in
return, and, finally, - invoke the appropriate method on the
QueryObject.</p>
<p>The const reference returned by the input port is considered “live” -
it is linked to the context, system, and cache (making full use of all
of those mechanisms). This const reference should <em>never</em> be
persisted; doing so can lead to erroneous query results. It is simpler
and more advisable to acquire it for evaluation in a limited scope
(e.g., CalcTimeDerivatives()) and then discard it. If a QueryObject is
needed for many separate functions in a LeafSystem, each should
re-evaluate the input port. The underlying caching mechanism should
make the cost of this negligible.</p>
<p>The QueryObject <em>can</em> be copied. The copied instance is no longer
“live”; it is now “baked”. Essentially, it freezes the state of the
live scene graph in its current configuration and disconnects it from
the system and context. This means, even if the original context
changes values, the copied/baked instance will always reproduce the
same query results. This baking process is not cheap and should not be
done without consideration.</p>
<p>A QueryObject <em>cannot</em> be converted to a different scalar type. A
QueryObject of scalar type T can only be acquired from the output port
of a SceneGraph of type T evaluated on a corresponding Context, also
of type T.</p>
<p>QueryObject’s support for arbitrary scalar type is incomplete. Not all
queries support all scalar types to the same degree. In some cases the
level of support is obvious (such as when the query is declared
<em>explicitly</em> in terms of a double-valued scalar – see
ComputePointPairPenetration()). In other cases, where the query is
expressed in terms of scalar <code class="docutils literal"><span class="pre">T</span></code>, the query may have restrictions.
If a query has restricted scalar support, it is included in the
query’s documentation.</p>
<dl class="method">
<dt id="pydrake.geometry.QueryObject_.QueryObject_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.QueryObject_.QueryObject_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a default QueryObject (all pointers are null).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_.QueryObject_[float].ComputePointPairPenetration">
<code class="descname">ComputePointPairPenetration</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float]</em><span class="sig-paren">)</span> &#x2192; List[drake::geometry::PenetrationAsPointPair&lt;double&gt;]<a class="headerlink" href="#pydrake.geometry.QueryObject_.QueryObject_[float].ComputePointPairPenetration" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the penetrations across all pairs of geometries in the world
with the penetrations characterized by pairs of points (see
PenetrationAsPointPair), providing some measure of the penetration
“depth” of the two objects, but <em>not</em> the overlapping volume.</p>
<p>Only reports results for <em>penetrating</em> geometries; if two geometries
are separated, there will be no result for that pair. Geometries whose
surfaces are just touching (osculating) are not considered in
penetration. Surfaces whose penetration is within an epsilon of
osculation, are likewise not considered penetrating. Pairs of
<em>anchored</em> geometry are also not reported. This method is affected by
collision filtering.</p>
<p>For two penetrating geometries g_A and g_B, it is guaranteed that they
will map to <code class="docutils literal"><span class="pre">id_A</span></code> and <code class="docutils literal"><span class="pre">id_B</span></code> in a fixed, repeatable manner.</p>
<p><strong>Scalar support</strong></p>
<p>This method only provides double-valued penetration results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A vector populated with all detected penetrations characterized as
point pairs. The ordering of the results is guaranteed to be
consistent – for fixed geometry poses, the results will remain
the same.</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This silently ignores Mesh geometries (but Convex mesh geometries
are included).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_.QueryObject_[float].ComputeSignedDistancePairClosestPoints">
<code class="descname">ComputeSignedDistancePairClosestPoints</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], id_A: pydrake.geometry.GeometryId, id_B: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; drake::geometry::SignedDistancePair&lt;double&gt;<a class="headerlink" href="#pydrake.geometry.QueryObject_.QueryObject_[float].ComputeSignedDistancePairClosestPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>A variant of ComputeSignedDistancePairwiseClosestPoints() which
computes the signed distance (and witnesses) between a specific pair
of geometries indicated by id. This function has the same restrictions
on scalar report as ComputeSignedDistancePairwiseClosestPoints().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>if either geometry id is invalid, or if the pair (id_A, id_B) has</li>
<li>been marked as filtered.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_.QueryObject_[float].ComputeSignedDistancePairwiseClosestPoints">
<code class="descname">ComputeSignedDistancePairwiseClosestPoints</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], max_distance: float = inf</em><span class="sig-paren">)</span> &#x2192; List[drake::geometry::SignedDistancePair&lt;double&gt;]<a class="headerlink" href="#pydrake.geometry.QueryObject_.QueryObject_[float].ComputeSignedDistancePairwiseClosestPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the signed distance together with the nearest points across
all pairs of geometries in the world. Reports both the separating
geometries and penetrating geometries.</p>
<p>This query provides φ(A, B), the signed distance between two objects A
and B.</p>
<p>If the objects do not overlap (i.e., A ⋂ B = ∅), φ &gt; 0 and represents
the minimal distance between the two objects. More formally: φ =
min(<a href="#id14"><span class="problematic" id="id15">|Aₚ - Bₚ|</span></a>) ∀ Aₚ ∈ A and Bₚ ∈ B.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The pair (Aₚ, Bₚ) is a “witness” of the distance. The pair need
not be unique (think of two parallel planes).</p>
</div>
<p>If the objects touch or overlap (i.e., A ⋂ B ≠ ∅), φ ≤ 0 and can be
interpreted as the negative penetration depth. It is the smallest
length of the vector v, such that by shifting one object along that
vector relative to the other, the two objects will no longer be
overlapping. More formally, φ(A, B) = -min <a href="#id16"><span class="problematic" id="id17">|v|</span></a>. s.t (Tᵥ · A) ⋂ B = ∅
where Tᵥ is a rigid transformation that displaces A by the vector v,
namely Tᵥ · A = {u + v | ∀ u ∈ A}. By implication, there exist points
Aₚ and Bₚ on the surfaces of objects A and B, respectively, such that
Aₚ + v = Bₚ, Aₚ ∈ A ∩ B, Bₚ ∈ A ∩ B. These points are the witnesses to
the penetration.</p>
<p>This method is affected by collision filtering; geometry pairs that
have been filtered will not produce signed distance query results.</p>
<p>For a geometry pair (A, B), the returned results will always be
reported in a fixed order (e.g., always (A, B) and never (B, A)). The
<em>basis</em> for the ordering is arbitrary (and therefore undocumented),
but guaranteed to be fixed and repeatable.</p>
<p>Notice that this is an O(N²) operation, where N is the number of
geometries remaining in the world after applying collision filter. We
report the distance between dynamic objects, and between dynamic and
anchored objects. We DO NOT report the distance between two anchored
objects.</p>
<p><strong>Scalar support</strong></p>
<p>This function does not support halfspaces. If an unfiltered pair
contains a halfspace, an exception will be thrown for all scalar
types. Otherwise, this query supports all other pairs of Drake
geometry types for <code class="docutils literal"><span class="pre">double</span></code>. For <code class="docutils literal"><span class="pre">AutoDiffXd</span></code>, it only supports
distance between sphere-box and sphere-sphere. If there are any
unfiltered geometry pairs that include other geometries, the AutoDiff
throws an exception.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">max_distance</span></code>:</dt>
<dd>The maximum distance at which distance data is reported.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The signed distance (and supporting data) for all unfiltered
geometry pairs whose distance is less than or equal to
<code class="docutils literal"><span class="pre">max_distance</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_.QueryObject_[float].ComputeSignedDistanceToPoint">
<code class="descname">ComputeSignedDistanceToPoint</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], p_WQ: numpy.ndarray[numpy.float64[3, 1]], threshold: float = inf</em><span class="sig-paren">)</span> &#x2192; List[drake::geometry::SignedDistanceToPoint&lt;double&gt;]<a class="headerlink" href="#pydrake.geometry.QueryObject_.QueryObject_[float].ComputeSignedDistanceToPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the signed distances and gradients to a query point from each
geometry in the scene.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Currently supports spheres, boxes, and cylinders only. Silently
ignores other kinds of geometries, which will be added later.</p>
</div>
<p>This query provides φᵢ(p), φᵢ:ℝ³→ℝ, the signed distance to the
position p of a query point from geometry Gᵢ in the scene. It returns
an array of the signed distances from all geometries.</p>
<p>Optionally you can specify a threshold distance that will filter out
any object beyond the threshold. By default, we report distances from
the query point to every object.</p>
<p>This query also provides the gradient vector ∇φᵢ(p) of the signed
distance function from geometry Gᵢ. Note that, in general, if p is
outside Gᵢ, then ∇φᵢ(p) equals the unit vector in the direction from
the nearest point Nᵢ on Gᵢ’s surface to p. If p is inside Gᵢ, then
∇φᵢ(p) is in the direction from p to Nᵢ. This observation is written
formally as:</p>
<p>∇φᵢ(p) = (p - Nᵢ)/<a href="#id18"><span class="problematic" id="id19">|p - Nᵢ|</span></a> if p is outside Gᵢ</p>
<p>∇φᵢ(p) = -(p - Nᵢ)/<a href="#id20"><span class="problematic" id="id21">|p - Nᵢ|</span></a> if p is inside Gᵢ</p>
<p>Note that ∇φᵢ(p) is also defined on Gᵢ’s surface, but we cannot use
the above formula.</p>
<p><strong>Scalar support</strong></p>
<p>This query only supports computing distances from the point to
spheres, boxes, and cylinders for both <code class="docutils literal"><span class="pre">double</span></code> and <code class="docutils literal"><span class="pre">AutoDiffXd</span></code>
scalar types. If the SceneGraph contains any other geometry shapes,
they will be silently ignored.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a sphere G, the signed distance function φᵢ(p) has an
undefined gradient vector at the center of the sphere–every point
on the sphere’s surface has the same distance to the center. In
this case, we will assign ∇φᵢ(p) the unit vector Gx (x-directional
vector of G’s frame) expressed in World frame.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a box, at a point p on an edge or a corner of the box, the
signed distance function φᵢ(p) has an undefined gradient vector.
In this case, we will assign a unit vector in the direction of the
average of the outward face unit normals of the incident faces of
the edge or the corner. A point p is considered being on a face,
or an edge, or a corner of the box if it lies within a certain
tolerance from them.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a box B, if a point p is inside the box, and it is equidistant
to to multiple nearest faces, the signed distance function φᵢ(p)
at p will have an undefined gradient vector. There is a nearest
point candidate associated with each nearest face. In this case,
we arbitrarily pick the point Nᵢ associated with one of the
nearest faces. Please note that, due to the possible round off
error arising from applying a pose X_WG to B, there is no
guarantee which of the nearest faces will be used.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The signed distance function is a continuous function with respect
to the position of the query point, but its gradient vector field
may not be continuous. Specifically at a position equidistant to
multiple nearest points, its gradient vector field is not
continuous.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a convex object, outside the object at positive distance from
the boundary, the signed distance function is smooth (having
continuous first-order partial derivatives).</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p_WQ</span></code>:</dt>
<dd>Position of a query point Q in world frame W.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">threshold</span></code>:</dt>
<dd>We ignore any object beyond this distance. By default, it is
infinity, so we report distances from the query point to every
object.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">signed_distances</span></code>:</dt>
<dd>A vector populated with per-object signed distance values (and
supporting data). See SignedDistanceToPoint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_.QueryObject_[float].FindCollisionCandidates">
<code class="descname">FindCollisionCandidates</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float]</em><span class="sig-paren">)</span> &#x2192; List[drake::SortedPair&lt;drake::geometry::GeometryId&gt;]<a class="headerlink" href="#pydrake.geometry.QueryObject_.QueryObject_[float].FindCollisionCandidates" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a conservative culling mechanism to create a subset of all
possible geometry pairs based on non-zero intersections. A geometry
pair that is <em>absent</em> from the results is either a) culled by
collision filters or b) <em>known</em> to be separated. The caller is
responsible for confirming that the remaining, unculled geometry pairs
are <em>actually</em> in collision.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A vector populated with collision pair candidates (the order will
remain constant for a fixed population but can change as geometry
ids are added/removed).</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This silently ignores Mesh geometries (but Convex mesh geometries
are included).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_.QueryObject_[float].HasCollisions">
<code class="descname">HasCollisions</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.QueryObject_.QueryObject_[float].HasCollisions" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports true if there are <em>any</em> collisions between unfiltered pairs in
the world.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This silently ignores Mesh geometries (but Convex mesh geometries
are included).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_.QueryObject_[float].inspector">
<code class="descname">inspector</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.SceneGraphInspector_[float]<a class="headerlink" href="#pydrake.geometry.QueryObject_.QueryObject_[float].inspector" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides an inspector for the topological structure of the underlying
scene graph data (see SceneGraphInspector for details).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_.QueryObject_[float].RenderColorImage">
<code class="descname">RenderColorImage</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], camera: drake::geometry::render::CameraProperties, parent_frame: pydrake.geometry.FrameId, X_PC: pydrake.math.RigidTransform_[float], show_window: bool = False</em><span class="sig-paren">)</span> &#x2192; drake::systems::sensors::Image&lt;(drake::systems::sensors::PixelType)2&gt;<a class="headerlink" href="#pydrake.geometry.QueryObject_.QueryObject_[float].RenderColorImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Renders an RGB image for the given <code class="docutils literal"><span class="pre">camera</span></code> posed with respect to
the indicated parent frame P.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">camera</span></code>:</dt>
<dd>The intrinsic properties of the camera.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">parent_frame</span></code>:</dt>
<dd>The id for the camera’s parent frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_PC</span></code>:</dt>
<dd>The pose of the camera body in the world frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">show_window</span></code>:</dt>
<dd>If true, the render window will be displayed.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">color_image_out</span></code>:</dt>
<dd>The rendered color image.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_.QueryObject_[float].RenderDepthImage">
<code class="descname">RenderDepthImage</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], camera: drake::geometry::render::DepthCameraProperties, parent_frame: pydrake.geometry.FrameId, X_PC: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; drake::systems::sensors::Image&lt;(drake::systems::sensors::PixelType)6&gt;<a class="headerlink" href="#pydrake.geometry.QueryObject_.QueryObject_[float].RenderDepthImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Renders a depth image for the given <code class="docutils literal"><span class="pre">camera</span></code> posed with respect to
the indicated parent frame P.</p>
<p>In contrast to the other rendering methods, rendering depth images
doesn’t provide the option to display the window; generally, basic
depth images are not readily communicative to humans.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">camera</span></code>:</dt>
<dd>The intrinsic properties of the camera.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">parent_frame</span></code>:</dt>
<dd>The id for the camera’s parent frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_PC</span></code>:</dt>
<dd>The pose of the camera body in the world frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">depth_image_out</span></code>:</dt>
<dd>The rendered depth image.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_.QueryObject_[float].RenderLabelImage">
<code class="descname">RenderLabelImage</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], camera: drake::geometry::render::CameraProperties, parent_frame: pydrake.geometry.FrameId, X_PC: pydrake.math.RigidTransform_[float], show_window: bool = False</em><span class="sig-paren">)</span> &#x2192; drake::systems::sensors::Image&lt;(drake::systems::sensors::PixelType)7&gt;<a class="headerlink" href="#pydrake.geometry.QueryObject_.QueryObject_[float].RenderLabelImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Renders a label image for the given <code class="docutils literal"><span class="pre">camera</span></code> posed with respect to
the indicated parent frame P.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">camera</span></code>:</dt>
<dd>The intrinsic properties of the camera.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">parent_frame</span></code>:</dt>
<dd>The id for the camera’s parent frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_PC</span></code>:</dt>
<dd>The pose of the camera body in the world frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">show_window</span></code>:</dt>
<dd>If true, the render window will be displayed.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">label_image_out</span></code>:</dt>
<dd>The rendered label image.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_.QueryObject_[float].X_PF">
<code class="descname">X_PF</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], id: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.QueryObject_.QueryObject_[float].X_PF" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the position of the frame indicated by <code class="docutils literal"><span class="pre">id</span></code> relative to its
parent frame. If the frame was registered with the world frame as its
parent frame, this value will be identical to that returned by X_WF().</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is analogous to but distinct from
SceneGraphInspector::X_PG(). In this case, the pose will <em>always</em>
be relative to another frame.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the frame <code class="docutils literal"><span class="pre">id</span></code> is not valid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_.QueryObject_[float].X_WF">
<code class="descname">X_WF</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], id: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.QueryObject_.QueryObject_[float].X_WF" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the position of the frame indicated by <code class="docutils literal"><span class="pre">id</span></code> relative to the
world frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the frame <code class="docutils literal"><span class="pre">id</span></code> is not valid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_.QueryObject_[float].X_WG">
<code class="descname">X_WG</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.QueryObject_.QueryObject_[float].X_WG" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the position of the geometry indicated by <code class="docutils literal"><span class="pre">id</span></code> relative to
the world frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the geometry <code class="docutils literal"><span class="pre">id</span></code> is not valid.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.QueryObject_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">QueryObject_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.geometry.QueryObject_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>The QueryObject serves as a mechanism to perform geometry queries on
the world’s geometry. The SceneGraph has an abstract-valued port that
contains a QueryObject (i.e., a QueryObject-valued output port).</p>
<p>To perform geometry queries on SceneGraph: - a LeafSystem must have a
QueryObject-valued input port and connect it to the corresponding
query output port on SceneGraph, - the querying LeafSystem can
evaluate the input port, retrieving a <code class="docutils literal"><span class="pre">const</span> <span class="pre">QueryObject&amp;</span></code> in
return, and, finally, - invoke the appropriate method on the
QueryObject.</p>
<p>The const reference returned by the input port is considered “live” -
it is linked to the context, system, and cache (making full use of all
of those mechanisms). This const reference should <em>never</em> be
persisted; doing so can lead to erroneous query results. It is simpler
and more advisable to acquire it for evaluation in a limited scope
(e.g., CalcTimeDerivatives()) and then discard it. If a QueryObject is
needed for many separate functions in a LeafSystem, each should
re-evaluate the input port. The underlying caching mechanism should
make the cost of this negligible.</p>
<p>The QueryObject <em>can</em> be copied. The copied instance is no longer
“live”; it is now “baked”. Essentially, it freezes the state of the
live scene graph in its current configuration and disconnects it from
the system and context. This means, even if the original context
changes values, the copied/baked instance will always reproduce the
same query results. This baking process is not cheap and should not be
done without consideration.</p>
<p>A QueryObject <em>cannot</em> be converted to a different scalar type. A
QueryObject of scalar type T can only be acquired from the output port
of a SceneGraph of type T evaluated on a corresponding Context, also
of type T.</p>
<p>QueryObject’s support for arbitrary scalar type is incomplete. Not all
queries support all scalar types to the same degree. In some cases the
level of support is obvious (such as when the query is declared
<em>explicitly</em> in terms of a double-valued scalar – see
ComputePointPairPenetration()). In other cases, where the query is
expressed in terms of scalar <code class="docutils literal"><span class="pre">T</span></code>, the query may have restrictions.
If a query has restricted scalar support, it is included in the
query’s documentation.</p>
<dl class="method">
<dt id="pydrake.geometry.QueryObject_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.QueryObject_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a default QueryObject (all pointers are null).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[AutoDiffXd].ComputePointPairPenetration">
<code class="descname">ComputePointPairPenetration</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.PenetrationAsPointPair_[float]]<a class="headerlink" href="#pydrake.geometry.QueryObject_[AutoDiffXd].ComputePointPairPenetration" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the penetrations across all pairs of geometries in the world
with the penetrations characterized by pairs of points (see
PenetrationAsPointPair), providing some measure of the penetration
“depth” of the two objects, but <em>not</em> the overlapping volume.</p>
<p>Only reports results for <em>penetrating</em> geometries; if two geometries
are separated, there will be no result for that pair. Geometries whose
surfaces are just touching (osculating) are not considered in
penetration. Surfaces whose penetration is within an epsilon of
osculation, are likewise not considered penetrating. Pairs of
<em>anchored</em> geometry are also not reported. This method is affected by
collision filtering.</p>
<p>For two penetrating geometries g_A and g_B, it is guaranteed that they
will map to <code class="docutils literal"><span class="pre">id_A</span></code> and <code class="docutils literal"><span class="pre">id_B</span></code> in a fixed, repeatable manner.</p>
<p><strong>Scalar support</strong></p>
<p>This method only provides double-valued penetration results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A vector populated with all detected penetrations characterized as
point pairs. The ordering of the results is guaranteed to be
consistent – for fixed geometry poses, the results will remain
the same.</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This silently ignores Mesh geometries (but Convex mesh geometries
are included).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[AutoDiffXd].ComputeSignedDistancePairClosestPoints">
<code class="descname">ComputeSignedDistancePairClosestPoints</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[AutoDiffXd], id_A: pydrake.geometry.GeometryId, id_B: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; drake::geometry::SignedDistancePair&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.geometry.QueryObject_[AutoDiffXd].ComputeSignedDistancePairClosestPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>A variant of ComputeSignedDistancePairwiseClosestPoints() which
computes the signed distance (and witnesses) between a specific pair
of geometries indicated by id. This function has the same restrictions
on scalar report as ComputeSignedDistancePairwiseClosestPoints().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>if either geometry id is invalid, or if the pair (id_A, id_B) has</li>
<li>been marked as filtered.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[AutoDiffXd].ComputeSignedDistancePairwiseClosestPoints">
<code class="descname">ComputeSignedDistancePairwiseClosestPoints</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[AutoDiffXd], max_distance: float = inf</em><span class="sig-paren">)</span> &#x2192; List[drake::geometry::SignedDistancePair&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;]<a class="headerlink" href="#pydrake.geometry.QueryObject_[AutoDiffXd].ComputeSignedDistancePairwiseClosestPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the signed distance together with the nearest points across
all pairs of geometries in the world. Reports both the separating
geometries and penetrating geometries.</p>
<p>This query provides φ(A, B), the signed distance between two objects A
and B.</p>
<p>If the objects do not overlap (i.e., A ⋂ B = ∅), φ &gt; 0 and represents
the minimal distance between the two objects. More formally: φ =
min(<a href="#id22"><span class="problematic" id="id23">|Aₚ - Bₚ|</span></a>) ∀ Aₚ ∈ A and Bₚ ∈ B.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The pair (Aₚ, Bₚ) is a “witness” of the distance. The pair need
not be unique (think of two parallel planes).</p>
</div>
<p>If the objects touch or overlap (i.e., A ⋂ B ≠ ∅), φ ≤ 0 and can be
interpreted as the negative penetration depth. It is the smallest
length of the vector v, such that by shifting one object along that
vector relative to the other, the two objects will no longer be
overlapping. More formally, φ(A, B) = -min <a href="#id24"><span class="problematic" id="id25">|v|</span></a>. s.t (Tᵥ · A) ⋂ B = ∅
where Tᵥ is a rigid transformation that displaces A by the vector v,
namely Tᵥ · A = {u + v | ∀ u ∈ A}. By implication, there exist points
Aₚ and Bₚ on the surfaces of objects A and B, respectively, such that
Aₚ + v = Bₚ, Aₚ ∈ A ∩ B, Bₚ ∈ A ∩ B. These points are the witnesses to
the penetration.</p>
<p>This method is affected by collision filtering; geometry pairs that
have been filtered will not produce signed distance query results.</p>
<p>For a geometry pair (A, B), the returned results will always be
reported in a fixed order (e.g., always (A, B) and never (B, A)). The
<em>basis</em> for the ordering is arbitrary (and therefore undocumented),
but guaranteed to be fixed and repeatable.</p>
<p>Notice that this is an O(N²) operation, where N is the number of
geometries remaining in the world after applying collision filter. We
report the distance between dynamic objects, and between dynamic and
anchored objects. We DO NOT report the distance between two anchored
objects.</p>
<p><strong>Scalar support</strong></p>
<p>This function does not support halfspaces. If an unfiltered pair
contains a halfspace, an exception will be thrown for all scalar
types. Otherwise, this query supports all other pairs of Drake
geometry types for <code class="docutils literal"><span class="pre">double</span></code>. For <code class="docutils literal"><span class="pre">AutoDiffXd</span></code>, it only supports
distance between sphere-box and sphere-sphere. If there are any
unfiltered geometry pairs that include other geometries, the AutoDiff
throws an exception.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">max_distance</span></code>:</dt>
<dd>The maximum distance at which distance data is reported.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The signed distance (and supporting data) for all unfiltered
geometry pairs whose distance is less than or equal to
<code class="docutils literal"><span class="pre">max_distance</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[AutoDiffXd].ComputeSignedDistanceToPoint">
<code class="descname">ComputeSignedDistanceToPoint</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[AutoDiffXd], p_WQ: numpy.ndarray[object[3, 1]], threshold: float = inf</em><span class="sig-paren">)</span> &#x2192; List[drake::geometry::SignedDistanceToPoint&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;]<a class="headerlink" href="#pydrake.geometry.QueryObject_[AutoDiffXd].ComputeSignedDistanceToPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the signed distances and gradients to a query point from each
geometry in the scene.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Currently supports spheres, boxes, and cylinders only. Silently
ignores other kinds of geometries, which will be added later.</p>
</div>
<p>This query provides φᵢ(p), φᵢ:ℝ³→ℝ, the signed distance to the
position p of a query point from geometry Gᵢ in the scene. It returns
an array of the signed distances from all geometries.</p>
<p>Optionally you can specify a threshold distance that will filter out
any object beyond the threshold. By default, we report distances from
the query point to every object.</p>
<p>This query also provides the gradient vector ∇φᵢ(p) of the signed
distance function from geometry Gᵢ. Note that, in general, if p is
outside Gᵢ, then ∇φᵢ(p) equals the unit vector in the direction from
the nearest point Nᵢ on Gᵢ’s surface to p. If p is inside Gᵢ, then
∇φᵢ(p) is in the direction from p to Nᵢ. This observation is written
formally as:</p>
<p>∇φᵢ(p) = (p - Nᵢ)/<a href="#id26"><span class="problematic" id="id27">|p - Nᵢ|</span></a> if p is outside Gᵢ</p>
<p>∇φᵢ(p) = -(p - Nᵢ)/<a href="#id28"><span class="problematic" id="id29">|p - Nᵢ|</span></a> if p is inside Gᵢ</p>
<p>Note that ∇φᵢ(p) is also defined on Gᵢ’s surface, but we cannot use
the above formula.</p>
<p><strong>Scalar support</strong></p>
<p>This query only supports computing distances from the point to
spheres, boxes, and cylinders for both <code class="docutils literal"><span class="pre">double</span></code> and <code class="docutils literal"><span class="pre">AutoDiffXd</span></code>
scalar types. If the SceneGraph contains any other geometry shapes,
they will be silently ignored.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a sphere G, the signed distance function φᵢ(p) has an
undefined gradient vector at the center of the sphere–every point
on the sphere’s surface has the same distance to the center. In
this case, we will assign ∇φᵢ(p) the unit vector Gx (x-directional
vector of G’s frame) expressed in World frame.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a box, at a point p on an edge or a corner of the box, the
signed distance function φᵢ(p) has an undefined gradient vector.
In this case, we will assign a unit vector in the direction of the
average of the outward face unit normals of the incident faces of
the edge or the corner. A point p is considered being on a face,
or an edge, or a corner of the box if it lies within a certain
tolerance from them.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a box B, if a point p is inside the box, and it is equidistant
to to multiple nearest faces, the signed distance function φᵢ(p)
at p will have an undefined gradient vector. There is a nearest
point candidate associated with each nearest face. In this case,
we arbitrarily pick the point Nᵢ associated with one of the
nearest faces. Please note that, due to the possible round off
error arising from applying a pose X_WG to B, there is no
guarantee which of the nearest faces will be used.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The signed distance function is a continuous function with respect
to the position of the query point, but its gradient vector field
may not be continuous. Specifically at a position equidistant to
multiple nearest points, its gradient vector field is not
continuous.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a convex object, outside the object at positive distance from
the boundary, the signed distance function is smooth (having
continuous first-order partial derivatives).</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p_WQ</span></code>:</dt>
<dd>Position of a query point Q in world frame W.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">threshold</span></code>:</dt>
<dd>We ignore any object beyond this distance. By default, it is
infinity, so we report distances from the query point to every
object.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">signed_distances</span></code>:</dt>
<dd>A vector populated with per-object signed distance values (and
supporting data). See SignedDistanceToPoint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[AutoDiffXd].FindCollisionCandidates">
<code class="descname">FindCollisionCandidates</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; List[drake::SortedPair&lt;drake::geometry::GeometryId&gt;]<a class="headerlink" href="#pydrake.geometry.QueryObject_[AutoDiffXd].FindCollisionCandidates" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a conservative culling mechanism to create a subset of all
possible geometry pairs based on non-zero intersections. A geometry
pair that is <em>absent</em> from the results is either a) culled by
collision filters or b) <em>known</em> to be separated. The caller is
responsible for confirming that the remaining, unculled geometry pairs
are <em>actually</em> in collision.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A vector populated with collision pair candidates (the order will
remain constant for a fixed population but can change as geometry
ids are added/removed).</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This silently ignores Mesh geometries (but Convex mesh geometries
are included).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[AutoDiffXd].HasCollisions">
<code class="descname">HasCollisions</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.QueryObject_[AutoDiffXd].HasCollisions" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports true if there are <em>any</em> collisions between unfiltered pairs in
the world.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This silently ignores Mesh geometries (but Convex mesh geometries
are included).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[AutoDiffXd].inspector">
<code class="descname">inspector</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.SceneGraphInspector_[AutoDiffXd]<a class="headerlink" href="#pydrake.geometry.QueryObject_[AutoDiffXd].inspector" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides an inspector for the topological structure of the underlying
scene graph data (see SceneGraphInspector for details).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[AutoDiffXd].RenderColorImage">
<code class="descname">RenderColorImage</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[AutoDiffXd], camera: drake::geometry::render::CameraProperties, parent_frame: pydrake.geometry.FrameId, X_PC: pydrake.math.RigidTransform_[float], show_window: bool = False</em><span class="sig-paren">)</span> &#x2192; drake::systems::sensors::Image&lt;(drake::systems::sensors::PixelType)2&gt;<a class="headerlink" href="#pydrake.geometry.QueryObject_[AutoDiffXd].RenderColorImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Renders an RGB image for the given <code class="docutils literal"><span class="pre">camera</span></code> posed with respect to
the indicated parent frame P.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">camera</span></code>:</dt>
<dd>The intrinsic properties of the camera.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">parent_frame</span></code>:</dt>
<dd>The id for the camera’s parent frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_PC</span></code>:</dt>
<dd>The pose of the camera body in the world frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">show_window</span></code>:</dt>
<dd>If true, the render window will be displayed.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">color_image_out</span></code>:</dt>
<dd>The rendered color image.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[AutoDiffXd].RenderDepthImage">
<code class="descname">RenderDepthImage</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[AutoDiffXd], camera: drake::geometry::render::DepthCameraProperties, parent_frame: pydrake.geometry.FrameId, X_PC: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; drake::systems::sensors::Image&lt;(drake::systems::sensors::PixelType)6&gt;<a class="headerlink" href="#pydrake.geometry.QueryObject_[AutoDiffXd].RenderDepthImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Renders a depth image for the given <code class="docutils literal"><span class="pre">camera</span></code> posed with respect to
the indicated parent frame P.</p>
<p>In contrast to the other rendering methods, rendering depth images
doesn’t provide the option to display the window; generally, basic
depth images are not readily communicative to humans.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">camera</span></code>:</dt>
<dd>The intrinsic properties of the camera.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">parent_frame</span></code>:</dt>
<dd>The id for the camera’s parent frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_PC</span></code>:</dt>
<dd>The pose of the camera body in the world frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">depth_image_out</span></code>:</dt>
<dd>The rendered depth image.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[AutoDiffXd].RenderLabelImage">
<code class="descname">RenderLabelImage</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[AutoDiffXd], camera: drake::geometry::render::CameraProperties, parent_frame: pydrake.geometry.FrameId, X_PC: pydrake.math.RigidTransform_[float], show_window: bool = False</em><span class="sig-paren">)</span> &#x2192; drake::systems::sensors::Image&lt;(drake::systems::sensors::PixelType)7&gt;<a class="headerlink" href="#pydrake.geometry.QueryObject_[AutoDiffXd].RenderLabelImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Renders a label image for the given <code class="docutils literal"><span class="pre">camera</span></code> posed with respect to
the indicated parent frame P.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">camera</span></code>:</dt>
<dd>The intrinsic properties of the camera.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">parent_frame</span></code>:</dt>
<dd>The id for the camera’s parent frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_PC</span></code>:</dt>
<dd>The pose of the camera body in the world frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">show_window</span></code>:</dt>
<dd>If true, the render window will be displayed.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">label_image_out</span></code>:</dt>
<dd>The rendered label image.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[AutoDiffXd].X_PF">
<code class="descname">X_PF</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[AutoDiffXd], id: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.geometry.QueryObject_[AutoDiffXd].X_PF" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the position of the frame indicated by <code class="docutils literal"><span class="pre">id</span></code> relative to its
parent frame. If the frame was registered with the world frame as its
parent frame, this value will be identical to that returned by X_WF().</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is analogous to but distinct from
SceneGraphInspector::X_PG(). In this case, the pose will <em>always</em>
be relative to another frame.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the frame <code class="docutils literal"><span class="pre">id</span></code> is not valid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[AutoDiffXd].X_WF">
<code class="descname">X_WF</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[AutoDiffXd], id: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.geometry.QueryObject_[AutoDiffXd].X_WF" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the position of the frame indicated by <code class="docutils literal"><span class="pre">id</span></code> relative to the
world frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the frame <code class="docutils literal"><span class="pre">id</span></code> is not valid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[AutoDiffXd].X_WG">
<code class="descname">X_WG</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[AutoDiffXd], id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.geometry.QueryObject_[AutoDiffXd].X_WG" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the position of the geometry indicated by <code class="docutils literal"><span class="pre">id</span></code> relative to
the world frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the geometry <code class="docutils literal"><span class="pre">id</span></code> is not valid.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.QueryObject_[float]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">QueryObject_[float]</code><a class="headerlink" href="#pydrake.geometry.QueryObject_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>The QueryObject serves as a mechanism to perform geometry queries on
the world’s geometry. The SceneGraph has an abstract-valued port that
contains a QueryObject (i.e., a QueryObject-valued output port).</p>
<p>To perform geometry queries on SceneGraph: - a LeafSystem must have a
QueryObject-valued input port and connect it to the corresponding
query output port on SceneGraph, - the querying LeafSystem can
evaluate the input port, retrieving a <code class="docutils literal"><span class="pre">const</span> <span class="pre">QueryObject&amp;</span></code> in
return, and, finally, - invoke the appropriate method on the
QueryObject.</p>
<p>The const reference returned by the input port is considered “live” -
it is linked to the context, system, and cache (making full use of all
of those mechanisms). This const reference should <em>never</em> be
persisted; doing so can lead to erroneous query results. It is simpler
and more advisable to acquire it for evaluation in a limited scope
(e.g., CalcTimeDerivatives()) and then discard it. If a QueryObject is
needed for many separate functions in a LeafSystem, each should
re-evaluate the input port. The underlying caching mechanism should
make the cost of this negligible.</p>
<p>The QueryObject <em>can</em> be copied. The copied instance is no longer
“live”; it is now “baked”. Essentially, it freezes the state of the
live scene graph in its current configuration and disconnects it from
the system and context. This means, even if the original context
changes values, the copied/baked instance will always reproduce the
same query results. This baking process is not cheap and should not be
done without consideration.</p>
<p>A QueryObject <em>cannot</em> be converted to a different scalar type. A
QueryObject of scalar type T can only be acquired from the output port
of a SceneGraph of type T evaluated on a corresponding Context, also
of type T.</p>
<p>QueryObject’s support for arbitrary scalar type is incomplete. Not all
queries support all scalar types to the same degree. In some cases the
level of support is obvious (such as when the query is declared
<em>explicitly</em> in terms of a double-valued scalar – see
ComputePointPairPenetration()). In other cases, where the query is
expressed in terms of scalar <code class="docutils literal"><span class="pre">T</span></code>, the query may have restrictions.
If a query has restricted scalar support, it is included in the
query’s documentation.</p>
<dl class="method">
<dt id="pydrake.geometry.QueryObject_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.QueryObject_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a default QueryObject (all pointers are null).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[float].ComputePointPairPenetration">
<code class="descname">ComputePointPairPenetration</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float]</em><span class="sig-paren">)</span> &#x2192; List[drake::geometry::PenetrationAsPointPair&lt;double&gt;]<a class="headerlink" href="#pydrake.geometry.QueryObject_[float].ComputePointPairPenetration" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the penetrations across all pairs of geometries in the world
with the penetrations characterized by pairs of points (see
PenetrationAsPointPair), providing some measure of the penetration
“depth” of the two objects, but <em>not</em> the overlapping volume.</p>
<p>Only reports results for <em>penetrating</em> geometries; if two geometries
are separated, there will be no result for that pair. Geometries whose
surfaces are just touching (osculating) are not considered in
penetration. Surfaces whose penetration is within an epsilon of
osculation, are likewise not considered penetrating. Pairs of
<em>anchored</em> geometry are also not reported. This method is affected by
collision filtering.</p>
<p>For two penetrating geometries g_A and g_B, it is guaranteed that they
will map to <code class="docutils literal"><span class="pre">id_A</span></code> and <code class="docutils literal"><span class="pre">id_B</span></code> in a fixed, repeatable manner.</p>
<p><strong>Scalar support</strong></p>
<p>This method only provides double-valued penetration results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A vector populated with all detected penetrations characterized as
point pairs. The ordering of the results is guaranteed to be
consistent – for fixed geometry poses, the results will remain
the same.</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This silently ignores Mesh geometries (but Convex mesh geometries
are included).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[float].ComputeSignedDistancePairClosestPoints">
<code class="descname">ComputeSignedDistancePairClosestPoints</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], id_A: pydrake.geometry.GeometryId, id_B: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; drake::geometry::SignedDistancePair&lt;double&gt;<a class="headerlink" href="#pydrake.geometry.QueryObject_[float].ComputeSignedDistancePairClosestPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>A variant of ComputeSignedDistancePairwiseClosestPoints() which
computes the signed distance (and witnesses) between a specific pair
of geometries indicated by id. This function has the same restrictions
on scalar report as ComputeSignedDistancePairwiseClosestPoints().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>if either geometry id is invalid, or if the pair (id_A, id_B) has</li>
<li>been marked as filtered.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[float].ComputeSignedDistancePairwiseClosestPoints">
<code class="descname">ComputeSignedDistancePairwiseClosestPoints</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], max_distance: float = inf</em><span class="sig-paren">)</span> &#x2192; List[drake::geometry::SignedDistancePair&lt;double&gt;]<a class="headerlink" href="#pydrake.geometry.QueryObject_[float].ComputeSignedDistancePairwiseClosestPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the signed distance together with the nearest points across
all pairs of geometries in the world. Reports both the separating
geometries and penetrating geometries.</p>
<p>This query provides φ(A, B), the signed distance between two objects A
and B.</p>
<p>If the objects do not overlap (i.e., A ⋂ B = ∅), φ &gt; 0 and represents
the minimal distance between the two objects. More formally: φ =
min(<a href="#id30"><span class="problematic" id="id31">|Aₚ - Bₚ|</span></a>) ∀ Aₚ ∈ A and Bₚ ∈ B.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The pair (Aₚ, Bₚ) is a “witness” of the distance. The pair need
not be unique (think of two parallel planes).</p>
</div>
<p>If the objects touch or overlap (i.e., A ⋂ B ≠ ∅), φ ≤ 0 and can be
interpreted as the negative penetration depth. It is the smallest
length of the vector v, such that by shifting one object along that
vector relative to the other, the two objects will no longer be
overlapping. More formally, φ(A, B) = -min <a href="#id32"><span class="problematic" id="id33">|v|</span></a>. s.t (Tᵥ · A) ⋂ B = ∅
where Tᵥ is a rigid transformation that displaces A by the vector v,
namely Tᵥ · A = {u + v | ∀ u ∈ A}. By implication, there exist points
Aₚ and Bₚ on the surfaces of objects A and B, respectively, such that
Aₚ + v = Bₚ, Aₚ ∈ A ∩ B, Bₚ ∈ A ∩ B. These points are the witnesses to
the penetration.</p>
<p>This method is affected by collision filtering; geometry pairs that
have been filtered will not produce signed distance query results.</p>
<p>For a geometry pair (A, B), the returned results will always be
reported in a fixed order (e.g., always (A, B) and never (B, A)). The
<em>basis</em> for the ordering is arbitrary (and therefore undocumented),
but guaranteed to be fixed and repeatable.</p>
<p>Notice that this is an O(N²) operation, where N is the number of
geometries remaining in the world after applying collision filter. We
report the distance between dynamic objects, and between dynamic and
anchored objects. We DO NOT report the distance between two anchored
objects.</p>
<p><strong>Scalar support</strong></p>
<p>This function does not support halfspaces. If an unfiltered pair
contains a halfspace, an exception will be thrown for all scalar
types. Otherwise, this query supports all other pairs of Drake
geometry types for <code class="docutils literal"><span class="pre">double</span></code>. For <code class="docutils literal"><span class="pre">AutoDiffXd</span></code>, it only supports
distance between sphere-box and sphere-sphere. If there are any
unfiltered geometry pairs that include other geometries, the AutoDiff
throws an exception.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">max_distance</span></code>:</dt>
<dd>The maximum distance at which distance data is reported.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The signed distance (and supporting data) for all unfiltered
geometry pairs whose distance is less than or equal to
<code class="docutils literal"><span class="pre">max_distance</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[float].ComputeSignedDistanceToPoint">
<code class="descname">ComputeSignedDistanceToPoint</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], p_WQ: numpy.ndarray[numpy.float64[3, 1]], threshold: float = inf</em><span class="sig-paren">)</span> &#x2192; List[drake::geometry::SignedDistanceToPoint&lt;double&gt;]<a class="headerlink" href="#pydrake.geometry.QueryObject_[float].ComputeSignedDistanceToPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the signed distances and gradients to a query point from each
geometry in the scene.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Currently supports spheres, boxes, and cylinders only. Silently
ignores other kinds of geometries, which will be added later.</p>
</div>
<p>This query provides φᵢ(p), φᵢ:ℝ³→ℝ, the signed distance to the
position p of a query point from geometry Gᵢ in the scene. It returns
an array of the signed distances from all geometries.</p>
<p>Optionally you can specify a threshold distance that will filter out
any object beyond the threshold. By default, we report distances from
the query point to every object.</p>
<p>This query also provides the gradient vector ∇φᵢ(p) of the signed
distance function from geometry Gᵢ. Note that, in general, if p is
outside Gᵢ, then ∇φᵢ(p) equals the unit vector in the direction from
the nearest point Nᵢ on Gᵢ’s surface to p. If p is inside Gᵢ, then
∇φᵢ(p) is in the direction from p to Nᵢ. This observation is written
formally as:</p>
<p>∇φᵢ(p) = (p - Nᵢ)/<a href="#id34"><span class="problematic" id="id35">|p - Nᵢ|</span></a> if p is outside Gᵢ</p>
<p>∇φᵢ(p) = -(p - Nᵢ)/<a href="#id36"><span class="problematic" id="id37">|p - Nᵢ|</span></a> if p is inside Gᵢ</p>
<p>Note that ∇φᵢ(p) is also defined on Gᵢ’s surface, but we cannot use
the above formula.</p>
<p><strong>Scalar support</strong></p>
<p>This query only supports computing distances from the point to
spheres, boxes, and cylinders for both <code class="docutils literal"><span class="pre">double</span></code> and <code class="docutils literal"><span class="pre">AutoDiffXd</span></code>
scalar types. If the SceneGraph contains any other geometry shapes,
they will be silently ignored.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a sphere G, the signed distance function φᵢ(p) has an
undefined gradient vector at the center of the sphere–every point
on the sphere’s surface has the same distance to the center. In
this case, we will assign ∇φᵢ(p) the unit vector Gx (x-directional
vector of G’s frame) expressed in World frame.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a box, at a point p on an edge or a corner of the box, the
signed distance function φᵢ(p) has an undefined gradient vector.
In this case, we will assign a unit vector in the direction of the
average of the outward face unit normals of the incident faces of
the edge or the corner. A point p is considered being on a face,
or an edge, or a corner of the box if it lies within a certain
tolerance from them.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a box B, if a point p is inside the box, and it is equidistant
to to multiple nearest faces, the signed distance function φᵢ(p)
at p will have an undefined gradient vector. There is a nearest
point candidate associated with each nearest face. In this case,
we arbitrarily pick the point Nᵢ associated with one of the
nearest faces. Please note that, due to the possible round off
error arising from applying a pose X_WG to B, there is no
guarantee which of the nearest faces will be used.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The signed distance function is a continuous function with respect
to the position of the query point, but its gradient vector field
may not be continuous. Specifically at a position equidistant to
multiple nearest points, its gradient vector field is not
continuous.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a convex object, outside the object at positive distance from
the boundary, the signed distance function is smooth (having
continuous first-order partial derivatives).</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p_WQ</span></code>:</dt>
<dd>Position of a query point Q in world frame W.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">threshold</span></code>:</dt>
<dd>We ignore any object beyond this distance. By default, it is
infinity, so we report distances from the query point to every
object.</dd>
<dt>Returns <code class="docutils literal"><span class="pre">signed_distances</span></code>:</dt>
<dd>A vector populated with per-object signed distance values (and
supporting data). See SignedDistanceToPoint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[float].FindCollisionCandidates">
<code class="descname">FindCollisionCandidates</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float]</em><span class="sig-paren">)</span> &#x2192; List[drake::SortedPair&lt;drake::geometry::GeometryId&gt;]<a class="headerlink" href="#pydrake.geometry.QueryObject_[float].FindCollisionCandidates" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a conservative culling mechanism to create a subset of all
possible geometry pairs based on non-zero intersections. A geometry
pair that is <em>absent</em> from the results is either a) culled by
collision filters or b) <em>known</em> to be separated. The caller is
responsible for confirming that the remaining, unculled geometry pairs
are <em>actually</em> in collision.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A vector populated with collision pair candidates (the order will
remain constant for a fixed population but can change as geometry
ids are added/removed).</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This silently ignores Mesh geometries (but Convex mesh geometries
are included).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[float].HasCollisions">
<code class="descname">HasCollisions</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.QueryObject_[float].HasCollisions" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports true if there are <em>any</em> collisions between unfiltered pairs in
the world.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This silently ignores Mesh geometries (but Convex mesh geometries
are included).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[float].inspector">
<code class="descname">inspector</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.SceneGraphInspector_[float]<a class="headerlink" href="#pydrake.geometry.QueryObject_[float].inspector" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides an inspector for the topological structure of the underlying
scene graph data (see SceneGraphInspector for details).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[float].RenderColorImage">
<code class="descname">RenderColorImage</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], camera: drake::geometry::render::CameraProperties, parent_frame: pydrake.geometry.FrameId, X_PC: pydrake.math.RigidTransform_[float], show_window: bool = False</em><span class="sig-paren">)</span> &#x2192; drake::systems::sensors::Image&lt;(drake::systems::sensors::PixelType)2&gt;<a class="headerlink" href="#pydrake.geometry.QueryObject_[float].RenderColorImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Renders an RGB image for the given <code class="docutils literal"><span class="pre">camera</span></code> posed with respect to
the indicated parent frame P.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">camera</span></code>:</dt>
<dd>The intrinsic properties of the camera.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">parent_frame</span></code>:</dt>
<dd>The id for the camera’s parent frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_PC</span></code>:</dt>
<dd>The pose of the camera body in the world frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">show_window</span></code>:</dt>
<dd>If true, the render window will be displayed.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">color_image_out</span></code>:</dt>
<dd>The rendered color image.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[float].RenderDepthImage">
<code class="descname">RenderDepthImage</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], camera: drake::geometry::render::DepthCameraProperties, parent_frame: pydrake.geometry.FrameId, X_PC: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; drake::systems::sensors::Image&lt;(drake::systems::sensors::PixelType)6&gt;<a class="headerlink" href="#pydrake.geometry.QueryObject_[float].RenderDepthImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Renders a depth image for the given <code class="docutils literal"><span class="pre">camera</span></code> posed with respect to
the indicated parent frame P.</p>
<p>In contrast to the other rendering methods, rendering depth images
doesn’t provide the option to display the window; generally, basic
depth images are not readily communicative to humans.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">camera</span></code>:</dt>
<dd>The intrinsic properties of the camera.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">parent_frame</span></code>:</dt>
<dd>The id for the camera’s parent frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_PC</span></code>:</dt>
<dd>The pose of the camera body in the world frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">depth_image_out</span></code>:</dt>
<dd>The rendered depth image.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[float].RenderLabelImage">
<code class="descname">RenderLabelImage</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], camera: drake::geometry::render::CameraProperties, parent_frame: pydrake.geometry.FrameId, X_PC: pydrake.math.RigidTransform_[float], show_window: bool = False</em><span class="sig-paren">)</span> &#x2192; drake::systems::sensors::Image&lt;(drake::systems::sensors::PixelType)7&gt;<a class="headerlink" href="#pydrake.geometry.QueryObject_[float].RenderLabelImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Renders a label image for the given <code class="docutils literal"><span class="pre">camera</span></code> posed with respect to
the indicated parent frame P.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">camera</span></code>:</dt>
<dd>The intrinsic properties of the camera.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">parent_frame</span></code>:</dt>
<dd>The id for the camera’s parent frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">X_PC</span></code>:</dt>
<dd>The pose of the camera body in the world frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">show_window</span></code>:</dt>
<dd>If true, the render window will be displayed.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">label_image_out</span></code>:</dt>
<dd>The rendered label image.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[float].X_PF">
<code class="descname">X_PF</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], id: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.QueryObject_[float].X_PF" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the position of the frame indicated by <code class="docutils literal"><span class="pre">id</span></code> relative to its
parent frame. If the frame was registered with the world frame as its
parent frame, this value will be identical to that returned by X_WF().</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is analogous to but distinct from
SceneGraphInspector::X_PG(). In this case, the pose will <em>always</em>
be relative to another frame.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the frame <code class="docutils literal"><span class="pre">id</span></code> is not valid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[float].X_WF">
<code class="descname">X_WF</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], id: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.QueryObject_[float].X_WF" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the position of the frame indicated by <code class="docutils literal"><span class="pre">id</span></code> relative to the
world frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the frame <code class="docutils literal"><span class="pre">id</span></code> is not valid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.QueryObject_[float].X_WG">
<code class="descname">X_WG</code><span class="sig-paren">(</span><em>self: pydrake.geometry.QueryObject_[float], id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.QueryObject_[float].X_WG" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the position of the geometry indicated by <code class="docutils literal"><span class="pre">id</span></code> relative to
the world frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the geometry <code class="docutils literal"><span class="pre">id</span></code> is not valid.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.geometry.ReadObjToSurfaceMesh">
<code class="descclassname">pydrake.geometry.</code><code class="descname">ReadObjToSurfaceMesh</code><span class="sig-paren">(</span><em>filename: str</em>, <em>scale: float = 1.0</em><span class="sig-paren">)</span> &#x2192; drake::geometry::SurfaceMesh&lt;double&gt;<a class="headerlink" href="#pydrake.geometry.ReadObjToSurfaceMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a surface mesh from a Wavefront .obj file and optionally
scales coordinates by the given scale factor. Polygons will be
triangulated if they are not triangles already. All objects in the
.obj file will be merged into the surface mesh. See
<a class="reference external" href="https://en.wikipedia.org/wiki/">https://en.wikipedia.org/wiki/</a><a href="#id44"><span class="problematic" id="id45">Wavefront_</span></a>.obj_file for the file format.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">filename</span></code>:</dt>
<dd>A valid file name with absolute path or relative path.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">scale</span></code>:</dt>
<dd>An optional scale to coordinates.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">filename</span></code> doesn’t have a valid file path, or</li>
<li>the file has no faces.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">surface mesh</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.Rgba">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">Rgba</code><a class="headerlink" href="#pydrake.geometry.Rgba" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines RGBA (red, green, blue, alpha) values on the range [0, 1].</p>
<dl class="method">
<dt id="pydrake.geometry.Rgba.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Rgba</em>, <em>r: float</em>, <em>g: float</em>, <em>b: float</em>, <em>a: float = 1.0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.Rgba.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs with given (r, g, b, a) values.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>All values are within the range of [0, 1].</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Rgba.a">
<code class="descname">a</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Rgba</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Rgba.a" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Rgba.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Rgba</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Rgba.b" title="Permalink to this definition">¶</a></dt>
<dd><p>Blue.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Rgba.g">
<code class="descname">g</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Rgba</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Rgba.g" title="Permalink to this definition">¶</a></dt>
<dd><p>Green.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Rgba.r">
<code class="descname">r</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Rgba</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Rgba.r" title="Permalink to this definition">¶</a></dt>
<dd><p>Red.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Rgba.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Rgba</em>, <em>r: float</em>, <em>g: float</em>, <em>b: float</em>, <em>a: float = 1.0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.Rgba.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets (r, g, b, a) values.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>All values are within the range of [0, 1]. The values are not
updated if this precondition is not met.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.Role">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">Role</code><a class="headerlink" href="#pydrake.geometry.Role" title="Permalink to this definition">¶</a></dt>
<dd><p>General enumeration for indicating geometry role.</p>
<p>Members:</p>
<blockquote>
<div><p>kUnassigned :</p>
<p>kProximity :</p>
<p>kIllustration :</p>
<p>kPerception :</p>
</div></blockquote>
<dl class="method">
<dt id="pydrake.geometry.Role.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Role</em>, <em>arg0: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.Role.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.Role.kIllustration">
<code class="descname">kIllustration</code><em class="property"> = Role.kIllustration</em><a class="headerlink" href="#pydrake.geometry.Role.kIllustration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.Role.kPerception">
<code class="descname">kPerception</code><em class="property"> = Role.kPerception</em><a class="headerlink" href="#pydrake.geometry.Role.kPerception" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.Role.kProximity">
<code class="descname">kProximity</code><em class="property"> = Role.kProximity</em><a class="headerlink" href="#pydrake.geometry.Role.kProximity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.Role.kUnassigned">
<code class="descname">kUnassigned</code><em class="property"> = Role.kUnassigned</em><a class="headerlink" href="#pydrake.geometry.Role.kUnassigned" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.Role.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.geometry.Role.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.RoleAssign">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">RoleAssign</code><a class="headerlink" href="#pydrake.geometry.RoleAssign" title="Permalink to this definition">¶</a></dt>
<dd><p>The operations that can be performed on the given properties when
assigning roles to geometry.</p>
<p>Members:</p>
<blockquote>
<div>kNew : Assign the properties to a geometry that doesn’t already have the</div></blockquote>
<p>role.</p>
<blockquote>
<div>kReplace : Replace the existing role properties completely.</div></blockquote>
<dl class="method">
<dt id="pydrake.geometry.RoleAssign.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.RoleAssign</em>, <em>arg0: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.RoleAssign.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.RoleAssign.kNew">
<code class="descname">kNew</code><em class="property"> = RoleAssign.kNew</em><a class="headerlink" href="#pydrake.geometry.RoleAssign.kNew" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.RoleAssign.kReplace">
<code class="descname">kReplace</code><em class="property"> = RoleAssign.kReplace</em><a class="headerlink" href="#pydrake.geometry.RoleAssign.kReplace" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.RoleAssign.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.geometry.RoleAssign.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SceneGraph">
<code class="descclassname">pydrake.geometry.</code><code class="descname">SceneGraph</code><a class="headerlink" href="#pydrake.geometry.SceneGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.geometry.SceneGraph_[float]" title="pydrake.geometry.SceneGraph_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.SceneGraph_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.geometry.SceneGraph_">
<em class="property">template </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SceneGraph_</code><a class="headerlink" href="#pydrake.geometry.SceneGraph_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.geometry.SceneGraph_[float]" title="pydrake.geometry.SceneGraph_[float]"><code class="xref py py-class docutils literal"><span class="pre">SceneGraph_[float]</span></code></a>, <a class="reference internal" href="#pydrake.geometry.SceneGraph_[AutoDiffXd]" title="pydrake.geometry.SceneGraph_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">SceneGraph_[AutoDiffXd]</span></code></a></p>
<dl class="class">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float]">
<em class="property">class </em><code class="descname">SceneGraph_[float]</code><a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_[float]" title="pydrake.systems.framework.LeafSystem_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.framework.LeafSystem_[float]</span></code></a></p>
<p>SceneGraph serves as the nexus for all geometry (and geometry-based
operations) in a Diagram. Through SceneGraph, other systems that
introduce geometry can <em>register</em> that geometry as part of a common
global domain, including it in geometric queries (e.g., cars
controlled by one LeafSystem can be observed by a different sensor
system). SceneGraph provides the interface for registering the
geometry, updating its position based on the current context, and
performing geometric queries.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">source_pose{0}&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">source_pose{N-1}&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>SceneGraph</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; lcm_visualization</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; query</td></tr></table></td></tr></table><p>Only registered “geometry sources” can introduce geometry into
SceneGraph. Geometry sources will typically be other leaf systems,
but, in the case of <em>anchored</em> (i.e., stationary) geometry, it could
also be some other block of code (e.g., adding a common ground plane
with which all systems’ geometries interact). For dynamic geometry
(geometry whose pose depends on a Context), the geometry source must
also provide pose values for all of the geometries the source owns,
via a port connection on SceneGraph. For N geometry sources, the
SceneGraph instance will have N pose input ports.</p>
<p>The basic workflow for interacting with SceneGraph is:</p>
<ul class="simple">
<li>Register as a geometry source, acquiring a unique SourceId.</li>
<li>Register geometry (anchored and dynamic) with the system.</li>
<li>Connect source’s geometry output ports to the corresponding SceneGraph</li>
</ul>
<p>input ports.
- Implement appropriate <code class="docutils literal"><span class="pre">Calc*</span></code> methods on the geometry output ports to
update geometry pose values.</p>
<p>For each registered geometry source, there is one input port for each
order of kinematics values (e.g., pose, velocity, and acceleration).
If a source registers a frame, it must connect to these ports
(although, in the current version, only pose is supported). Failure to
connect to the port (or to provide valid kinematics values) will lead
to runtime exceptions.</p>
<p><strong>pose port</strong>: An abstract-valued port providing an instance of
FramePoseVector. For each registered frame, this “pose vector” maps
the registered FrameId to a pose value. All registered frames must be
accounted for and only frames registered by a source can be included
in its output port. See the details in FrameKinematicsVector for
details on how to provide values for this port.</p>
<p>SceneGraph has two output ports:</p>
<p><strong>query port</strong>: An abstract-valued port containing an instance of
QueryObject. It provides a “ticket” for downstream LeafSystem
instances to perform geometric queries on the SceneGraph. To perform
geometric queries, downstream LeafSystem instances acquire the
QueryObject from SceneGraph’s output port and provide it as a
parameter to one of SceneGraph’s query methods (e.g.,
SceneGraph::ComputeContact()). This assumes that the querying system
has access to a const pointer to the connected SceneGraph instance.
Use get_query_output_port() to acquire the output port for the query
handle.</p>
<p><strong>lcm visualization port</strong>: An abstract-valued port containing an
instance of PoseBundle. This is a convenience port designed to feed
LCM update messages to drake_visualizer for the purpose of visualizing
the state of the world’s geometry. Additional uses of this port are
strongly discouraged; instead, use an appropriate geometric query to
obtain the state of the world’s geometry.</p>
<p>LeafSystem instances can relate to SceneGraph in one of two ways: as a
<em>consumer</em> that performs queries, or as a <em>producer</em> that introduces
geometry into the shared world and defines its context-dependent
kinematics values. It is reasonable for systems to perform either role
singly, or both.</p>
<p><strong>Consumer</strong></p>
<p>Consumers perform geometric queries upon the world geometry.
SceneGraph <em>serves</em> those queries. As indicated above, in order for a
LeafSystem to act as a consumer, it must: 1. define a
QueryObject-valued input port and connect it to SceneGraph’s
corresponding output port, and 2. have a reference to the connected
SceneGraph instance.</p>
<p>With those two requirements satisfied, a LeafSystem can perform
geometry queries by: 1. evaluating the QueryObject input port, and 2.
passing the returned query object into the appropriate query method on
SceneGraph (e.g., SceneGraph::ComputeContact()).</p>
<p><strong>Producer</strong></p>
<p>All producers introduce geometry into the shared geometric world. This
is called <em>registering</em> geometry. Depending on what exactly has been
registered, a producer may also have to <em>update kinematics</em>. Producers
themselves must be registered with SceneGraph as producers (a.k.a.
<em>geometry sources</em>). They do this by acquiring a SourceId (via
SceneGraph::RegisterSource()). The SourceId serves as a unique handle
through which the producer’s identity is validated and its ownership
of its registered geometry is maintained.</p>
<p><em>Registering Geometry</em></p>
<p>SceneGraph cannot know what geometry <em>should</em> be part of the shared
world. Other systems are responsible for introducing geometry into the
world. This process (defining geometry and informing SceneGraph) is
called <em>registering</em> the geometry. The source that registers the
geometry “owns” the geometry; the source’s unique SourceId is required
to perform any operations on the geometry registered with that
SourceId. Geometry can be registered as <em>anchored</em> or <em>dynamic</em>.</p>
<p>Dynamic geometry can move; more specifically, its kinematics (e.g.,
pose) depends on a system’s Context. Particularly, dynamic geometry is
<em>fixed</em> to a <em>frame</em> whose kinematics values depend on a context. As
the frame moves, the geometries fixed to it move with it. Therefore,
to register dynamic geometry a frame must be registered first. These
registered frames serve as the basis for repositioning geometry in the
shared world. The geometry source is responsible for providing
up-to-date kinematics values for those registered frames upon request
(via an appropriate output port on the source LeafSystem connecting to
the appropriate input port on SceneGraph). The work flow is as
follows: 1. A LeafSystem registers itself as a geometry source,
acquiring a SourceId (RegisterSource()). 2. The source registers a
frame (GeometrySource::RegisterFrame()). - A frame always has a
“parent” frame. It can implicitly be the world frame, <em>or</em> another
frame registered by the source. 3. Register one or more geometries to
a frame (GeometrySource::RegisterGeometry()). - The registered
geometry is posed relative to the frame to which it is fixed. - The
geometry can also be posed relative to another registered geometry. It
will be affixed to <em>that</em> geometry’s frame.</p>
<p>Anchored geometry is <em>independent</em> of the context (i.e., it doesn’t
move). Anchored geometries are always affixed to the immobile world
frame. As such, registering a frame is <em>not</em> required for registering
anchored geometry (see GeometrySource::RegisterAnchoredGeometry()).
However, the source still “owns” the anchored geometry.</p>
<p><em>Updating Kinematics</em></p>
<p>Registering <em>dynamic</em> geometry implies a contract between the geometry
source and SceneGraph. The geometry source must do the following: - It
must provide, populate, and connect two output ports: the “id” port
and the “pose” port. - The id port must contain <em>all</em> the frame ids
returned as a result of frame registration. - The pose port must
contain one pose per registered frame; the pose value is expressed
relative to the registered frame’s <em>parent</em> frame. As mentioned above,
the iᵗʰ pose value should describe the frame indicated by the iᵗʰ id
in the id output port.</p>
<p>Failure to meet these requirements will lead to a run-time error.</p>
<p>Many (and eventually all) methods that configure the population of
SceneGraph have two variants that differ by whether they accept a
mutable Context or not. When no Context is provided, <em>this</em> SceneGraph
instance’s underlying model is modified. When the SceneGraph instance
allocates a context, its model is copied into that context.</p>
<p>The second variant causes SceneGraph to modify the data stored in the
provided Context to be modified <em>instead of the internal model</em>.</p>
<p>The two interfaces <em>can</em> be used interchangeably. However,
modifications to <code class="docutils literal"><span class="pre">this</span></code> SceneGraph’s underlying model will <em>not</em>
affect previously allocated Context instances. A new Context should be
allocated after modifying the model.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this initial version, the only methods with the
Context-modifying variant are those methods that <em>do not</em> change
the the semantics of the input or output ports. Modifications that
make such changes must be coordinated across systems.</p>
</div>
<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a default (empty) scene graph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].AddRenderer">
<code class="descname">AddRenderer</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float], name: str, renderer: drake::geometry::render::RenderEngine</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].AddRenderer" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a new render engine to this SceneGraph. The SceneGraph owns the
render engine. The render engine’s name should be referenced in the
render::CameraProperties “CameraProperties” provided in the render
queries (see QueryObject::RenderColorImage() as an example).</p>
<p>There is no restriction on when a renderer is added relative to
geometry registration and role assignment. Given a representative
sequence of registration and perception role assignment, the addition
of the renderer can be introduced anywhere in the sequence and the end
result would be the same.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">GeometryId</span> <span class="n">id1</span> <span class="o">=</span> <span class="n">scene_graph</span><span class="o">.</span><span class="n">RegisterGeometry</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
<span class="n">scene_graph</span><span class="o">.</span><span class="n">AssignRole</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="n">id1</span><span class="p">,</span> <span class="n">PerceptionProperties</span><span class="p">());</span>
<span class="n">GeometryId</span> <span class="n">id2</span> <span class="o">=</span> <span class="n">scene_graph</span><span class="o">.</span><span class="n">RegisterGeometry</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
<span class="n">scene_graph</span><span class="o">.</span><span class="n">AssignRole</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="n">id2</span><span class="p">,</span> <span class="n">PerceptionProperties</span><span class="p">());</span>
<span class="n">GeometryId</span> <span class="n">id3</span> <span class="o">=</span> <span class="n">scene_graph</span><span class="o">.</span><span class="n">RegisterGeometry</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
<span class="n">scene_graph</span><span class="o">.</span><span class="n">AssignRole</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="n">id3</span><span class="p">,</span> <span class="n">PerceptionProperties</span><span class="p">());</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The unique name of the renderer.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">renderer</span></code>:</dt>
<dd>The <code class="docutils literal"><span class="pre">renderer</span></code> to add.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the name is not unique.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].AssignRole">
<code class="descname">AssignRole</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].AssignRole" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.ProximityProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>Assigns the proximity role to the geometry indicated by
<code class="docutils literal"><span class="pre">geometry_id</span></code>.</p>
<ol class="arabic simple" start="2">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[float], context: pydrake.systems.framework.Context_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.ProximityProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>systems::Context-modifying variant of
AssignRole(SourceId,GeometryId,ProximityProperties) “AssignRole()” for
proximity properties. Rather than modifying SceneGraph’s model, it
modifies the copy of the model stored in the provided context.</p>
<ol class="arabic simple" start="3">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.PerceptionProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>Assigns the perception role to the geometry indicated by
<code class="docutils literal"><span class="pre">geometry_id</span></code>.</p>
<p>By default, a geometry with a perception role will be reified by all
render::RenderEngine instances. This behavior can be changed.
Renderers can be explicitly whitelisted via the (‘renderer’,
‘accepting’) perception property. Its type is std::set&lt;std::string&gt;
and it contains the names of all the renderers that <em>may</em> reify it. If
no property is defined (or an empty set is given), then the default
behavior of all renderers attempting to reify it will be restored.</p>
<ol class="arabic simple" start="4">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[float], context: pydrake.systems.framework.Context_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.PerceptionProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>systems::Context-modifying variant of
AssignRole(SourceId,GeometryId,PerceptionProperties) “AssignRole()”
for perception properties. Rather than modifying SceneGraph’s model,
it modifies the copy of the model stored in the provided context.</p>
<ol class="arabic simple" start="5">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.IllustrationProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>Assigns the illustration role to the geometry indicated by
<code class="docutils literal"><span class="pre">geometry_id</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When changing illustration properties (<code class="docutils literal"><span class="pre">assign</span> <span class="pre">=</span>
<span class="pre">RoleAssign::kReplace</span></code>), there is no guarantee that these changes
will affect the visualization. The visualizer needs to be able to
“initialize” itself after changes to properties that will affect
how a geometry appears. If changing a geometry’s illustration
properties doesn’t seem to be affecting the visualization,
retrigger its initialization action.</p>
</div>
<ol class="arabic simple" start="6">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[float], context: pydrake.systems.framework.Context_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.IllustrationProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>systems::Context-modifying variant of
AssignRole(SourceId,GeometryId,IllustrationProperties) “AssignRole()”
for illustration properties. Rather than modifying SceneGraph’s model,
it modifies the copy of the model stored in the provided context.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When changing illustration properties (<code class="docutils literal"><span class="pre">assign</span> <span class="pre">=</span>
<span class="pre">RoleAssign::kReplace</span></code>), there is no guarantee that these changes
will affect the visualization. The visualizer needs to be able to
“initialize” itself after changes to properties that will affect
how a geometry appears. If changing a geometry’s illustration
properties doesn’t seem to be affecting the visualization,
retrigger its initialization action.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Due to a bug (see issue <a class="reference external" href="https://github.com/RobotLocomotion/drake/issues/13597">#13597</a>),
changing the illustration roles or properties in a
systems::Context will not have any apparent effect in, at least,
drake_visualizer. Please change the illustration role in the model
prior to allocating the context.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].ExcludeCollisionsBetween">
<code class="descname">ExcludeCollisionsBetween</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].ExcludeCollisionsBetween" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>ExcludeCollisionsBetween(self: pydrake.geometry.SceneGraph_[float], setA: pydrake.geometry.GeometrySet, setB: pydrake.geometry.GeometrySet) -&gt; None</li>
</ol>
<p>Excludes geometry pairs from collision evaluation by updating the
candidate pair set <code class="docutils literal"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">-</span> <span class="pre">P</span></code>, where <code class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">{(a,</span> <span class="pre">b)},</span> <span class="pre">∀</span> <span class="pre">a</span> <span class="pre">∈</span> <span class="pre">A,</span> <span class="pre">b</span> <span class="pre">∈</span>
<span class="pre">B</span></code> and <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">{a₀,</span> <span class="pre">a₁,</span> <span class="pre">...,</span> <span class="pre">aₘ}</span></code> and <code class="docutils literal"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">{b₀,</span> <span class="pre">b₁,</span> <span class="pre">...,</span> <span class="pre">bₙ}</span></code> are
the input sets of geometries <code class="docutils literal"><span class="pre">setA</span></code> and <code class="docutils literal"><span class="pre">setB</span></code>, respectively. This
does <em>not</em> preclude collisions between members of the <em>same</em> set.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">scene_graph_collision_filtering for requirements and how collision
filtering works.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the groups include ids that don’t exist in the</li>
<li>scene graph.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>ExcludeCollisionsBetween(self: pydrake.geometry.SceneGraph_[float], context: pydrake.systems.framework.Context_[float], setA: pydrake.geometry.GeometrySet, setB: pydrake.geometry.GeometrySet) -&gt; None</li>
</ol>
<p>systems::Context-modifying variant of ExcludeCollisionsBetween().
Rather than modifying SceneGraph’s model, it modifies the copy of the
model stored in the provided context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].ExcludeCollisionsWithin">
<code class="descname">ExcludeCollisionsWithin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].ExcludeCollisionsWithin" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>ExcludeCollisionsWithin(self: pydrake.geometry.SceneGraph_[float], set: pydrake.geometry.GeometrySet) -&gt; None</li>
</ol>
<p>Excludes geometry pairs from collision evaluation by updating the
candidate pair set <code class="docutils literal"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">-</span> <span class="pre">P</span></code>, where <code class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">{(gᵢ,</span> <span class="pre">gⱼ)},</span> <span class="pre">∀</span> <span class="pre">gᵢ,</span> <span class="pre">gⱼ</span> <span class="pre">∈</span>
<span class="pre">G</span></code> and <code class="docutils literal"><span class="pre">G</span> <span class="pre">=</span> <span class="pre">{g₀,</span> <span class="pre">g₁,</span> <span class="pre">...,</span> <span class="pre">gₘ}</span></code> is the input <code class="docutils literal"><span class="pre">set</span></code> of geometries.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">scene_graph_collision_filtering for requirements and how collision
filtering works.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the set includes ids that don’t exist in the scene</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">graph.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>ExcludeCollisionsWithin(self: pydrake.geometry.SceneGraph_[float], context: pydrake.systems.framework.Context_[float], set: pydrake.geometry.GeometrySet) -&gt; None</li>
</ol>
<p>systems::Context-modifying variant of ExcludeCollisionsWithin().
Rather than modifying SceneGraph’s model, it modifies the copy of the
model stored in the provided context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].get_pose_bundle_output_port">
<code class="descname">get_pose_bundle_output_port</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].get_pose_bundle_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port which produces the PoseBundle for LCM
communication to drake visualizer.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].get_query_output_port">
<code class="descname">get_query_output_port</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].get_query_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port which produces the QueryObject for performing
geometric queries.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].get_source_pose_port">
<code class="descname">get_source_pose_port</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float], arg0: pydrake.geometry.SourceId</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[float]<a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].get_source_pose_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a valid source <code class="docutils literal"><span class="pre">id</span></code>, returns a <em>pose</em> input port associated
with that <code class="docutils literal"><span class="pre">id</span></code>. This port is used to communicate <em>pose</em> data for
registered frames.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the source_id is <em>not</em> recognized.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].HasRenderer">
<code class="descname">HasRenderer</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float], name: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].HasRenderer" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if this SceneGraph has a renderer registered to the given
name.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].model_inspector">
<code class="descname">model_inspector</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.SceneGraphInspector_[float]<a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].model_inspector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an inspector on the system’s <em>model</em> scene graph data.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].RegisterAnchoredGeometry">
<code class="descname">RegisterAnchoredGeometry</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, geometry: pydrake.geometry.GeometryInstance</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.GeometryId<a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].RegisterAnchoredGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a new <em>anchored</em> geometry G for this source. This hangs
geometry G from the world frame (W). Its pose is defined in that frame
(i.e., <code class="docutils literal"><span class="pre">X_WG</span></code>). Returns the corresponding unique geometry id.</p>
<p>Roles will be assigned to the registered geometry if the corresponding
GeometryInstance <code class="docutils literal"><span class="pre">geometry</span></code> has had properties assigned.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">source_id</span></code>:</dt>
<dd>The id for the source registering the frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">geometry</span></code>:</dt>
<dd>The anchored geometry G to add to the world.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A unique identifier for the added geometry.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the <code class="docutils literal"><span class="pre">source_id</span></code> does <em>not</em> map to a</li>
<li>registered source or b) the geometry’s name doesn’t satisfy the</li>
<li>requirements outlined in GeometryInstance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].RegisterFrame">
<code class="descname">RegisterFrame</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].RegisterFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RegisterFrame(self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, frame: pydrake.geometry.GeometryFrame) -&gt; pydrake.geometry.FrameId</li>
</ol>
<p>Registers a new frame F for this source. This hangs frame F on the
world frame (W). Its pose is defined relative to the world frame (i.e,
<code class="docutils literal"><span class="pre">X_WF</span></code>). Returns the corresponding unique frame id.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">source_id</span></code>:</dt>
<dd>The id for the source registering the frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame</span></code>:</dt>
<dd>The frame to register.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A unique identifier for the added frame.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the <code class="docutils literal"><span class="pre">source_id</span></code> does <em>not</em> map to a</li>
<li>registered source, or b) <code class="docutils literal"><span class="pre">frame</span></code> has an id that has already been</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">registered.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>RegisterFrame(self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, parent_id: pydrake.geometry.FrameId, frame: pydrake.geometry.GeometryFrame) -&gt; pydrake.geometry.FrameId</li>
</ol>
<p>Registers a new frame F for this source. This hangs frame F on another
previously registered frame P (indicated by <code class="docutils literal"><span class="pre">parent_id</span></code>). The pose
of the new frame is defined relative to the parent frame (i.e.,
<code class="docutils literal"><span class="pre">X_PF</span></code>). Returns the corresponding unique frame id.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">source_id</span></code>:</dt>
<dd>The id for the source registering the frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">parent_id</span></code>:</dt>
<dd>The id of the parent frame P.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame</span></code>:</dt>
<dd>The frame to register.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A unique identifier for the added frame.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the <code class="docutils literal"><span class="pre">source_id</span></code> does <em>not</em> map to a</li>
<li>registered source, b) the <code class="docutils literal"><span class="pre">parent_id</span></code> does <em>not</em> map to a known</li>
<li>frame or does not belong to the source, or c) <code class="docutils literal"><span class="pre">frame</span></code> has an id</li>
<li>that has already been registered.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].RegisterGeometry">
<code class="descname">RegisterGeometry</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].RegisterGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RegisterGeometry(self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, frame_id: pydrake.geometry.FrameId, geometry: pydrake.geometry.GeometryInstance) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Registers a new geometry G for this source. This hangs geometry G on a
previously registered frame F (indicated by <code class="docutils literal"><span class="pre">frame_id</span></code>). The pose of
the geometry is defined in a fixed pose relative to F (i.e.,
<code class="docutils literal"><span class="pre">X_FG</span></code>). Returns the corresponding unique geometry id.</p>
<p>Roles will be assigned to the registered geometry if the corresponding
GeometryInstance <code class="docutils literal"><span class="pre">geometry</span></code> has had properties assigned.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">source_id</span></code>:</dt>
<dd>The id for the source registering the geometry.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_id</span></code>:</dt>
<dd>The id for the frame F to hang the geometry on.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">geometry</span></code>:</dt>
<dd>The geometry G to affix to frame F.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A unique identifier for the added geometry.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the <code class="docutils literal"><span class="pre">source_id</span></code> does <em>not</em> map to a</li>
<li>registered source, b) the <code class="docutils literal"><span class="pre">frame_id</span></code> doesn’t belong to the</li>
<li>source, c) the <code class="docutils literal"><span class="pre">geometry</span></code> is equal to <code class="docutils literal"><span class="pre">nullptr</span></code>, or d) the</li>
<li>geometry’s name doesn’t satisfy the requirements outlined in</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">GeometryInstance.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>RegisterGeometry(self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, geometry: pydrake.geometry.GeometryInstance) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Registers a new geometry G for this source. This hangs geometry G on a
previously registered geometry P (indicated by <code class="docutils literal"><span class="pre">geometry_id</span></code>). The
pose of the geometry is defined in a fixed pose relative to geometry P
(i.e., <code class="docutils literal"><span class="pre">X_PG</span></code>). By induction, this geometry is effectively rigidly
affixed to the frame that P is affixed to. Returns the corresponding
unique geometry id.</p>
<p>Roles will be assigned to the registered geometry if the corresponding
GeometryInstance <code class="docutils literal"><span class="pre">geometry</span></code> has had properties assigned.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">source_id</span></code>:</dt>
<dd>The id for the source registering the geometry.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">geometry_id</span></code>:</dt>
<dd>The id for the parent geometry P.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">geometry</span></code>:</dt>
<dd>The geometry G to add.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A unique identifier for the added geometry.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the <code class="docutils literal"><span class="pre">source_id</span></code> does <em>not</em> map to a</li>
<li>registered source, b) the <code class="docutils literal"><span class="pre">geometry_id</span></code> doesn’t belong to the</li>
<li>source, c) the <code class="docutils literal"><span class="pre">geometry</span></code> is equal to <code class="docutils literal"><span class="pre">nullptr</span></code>, or d) the</li>
<li>geometry’s name doesn’t satisfy the requirements outlined in</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">GeometryInstance.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].RegisterSource">
<code class="descname">RegisterSource</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float], name: str = ''</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.SourceId<a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].RegisterSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a new, named source to the geometry system. The caller must
save the returned SourceId; it is the token by which all other
operations on the geometry world are conducted.</p>
<p>This source id can be used to register arbitrary <em>anchored</em> geometry.
But if dynamic geometry is registered (via
RegisterGeometry/RegisterFrame), then the context-dependent pose
values must be provided on an input port. See get_source_pose_port().</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The optional name of the source. If none is provided (or the empty
string) a default name will be defined by SceneGraph’s logic.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the name is not unique.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].RemoveRole">
<code class="descname">RemoveRole</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, role: pydrake.geometry.Role</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].RemoveRole" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the indicated <code class="docutils literal"><span class="pre">role</span></code> from the geometry indicated by
<code class="docutils literal"><span class="pre">geometry_id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">One if the geometry had the role removed and zero if the geometry
did not have the role assigned in the first place.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) <code class="docutils literal"><span class="pre">source_id</span></code> does not map to a registered</li>
<li>source, b) <code class="docutils literal"><span class="pre">geometry_id</span></code> does not map to a registered geometry,</li>
<li><ol class="first loweralpha" start="3">
<li><code class="docutils literal"><span class="pre">geometry_id</span></code> does not belong to <code class="docutils literal"><span class="pre">source_id</span></code>, or d) the</li>
</ol>
</li>
<li>context has already been allocated.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].RendererCount">
<code class="descname">RendererCount</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].RendererCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the number of renderers registered to this SceneGraph.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.SceneGraph_.SceneGraph_[float].world_frame_id">
<em class="property">static </em><code class="descname">world_frame_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.geometry.FrameId<a class="headerlink" href="#pydrake.geometry.SceneGraph_.SceneGraph_[float].world_frame_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the identifier for the world frame.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SceneGraph_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_[AutoDiffXd]" title="pydrake.systems.framework.LeafSystem_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></a></p>
<p>SceneGraph serves as the nexus for all geometry (and geometry-based
operations) in a Diagram. Through SceneGraph, other systems that
introduce geometry can <em>register</em> that geometry as part of a common
global domain, including it in geometric queries (e.g., cars
controlled by one LeafSystem can be observed by a different sensor
system). SceneGraph provides the interface for registering the
geometry, updating its position based on the current context, and
performing geometric queries.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">source_pose{0}&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">source_pose{N-1}&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>SceneGraph</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; lcm_visualization</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; query</td></tr></table></td></tr></table><p>Only registered “geometry sources” can introduce geometry into
SceneGraph. Geometry sources will typically be other leaf systems,
but, in the case of <em>anchored</em> (i.e., stationary) geometry, it could
also be some other block of code (e.g., adding a common ground plane
with which all systems’ geometries interact). For dynamic geometry
(geometry whose pose depends on a Context), the geometry source must
also provide pose values for all of the geometries the source owns,
via a port connection on SceneGraph. For N geometry sources, the
SceneGraph instance will have N pose input ports.</p>
<p>The basic workflow for interacting with SceneGraph is:</p>
<ul class="simple">
<li>Register as a geometry source, acquiring a unique SourceId.</li>
<li>Register geometry (anchored and dynamic) with the system.</li>
<li>Connect source’s geometry output ports to the corresponding SceneGraph</li>
</ul>
<p>input ports.
- Implement appropriate <code class="docutils literal"><span class="pre">Calc*</span></code> methods on the geometry output ports to
update geometry pose values.</p>
<p>For each registered geometry source, there is one input port for each
order of kinematics values (e.g., pose, velocity, and acceleration).
If a source registers a frame, it must connect to these ports
(although, in the current version, only pose is supported). Failure to
connect to the port (or to provide valid kinematics values) will lead
to runtime exceptions.</p>
<p><strong>pose port</strong>: An abstract-valued port providing an instance of
FramePoseVector. For each registered frame, this “pose vector” maps
the registered FrameId to a pose value. All registered frames must be
accounted for and only frames registered by a source can be included
in its output port. See the details in FrameKinematicsVector for
details on how to provide values for this port.</p>
<p>SceneGraph has two output ports:</p>
<p><strong>query port</strong>: An abstract-valued port containing an instance of
QueryObject. It provides a “ticket” for downstream LeafSystem
instances to perform geometric queries on the SceneGraph. To perform
geometric queries, downstream LeafSystem instances acquire the
QueryObject from SceneGraph’s output port and provide it as a
parameter to one of SceneGraph’s query methods (e.g.,
SceneGraph::ComputeContact()). This assumes that the querying system
has access to a const pointer to the connected SceneGraph instance.
Use get_query_output_port() to acquire the output port for the query
handle.</p>
<p><strong>lcm visualization port</strong>: An abstract-valued port containing an
instance of PoseBundle. This is a convenience port designed to feed
LCM update messages to drake_visualizer for the purpose of visualizing
the state of the world’s geometry. Additional uses of this port are
strongly discouraged; instead, use an appropriate geometric query to
obtain the state of the world’s geometry.</p>
<p>LeafSystem instances can relate to SceneGraph in one of two ways: as a
<em>consumer</em> that performs queries, or as a <em>producer</em> that introduces
geometry into the shared world and defines its context-dependent
kinematics values. It is reasonable for systems to perform either role
singly, or both.</p>
<p><strong>Consumer</strong></p>
<p>Consumers perform geometric queries upon the world geometry.
SceneGraph <em>serves</em> those queries. As indicated above, in order for a
LeafSystem to act as a consumer, it must: 1. define a
QueryObject-valued input port and connect it to SceneGraph’s
corresponding output port, and 2. have a reference to the connected
SceneGraph instance.</p>
<p>With those two requirements satisfied, a LeafSystem can perform
geometry queries by: 1. evaluating the QueryObject input port, and 2.
passing the returned query object into the appropriate query method on
SceneGraph (e.g., SceneGraph::ComputeContact()).</p>
<p><strong>Producer</strong></p>
<p>All producers introduce geometry into the shared geometric world. This
is called <em>registering</em> geometry. Depending on what exactly has been
registered, a producer may also have to <em>update kinematics</em>. Producers
themselves must be registered with SceneGraph as producers (a.k.a.
<em>geometry sources</em>). They do this by acquiring a SourceId (via
SceneGraph::RegisterSource()). The SourceId serves as a unique handle
through which the producer’s identity is validated and its ownership
of its registered geometry is maintained.</p>
<p><em>Registering Geometry</em></p>
<p>SceneGraph cannot know what geometry <em>should</em> be part of the shared
world. Other systems are responsible for introducing geometry into the
world. This process (defining geometry and informing SceneGraph) is
called <em>registering</em> the geometry. The source that registers the
geometry “owns” the geometry; the source’s unique SourceId is required
to perform any operations on the geometry registered with that
SourceId. Geometry can be registered as <em>anchored</em> or <em>dynamic</em>.</p>
<p>Dynamic geometry can move; more specifically, its kinematics (e.g.,
pose) depends on a system’s Context. Particularly, dynamic geometry is
<em>fixed</em> to a <em>frame</em> whose kinematics values depend on a context. As
the frame moves, the geometries fixed to it move with it. Therefore,
to register dynamic geometry a frame must be registered first. These
registered frames serve as the basis for repositioning geometry in the
shared world. The geometry source is responsible for providing
up-to-date kinematics values for those registered frames upon request
(via an appropriate output port on the source LeafSystem connecting to
the appropriate input port on SceneGraph). The work flow is as
follows: 1. A LeafSystem registers itself as a geometry source,
acquiring a SourceId (RegisterSource()). 2. The source registers a
frame (GeometrySource::RegisterFrame()). - A frame always has a
“parent” frame. It can implicitly be the world frame, <em>or</em> another
frame registered by the source. 3. Register one or more geometries to
a frame (GeometrySource::RegisterGeometry()). - The registered
geometry is posed relative to the frame to which it is fixed. - The
geometry can also be posed relative to another registered geometry. It
will be affixed to <em>that</em> geometry’s frame.</p>
<p>Anchored geometry is <em>independent</em> of the context (i.e., it doesn’t
move). Anchored geometries are always affixed to the immobile world
frame. As such, registering a frame is <em>not</em> required for registering
anchored geometry (see GeometrySource::RegisterAnchoredGeometry()).
However, the source still “owns” the anchored geometry.</p>
<p><em>Updating Kinematics</em></p>
<p>Registering <em>dynamic</em> geometry implies a contract between the geometry
source and SceneGraph. The geometry source must do the following: - It
must provide, populate, and connect two output ports: the “id” port
and the “pose” port. - The id port must contain <em>all</em> the frame ids
returned as a result of frame registration. - The pose port must
contain one pose per registered frame; the pose value is expressed
relative to the registered frame’s <em>parent</em> frame. As mentioned above,
the iᵗʰ pose value should describe the frame indicated by the iᵗʰ id
in the id output port.</p>
<p>Failure to meet these requirements will lead to a run-time error.</p>
<p>Many (and eventually all) methods that configure the population of
SceneGraph have two variants that differ by whether they accept a
mutable Context or not. When no Context is provided, <em>this</em> SceneGraph
instance’s underlying model is modified. When the SceneGraph instance
allocates a context, its model is copied into that context.</p>
<p>The second variant causes SceneGraph to modify the data stored in the
provided Context to be modified <em>instead of the internal model</em>.</p>
<p>The two interfaces <em>can</em> be used interchangeably. However,
modifications to <code class="docutils literal"><span class="pre">this</span></code> SceneGraph’s underlying model will <em>not</em>
affect previously allocated Context instances. A new Context should be
allocated after modifying the model.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this initial version, the only methods with the
Context-modifying variant are those methods that <em>do not</em> change
the the semantics of the input or output ports. Modifications that
make such changes must be coordinated across systems.</p>
</div>
<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a default (empty) scene graph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].AddRenderer">
<code class="descname">AddRenderer</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[AutoDiffXd], name: str, renderer: drake::geometry::render::RenderEngine</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].AddRenderer" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a new render engine to this SceneGraph. The SceneGraph owns the
render engine. The render engine’s name should be referenced in the
render::CameraProperties “CameraProperties” provided in the render
queries (see QueryObject::RenderColorImage() as an example).</p>
<p>There is no restriction on when a renderer is added relative to
geometry registration and role assignment. Given a representative
sequence of registration and perception role assignment, the addition
of the renderer can be introduced anywhere in the sequence and the end
result would be the same.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">GeometryId</span> <span class="n">id1</span> <span class="o">=</span> <span class="n">scene_graph</span><span class="o">.</span><span class="n">RegisterGeometry</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
<span class="n">scene_graph</span><span class="o">.</span><span class="n">AssignRole</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="n">id1</span><span class="p">,</span> <span class="n">PerceptionProperties</span><span class="p">());</span>
<span class="n">GeometryId</span> <span class="n">id2</span> <span class="o">=</span> <span class="n">scene_graph</span><span class="o">.</span><span class="n">RegisterGeometry</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
<span class="n">scene_graph</span><span class="o">.</span><span class="n">AssignRole</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="n">id2</span><span class="p">,</span> <span class="n">PerceptionProperties</span><span class="p">());</span>
<span class="n">GeometryId</span> <span class="n">id3</span> <span class="o">=</span> <span class="n">scene_graph</span><span class="o">.</span><span class="n">RegisterGeometry</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
<span class="n">scene_graph</span><span class="o">.</span><span class="n">AssignRole</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="n">id3</span><span class="p">,</span> <span class="n">PerceptionProperties</span><span class="p">());</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The unique name of the renderer.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">renderer</span></code>:</dt>
<dd>The <code class="docutils literal"><span class="pre">renderer</span></code> to add.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the name is not unique.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].AssignRole">
<code class="descname">AssignRole</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].AssignRole" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[AutoDiffXd], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.ProximityProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>Assigns the proximity role to the geometry indicated by
<code class="docutils literal"><span class="pre">geometry_id</span></code>.</p>
<ol class="arabic simple" start="2">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.ProximityProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>systems::Context-modifying variant of
AssignRole(SourceId,GeometryId,ProximityProperties) “AssignRole()” for
proximity properties. Rather than modifying SceneGraph’s model, it
modifies the copy of the model stored in the provided context.</p>
<ol class="arabic simple" start="3">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[AutoDiffXd], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.PerceptionProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>Assigns the perception role to the geometry indicated by
<code class="docutils literal"><span class="pre">geometry_id</span></code>.</p>
<p>By default, a geometry with a perception role will be reified by all
render::RenderEngine instances. This behavior can be changed.
Renderers can be explicitly whitelisted via the (‘renderer’,
‘accepting’) perception property. Its type is std::set&lt;std::string&gt;
and it contains the names of all the renderers that <em>may</em> reify it. If
no property is defined (or an empty set is given), then the default
behavior of all renderers attempting to reify it will be restored.</p>
<ol class="arabic simple" start="4">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.PerceptionProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>systems::Context-modifying variant of
AssignRole(SourceId,GeometryId,PerceptionProperties) “AssignRole()”
for perception properties. Rather than modifying SceneGraph’s model,
it modifies the copy of the model stored in the provided context.</p>
<ol class="arabic simple" start="5">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[AutoDiffXd], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.IllustrationProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>Assigns the illustration role to the geometry indicated by
<code class="docutils literal"><span class="pre">geometry_id</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When changing illustration properties (<code class="docutils literal"><span class="pre">assign</span> <span class="pre">=</span>
<span class="pre">RoleAssign::kReplace</span></code>), there is no guarantee that these changes
will affect the visualization. The visualizer needs to be able to
“initialize” itself after changes to properties that will affect
how a geometry appears. If changing a geometry’s illustration
properties doesn’t seem to be affecting the visualization,
retrigger its initialization action.</p>
</div>
<ol class="arabic simple" start="6">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.IllustrationProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>systems::Context-modifying variant of
AssignRole(SourceId,GeometryId,IllustrationProperties) “AssignRole()”
for illustration properties. Rather than modifying SceneGraph’s model,
it modifies the copy of the model stored in the provided context.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When changing illustration properties (<code class="docutils literal"><span class="pre">assign</span> <span class="pre">=</span>
<span class="pre">RoleAssign::kReplace</span></code>), there is no guarantee that these changes
will affect the visualization. The visualizer needs to be able to
“initialize” itself after changes to properties that will affect
how a geometry appears. If changing a geometry’s illustration
properties doesn’t seem to be affecting the visualization,
retrigger its initialization action.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Due to a bug (see issue <a class="reference external" href="https://github.com/RobotLocomotion/drake/issues/13597">#13597</a>),
changing the illustration roles or properties in a
systems::Context will not have any apparent effect in, at least,
drake_visualizer. Please change the illustration role in the model
prior to allocating the context.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].ExcludeCollisionsBetween">
<code class="descname">ExcludeCollisionsBetween</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].ExcludeCollisionsBetween" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>ExcludeCollisionsBetween(self: pydrake.geometry.SceneGraph_[AutoDiffXd], setA: pydrake.geometry.GeometrySet, setB: pydrake.geometry.GeometrySet) -&gt; None</li>
</ol>
<p>Excludes geometry pairs from collision evaluation by updating the
candidate pair set <code class="docutils literal"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">-</span> <span class="pre">P</span></code>, where <code class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">{(a,</span> <span class="pre">b)},</span> <span class="pre">∀</span> <span class="pre">a</span> <span class="pre">∈</span> <span class="pre">A,</span> <span class="pre">b</span> <span class="pre">∈</span>
<span class="pre">B</span></code> and <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">{a₀,</span> <span class="pre">a₁,</span> <span class="pre">...,</span> <span class="pre">aₘ}</span></code> and <code class="docutils literal"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">{b₀,</span> <span class="pre">b₁,</span> <span class="pre">...,</span> <span class="pre">bₙ}</span></code> are
the input sets of geometries <code class="docutils literal"><span class="pre">setA</span></code> and <code class="docutils literal"><span class="pre">setB</span></code>, respectively. This
does <em>not</em> preclude collisions between members of the <em>same</em> set.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">scene_graph_collision_filtering for requirements and how collision
filtering works.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the groups include ids that don’t exist in the</li>
<li>scene graph.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>ExcludeCollisionsBetween(self: pydrake.geometry.SceneGraph_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], setA: pydrake.geometry.GeometrySet, setB: pydrake.geometry.GeometrySet) -&gt; None</li>
</ol>
<p>systems::Context-modifying variant of ExcludeCollisionsBetween().
Rather than modifying SceneGraph’s model, it modifies the copy of the
model stored in the provided context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].ExcludeCollisionsWithin">
<code class="descname">ExcludeCollisionsWithin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].ExcludeCollisionsWithin" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>ExcludeCollisionsWithin(self: pydrake.geometry.SceneGraph_[AutoDiffXd], set: pydrake.geometry.GeometrySet) -&gt; None</li>
</ol>
<p>Excludes geometry pairs from collision evaluation by updating the
candidate pair set <code class="docutils literal"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">-</span> <span class="pre">P</span></code>, where <code class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">{(gᵢ,</span> <span class="pre">gⱼ)},</span> <span class="pre">∀</span> <span class="pre">gᵢ,</span> <span class="pre">gⱼ</span> <span class="pre">∈</span>
<span class="pre">G</span></code> and <code class="docutils literal"><span class="pre">G</span> <span class="pre">=</span> <span class="pre">{g₀,</span> <span class="pre">g₁,</span> <span class="pre">...,</span> <span class="pre">gₘ}</span></code> is the input <code class="docutils literal"><span class="pre">set</span></code> of geometries.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">scene_graph_collision_filtering for requirements and how collision
filtering works.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the set includes ids that don’t exist in the scene</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">graph.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>ExcludeCollisionsWithin(self: pydrake.geometry.SceneGraph_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], set: pydrake.geometry.GeometrySet) -&gt; None</li>
</ol>
<p>systems::Context-modifying variant of ExcludeCollisionsWithin().
Rather than modifying SceneGraph’s model, it modifies the copy of the
model stored in the provided context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].get_pose_bundle_output_port">
<code class="descname">get_pose_bundle_output_port</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].get_pose_bundle_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port which produces the PoseBundle for LCM
communication to drake visualizer.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].get_query_output_port">
<code class="descname">get_query_output_port</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].get_query_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port which produces the QueryObject for performing
geometric queries.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].get_source_pose_port">
<code class="descname">get_source_pose_port</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[AutoDiffXd], arg0: pydrake.geometry.SourceId</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[AutoDiffXd]<a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].get_source_pose_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a valid source <code class="docutils literal"><span class="pre">id</span></code>, returns a <em>pose</em> input port associated
with that <code class="docutils literal"><span class="pre">id</span></code>. This port is used to communicate <em>pose</em> data for
registered frames.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the source_id is <em>not</em> recognized.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].HasRenderer">
<code class="descname">HasRenderer</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[AutoDiffXd], name: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].HasRenderer" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if this SceneGraph has a renderer registered to the given
name.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].model_inspector">
<code class="descname">model_inspector</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.SceneGraphInspector_[AutoDiffXd]<a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].model_inspector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an inspector on the system’s <em>model</em> scene graph data.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].RegisterAnchoredGeometry">
<code class="descname">RegisterAnchoredGeometry</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[AutoDiffXd], source_id: pydrake.geometry.SourceId, geometry: pydrake.geometry.GeometryInstance</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.GeometryId<a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].RegisterAnchoredGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a new <em>anchored</em> geometry G for this source. This hangs
geometry G from the world frame (W). Its pose is defined in that frame
(i.e., <code class="docutils literal"><span class="pre">X_WG</span></code>). Returns the corresponding unique geometry id.</p>
<p>Roles will be assigned to the registered geometry if the corresponding
GeometryInstance <code class="docutils literal"><span class="pre">geometry</span></code> has had properties assigned.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">source_id</span></code>:</dt>
<dd>The id for the source registering the frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">geometry</span></code>:</dt>
<dd>The anchored geometry G to add to the world.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A unique identifier for the added geometry.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the <code class="docutils literal"><span class="pre">source_id</span></code> does <em>not</em> map to a</li>
<li>registered source or b) the geometry’s name doesn’t satisfy the</li>
<li>requirements outlined in GeometryInstance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].RegisterFrame">
<code class="descname">RegisterFrame</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].RegisterFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RegisterFrame(self: pydrake.geometry.SceneGraph_[AutoDiffXd], source_id: pydrake.geometry.SourceId, frame: pydrake.geometry.GeometryFrame) -&gt; pydrake.geometry.FrameId</li>
</ol>
<p>Registers a new frame F for this source. This hangs frame F on the
world frame (W). Its pose is defined relative to the world frame (i.e,
<code class="docutils literal"><span class="pre">X_WF</span></code>). Returns the corresponding unique frame id.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">source_id</span></code>:</dt>
<dd>The id for the source registering the frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame</span></code>:</dt>
<dd>The frame to register.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A unique identifier for the added frame.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the <code class="docutils literal"><span class="pre">source_id</span></code> does <em>not</em> map to a</li>
<li>registered source, or b) <code class="docutils literal"><span class="pre">frame</span></code> has an id that has already been</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">registered.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>RegisterFrame(self: pydrake.geometry.SceneGraph_[AutoDiffXd], source_id: pydrake.geometry.SourceId, parent_id: pydrake.geometry.FrameId, frame: pydrake.geometry.GeometryFrame) -&gt; pydrake.geometry.FrameId</li>
</ol>
<p>Registers a new frame F for this source. This hangs frame F on another
previously registered frame P (indicated by <code class="docutils literal"><span class="pre">parent_id</span></code>). The pose
of the new frame is defined relative to the parent frame (i.e.,
<code class="docutils literal"><span class="pre">X_PF</span></code>). Returns the corresponding unique frame id.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">source_id</span></code>:</dt>
<dd>The id for the source registering the frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">parent_id</span></code>:</dt>
<dd>The id of the parent frame P.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame</span></code>:</dt>
<dd>The frame to register.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A unique identifier for the added frame.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the <code class="docutils literal"><span class="pre">source_id</span></code> does <em>not</em> map to a</li>
<li>registered source, b) the <code class="docutils literal"><span class="pre">parent_id</span></code> does <em>not</em> map to a known</li>
<li>frame or does not belong to the source, or c) <code class="docutils literal"><span class="pre">frame</span></code> has an id</li>
<li>that has already been registered.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].RegisterGeometry">
<code class="descname">RegisterGeometry</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].RegisterGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RegisterGeometry(self: pydrake.geometry.SceneGraph_[AutoDiffXd], source_id: pydrake.geometry.SourceId, frame_id: pydrake.geometry.FrameId, geometry: pydrake.geometry.GeometryInstance) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Registers a new geometry G for this source. This hangs geometry G on a
previously registered frame F (indicated by <code class="docutils literal"><span class="pre">frame_id</span></code>). The pose of
the geometry is defined in a fixed pose relative to F (i.e.,
<code class="docutils literal"><span class="pre">X_FG</span></code>). Returns the corresponding unique geometry id.</p>
<p>Roles will be assigned to the registered geometry if the corresponding
GeometryInstance <code class="docutils literal"><span class="pre">geometry</span></code> has had properties assigned.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">source_id</span></code>:</dt>
<dd>The id for the source registering the geometry.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_id</span></code>:</dt>
<dd>The id for the frame F to hang the geometry on.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">geometry</span></code>:</dt>
<dd>The geometry G to affix to frame F.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A unique identifier for the added geometry.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the <code class="docutils literal"><span class="pre">source_id</span></code> does <em>not</em> map to a</li>
<li>registered source, b) the <code class="docutils literal"><span class="pre">frame_id</span></code> doesn’t belong to the</li>
<li>source, c) the <code class="docutils literal"><span class="pre">geometry</span></code> is equal to <code class="docutils literal"><span class="pre">nullptr</span></code>, or d) the</li>
<li>geometry’s name doesn’t satisfy the requirements outlined in</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">GeometryInstance.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>RegisterGeometry(self: pydrake.geometry.SceneGraph_[AutoDiffXd], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, geometry: pydrake.geometry.GeometryInstance) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Registers a new geometry G for this source. This hangs geometry G on a
previously registered geometry P (indicated by <code class="docutils literal"><span class="pre">geometry_id</span></code>). The
pose of the geometry is defined in a fixed pose relative to geometry P
(i.e., <code class="docutils literal"><span class="pre">X_PG</span></code>). By induction, this geometry is effectively rigidly
affixed to the frame that P is affixed to. Returns the corresponding
unique geometry id.</p>
<p>Roles will be assigned to the registered geometry if the corresponding
GeometryInstance <code class="docutils literal"><span class="pre">geometry</span></code> has had properties assigned.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">source_id</span></code>:</dt>
<dd>The id for the source registering the geometry.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">geometry_id</span></code>:</dt>
<dd>The id for the parent geometry P.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">geometry</span></code>:</dt>
<dd>The geometry G to add.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A unique identifier for the added geometry.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the <code class="docutils literal"><span class="pre">source_id</span></code> does <em>not</em> map to a</li>
<li>registered source, b) the <code class="docutils literal"><span class="pre">geometry_id</span></code> doesn’t belong to the</li>
<li>source, c) the <code class="docutils literal"><span class="pre">geometry</span></code> is equal to <code class="docutils literal"><span class="pre">nullptr</span></code>, or d) the</li>
<li>geometry’s name doesn’t satisfy the requirements outlined in</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">GeometryInstance.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].RegisterSource">
<code class="descname">RegisterSource</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[AutoDiffXd], name: str = ''</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.SourceId<a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].RegisterSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a new, named source to the geometry system. The caller must
save the returned SourceId; it is the token by which all other
operations on the geometry world are conducted.</p>
<p>This source id can be used to register arbitrary <em>anchored</em> geometry.
But if dynamic geometry is registered (via
RegisterGeometry/RegisterFrame), then the context-dependent pose
values must be provided on an input port. See get_source_pose_port().</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The optional name of the source. If none is provided (or the empty
string) a default name will be defined by SceneGraph’s logic.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the name is not unique.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].RemoveRole">
<code class="descname">RemoveRole</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[AutoDiffXd], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, role: pydrake.geometry.Role</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].RemoveRole" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the indicated <code class="docutils literal"><span class="pre">role</span></code> from the geometry indicated by
<code class="docutils literal"><span class="pre">geometry_id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">One if the geometry had the role removed and zero if the geometry
did not have the role assigned in the first place.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) <code class="docutils literal"><span class="pre">source_id</span></code> does not map to a registered</li>
<li>source, b) <code class="docutils literal"><span class="pre">geometry_id</span></code> does not map to a registered geometry,</li>
<li><ol class="first loweralpha" start="3">
<li><code class="docutils literal"><span class="pre">geometry_id</span></code> does not belong to <code class="docutils literal"><span class="pre">source_id</span></code>, or d) the</li>
</ol>
</li>
<li>context has already been allocated.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].RendererCount">
<code class="descname">RendererCount</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].RendererCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the number of renderers registered to this SceneGraph.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.SceneGraph_[AutoDiffXd].world_frame_id">
<em class="property">static </em><code class="descname">world_frame_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.geometry.FrameId<a class="headerlink" href="#pydrake.geometry.SceneGraph_[AutoDiffXd].world_frame_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the identifier for the world frame.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.SceneGraph_[float]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SceneGraph_[float]</code><a class="headerlink" href="#pydrake.geometry.SceneGraph_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.LeafSystem_[float]" title="pydrake.systems.framework.LeafSystem_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.systems.framework.LeafSystem_[float]</span></code></a></p>
<p>SceneGraph serves as the nexus for all geometry (and geometry-based
operations) in a Diagram. Through SceneGraph, other systems that
introduce geometry can <em>register</em> that geometry as part of a common
global domain, including it in geometric queries (e.g., cars
controlled by one LeafSystem can be observed by a different sensor
system). SceneGraph provides the interface for registering the
geometry, updating its position based on the current context, and
performing geometric queries.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">source_pose{0}&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">source_pose{N-1}&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>SceneGraph</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; lcm_visualization</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; query</td></tr></table></td></tr></table><p>Only registered “geometry sources” can introduce geometry into
SceneGraph. Geometry sources will typically be other leaf systems,
but, in the case of <em>anchored</em> (i.e., stationary) geometry, it could
also be some other block of code (e.g., adding a common ground plane
with which all systems’ geometries interact). For dynamic geometry
(geometry whose pose depends on a Context), the geometry source must
also provide pose values for all of the geometries the source owns,
via a port connection on SceneGraph. For N geometry sources, the
SceneGraph instance will have N pose input ports.</p>
<p>The basic workflow for interacting with SceneGraph is:</p>
<ul class="simple">
<li>Register as a geometry source, acquiring a unique SourceId.</li>
<li>Register geometry (anchored and dynamic) with the system.</li>
<li>Connect source’s geometry output ports to the corresponding SceneGraph</li>
</ul>
<p>input ports.
- Implement appropriate <code class="docutils literal"><span class="pre">Calc*</span></code> methods on the geometry output ports to
update geometry pose values.</p>
<p>For each registered geometry source, there is one input port for each
order of kinematics values (e.g., pose, velocity, and acceleration).
If a source registers a frame, it must connect to these ports
(although, in the current version, only pose is supported). Failure to
connect to the port (or to provide valid kinematics values) will lead
to runtime exceptions.</p>
<p><strong>pose port</strong>: An abstract-valued port providing an instance of
FramePoseVector. For each registered frame, this “pose vector” maps
the registered FrameId to a pose value. All registered frames must be
accounted for and only frames registered by a source can be included
in its output port. See the details in FrameKinematicsVector for
details on how to provide values for this port.</p>
<p>SceneGraph has two output ports:</p>
<p><strong>query port</strong>: An abstract-valued port containing an instance of
QueryObject. It provides a “ticket” for downstream LeafSystem
instances to perform geometric queries on the SceneGraph. To perform
geometric queries, downstream LeafSystem instances acquire the
QueryObject from SceneGraph’s output port and provide it as a
parameter to one of SceneGraph’s query methods (e.g.,
SceneGraph::ComputeContact()). This assumes that the querying system
has access to a const pointer to the connected SceneGraph instance.
Use get_query_output_port() to acquire the output port for the query
handle.</p>
<p><strong>lcm visualization port</strong>: An abstract-valued port containing an
instance of PoseBundle. This is a convenience port designed to feed
LCM update messages to drake_visualizer for the purpose of visualizing
the state of the world’s geometry. Additional uses of this port are
strongly discouraged; instead, use an appropriate geometric query to
obtain the state of the world’s geometry.</p>
<p>LeafSystem instances can relate to SceneGraph in one of two ways: as a
<em>consumer</em> that performs queries, or as a <em>producer</em> that introduces
geometry into the shared world and defines its context-dependent
kinematics values. It is reasonable for systems to perform either role
singly, or both.</p>
<p><strong>Consumer</strong></p>
<p>Consumers perform geometric queries upon the world geometry.
SceneGraph <em>serves</em> those queries. As indicated above, in order for a
LeafSystem to act as a consumer, it must: 1. define a
QueryObject-valued input port and connect it to SceneGraph’s
corresponding output port, and 2. have a reference to the connected
SceneGraph instance.</p>
<p>With those two requirements satisfied, a LeafSystem can perform
geometry queries by: 1. evaluating the QueryObject input port, and 2.
passing the returned query object into the appropriate query method on
SceneGraph (e.g., SceneGraph::ComputeContact()).</p>
<p><strong>Producer</strong></p>
<p>All producers introduce geometry into the shared geometric world. This
is called <em>registering</em> geometry. Depending on what exactly has been
registered, a producer may also have to <em>update kinematics</em>. Producers
themselves must be registered with SceneGraph as producers (a.k.a.
<em>geometry sources</em>). They do this by acquiring a SourceId (via
SceneGraph::RegisterSource()). The SourceId serves as a unique handle
through which the producer’s identity is validated and its ownership
of its registered geometry is maintained.</p>
<p><em>Registering Geometry</em></p>
<p>SceneGraph cannot know what geometry <em>should</em> be part of the shared
world. Other systems are responsible for introducing geometry into the
world. This process (defining geometry and informing SceneGraph) is
called <em>registering</em> the geometry. The source that registers the
geometry “owns” the geometry; the source’s unique SourceId is required
to perform any operations on the geometry registered with that
SourceId. Geometry can be registered as <em>anchored</em> or <em>dynamic</em>.</p>
<p>Dynamic geometry can move; more specifically, its kinematics (e.g.,
pose) depends on a system’s Context. Particularly, dynamic geometry is
<em>fixed</em> to a <em>frame</em> whose kinematics values depend on a context. As
the frame moves, the geometries fixed to it move with it. Therefore,
to register dynamic geometry a frame must be registered first. These
registered frames serve as the basis for repositioning geometry in the
shared world. The geometry source is responsible for providing
up-to-date kinematics values for those registered frames upon request
(via an appropriate output port on the source LeafSystem connecting to
the appropriate input port on SceneGraph). The work flow is as
follows: 1. A LeafSystem registers itself as a geometry source,
acquiring a SourceId (RegisterSource()). 2. The source registers a
frame (GeometrySource::RegisterFrame()). - A frame always has a
“parent” frame. It can implicitly be the world frame, <em>or</em> another
frame registered by the source. 3. Register one or more geometries to
a frame (GeometrySource::RegisterGeometry()). - The registered
geometry is posed relative to the frame to which it is fixed. - The
geometry can also be posed relative to another registered geometry. It
will be affixed to <em>that</em> geometry’s frame.</p>
<p>Anchored geometry is <em>independent</em> of the context (i.e., it doesn’t
move). Anchored geometries are always affixed to the immobile world
frame. As such, registering a frame is <em>not</em> required for registering
anchored geometry (see GeometrySource::RegisterAnchoredGeometry()).
However, the source still “owns” the anchored geometry.</p>
<p><em>Updating Kinematics</em></p>
<p>Registering <em>dynamic</em> geometry implies a contract between the geometry
source and SceneGraph. The geometry source must do the following: - It
must provide, populate, and connect two output ports: the “id” port
and the “pose” port. - The id port must contain <em>all</em> the frame ids
returned as a result of frame registration. - The pose port must
contain one pose per registered frame; the pose value is expressed
relative to the registered frame’s <em>parent</em> frame. As mentioned above,
the iᵗʰ pose value should describe the frame indicated by the iᵗʰ id
in the id output port.</p>
<p>Failure to meet these requirements will lead to a run-time error.</p>
<p>Many (and eventually all) methods that configure the population of
SceneGraph have two variants that differ by whether they accept a
mutable Context or not. When no Context is provided, <em>this</em> SceneGraph
instance’s underlying model is modified. When the SceneGraph instance
allocates a context, its model is copied into that context.</p>
<p>The second variant causes SceneGraph to modify the data stored in the
provided Context to be modified <em>instead of the internal model</em>.</p>
<p>The two interfaces <em>can</em> be used interchangeably. However,
modifications to <code class="docutils literal"><span class="pre">this</span></code> SceneGraph’s underlying model will <em>not</em>
affect previously allocated Context instances. A new Context should be
allocated after modifying the model.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this initial version, the only methods with the
Context-modifying variant are those methods that <em>do not</em> change
the the semantics of the input or output ports. Modifications that
make such changes must be coordinated across systems.</p>
</div>
<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a default (empty) scene graph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].AddRenderer">
<code class="descname">AddRenderer</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float], name: str, renderer: drake::geometry::render::RenderEngine</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].AddRenderer" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a new render engine to this SceneGraph. The SceneGraph owns the
render engine. The render engine’s name should be referenced in the
render::CameraProperties “CameraProperties” provided in the render
queries (see QueryObject::RenderColorImage() as an example).</p>
<p>There is no restriction on when a renderer is added relative to
geometry registration and role assignment. Given a representative
sequence of registration and perception role assignment, the addition
of the renderer can be introduced anywhere in the sequence and the end
result would be the same.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">GeometryId</span> <span class="n">id1</span> <span class="o">=</span> <span class="n">scene_graph</span><span class="o">.</span><span class="n">RegisterGeometry</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
<span class="n">scene_graph</span><span class="o">.</span><span class="n">AssignRole</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="n">id1</span><span class="p">,</span> <span class="n">PerceptionProperties</span><span class="p">());</span>
<span class="n">GeometryId</span> <span class="n">id2</span> <span class="o">=</span> <span class="n">scene_graph</span><span class="o">.</span><span class="n">RegisterGeometry</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
<span class="n">scene_graph</span><span class="o">.</span><span class="n">AssignRole</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="n">id2</span><span class="p">,</span> <span class="n">PerceptionProperties</span><span class="p">());</span>
<span class="n">GeometryId</span> <span class="n">id3</span> <span class="o">=</span> <span class="n">scene_graph</span><span class="o">.</span><span class="n">RegisterGeometry</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
<span class="n">scene_graph</span><span class="o">.</span><span class="n">AssignRole</span><span class="p">(</span><span class="n">source_id</span><span class="p">,</span> <span class="n">id3</span><span class="p">,</span> <span class="n">PerceptionProperties</span><span class="p">());</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The unique name of the renderer.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">renderer</span></code>:</dt>
<dd>The <code class="docutils literal"><span class="pre">renderer</span></code> to add.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the name is not unique.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].AssignRole">
<code class="descname">AssignRole</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].AssignRole" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.ProximityProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>Assigns the proximity role to the geometry indicated by
<code class="docutils literal"><span class="pre">geometry_id</span></code>.</p>
<ol class="arabic simple" start="2">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[float], context: pydrake.systems.framework.Context_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.ProximityProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>systems::Context-modifying variant of
AssignRole(SourceId,GeometryId,ProximityProperties) “AssignRole()” for
proximity properties. Rather than modifying SceneGraph’s model, it
modifies the copy of the model stored in the provided context.</p>
<ol class="arabic simple" start="3">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.PerceptionProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>Assigns the perception role to the geometry indicated by
<code class="docutils literal"><span class="pre">geometry_id</span></code>.</p>
<p>By default, a geometry with a perception role will be reified by all
render::RenderEngine instances. This behavior can be changed.
Renderers can be explicitly whitelisted via the (‘renderer’,
‘accepting’) perception property. Its type is std::set&lt;std::string&gt;
and it contains the names of all the renderers that <em>may</em> reify it. If
no property is defined (or an empty set is given), then the default
behavior of all renderers attempting to reify it will be restored.</p>
<ol class="arabic simple" start="4">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[float], context: pydrake.systems.framework.Context_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.PerceptionProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>systems::Context-modifying variant of
AssignRole(SourceId,GeometryId,PerceptionProperties) “AssignRole()”
for perception properties. Rather than modifying SceneGraph’s model,
it modifies the copy of the model stored in the provided context.</p>
<ol class="arabic simple" start="5">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.IllustrationProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>Assigns the illustration role to the geometry indicated by
<code class="docutils literal"><span class="pre">geometry_id</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When changing illustration properties (<code class="docutils literal"><span class="pre">assign</span> <span class="pre">=</span>
<span class="pre">RoleAssign::kReplace</span></code>), there is no guarantee that these changes
will affect the visualization. The visualizer needs to be able to
“initialize” itself after changes to properties that will affect
how a geometry appears. If changing a geometry’s illustration
properties doesn’t seem to be affecting the visualization,
retrigger its initialization action.</p>
</div>
<ol class="arabic simple" start="6">
<li>AssignRole(self: pydrake.geometry.SceneGraph_[float], context: pydrake.systems.framework.Context_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, properties: pydrake.geometry.IllustrationProperties, assign: pydrake.geometry.RoleAssign = RoleAssign.kNew) -&gt; None</li>
</ol>
<p>systems::Context-modifying variant of
AssignRole(SourceId,GeometryId,IllustrationProperties) “AssignRole()”
for illustration properties. Rather than modifying SceneGraph’s model,
it modifies the copy of the model stored in the provided context.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When changing illustration properties (<code class="docutils literal"><span class="pre">assign</span> <span class="pre">=</span>
<span class="pre">RoleAssign::kReplace</span></code>), there is no guarantee that these changes
will affect the visualization. The visualizer needs to be able to
“initialize” itself after changes to properties that will affect
how a geometry appears. If changing a geometry’s illustration
properties doesn’t seem to be affecting the visualization,
retrigger its initialization action.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Due to a bug (see issue <a class="reference external" href="https://github.com/RobotLocomotion/drake/issues/13597">#13597</a>),
changing the illustration roles or properties in a
systems::Context will not have any apparent effect in, at least,
drake_visualizer. Please change the illustration role in the model
prior to allocating the context.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].ExcludeCollisionsBetween">
<code class="descname">ExcludeCollisionsBetween</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].ExcludeCollisionsBetween" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>ExcludeCollisionsBetween(self: pydrake.geometry.SceneGraph_[float], setA: pydrake.geometry.GeometrySet, setB: pydrake.geometry.GeometrySet) -&gt; None</li>
</ol>
<p>Excludes geometry pairs from collision evaluation by updating the
candidate pair set <code class="docutils literal"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">-</span> <span class="pre">P</span></code>, where <code class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">{(a,</span> <span class="pre">b)},</span> <span class="pre">∀</span> <span class="pre">a</span> <span class="pre">∈</span> <span class="pre">A,</span> <span class="pre">b</span> <span class="pre">∈</span>
<span class="pre">B</span></code> and <code class="docutils literal"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">{a₀,</span> <span class="pre">a₁,</span> <span class="pre">...,</span> <span class="pre">aₘ}</span></code> and <code class="docutils literal"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">{b₀,</span> <span class="pre">b₁,</span> <span class="pre">...,</span> <span class="pre">bₙ}</span></code> are
the input sets of geometries <code class="docutils literal"><span class="pre">setA</span></code> and <code class="docutils literal"><span class="pre">setB</span></code>, respectively. This
does <em>not</em> preclude collisions between members of the <em>same</em> set.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">scene_graph_collision_filtering for requirements and how collision
filtering works.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the groups include ids that don’t exist in the</li>
<li>scene graph.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>ExcludeCollisionsBetween(self: pydrake.geometry.SceneGraph_[float], context: pydrake.systems.framework.Context_[float], setA: pydrake.geometry.GeometrySet, setB: pydrake.geometry.GeometrySet) -&gt; None</li>
</ol>
<p>systems::Context-modifying variant of ExcludeCollisionsBetween().
Rather than modifying SceneGraph’s model, it modifies the copy of the
model stored in the provided context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].ExcludeCollisionsWithin">
<code class="descname">ExcludeCollisionsWithin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].ExcludeCollisionsWithin" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>ExcludeCollisionsWithin(self: pydrake.geometry.SceneGraph_[float], set: pydrake.geometry.GeometrySet) -&gt; None</li>
</ol>
<p>Excludes geometry pairs from collision evaluation by updating the
candidate pair set <code class="docutils literal"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">-</span> <span class="pre">P</span></code>, where <code class="docutils literal"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">{(gᵢ,</span> <span class="pre">gⱼ)},</span> <span class="pre">∀</span> <span class="pre">gᵢ,</span> <span class="pre">gⱼ</span> <span class="pre">∈</span>
<span class="pre">G</span></code> and <code class="docutils literal"><span class="pre">G</span> <span class="pre">=</span> <span class="pre">{g₀,</span> <span class="pre">g₁,</span> <span class="pre">...,</span> <span class="pre">gₘ}</span></code> is the input <code class="docutils literal"><span class="pre">set</span></code> of geometries.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">scene_graph_collision_filtering for requirements and how collision
filtering works.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the set includes ids that don’t exist in the scene</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">graph.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>ExcludeCollisionsWithin(self: pydrake.geometry.SceneGraph_[float], context: pydrake.systems.framework.Context_[float], set: pydrake.geometry.GeometrySet) -&gt; None</li>
</ol>
<p>systems::Context-modifying variant of ExcludeCollisionsWithin().
Rather than modifying SceneGraph’s model, it modifies the copy of the
model stored in the provided context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].get_pose_bundle_output_port">
<code class="descname">get_pose_bundle_output_port</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].get_pose_bundle_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port which produces the PoseBundle for LCM
communication to drake visualizer.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].get_query_output_port">
<code class="descname">get_query_output_port</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.OutputPort_[float]<a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].get_query_output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the output port which produces the QueryObject for performing
geometric queries.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].get_source_pose_port">
<code class="descname">get_source_pose_port</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float], arg0: pydrake.geometry.SourceId</em><span class="sig-paren">)</span> &#x2192; pydrake.systems.framework.InputPort_[float]<a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].get_source_pose_port" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a valid source <code class="docutils literal"><span class="pre">id</span></code>, returns a <em>pose</em> input port associated
with that <code class="docutils literal"><span class="pre">id</span></code>. This port is used to communicate <em>pose</em> data for
registered frames.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the source_id is <em>not</em> recognized.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].HasRenderer">
<code class="descname">HasRenderer</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float], name: str</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].HasRenderer" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if this SceneGraph has a renderer registered to the given
name.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].model_inspector">
<code class="descname">model_inspector</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.SceneGraphInspector_[float]<a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].model_inspector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an inspector on the system’s <em>model</em> scene graph data.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].RegisterAnchoredGeometry">
<code class="descname">RegisterAnchoredGeometry</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, geometry: pydrake.geometry.GeometryInstance</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.GeometryId<a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].RegisterAnchoredGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a new <em>anchored</em> geometry G for this source. This hangs
geometry G from the world frame (W). Its pose is defined in that frame
(i.e., <code class="docutils literal"><span class="pre">X_WG</span></code>). Returns the corresponding unique geometry id.</p>
<p>Roles will be assigned to the registered geometry if the corresponding
GeometryInstance <code class="docutils literal"><span class="pre">geometry</span></code> has had properties assigned.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">source_id</span></code>:</dt>
<dd>The id for the source registering the frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">geometry</span></code>:</dt>
<dd>The anchored geometry G to add to the world.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A unique identifier for the added geometry.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the <code class="docutils literal"><span class="pre">source_id</span></code> does <em>not</em> map to a</li>
<li>registered source or b) the geometry’s name doesn’t satisfy the</li>
<li>requirements outlined in GeometryInstance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].RegisterFrame">
<code class="descname">RegisterFrame</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].RegisterFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RegisterFrame(self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, frame: pydrake.geometry.GeometryFrame) -&gt; pydrake.geometry.FrameId</li>
</ol>
<p>Registers a new frame F for this source. This hangs frame F on the
world frame (W). Its pose is defined relative to the world frame (i.e,
<code class="docutils literal"><span class="pre">X_WF</span></code>). Returns the corresponding unique frame id.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">source_id</span></code>:</dt>
<dd>The id for the source registering the frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame</span></code>:</dt>
<dd>The frame to register.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A unique identifier for the added frame.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the <code class="docutils literal"><span class="pre">source_id</span></code> does <em>not</em> map to a</li>
<li>registered source, or b) <code class="docutils literal"><span class="pre">frame</span></code> has an id that has already been</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">registered.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>RegisterFrame(self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, parent_id: pydrake.geometry.FrameId, frame: pydrake.geometry.GeometryFrame) -&gt; pydrake.geometry.FrameId</li>
</ol>
<p>Registers a new frame F for this source. This hangs frame F on another
previously registered frame P (indicated by <code class="docutils literal"><span class="pre">parent_id</span></code>). The pose
of the new frame is defined relative to the parent frame (i.e.,
<code class="docutils literal"><span class="pre">X_PF</span></code>). Returns the corresponding unique frame id.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">source_id</span></code>:</dt>
<dd>The id for the source registering the frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">parent_id</span></code>:</dt>
<dd>The id of the parent frame P.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame</span></code>:</dt>
<dd>The frame to register.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A unique identifier for the added frame.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the <code class="docutils literal"><span class="pre">source_id</span></code> does <em>not</em> map to a</li>
<li>registered source, b) the <code class="docutils literal"><span class="pre">parent_id</span></code> does <em>not</em> map to a known</li>
<li>frame or does not belong to the source, or c) <code class="docutils literal"><span class="pre">frame</span></code> has an id</li>
<li>that has already been registered.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].RegisterGeometry">
<code class="descname">RegisterGeometry</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].RegisterGeometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>RegisterGeometry(self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, frame_id: pydrake.geometry.FrameId, geometry: pydrake.geometry.GeometryInstance) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Registers a new geometry G for this source. This hangs geometry G on a
previously registered frame F (indicated by <code class="docutils literal"><span class="pre">frame_id</span></code>). The pose of
the geometry is defined in a fixed pose relative to F (i.e.,
<code class="docutils literal"><span class="pre">X_FG</span></code>). Returns the corresponding unique geometry id.</p>
<p>Roles will be assigned to the registered geometry if the corresponding
GeometryInstance <code class="docutils literal"><span class="pre">geometry</span></code> has had properties assigned.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">source_id</span></code>:</dt>
<dd>The id for the source registering the geometry.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">frame_id</span></code>:</dt>
<dd>The id for the frame F to hang the geometry on.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">geometry</span></code>:</dt>
<dd>The geometry G to affix to frame F.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A unique identifier for the added geometry.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the <code class="docutils literal"><span class="pre">source_id</span></code> does <em>not</em> map to a</li>
<li>registered source, b) the <code class="docutils literal"><span class="pre">frame_id</span></code> doesn’t belong to the</li>
<li>source, c) the <code class="docutils literal"><span class="pre">geometry</span></code> is equal to <code class="docutils literal"><span class="pre">nullptr</span></code>, or d) the</li>
<li>geometry’s name doesn’t satisfy the requirements outlined in</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">GeometryInstance.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>RegisterGeometry(self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, geometry: pydrake.geometry.GeometryInstance) -&gt; pydrake.geometry.GeometryId</li>
</ol>
<p>Registers a new geometry G for this source. This hangs geometry G on a
previously registered geometry P (indicated by <code class="docutils literal"><span class="pre">geometry_id</span></code>). The
pose of the geometry is defined in a fixed pose relative to geometry P
(i.e., <code class="docutils literal"><span class="pre">X_PG</span></code>). By induction, this geometry is effectively rigidly
affixed to the frame that P is affixed to. Returns the corresponding
unique geometry id.</p>
<p>Roles will be assigned to the registered geometry if the corresponding
GeometryInstance <code class="docutils literal"><span class="pre">geometry</span></code> has had properties assigned.</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">source_id</span></code>:</dt>
<dd>The id for the source registering the geometry.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">geometry_id</span></code>:</dt>
<dd>The id for the parent geometry P.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">geometry</span></code>:</dt>
<dd>The geometry G to add.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A unique identifier for the added geometry.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) the <code class="docutils literal"><span class="pre">source_id</span></code> does <em>not</em> map to a</li>
<li>registered source, b) the <code class="docutils literal"><span class="pre">geometry_id</span></code> doesn’t belong to the</li>
<li>source, c) the <code class="docutils literal"><span class="pre">geometry</span></code> is equal to <code class="docutils literal"><span class="pre">nullptr</span></code>, or d) the</li>
<li>geometry’s name doesn’t satisfy the requirements outlined in</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">GeometryInstance.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].RegisterSource">
<code class="descname">RegisterSource</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float], name: str = ''</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.SourceId<a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].RegisterSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a new, named source to the geometry system. The caller must
save the returned SourceId; it is the token by which all other
operations on the geometry world are conducted.</p>
<p>This source id can be used to register arbitrary <em>anchored</em> geometry.
But if dynamic geometry is registered (via
RegisterGeometry/RegisterFrame), then the context-dependent pose
values must be provided on an input port. See get_source_pose_port().</p>
<p>This method modifies the underlying model and requires a new Context
to be allocated.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The optional name of the source. If none is provided (or the empty
string) a default name will be defined by SceneGraph’s logic.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the name is not unique.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].RemoveRole">
<code class="descname">RemoveRole</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float], source_id: pydrake.geometry.SourceId, geometry_id: pydrake.geometry.GeometryId, role: pydrake.geometry.Role</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].RemoveRole" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the indicated <code class="docutils literal"><span class="pre">role</span></code> from the geometry indicated by
<code class="docutils literal"><span class="pre">geometry_id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">One if the geometry had the role removed and zero if the geometry
did not have the role assigned in the first place.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if a) <code class="docutils literal"><span class="pre">source_id</span></code> does not map to a registered</li>
<li>source, b) <code class="docutils literal"><span class="pre">geometry_id</span></code> does not map to a registered geometry,</li>
<li><ol class="first loweralpha" start="3">
<li><code class="docutils literal"><span class="pre">geometry_id</span></code> does not belong to <code class="docutils literal"><span class="pre">source_id</span></code>, or d) the</li>
</ol>
</li>
<li>context has already been allocated.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraph_[float].RendererCount">
<code class="descname">RendererCount</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraph_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].RendererCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the number of renderers registered to this SceneGraph.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.SceneGraph_[float].world_frame_id">
<em class="property">static </em><code class="descname">world_frame_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.geometry.FrameId<a class="headerlink" href="#pydrake.geometry.SceneGraph_[float].world_frame_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the identifier for the world frame.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SceneGraphInspector">
<code class="descclassname">pydrake.geometry.</code><code class="descname">SceneGraphInspector</code><a class="headerlink" href="#pydrake.geometry.SceneGraphInspector" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.geometry.SceneGraphInspector_[float]" title="pydrake.geometry.SceneGraphInspector_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.SceneGraphInspector_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.geometry.SceneGraphInspector_">
<em class="property">template </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SceneGraphInspector_</code><a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.geometry.SceneGraphInspector_[float]" title="pydrake.geometry.SceneGraphInspector_[float]"><code class="xref py py-class docutils literal"><span class="pre">SceneGraphInspector_[float]</span></code></a>, <a class="reference internal" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd]" title="pydrake.geometry.SceneGraphInspector_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">SceneGraphInspector_[AutoDiffXd]</span></code></a></p>
<dl class="class">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float]">
<em class="property">class </em><code class="descname">SceneGraphInspector_[float]</code><a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>The SceneGraphInspector serves as a mechanism to query the topological
structure of a SceneGraph instance. The topological structure consists
of all of the SceneGraph data that does <em>not</em> depend on input pose
data. Including, but not limited to:</p>
<ul class="simple">
<li>names of frames and geometries</li>
<li>hierarchies (parents of geometries, parents of frames, etc.)</li>
<li>geometry parameters (e.g., contact, rendering, visualization)</li>
<li>fixed poses of geometries relative to frames</li>
</ul>
<p>In contrast, the following pieces of data <em>do</em> depend on input pose
data and <em>cannot</em> be performed with the SceneGraphInspector (see the
QueryObject instead):</p>
<ul class="simple">
<li>world pose of frames or geometry</li>
<li>collision queries</li>
<li>proximity queries</li>
</ul>
<p>A SceneGraphInspector cannot be instantiated explicitly. Nor can it be
copied or moved. A <em>reference</em> to a SceneGraphInspector instance can
be acquired from</p>
<ul class="simple">
<li>a SceneGraph instance (to inspect the state of the system’s <em>model</em>), or</li>
<li>a QueryObject instance (to inspect the state of the scene graph data stored</li>
</ul>
<p>in the context).</p>
<p>The reference should not be persisted (and, as previously indicated,
cannot be copied). SceneGraphInspector instances are cheap; they can
be created, queried, and thrown out. If there is any doubt about the
valid lifespan of a SceneGraphInspector, throw out the old instance
and request a new instance.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The scalar of the associated SceneGraph instance. The template
parameter is provided for the sake of compatibility, although no
queries (or their results) depend on the scalar.</dd>
</dl>
<dl class="attribute">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].CloneGeometryInstance">
<code class="descname">CloneGeometryInstance</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.GeometryInstance<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].CloneGeometryInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtains a new GeometryInstance that copies the geometry indicated by
the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new GeometryInstance that is ready to be added as a new
geometry. All roles/properties will be copied, the shape will be
cloned based off of the original, but the returned id() will
completely unique.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the <code class="docutils literal"><span class="pre">id</span></code> does not refer to a valid geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetAllGeometryIds">
<code class="descname">GetAllGeometryIds</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.GeometryId]<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetAllGeometryIds" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set of all ids for registered geometries. The order is
<em>not</em> guaranteed to have any particular meaning. But the order is
guaranteed to remain fixed until a topological change is made (e.g.,
removal or addition of geometry/frames).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetFrameId">
<code class="descname">GetFrameId</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.FrameId<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetFrameId" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the id of the frame to which the given geometry with the given
<code class="docutils literal"><span class="pre">id</span></code> is registered.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetGeometryIdByName">
<code class="descname">GetGeometryIdByName</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], frame_id: pydrake.geometry.FrameId, role: pydrake.geometry.Role, name: str</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.GeometryId<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetGeometryIdByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the id of the geometry with the given <code class="docutils literal"><span class="pre">name</span></code> and <code class="docutils literal"><span class="pre">role</span></code>,
attached to the frame with the given frame <code class="docutils literal"><span class="pre">id</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">id</span></code>:</dt>
<dd>The id of the frame whose geometry is being queried.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">role</span></code>:</dt>
<dd>The assigned role of the desired geometry.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The name of the geometry to query for. The name will be
canonicalized prior to lookup (see canonicalized_geometry_names
“GeometryInstance” for details).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The id of the queried geometry.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if no such geometry exists, multiple geometries have</li>
<li>that name, or if the <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetIllustrationProperties">
<code class="descname">GetIllustrationProperties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.IllustrationProperties<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetIllustrationProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the const illustration properties of the geometry
with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">id</span></code>:</dt>
<dd>The identifier for the queried geometry.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A pointer to the properties (or nullptr if there are no such
properties).</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetName">
<code class="descname">GetName</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetName" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetName(self: pydrake.geometry.SceneGraphInspector_[float], frame_id: pydrake.geometry.FrameId) -&gt; str</li>
</ol>
<p>Reports the name of the frame with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered frame.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetName(self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId) -&gt; str</li>
</ol>
<p>Reports the stored, canonical name of the geometry with the given
<code class="docutils literal"><span class="pre">id</span></code> (see canonicalized_geometry_names “GeometryInstance” for
details).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetNameByFrameId">
<code class="descname">GetNameByFrameId</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], frame_id: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetNameByFrameId" title="Permalink to this definition">¶</a></dt>
<dd><p>Please use SceneGraphInspector.GetName() instead. This method will be removed on or after 2020-10-01.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetNameByGeometryId">
<code class="descname">GetNameByGeometryId</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetNameByGeometryId" title="Permalink to this definition">¶</a></dt>
<dd><p>Please use SceneGraphInspector.GetName() instead. This method will be removed on or after 2020-10-01.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetPerceptionProperties">
<code class="descname">GetPerceptionProperties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.PerceptionProperties<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetPerceptionProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the const perception properties of the geometry
with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">id</span></code>:</dt>
<dd>The identifier for the queried geometry.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A pointer to the properties (or nullptr if there are no such
properties).</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetPoseInFrame">
<code class="descname">GetPoseInFrame</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetPoseInFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the pose of the geometry G with the given <code class="docutils literal"><span class="pre">id</span></code> in its
registered frame F (regardless of whether its <em>topological parent</em> is
another geometry P or not). If the geometry was registered directly to
the frame F, then <code class="docutils literal"><span class="pre">X_PG</span> <span class="pre">=</span> <span class="pre">X_FG</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetPoseInParent()</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetPoseInParent">
<code class="descname">GetPoseInParent</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetPoseInParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the pose of the geometry G with the given <code class="docutils literal"><span class="pre">id</span></code> in its
registered <em>topological parent</em> P, <code class="docutils literal"><span class="pre">X_PG</span></code>. That topological parent
may be a frame F or another geometry. If the geometry was registered
directly to F, then <code class="docutils literal"><span class="pre">X_PG</span> <span class="pre">=</span> <span class="pre">X_FG</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetPoseInFrame()</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetProximityProperties">
<code class="descname">GetProximityProperties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.ProximityProperties<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetProximityProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the const proximity properties of the geometry
with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">id</span></code>:</dt>
<dd>The identifier for the queried geometry.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A pointer to the properties (or nullptr if there are no such
properties).</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetShape">
<code class="descname">GetShape</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.Shape<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the shape specified for the geometry with the given <code class="docutils literal"><span class="pre">id</span></code>. In
order to extract the details of the shape, it should be passed through
an implementation of a ShapeReifier.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetSourceName">
<code class="descname">GetSourceName</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], id: pydrake.geometry.SourceId</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].GetSourceName" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the name for the source with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered source.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].num_frames">
<code class="descname">num_frames</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].num_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the <em>total</em> number of frames registered in the scene graph
(including the world frame).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].num_geometries">
<code class="descname">num_geometries</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].num_geometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the <em>total</em> number of geometries in the scene graph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].num_sources">
<code class="descname">num_sources</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].num_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the number of registered sources – whether they have
registered frames/geometries or not. This will always be at least 1;
the SceneGraph itself counts as a source.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].NumAnchoredGeometries">
<code class="descname">NumAnchoredGeometries</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].NumAnchoredGeometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the total number of <em>anchored</em> geometries. This should provide
the same answer as calling NumGeometriesForFrame() with the world
frame id.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].NumDynamicGeometries">
<code class="descname">NumDynamicGeometries</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].NumDynamicGeometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the total number of <em>dynamic</em> geometries in the scene graph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].NumGeometriesWithRole">
<code class="descname">NumGeometriesWithRole</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], role: pydrake.geometry.Role</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].NumGeometriesWithRole" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the <em>total</em> number of geometries in the scene graph with the
indicated role.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].SourceIsRegistered">
<code class="descname">SourceIsRegistered</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], id: pydrake.geometry.SourceId</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_.SceneGraphInspector_[float].SourceIsRegistered" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports <code class="docutils literal"><span class="pre">True</span></code> if the given <code class="docutils literal"><span class="pre">id</span></code> maps to a registered source.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SceneGraphInspector_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>The SceneGraphInspector serves as a mechanism to query the topological
structure of a SceneGraph instance. The topological structure consists
of all of the SceneGraph data that does <em>not</em> depend on input pose
data. Including, but not limited to:</p>
<ul class="simple">
<li>names of frames and geometries</li>
<li>hierarchies (parents of geometries, parents of frames, etc.)</li>
<li>geometry parameters (e.g., contact, rendering, visualization)</li>
<li>fixed poses of geometries relative to frames</li>
</ul>
<p>In contrast, the following pieces of data <em>do</em> depend on input pose
data and <em>cannot</em> be performed with the SceneGraphInspector (see the
QueryObject instead):</p>
<ul class="simple">
<li>world pose of frames or geometry</li>
<li>collision queries</li>
<li>proximity queries</li>
</ul>
<p>A SceneGraphInspector cannot be instantiated explicitly. Nor can it be
copied or moved. A <em>reference</em> to a SceneGraphInspector instance can
be acquired from</p>
<ul class="simple">
<li>a SceneGraph instance (to inspect the state of the system’s <em>model</em>), or</li>
<li>a QueryObject instance (to inspect the state of the scene graph data stored</li>
</ul>
<p>in the context).</p>
<p>The reference should not be persisted (and, as previously indicated,
cannot be copied). SceneGraphInspector instances are cheap; they can
be created, queried, and thrown out. If there is any doubt about the
valid lifespan of a SceneGraphInspector, throw out the old instance
and request a new instance.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The scalar of the associated SceneGraph instance. The template
parameter is provided for the sake of compatibility, although no
queries (or their results) depend on the scalar.</dd>
</dl>
<dl class="attribute">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].CloneGeometryInstance">
<code class="descname">CloneGeometryInstance</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.GeometryInstance<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].CloneGeometryInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtains a new GeometryInstance that copies the geometry indicated by
the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new GeometryInstance that is ready to be added as a new
geometry. All roles/properties will be copied, the shape will be
cloned based off of the original, but the returned id() will
completely unique.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the <code class="docutils literal"><span class="pre">id</span></code> does not refer to a valid geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetAllGeometryIds">
<code class="descname">GetAllGeometryIds</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.GeometryId]<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetAllGeometryIds" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set of all ids for registered geometries. The order is
<em>not</em> guaranteed to have any particular meaning. But the order is
guaranteed to remain fixed until a topological change is made (e.g.,
removal or addition of geometry/frames).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetFrameId">
<code class="descname">GetFrameId</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.FrameId<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetFrameId" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the id of the frame to which the given geometry with the given
<code class="docutils literal"><span class="pre">id</span></code> is registered.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetGeometryIdByName">
<code class="descname">GetGeometryIdByName</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], frame_id: pydrake.geometry.FrameId, role: pydrake.geometry.Role, name: str</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.GeometryId<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetGeometryIdByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the id of the geometry with the given <code class="docutils literal"><span class="pre">name</span></code> and <code class="docutils literal"><span class="pre">role</span></code>,
attached to the frame with the given frame <code class="docutils literal"><span class="pre">id</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">id</span></code>:</dt>
<dd>The id of the frame whose geometry is being queried.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">role</span></code>:</dt>
<dd>The assigned role of the desired geometry.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The name of the geometry to query for. The name will be
canonicalized prior to lookup (see canonicalized_geometry_names
“GeometryInstance” for details).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The id of the queried geometry.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if no such geometry exists, multiple geometries have</li>
<li>that name, or if the <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetIllustrationProperties">
<code class="descname">GetIllustrationProperties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.IllustrationProperties<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetIllustrationProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the const illustration properties of the geometry
with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">id</span></code>:</dt>
<dd>The identifier for the queried geometry.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A pointer to the properties (or nullptr if there are no such
properties).</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetName">
<code class="descname">GetName</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetName" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetName(self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], frame_id: pydrake.geometry.FrameId) -&gt; str</li>
</ol>
<p>Reports the name of the frame with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered frame.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetName(self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], geometry_id: pydrake.geometry.GeometryId) -&gt; str</li>
</ol>
<p>Reports the stored, canonical name of the geometry with the given
<code class="docutils literal"><span class="pre">id</span></code> (see canonicalized_geometry_names “GeometryInstance” for
details).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetNameByFrameId">
<code class="descname">GetNameByFrameId</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], frame_id: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetNameByFrameId" title="Permalink to this definition">¶</a></dt>
<dd><p>Please use SceneGraphInspector.GetName() instead. This method will be removed on or after 2020-10-01.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetNameByGeometryId">
<code class="descname">GetNameByGeometryId</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetNameByGeometryId" title="Permalink to this definition">¶</a></dt>
<dd><p>Please use SceneGraphInspector.GetName() instead. This method will be removed on or after 2020-10-01.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetPerceptionProperties">
<code class="descname">GetPerceptionProperties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.PerceptionProperties<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetPerceptionProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the const perception properties of the geometry
with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">id</span></code>:</dt>
<dd>The identifier for the queried geometry.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A pointer to the properties (or nullptr if there are no such
properties).</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetPoseInFrame">
<code class="descname">GetPoseInFrame</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetPoseInFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the pose of the geometry G with the given <code class="docutils literal"><span class="pre">id</span></code> in its
registered frame F (regardless of whether its <em>topological parent</em> is
another geometry P or not). If the geometry was registered directly to
the frame F, then <code class="docutils literal"><span class="pre">X_PG</span> <span class="pre">=</span> <span class="pre">X_FG</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetPoseInParent()</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetPoseInParent">
<code class="descname">GetPoseInParent</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetPoseInParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the pose of the geometry G with the given <code class="docutils literal"><span class="pre">id</span></code> in its
registered <em>topological parent</em> P, <code class="docutils literal"><span class="pre">X_PG</span></code>. That topological parent
may be a frame F or another geometry. If the geometry was registered
directly to F, then <code class="docutils literal"><span class="pre">X_PG</span> <span class="pre">=</span> <span class="pre">X_FG</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetPoseInFrame()</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetProximityProperties">
<code class="descname">GetProximityProperties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.ProximityProperties<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetProximityProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the const proximity properties of the geometry
with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">id</span></code>:</dt>
<dd>The identifier for the queried geometry.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A pointer to the properties (or nullptr if there are no such
properties).</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetShape">
<code class="descname">GetShape</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.Shape<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the shape specified for the geometry with the given <code class="docutils literal"><span class="pre">id</span></code>. In
order to extract the details of the shape, it should be passed through
an implementation of a ShapeReifier.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetSourceName">
<code class="descname">GetSourceName</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], id: pydrake.geometry.SourceId</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].GetSourceName" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the name for the source with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered source.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].num_frames">
<code class="descname">num_frames</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].num_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the <em>total</em> number of frames registered in the scene graph
(including the world frame).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].num_geometries">
<code class="descname">num_geometries</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].num_geometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the <em>total</em> number of geometries in the scene graph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].num_sources">
<code class="descname">num_sources</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].num_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the number of registered sources – whether they have
registered frames/geometries or not. This will always be at least 1;
the SceneGraph itself counts as a source.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].NumAnchoredGeometries">
<code class="descname">NumAnchoredGeometries</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].NumAnchoredGeometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the total number of <em>anchored</em> geometries. This should provide
the same answer as calling NumGeometriesForFrame() with the world
frame id.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].NumDynamicGeometries">
<code class="descname">NumDynamicGeometries</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].NumDynamicGeometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the total number of <em>dynamic</em> geometries in the scene graph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].NumGeometriesWithRole">
<code class="descname">NumGeometriesWithRole</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], role: pydrake.geometry.Role</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].NumGeometriesWithRole" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the <em>total</em> number of geometries in the scene graph with the
indicated role.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[AutoDiffXd].SourceIsRegistered">
<code class="descname">SourceIsRegistered</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[AutoDiffXd], id: pydrake.geometry.SourceId</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[AutoDiffXd].SourceIsRegistered" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports <code class="docutils literal"><span class="pre">True</span></code> if the given <code class="docutils literal"><span class="pre">id</span></code> maps to a registered source.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.SceneGraphInspector_[float]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SceneGraphInspector_[float]</code><a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>The SceneGraphInspector serves as a mechanism to query the topological
structure of a SceneGraph instance. The topological structure consists
of all of the SceneGraph data that does <em>not</em> depend on input pose
data. Including, but not limited to:</p>
<ul class="simple">
<li>names of frames and geometries</li>
<li>hierarchies (parents of geometries, parents of frames, etc.)</li>
<li>geometry parameters (e.g., contact, rendering, visualization)</li>
<li>fixed poses of geometries relative to frames</li>
</ul>
<p>In contrast, the following pieces of data <em>do</em> depend on input pose
data and <em>cannot</em> be performed with the SceneGraphInspector (see the
QueryObject instead):</p>
<ul class="simple">
<li>world pose of frames or geometry</li>
<li>collision queries</li>
<li>proximity queries</li>
</ul>
<p>A SceneGraphInspector cannot be instantiated explicitly. Nor can it be
copied or moved. A <em>reference</em> to a SceneGraphInspector instance can
be acquired from</p>
<ul class="simple">
<li>a SceneGraph instance (to inspect the state of the system’s <em>model</em>), or</li>
<li>a QueryObject instance (to inspect the state of the scene graph data stored</li>
</ul>
<p>in the context).</p>
<p>The reference should not be persisted (and, as previously indicated,
cannot be copied). SceneGraphInspector instances are cheap; they can
be created, queried, and thrown out. If there is any doubt about the
valid lifespan of a SceneGraphInspector, throw out the old instance
and request a new instance.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The scalar of the associated SceneGraph instance. The template
parameter is provided for the sake of compatibility, although no
queries (or their results) depend on the scalar.</dd>
</dl>
<dl class="attribute">
<dt id="pydrake.geometry.SceneGraphInspector_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].CloneGeometryInstance">
<code class="descname">CloneGeometryInstance</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.GeometryInstance<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].CloneGeometryInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtains a new GeometryInstance that copies the geometry indicated by
the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A new GeometryInstance that is ready to be added as a new
geometry. All roles/properties will be copied, the shape will be
cloned based off of the original, but the returned id() will
completely unique.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the <code class="docutils literal"><span class="pre">id</span></code> does not refer to a valid geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].GetAllGeometryIds">
<code class="descname">GetAllGeometryIds</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.GeometryId]<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].GetAllGeometryIds" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set of all ids for registered geometries. The order is
<em>not</em> guaranteed to have any particular meaning. But the order is
guaranteed to remain fixed until a topological change is made (e.g.,
removal or addition of geometry/frames).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].GetFrameId">
<code class="descname">GetFrameId</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.FrameId<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].GetFrameId" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the id of the frame to which the given geometry with the given
<code class="docutils literal"><span class="pre">id</span></code> is registered.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].GetGeometryIdByName">
<code class="descname">GetGeometryIdByName</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], frame_id: pydrake.geometry.FrameId, role: pydrake.geometry.Role, name: str</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.GeometryId<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].GetGeometryIdByName" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the id of the geometry with the given <code class="docutils literal"><span class="pre">name</span></code> and <code class="docutils literal"><span class="pre">role</span></code>,
attached to the frame with the given frame <code class="docutils literal"><span class="pre">id</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">id</span></code>:</dt>
<dd>The id of the frame whose geometry is being queried.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">role</span></code>:</dt>
<dd>The assigned role of the desired geometry.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The name of the geometry to query for. The name will be
canonicalized prior to lookup (see canonicalized_geometry_names
“GeometryInstance” for details).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The id of the queried geometry.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if no such geometry exists, multiple geometries have</li>
<li>that name, or if the <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].GetIllustrationProperties">
<code class="descname">GetIllustrationProperties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.IllustrationProperties<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].GetIllustrationProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the const illustration properties of the geometry
with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">id</span></code>:</dt>
<dd>The identifier for the queried geometry.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A pointer to the properties (or nullptr if there are no such
properties).</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].GetName">
<code class="descname">GetName</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].GetName" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetName(self: pydrake.geometry.SceneGraphInspector_[float], frame_id: pydrake.geometry.FrameId) -&gt; str</li>
</ol>
<p>Reports the name of the frame with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered frame.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetName(self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId) -&gt; str</li>
</ol>
<p>Reports the stored, canonical name of the geometry with the given
<code class="docutils literal"><span class="pre">id</span></code> (see canonicalized_geometry_names “GeometryInstance” for
details).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].GetNameByFrameId">
<code class="descname">GetNameByFrameId</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], frame_id: pydrake.geometry.FrameId</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].GetNameByFrameId" title="Permalink to this definition">¶</a></dt>
<dd><p>Please use SceneGraphInspector.GetName() instead. This method will be removed on or after 2020-10-01.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].GetNameByGeometryId">
<code class="descname">GetNameByGeometryId</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].GetNameByGeometryId" title="Permalink to this definition">¶</a></dt>
<dd><p>Please use SceneGraphInspector.GetName() instead. This method will be removed on or after 2020-10-01.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].GetPerceptionProperties">
<code class="descname">GetPerceptionProperties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.PerceptionProperties<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].GetPerceptionProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the const perception properties of the geometry
with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">id</span></code>:</dt>
<dd>The identifier for the queried geometry.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A pointer to the properties (or nullptr if there are no such
properties).</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].GetPoseInFrame">
<code class="descname">GetPoseInFrame</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].GetPoseInFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the pose of the geometry G with the given <code class="docutils literal"><span class="pre">id</span></code> in its
registered frame F (regardless of whether its <em>topological parent</em> is
another geometry P or not). If the geometry was registered directly to
the frame F, then <code class="docutils literal"><span class="pre">X_PG</span> <span class="pre">=</span> <span class="pre">X_FG</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetPoseInParent()</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].GetPoseInParent">
<code class="descname">GetPoseInParent</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].GetPoseInParent" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the pose of the geometry G with the given <code class="docutils literal"><span class="pre">id</span></code> in its
registered <em>topological parent</em> P, <code class="docutils literal"><span class="pre">X_PG</span></code>. That topological parent
may be a frame F or another geometry. If the geometry was registered
directly to F, then <code class="docutils literal"><span class="pre">X_PG</span> <span class="pre">=</span> <span class="pre">X_FG</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">GetPoseInFrame()</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].GetProximityProperties">
<code class="descname">GetProximityProperties</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.ProximityProperties<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].GetProximityProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the const proximity properties of the geometry
with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">id</span></code>:</dt>
<dd>The identifier for the queried geometry.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A pointer to the properties (or nullptr if there are no such
properties).</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered geometry.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].GetShape">
<code class="descname">GetShape</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], geometry_id: pydrake.geometry.GeometryId</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.Shape<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].GetShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the shape specified for the geometry with the given <code class="docutils literal"><span class="pre">id</span></code>. In
order to extract the details of the shape, it should be passed through
an implementation of a ShapeReifier.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].GetSourceName">
<code class="descname">GetSourceName</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], id: pydrake.geometry.SourceId</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].GetSourceName" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the name for the source with the given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">id</span></code> does not map to a registered source.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].num_frames">
<code class="descname">num_frames</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].num_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the <em>total</em> number of frames registered in the scene graph
(including the world frame).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].num_geometries">
<code class="descname">num_geometries</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].num_geometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the <em>total</em> number of geometries in the scene graph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].num_sources">
<code class="descname">num_sources</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].num_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the number of registered sources – whether they have
registered frames/geometries or not. This will always be at least 1;
the SceneGraph itself counts as a source.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].NumAnchoredGeometries">
<code class="descname">NumAnchoredGeometries</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].NumAnchoredGeometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the total number of <em>anchored</em> geometries. This should provide
the same answer as calling NumGeometriesForFrame() with the world
frame id.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].NumDynamicGeometries">
<code class="descname">NumDynamicGeometries</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].NumDynamicGeometries" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the total number of <em>dynamic</em> geometries in the scene graph.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].NumGeometriesWithRole">
<code class="descname">NumGeometriesWithRole</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], role: pydrake.geometry.Role</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].NumGeometriesWithRole" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the <em>total</em> number of geometries in the scene graph with the
indicated role.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SceneGraphInspector_[float].SourceIsRegistered">
<code class="descname">SourceIsRegistered</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SceneGraphInspector_[float], id: pydrake.geometry.SourceId</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.SceneGraphInspector_[float].SourceIsRegistered" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports <code class="docutils literal"><span class="pre">True</span></code> if the given <code class="docutils literal"><span class="pre">id</span></code> maps to a registered source.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.Shape">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">Shape</code><a class="headerlink" href="#pydrake.geometry.Shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The base interface for all shape specifications. It has no public
constructor and cannot be instantiated directly. The Shape class has
two key properties:</p>
<ul class="simple">
<li>it is cloneable, and</li>
<li>it can be “reified” (see ShapeReifier).</li>
</ul>
<p>When you add a new subclass of Shape, you must:</p>
<p>1. add a virtual function ImplementGeometry() for the new shape in
ShapeReifier that invokes the ThrowUnsupportedGeometry method, and add to
the test for it in shape_specification_test.cc.
2. implement ImplementGeometry in derived ShapeReifiers to continue support
if desired, otherwise ensure unimplemented functions are not hidden in new
derivations of ShapeReifier with <code class="docutils literal"><span class="pre">using</span></code>, for example, <code class="docutils literal"><span class="pre">using</span>
<span class="pre">ShapeReifier::ImplementGeometry</span></code>. Existing subclasses should already have
this.</p>
<p>Otherwise, you might get a runtime error. We do not have an automatic
way to enforce them at compile time.</p>
<dl class="attribute">
<dt id="pydrake.geometry.Shape.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.geometry.Shape.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Shape.Clone">
<code class="descname">Clone</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Shape</em><span class="sig-paren">)</span> &#x2192; pydrake.geometry.Shape<a class="headerlink" href="#pydrake.geometry.Shape.Clone" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair">
<code class="descclassname">pydrake.geometry.</code><code class="descname">SignedDistancePair</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.geometry.SignedDistancePair_[float]" title="pydrake.geometry.SignedDistancePair_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.SignedDistancePair_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.geometry.SignedDistancePair_">
<em class="property">template </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SignedDistancePair_</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.geometry.SignedDistancePair_[float]" title="pydrake.geometry.SignedDistancePair_[float]"><code class="xref py py-class docutils literal"><span class="pre">SignedDistancePair_[float]</span></code></a>, <a class="reference internal" href="#pydrake.geometry.SignedDistancePair_[AutoDiffXd]" title="pydrake.geometry.SignedDistancePair_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">SignedDistancePair_[AutoDiffXd]</span></code></a></p>
<dl class="class">
<dt id="pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float]">
<em class="property">class </em><code class="descname">SignedDistancePair_[float]</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>The data for reporting the signed distance between two geometries, A
and B. It provides the id’s of the two geometries, the witness points
Ca and Cb on the surfaces of A and B, the signed distance, and
nhat_BA_W a direction of fastest increasing distance (always unit
length and always point outward from B’s surface).</p>
<ul class="simple">
<li>When A and B are separated, distance &gt; 0.</li>
<li>When A and B are touching or penetrating, distance &lt;= 0.</li>
<li>By definition, nhat_AB_W must be in the opposite direction of nhat_BA_W.</li>
<li>(p_WCa - p_Wcb) = distance · nhat_BA_W.</li>
<li>In some cases, nhat_BA_W is not unique, and is_nhat_BA_W_unique is false.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For two geometries that are just touching (i.e., distance = 0),
the underlying code can guarantee a correct value for nhat_BA_W
only when one geometry is a sphere, and the other geometry is a
sphere, a box, or a cylinder. Otherwise, the underlying code is
not in place yet to guarantee a correct value for nhat_BA_W when
surfaces are just touching, and the vector will be populated by
NaN values.</p>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type. Must be a valid Eigen scalar.</dd>
</dl>
<dl class="method">
<dt id="pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SignedDistancePair_[float], **kwargs</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">a</span></code>:</dt>
<dd>The id of the first geometry (A).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">b</span></code>:</dt>
<dd>The id of the second geometry (B).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_ACa_in</span></code>:</dt>
<dd>The witness point on geometry A’s surface, in A’s frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BCb_in</span></code>:</dt>
<dd>The witness point on geometry B’s surface, in B’s frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">dist</span></code>:</dt>
<dd>The signed distance between p_A and p_B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">nhat_BA_W_in</span></code>:</dt>
<dd>A direction of fastest increasing distance.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">is_nhat_BA_W_unique_in</span></code>:</dt>
<dd>True if nhat_BA_W is unique.</dd>
<dt>Precondition:</dt>
<dd>nhat_BA_W_in is unit-length.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].distance">
<code class="descname">distance</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].distance" title="Permalink to this definition">¶</a></dt>
<dd><p>The signed distance between p_ACa and p_BCb.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].id_A">
<code class="descname">id_A</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].id_A" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the first geometry in the pair.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].id_B">
<code class="descname">id_B</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].id_B" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the second geometry in the pair.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].is_nhat_BA_W_unique">
<code class="descname">is_nhat_BA_W_unique</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].is_nhat_BA_W_unique" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].nhat_BA_W">
<code class="descname">nhat_BA_W</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].nhat_BA_W" title="Permalink to this definition">¶</a></dt>
<dd><p>A direction of fastest increasing distance.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].p_ACa">
<code class="descname">p_ACa</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].p_ACa" title="Permalink to this definition">¶</a></dt>
<dd><p>The witness point on geometry A’s surface, expressed in A’s frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].p_BCb">
<code class="descname">p_BCb</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_.SignedDistancePair_[float].p_BCb" title="Permalink to this definition">¶</a></dt>
<dd><p>The witness point on geometry B’s surface, expressed in B’s frame.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.SignedDistancePair_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SignedDistancePair_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>The data for reporting the signed distance between two geometries, A
and B. It provides the id’s of the two geometries, the witness points
Ca and Cb on the surfaces of A and B, the signed distance, and
nhat_BA_W a direction of fastest increasing distance (always unit
length and always point outward from B’s surface).</p>
<ul class="simple">
<li>When A and B are separated, distance &gt; 0.</li>
<li>When A and B are touching or penetrating, distance &lt;= 0.</li>
<li>By definition, nhat_AB_W must be in the opposite direction of nhat_BA_W.</li>
<li>(p_WCa - p_Wcb) = distance · nhat_BA_W.</li>
<li>In some cases, nhat_BA_W is not unique, and is_nhat_BA_W_unique is false.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For two geometries that are just touching (i.e., distance = 0),
the underlying code can guarantee a correct value for nhat_BA_W
only when one geometry is a sphere, and the other geometry is a
sphere, a box, or a cylinder. Otherwise, the underlying code is
not in place yet to guarantee a correct value for nhat_BA_W when
surfaces are just touching, and the vector will be populated by
NaN values.</p>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type. Must be a valid Eigen scalar.</dd>
</dl>
<dl class="method">
<dt id="pydrake.geometry.SignedDistancePair_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SignedDistancePair_[AutoDiffXd], **kwargs</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">a</span></code>:</dt>
<dd>The id of the first geometry (A).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">b</span></code>:</dt>
<dd>The id of the second geometry (B).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_ACa_in</span></code>:</dt>
<dd>The witness point on geometry A’s surface, in A’s frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BCb_in</span></code>:</dt>
<dd>The witness point on geometry B’s surface, in B’s frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">dist</span></code>:</dt>
<dd>The signed distance between p_A and p_B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">nhat_BA_W_in</span></code>:</dt>
<dd>A direction of fastest increasing distance.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">is_nhat_BA_W_unique_in</span></code>:</dt>
<dd>True if nhat_BA_W is unique.</dd>
<dt>Precondition:</dt>
<dd>nhat_BA_W_in is unit-length.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_[AutoDiffXd].distance">
<code class="descname">distance</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[AutoDiffXd].distance" title="Permalink to this definition">¶</a></dt>
<dd><p>The signed distance between p_ACa and p_BCb.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_[AutoDiffXd].id_A">
<code class="descname">id_A</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[AutoDiffXd].id_A" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the first geometry in the pair.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_[AutoDiffXd].id_B">
<code class="descname">id_B</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[AutoDiffXd].id_B" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the second geometry in the pair.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_[AutoDiffXd].is_nhat_BA_W_unique">
<code class="descname">is_nhat_BA_W_unique</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[AutoDiffXd].is_nhat_BA_W_unique" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_[AutoDiffXd].nhat_BA_W">
<code class="descname">nhat_BA_W</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[AutoDiffXd].nhat_BA_W" title="Permalink to this definition">¶</a></dt>
<dd><p>A direction of fastest increasing distance.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_[AutoDiffXd].p_ACa">
<code class="descname">p_ACa</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[AutoDiffXd].p_ACa" title="Permalink to this definition">¶</a></dt>
<dd><p>The witness point on geometry A’s surface, expressed in A’s frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_[AutoDiffXd].p_BCb">
<code class="descname">p_BCb</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[AutoDiffXd].p_BCb" title="Permalink to this definition">¶</a></dt>
<dd><p>The witness point on geometry B’s surface, expressed in B’s frame.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.SignedDistancePair_[float]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SignedDistancePair_[float]</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>The data for reporting the signed distance between two geometries, A
and B. It provides the id’s of the two geometries, the witness points
Ca and Cb on the surfaces of A and B, the signed distance, and
nhat_BA_W a direction of fastest increasing distance (always unit
length and always point outward from B’s surface).</p>
<ul class="simple">
<li>When A and B are separated, distance &gt; 0.</li>
<li>When A and B are touching or penetrating, distance &lt;= 0.</li>
<li>By definition, nhat_AB_W must be in the opposite direction of nhat_BA_W.</li>
<li>(p_WCa - p_Wcb) = distance · nhat_BA_W.</li>
<li>In some cases, nhat_BA_W is not unique, and is_nhat_BA_W_unique is false.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For two geometries that are just touching (i.e., distance = 0),
the underlying code can guarantee a correct value for nhat_BA_W
only when one geometry is a sphere, and the other geometry is a
sphere, a box, or a cylinder. Otherwise, the underlying code is
not in place yet to guarantee a correct value for nhat_BA_W when
surfaces are just touching, and the vector will be populated by
NaN values.</p>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type. Must be a valid Eigen scalar.</dd>
</dl>
<dl class="method">
<dt id="pydrake.geometry.SignedDistancePair_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SignedDistancePair_[float], **kwargs</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">a</span></code>:</dt>
<dd>The id of the first geometry (A).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">b</span></code>:</dt>
<dd>The id of the second geometry (B).</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_ACa_in</span></code>:</dt>
<dd>The witness point on geometry A’s surface, in A’s frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_BCb_in</span></code>:</dt>
<dd>The witness point on geometry B’s surface, in B’s frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">dist</span></code>:</dt>
<dd>The signed distance between p_A and p_B.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">nhat_BA_W_in</span></code>:</dt>
<dd>A direction of fastest increasing distance.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">is_nhat_BA_W_unique_in</span></code>:</dt>
<dd>True if nhat_BA_W is unique.</dd>
<dt>Precondition:</dt>
<dd>nhat_BA_W_in is unit-length.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_[float].distance">
<code class="descname">distance</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[float].distance" title="Permalink to this definition">¶</a></dt>
<dd><p>The signed distance between p_ACa and p_BCb.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_[float].id_A">
<code class="descname">id_A</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[float].id_A" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the first geometry in the pair.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_[float].id_B">
<code class="descname">id_B</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[float].id_B" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the second geometry in the pair.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_[float].is_nhat_BA_W_unique">
<code class="descname">is_nhat_BA_W_unique</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[float].is_nhat_BA_W_unique" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_[float].nhat_BA_W">
<code class="descname">nhat_BA_W</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[float].nhat_BA_W" title="Permalink to this definition">¶</a></dt>
<dd><p>A direction of fastest increasing distance.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_[float].p_ACa">
<code class="descname">p_ACa</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[float].p_ACa" title="Permalink to this definition">¶</a></dt>
<dd><p>The witness point on geometry A’s surface, expressed in A’s frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistancePair_[float].p_BCb">
<code class="descname">p_BCb</code><a class="headerlink" href="#pydrake.geometry.SignedDistancePair_[float].p_BCb" title="Permalink to this definition">¶</a></dt>
<dd><p>The witness point on geometry B’s surface, expressed in B’s frame.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistanceToPoint">
<code class="descclassname">pydrake.geometry.</code><code class="descname">SignedDistanceToPoint</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.geometry.SignedDistanceToPoint_[float]" title="pydrake.geometry.SignedDistanceToPoint_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.SignedDistanceToPoint_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.geometry.SignedDistanceToPoint_">
<em class="property">template </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SignedDistanceToPoint_</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.geometry.SignedDistanceToPoint_[float]" title="pydrake.geometry.SignedDistanceToPoint_[float]"><code class="xref py py-class docutils literal"><span class="pre">SignedDistanceToPoint_[float]</span></code></a>, <a class="reference internal" href="#pydrake.geometry.SignedDistanceToPoint_[AutoDiffXd]" title="pydrake.geometry.SignedDistanceToPoint_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">SignedDistanceToPoint_[AutoDiffXd]</span></code></a></p>
<dl class="class">
<dt id="pydrake.geometry.SignedDistanceToPoint_.SignedDistanceToPoint_[float]">
<em class="property">class </em><code class="descname">SignedDistanceToPoint_[float]</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_.SignedDistanceToPoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>The data for reporting the signed distance from a query point to a
geometry. Reports the result of a signed distance query between a
query point Q and geometry G. This includes G’s id, the signed
distance, the nearest point N on the surface of G, and the gradient of
the signed distance with respect to the position of Q. Generally, the
gradient of the signed distance function is not defined everywhere.
The value reported in this struct depends on the query function
returning it. Refer to the query function’s documentation for what
value it will report for otherwise undefined gradient values.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type. Must be a valid Eigen scalar.</dd>
</dl>
<dl class="method">
<dt id="pydrake.geometry.SignedDistanceToPoint_.SignedDistanceToPoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SignedDistanceToPoint_[float], **kwargs</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_.SignedDistanceToPoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs SignedDistanceToPoint struct from calculated results.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">id_G_in</span></code>:</dt>
<dd>The id of the geometry G to which we measure distance from the
query point Q.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_GN_in</span></code>:</dt>
<dd>The position of the nearest point N on G’s surface from the query
point Q, expressed in G’s frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">distance_in</span></code>:</dt>
<dd>The signed distance from the query point Q to the nearest point N
on the surface of geometry G. It is positive if Q is outside G. It
is negative if Q is inside G. It is zero if Q is on the boundary
of G.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">grad_W_in</span></code>:</dt>
<dd>The gradient vector of the distance function with respect to the
query point Q, expressed in world frame W.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">is_grad_W_unique_in</span></code>:</dt>
<dd>True if grad_W is unique, false otherwise.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">grad_W is not well defined everywhere. For example, when computing
the distance from a point to a sphere, and the point coincides
with the center of the sphere, grad_W is not well defined (as it
can be computed as p_GQ / <a href="#id38"><span class="problematic" id="id39">|p_GQ|</span></a>, but the denominator is 0). When
grad_W is not well defined, and we instantiate
SignedDistanceToPoint&lt;T&gt; with T being an AutoDiffScalar (like
AutoDiffXd), the gradient of the query result is not well defined
either, so the user should use the gradient in p_GN, distance and
grad_W with caution.</p>
</div>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>grad_W_in must not contain NaN.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistanceToPoint_.SignedDistanceToPoint_[float].distance">
<code class="descname">distance</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_.SignedDistanceToPoint_[float].distance" title="Permalink to this definition">¶</a></dt>
<dd><p>The signed distance from the query point Q to the nearest point N on
the surface of geometry G. It is positive if Q is outside G. It is
negative if Q is inside G. It is zero if Q is on the boundary of G.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistanceToPoint_.SignedDistanceToPoint_[float].grad_W">
<code class="descname">grad_W</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_.SignedDistanceToPoint_[float].grad_W" title="Permalink to this definition">¶</a></dt>
<dd><p>The gradient vector of the distance function with respect to the query
point Q, expressed in world frame W.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistanceToPoint_.SignedDistanceToPoint_[float].id_G">
<code class="descname">id_G</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_.SignedDistanceToPoint_[float].id_G" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the geometry G to which we measure distance from the query
point Q.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistanceToPoint_.SignedDistanceToPoint_[float].p_GN">
<code class="descname">p_GN</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_.SignedDistanceToPoint_[float].p_GN" title="Permalink to this definition">¶</a></dt>
<dd><p>The position of the nearest point N on G’s surface from the query
point Q, expressed in G’s frame.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.SignedDistanceToPoint_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SignedDistanceToPoint_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>The data for reporting the signed distance from a query point to a
geometry. Reports the result of a signed distance query between a
query point Q and geometry G. This includes G’s id, the signed
distance, the nearest point N on the surface of G, and the gradient of
the signed distance with respect to the position of Q. Generally, the
gradient of the signed distance function is not defined everywhere.
The value reported in this struct depends on the query function
returning it. Refer to the query function’s documentation for what
value it will report for otherwise undefined gradient values.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type. Must be a valid Eigen scalar.</dd>
</dl>
<dl class="method">
<dt id="pydrake.geometry.SignedDistanceToPoint_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SignedDistanceToPoint_[AutoDiffXd], **kwargs</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs SignedDistanceToPoint struct from calculated results.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">id_G_in</span></code>:</dt>
<dd>The id of the geometry G to which we measure distance from the
query point Q.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_GN_in</span></code>:</dt>
<dd>The position of the nearest point N on G’s surface from the query
point Q, expressed in G’s frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">distance_in</span></code>:</dt>
<dd>The signed distance from the query point Q to the nearest point N
on the surface of geometry G. It is positive if Q is outside G. It
is negative if Q is inside G. It is zero if Q is on the boundary
of G.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">grad_W_in</span></code>:</dt>
<dd>The gradient vector of the distance function with respect to the
query point Q, expressed in world frame W.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">is_grad_W_unique_in</span></code>:</dt>
<dd>True if grad_W is unique, false otherwise.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">grad_W is not well defined everywhere. For example, when computing
the distance from a point to a sphere, and the point coincides
with the center of the sphere, grad_W is not well defined (as it
can be computed as p_GQ / <a href="#id40"><span class="problematic" id="id41">|p_GQ|</span></a>, but the denominator is 0). When
grad_W is not well defined, and we instantiate
SignedDistanceToPoint&lt;T&gt; with T being an AutoDiffScalar (like
AutoDiffXd), the gradient of the query result is not well defined
either, so the user should use the gradient in p_GN, distance and
grad_W with caution.</p>
</div>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>grad_W_in must not contain NaN.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistanceToPoint_[AutoDiffXd].distance">
<code class="descname">distance</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_[AutoDiffXd].distance" title="Permalink to this definition">¶</a></dt>
<dd><p>The signed distance from the query point Q to the nearest point N on
the surface of geometry G. It is positive if Q is outside G. It is
negative if Q is inside G. It is zero if Q is on the boundary of G.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistanceToPoint_[AutoDiffXd].grad_W">
<code class="descname">grad_W</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_[AutoDiffXd].grad_W" title="Permalink to this definition">¶</a></dt>
<dd><p>The gradient vector of the distance function with respect to the query
point Q, expressed in world frame W.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistanceToPoint_[AutoDiffXd].id_G">
<code class="descname">id_G</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_[AutoDiffXd].id_G" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the geometry G to which we measure distance from the query
point Q.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistanceToPoint_[AutoDiffXd].p_GN">
<code class="descname">p_GN</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_[AutoDiffXd].p_GN" title="Permalink to this definition">¶</a></dt>
<dd><p>The position of the nearest point N on G’s surface from the query
point Q, expressed in G’s frame.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.SignedDistanceToPoint_[float]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SignedDistanceToPoint_[float]</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>The data for reporting the signed distance from a query point to a
geometry. Reports the result of a signed distance query between a
query point Q and geometry G. This includes G’s id, the signed
distance, the nearest point N on the surface of G, and the gradient of
the signed distance with respect to the position of Q. Generally, the
gradient of the signed distance function is not defined everywhere.
The value reported in this struct depends on the query function
returning it. Refer to the query function’s documentation for what
value it will report for otherwise undefined gradient values.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type. Must be a valid Eigen scalar.</dd>
</dl>
<dl class="method">
<dt id="pydrake.geometry.SignedDistanceToPoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SignedDistanceToPoint_[float], **kwargs</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs SignedDistanceToPoint struct from calculated results.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">id_G_in</span></code>:</dt>
<dd>The id of the geometry G to which we measure distance from the
query point Q.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p_GN_in</span></code>:</dt>
<dd>The position of the nearest point N on G’s surface from the query
point Q, expressed in G’s frame.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">distance_in</span></code>:</dt>
<dd>The signed distance from the query point Q to the nearest point N
on the surface of geometry G. It is positive if Q is outside G. It
is negative if Q is inside G. It is zero if Q is on the boundary
of G.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">grad_W_in</span></code>:</dt>
<dd>The gradient vector of the distance function with respect to the
query point Q, expressed in world frame W.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">is_grad_W_unique_in</span></code>:</dt>
<dd>True if grad_W is unique, false otherwise.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">grad_W is not well defined everywhere. For example, when computing
the distance from a point to a sphere, and the point coincides
with the center of the sphere, grad_W is not well defined (as it
can be computed as p_GQ / <a href="#id42"><span class="problematic" id="id43">|p_GQ|</span></a>, but the denominator is 0). When
grad_W is not well defined, and we instantiate
SignedDistanceToPoint&lt;T&gt; with T being an AutoDiffScalar (like
AutoDiffXd), the gradient of the query result is not well defined
either, so the user should use the gradient in p_GN, distance and
grad_W with caution.</p>
</div>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>grad_W_in must not contain NaN.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistanceToPoint_[float].distance">
<code class="descname">distance</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_[float].distance" title="Permalink to this definition">¶</a></dt>
<dd><p>The signed distance from the query point Q to the nearest point N on
the surface of geometry G. It is positive if Q is outside G. It is
negative if Q is inside G. It is zero if Q is on the boundary of G.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistanceToPoint_[float].grad_W">
<code class="descname">grad_W</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_[float].grad_W" title="Permalink to this definition">¶</a></dt>
<dd><p>The gradient vector of the distance function with respect to the query
point Q, expressed in world frame W.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistanceToPoint_[float].id_G">
<code class="descname">id_G</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_[float].id_G" title="Permalink to this definition">¶</a></dt>
<dd><p>The id of the geometry G to which we measure distance from the query
point Q.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SignedDistanceToPoint_[float].p_GN">
<code class="descname">p_GN</code><a class="headerlink" href="#pydrake.geometry.SignedDistanceToPoint_[float].p_GN" title="Permalink to this definition">¶</a></dt>
<dd><p>The position of the nearest point N on G’s surface from the query
point Q, expressed in G’s frame.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.SourceId">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SourceId</code><a class="headerlink" href="#pydrake.geometry.SourceId" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify geometry sources in SceneGraph.</p>
<dl class="attribute">
<dt id="pydrake.geometry.SourceId.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.geometry.SourceId.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.geometry.SourceId.get_new_id">
<em class="property">static </em><code class="descname">get_new_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.geometry.SourceId<a class="headerlink" href="#pydrake.geometry.SourceId.get_new_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a new identifier for this id type. This new identifier will
be different from all previous identifiers created. This method does
<em>not</em> make any guarantees about the values of ids from successive
invocations. This method is guaranteed to be thread safe.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SourceId.get_value">
<code class="descname">get_value</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SourceId</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.geometry.SourceId.get_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the underlying representation from the identifier. This is
considered invalid for invalid ids and is strictly enforced in Debug
builds.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SourceId.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SourceId</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.geometry.SourceId.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the id is valid.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.Sphere">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">Sphere</code><a class="headerlink" href="#pydrake.geometry.Sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.Shape</span></code></a></p>
<p>Definition of sphere. It is centered in its canonical frame with the
given radius.</p>
<dl class="method">
<dt id="pydrake.geometry.Sphere.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Sphere</em>, <em>radius: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.Sphere.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a sphere with the given <code class="docutils literal"><span class="pre">radius</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">radius</span></code> is negative. Note that a zero radius is</li>
<li>is considered valid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.Sphere.radius">
<code class="descname">radius</code><span class="sig-paren">(</span><em>self: pydrake.geometry.Sphere</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.geometry.Sphere.radius" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SurfaceMesh">
<code class="descclassname">pydrake.geometry.</code><code class="descname">SurfaceMesh</code><a class="headerlink" href="#pydrake.geometry.SurfaceMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.geometry.SurfaceMesh_[float]" title="pydrake.geometry.SurfaceMesh_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.SurfaceMesh_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.geometry.SurfaceMesh_">
<em class="property">template </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SurfaceMesh_</code><a class="headerlink" href="#pydrake.geometry.SurfaceMesh_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.geometry.SurfaceMesh_[float]" title="pydrake.geometry.SurfaceMesh_[float]"><code class="xref py py-class docutils literal"><span class="pre">SurfaceMesh_[float]</span></code></a>, <a class="reference internal" href="#pydrake.geometry.SurfaceMesh_[AutoDiffXd]" title="pydrake.geometry.SurfaceMesh_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">SurfaceMesh_[AutoDiffXd]</span></code></a></p>
<dl class="class">
<dt id="pydrake.geometry.SurfaceMesh_.SurfaceMesh_[float]">
<em class="property">class </em><code class="descname">SurfaceMesh_[float]</code><a class="headerlink" href="#pydrake.geometry.SurfaceMesh_.SurfaceMesh_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>SurfaceMesh represents a triangulated surface.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type for coordinates, e.g., double or
AutoDiffXd. Must be a valid Eigen scalar.</dd>
</dl>
<dl class="method">
<dt id="pydrake.geometry.SurfaceMesh_.SurfaceMesh_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SurfaceMesh_[float], faces: List[drake::geometry::SurfaceFace], vertices: List[pydrake.geometry.SurfaceVertex_[float]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SurfaceMesh_.SurfaceMesh_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a SurfaceMesh from faces and vertices.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">faces</span></code>:</dt>
<dd>The triangular faces.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">vertices</span></code>:</dt>
<dd>The vertices.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SurfaceMesh_.SurfaceMesh_[float].faces">
<code class="descname">faces</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SurfaceMesh_[float]</em><span class="sig-paren">)</span> &#x2192; List[drake::geometry::SurfaceFace]<a class="headerlink" href="#pydrake.geometry.SurfaceMesh_.SurfaceMesh_[float].faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the faces.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SurfaceMesh_.SurfaceMesh_[float].vertices">
<code class="descname">vertices</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SurfaceMesh_[float]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.SurfaceVertex_[float]]<a class="headerlink" href="#pydrake.geometry.SurfaceMesh_.SurfaceMesh_[float].vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vertices.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.SurfaceMesh_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SurfaceMesh_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.geometry.SurfaceMesh_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>SurfaceMesh represents a triangulated surface.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type for coordinates, e.g., double or
AutoDiffXd. Must be a valid Eigen scalar.</dd>
</dl>
<dl class="method">
<dt id="pydrake.geometry.SurfaceMesh_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SurfaceMesh_[AutoDiffXd], faces: List[drake::geometry::SurfaceFace], vertices: List[pydrake.geometry.SurfaceVertex_[AutoDiffXd]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SurfaceMesh_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a SurfaceMesh from faces and vertices.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">faces</span></code>:</dt>
<dd>The triangular faces.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">vertices</span></code>:</dt>
<dd>The vertices.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SurfaceMesh_[AutoDiffXd].faces">
<code class="descname">faces</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SurfaceMesh_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; List[drake::geometry::SurfaceFace]<a class="headerlink" href="#pydrake.geometry.SurfaceMesh_[AutoDiffXd].faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the faces.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SurfaceMesh_[AutoDiffXd].vertices">
<code class="descname">vertices</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SurfaceMesh_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.SurfaceVertex_[AutoDiffXd]]<a class="headerlink" href="#pydrake.geometry.SurfaceMesh_[AutoDiffXd].vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vertices.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.SurfaceMesh_[float]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SurfaceMesh_[float]</code><a class="headerlink" href="#pydrake.geometry.SurfaceMesh_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>SurfaceMesh represents a triangulated surface.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type for coordinates, e.g., double or
AutoDiffXd. Must be a valid Eigen scalar.</dd>
</dl>
<dl class="method">
<dt id="pydrake.geometry.SurfaceMesh_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SurfaceMesh_[float], faces: List[drake::geometry::SurfaceFace], vertices: List[pydrake.geometry.SurfaceVertex_[float]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SurfaceMesh_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a SurfaceMesh from faces and vertices.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">faces</span></code>:</dt>
<dd>The triangular faces.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">vertices</span></code>:</dt>
<dd>The vertices.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SurfaceMesh_[float].faces">
<code class="descname">faces</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SurfaceMesh_[float]</em><span class="sig-paren">)</span> &#x2192; List[drake::geometry::SurfaceFace]<a class="headerlink" href="#pydrake.geometry.SurfaceMesh_[float].faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the faces.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SurfaceMesh_[float].vertices">
<code class="descname">vertices</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SurfaceMesh_[float]</em><span class="sig-paren">)</span> &#x2192; List[pydrake.geometry.SurfaceVertex_[float]]<a class="headerlink" href="#pydrake.geometry.SurfaceMesh_[float].vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vertices.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.geometry.SurfaceVertex">
<code class="descclassname">pydrake.geometry.</code><code class="descname">SurfaceVertex</code><a class="headerlink" href="#pydrake.geometry.SurfaceVertex" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.geometry.SurfaceVertex_[float]" title="pydrake.geometry.SurfaceVertex_[float]"><code class="xref py py-class docutils literal"><span class="pre">pydrake.geometry.SurfaceVertex_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.geometry.SurfaceVertex_">
<em class="property">template </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SurfaceVertex_</code><a class="headerlink" href="#pydrake.geometry.SurfaceVertex_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.geometry.SurfaceVertex_[float]" title="pydrake.geometry.SurfaceVertex_[float]"><code class="xref py py-class docutils literal"><span class="pre">SurfaceVertex_[float]</span></code></a>, <a class="reference internal" href="#pydrake.geometry.SurfaceVertex_[AutoDiffXd]" title="pydrake.geometry.SurfaceVertex_[AutoDiffXd]"><code class="xref py py-class docutils literal"><span class="pre">SurfaceVertex_[AutoDiffXd]</span></code></a></p>
<dl class="class">
<dt id="pydrake.geometry.SurfaceVertex_.SurfaceVertex_[float]">
<em class="property">class </em><code class="descname">SurfaceVertex_[float]</code><a class="headerlink" href="#pydrake.geometry.SurfaceVertex_.SurfaceVertex_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>SurfaceVertex represents a vertex in SurfaceMesh.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type for coordinates, e.g., double or
AutoDiffXd. Must be a valid Eigen scalar.</dd>
</dl>
<dl class="method">
<dt id="pydrake.geometry.SurfaceVertex_.SurfaceVertex_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SurfaceVertex_[float], r_MV: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SurfaceVertex_.SurfaceVertex_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs SurfaceVertex.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">r_MV</span></code>:</dt>
<dd>displacement vector from the origin of M’s frame to this vertex,
expressed in M’s frame.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SurfaceVertex_.SurfaceVertex_[float].r_MV">
<code class="descname">r_MV</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SurfaceVertex_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.geometry.SurfaceVertex_.SurfaceVertex_[float].r_MV" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the displacement vector from the origin of M’s frame to this
vertex, expressed in M’s frame.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.SurfaceVertex_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SurfaceVertex_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.geometry.SurfaceVertex_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>SurfaceVertex represents a vertex in SurfaceMesh.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type for coordinates, e.g., double or
AutoDiffXd. Must be a valid Eigen scalar.</dd>
</dl>
<dl class="method">
<dt id="pydrake.geometry.SurfaceVertex_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SurfaceVertex_[AutoDiffXd], r_MV: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SurfaceVertex_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs SurfaceVertex.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">r_MV</span></code>:</dt>
<dd>displacement vector from the origin of M’s frame to this vertex,
expressed in M’s frame.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SurfaceVertex_[AutoDiffXd].r_MV">
<code class="descname">r_MV</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SurfaceVertex_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.geometry.SurfaceVertex_[AutoDiffXd].r_MV" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the displacement vector from the origin of M’s frame to this
vertex, expressed in M’s frame.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.geometry.SurfaceVertex_[float]">
<em class="property">class </em><code class="descclassname">pydrake.geometry.</code><code class="descname">SurfaceVertex_[float]</code><a class="headerlink" href="#pydrake.geometry.SurfaceVertex_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>SurfaceVertex represents a vertex in SurfaceMesh.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type for coordinates, e.g., double or
AutoDiffXd. Must be a valid Eigen scalar.</dd>
</dl>
<dl class="method">
<dt id="pydrake.geometry.SurfaceVertex_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SurfaceVertex_[float], r_MV: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.geometry.SurfaceVertex_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs SurfaceVertex.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">r_MV</span></code>:</dt>
<dd>displacement vector from the origin of M’s frame to this vertex,
expressed in M’s frame.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.geometry.SurfaceVertex_[float].r_MV">
<code class="descname">r_MV</code><span class="sig-paren">(</span><em>self: pydrake.geometry.SurfaceVertex_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.geometry.SurfaceVertex_[float].r_MV" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the displacement vector from the origin of M’s frame to this
vertex, expressed in M’s frame.</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pydrake.geometry.all.html" class="btn btn-neutral float-right" title="pydrake.geometry.all" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pydrake.forwarddiff.html" class="btn btn-neutral" title="pydrake.forwarddiff" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
<footer class="footer">
   <div class="wrap grid">
      <a href="/" class="footer__logo">
      <img src="_static/drake-logo.svg" class="footer__logo__img">
      </a>
      <div class="menu__wrap">
         <ul class="menu__list">
            <li class="menu__list__item menu__list__item__link button--text">
               <a href="https://drake.mit.edu/doxygen_cxx/index.html" class="menu__list__item__link button--text">C++</a>
            </li>
            <li class="menu__list__item menu__list__item__link button--text">
               <a href="https://drake.mit.edu/pydrake/index.html" class="menu__list__item__link button--text">Python</a>
            </li>
            <li class="menu__list__item menu__list__item__link button--text github--link">
               <a href="https://github.com/RobotLocomotion/drake" class="menu__list__item__link button--text">
               Github <img src="_static/github.svg">
               </a>
            </li>
         </ul>
      </div>
   </div>
   <div class="footer__copyright wrap">
      <span class="footnote">© 2020 The Drake Development Team</span>
   </div>
</footer>


</body>
</html>