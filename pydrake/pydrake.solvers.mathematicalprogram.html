

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydrake.solvers.mathematicalprogram &mdash; pydrake  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="pydrake  documentation" href="index.html"/>
        <link rel="up" title="pydrake.solvers" href="pydrake.solvers.html"/>
        <link rel="next" title="pydrake.solvers.mixed_integer_optimization_util" href="pydrake.solvers.mixed_integer_optimization_util.html"/>
        <link rel="prev" title="pydrake.solvers.ipopt" href="pydrake.solvers.ipopt.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> pydrake
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.all.html">pydrake.solvers.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.branch_and_bound.html">pydrake.solvers.branch_and_bound</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.csdp.html">pydrake.solvers.csdp</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.gurobi.html">pydrake.solvers.gurobi</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.ipopt.html">pydrake.solvers.ipopt</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.solvers.mathematicalprogram</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.mixed_integer_optimization_util.html">pydrake.solvers.mixed_integer_optimization_util</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.mosek.html">pydrake.solvers.mosek</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.osqp.html">pydrake.solvers.osqp</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.sdpa_free_format.html">pydrake.solvers.sdpa_free_format</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.snopt.html">pydrake.solvers.snopt</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="pydrake.solvers.html">pydrake.solvers</a> &raquo;</li>
        
      <li>pydrake.solvers.mathematicalprogram</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pydrake-solvers-mathematicalprogram">
<h1>pydrake.solvers.mathematicalprogram<a class="headerlink" href="#pydrake-solvers-mathematicalprogram" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-pydrake.solvers.mathematicalprogram"></span><p>Bindings for MathematicalProgram</p>
<p>If you are formulating constraints using symbolic formulas, please review the
top-level documentation for <a class="reference internal" href="pydrake.math.html#module-pydrake.math" title="pydrake.math"><code class="xref py py-mod docutils literal"><span class="pre">pydrake.math</span></code></a>.</p>
<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.Binding_BoundingBoxConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Binding_BoundingBoxConstraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_BoundingBoxConstraint" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.Binding_BoundingBoxConstraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_BoundingBoxConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_BoundingBoxConstraint.evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_BoundingBoxConstraint</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.BoundingBoxConstraint<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_BoundingBoxConstraint.evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_BoundingBoxConstraint.variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_BoundingBoxConstraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_BoundingBoxConstraint.variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.Binding_Constraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Binding_Constraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_Constraint" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.Binding_Constraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_Constraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_Constraint.evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_Constraint</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.Constraint<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_Constraint.evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_Constraint.variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_Constraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_Constraint.variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.Binding_Cost">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Binding_Cost</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_Cost" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.Binding_Cost.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_Cost.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_Cost.evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_Cost</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.Cost<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_Cost.evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_Cost.variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_Cost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_Cost.variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.Binding_EvaluatorBase">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Binding_EvaluatorBase</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_EvaluatorBase" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_EvaluatorBase.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_EvaluatorBase</em>, <em>arg0: object</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_EvaluatorBase.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_EvaluatorBase.evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_EvaluatorBase</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.EvaluatorBase<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_EvaluatorBase.evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_EvaluatorBase.variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_EvaluatorBase</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_EvaluatorBase.variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.Binding_ExponentialConeConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Binding_ExponentialConeConstraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_ExponentialConeConstraint" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.Binding_ExponentialConeConstraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_ExponentialConeConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_ExponentialConeConstraint.evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_ExponentialConeConstraint</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.ExponentialConeConstraint<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_ExponentialConeConstraint.evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_ExponentialConeConstraint.variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_ExponentialConeConstraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_ExponentialConeConstraint.variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearComplementarityConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Binding_LinearComplementarityConstraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearComplementarityConstraint" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearComplementarityConstraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearComplementarityConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearComplementarityConstraint.evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_LinearComplementarityConstraint</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.LinearComplementarityConstraint<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearComplementarityConstraint.evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearComplementarityConstraint.variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_LinearComplementarityConstraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearComplementarityConstraint.variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Binding_LinearConstraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearConstraint" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearConstraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearConstraint.evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_LinearConstraint</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.LinearConstraint<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearConstraint.evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearConstraint.variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_LinearConstraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearConstraint.variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearCost">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Binding_LinearCost</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearCost" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearCost.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearCost.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearCost.evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_LinearCost</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.LinearCost<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearCost.evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearCost.variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_LinearCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearCost.variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearEqualityConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Binding_LinearEqualityConstraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearEqualityConstraint" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearEqualityConstraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearEqualityConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearEqualityConstraint.evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_LinearEqualityConstraint</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.LinearEqualityConstraint<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearEqualityConstraint.evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LinearEqualityConstraint.variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_LinearEqualityConstraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LinearEqualityConstraint.variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LorentzConeConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Binding_LorentzConeConstraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LorentzConeConstraint" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LorentzConeConstraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LorentzConeConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LorentzConeConstraint.evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_LorentzConeConstraint</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.LorentzConeConstraint<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LorentzConeConstraint.evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_LorentzConeConstraint.variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_LorentzConeConstraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_LorentzConeConstraint.variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.Binding_PositiveSemidefiniteConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Binding_PositiveSemidefiniteConstraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_PositiveSemidefiniteConstraint" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.Binding_PositiveSemidefiniteConstraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_PositiveSemidefiniteConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_PositiveSemidefiniteConstraint.evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_PositiveSemidefiniteConstraint</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.PositiveSemidefiniteConstraint<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_PositiveSemidefiniteConstraint.evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_PositiveSemidefiniteConstraint.variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_PositiveSemidefiniteConstraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_PositiveSemidefiniteConstraint.variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.Binding_QuadraticCost">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Binding_QuadraticCost</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_QuadraticCost" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.Binding_QuadraticCost.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_QuadraticCost.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_QuadraticCost.evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_QuadraticCost</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.QuadraticCost<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_QuadraticCost.evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_QuadraticCost.variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_QuadraticCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_QuadraticCost.variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.Binding_VisualizationCallback">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Binding_VisualizationCallback</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_VisualizationCallback" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.Binding_VisualizationCallback.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_VisualizationCallback.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_VisualizationCallback.evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_VisualizationCallback</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.VisualizationCallback<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_VisualizationCallback.evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Binding_VisualizationCallback.variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Binding_VisualizationCallback</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Binding_VisualizationCallback.variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.BoundingBoxConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">BoundingBoxConstraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.BoundingBoxConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.mathematicalprogram.LinearConstraint" title="pydrake.solvers.mathematicalprogram.LinearConstraint"><code class="xref py py-class docutils literal"><span class="pre">pydrake.solvers.mathematicalprogram.LinearConstraint</span></code></a></p>
<p>Implements a constraint of the form <span class="math">\(lb &lt;= x &lt;= ub\)</span></p>
<p>Note: the base Constraint class (as implemented at the moment) could
play this role. But this class enforces that it is ONLY a bounding box
constraint, and not something more general. Some solvers use this
information to handle bounding box constraints differently than
general constraints, so use of this form is encouraged.</p>
<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.BoundingBoxConstraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.BoundingBoxConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.solvers.mathematicalprogram.ChooseBestSolver">
<code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">ChooseBestSolver</code><span class="sig-paren">(</span><em>prog: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.SolverId<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.ChooseBestSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose the best solver given the formulation in the optimization
program and the availability of the solvers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">invalid_argument if there is no available solver for <code class="docutils literal"><span class="pre">prog</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.Constraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Constraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.mathematicalprogram.EvaluatorBase" title="pydrake.solvers.mathematicalprogram.EvaluatorBase"><code class="xref py py-class docutils literal"><span class="pre">pydrake.solvers.mathematicalprogram.EvaluatorBase</span></code></a></p>
<p>A constraint is a function + lower and upper bounds.</p>
<p>Solver interfaces must acknowledge that these constraints are mutable.
Parameters can change after the constraint is constructed and before
the call to Solve().</p>
<p>It should support evaluating the constraint, and adding it to an
optimization problem.</p>
<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.Constraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Constraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Constraint.CheckSatisfied">
<code class="descname">CheckSatisfied</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Constraint.CheckSatisfied" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>CheckSatisfied(self: pydrake.solvers.mathematicalprogram.Constraint, x: numpy.ndarray[numpy.float64[m, 1]], tol: float = 1e-06) -&gt; bool</li>
</ol>
<p>Return whether this constraint is satisfied by the given value, <code class="docutils literal"><span class="pre">x</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">x</span></code>:</dt>
<dd>A <code class="docutils literal"><span class="pre">num_vars</span></code> x 1 vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">tol</span></code>:</dt>
<dd>A tolerance for bound checking.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>CheckSatisfied(self: pydrake.solvers.mathematicalprogram.Constraint, x: numpy.ndarray[object[m, 1]], tol: float = 1e-06) -&gt; bool</li>
</ol>
<p>Return whether this constraint is satisfied by the given value, <code class="docutils literal"><span class="pre">x</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">x</span></code>:</dt>
<dd>A <code class="docutils literal"><span class="pre">num_vars</span></code> x 1 vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">tol</span></code>:</dt>
<dd>A tolerance for bound checking.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>CheckSatisfied(self: pydrake.solvers.mathematicalprogram.Constraint, x: numpy.ndarray[object[m, 1]]) -&gt; pydrake.symbolic.Formula</li>
</ol>
<p>Return whether this constraint is satisfied by the given value, <code class="docutils literal"><span class="pre">x</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">x</span></code>:</dt>
<dd>A <code class="docutils literal"><span class="pre">num_vars</span></code> x 1 vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">tol</span></code>:</dt>
<dd>A tolerance for bound checking.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Constraint.lower_bound">
<code class="descname">lower_bound</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Constraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Constraint.lower_bound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Constraint.num_constraints">
<code class="descname">num_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Constraint</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Constraint.num_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of rows in the output constraint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.Constraint.upper_bound">
<code class="descname">upper_bound</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.Constraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Constraint.upper_bound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.Cost">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Cost</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.mathematicalprogram.EvaluatorBase" title="pydrake.solvers.mathematicalprogram.EvaluatorBase"><code class="xref py py-class docutils literal"><span class="pre">pydrake.solvers.mathematicalprogram.EvaluatorBase</span></code></a></p>
<p>Provides an abstract base for all costs.</p>
<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.Cost.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Cost.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.EvaluatorBase">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">EvaluatorBase</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.EvaluatorBase" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.EvaluatorBase.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.EvaluatorBase.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.EvaluatorBase.Eval">
<code class="descname">Eval</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.EvaluatorBase.Eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Eval(self: pydrake.solvers.mathematicalprogram.EvaluatorBase, x: numpy.ndarray[numpy.float64[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Evaluates the expression.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">x</span></code>:</dt>
<dd>A <code class="docutils literal"><span class="pre">num_vars</span></code> x 1 input vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">y</span></code>:</dt>
<dd>A <code class="docutils literal"><span class="pre">num_outputs</span></code> x 1 output vector.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>Eval(self: pydrake.solvers.mathematicalprogram.EvaluatorBase, x: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Evaluates the expression.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">x</span></code>:</dt>
<dd>A <code class="docutils literal"><span class="pre">num_vars</span></code> x 1 input vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">y</span></code>:</dt>
<dd>A <code class="docutils literal"><span class="pre">num_outputs</span></code> x 1 output vector.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>Eval(self: pydrake.solvers.mathematicalprogram.EvaluatorBase, x: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Evaluates the expression.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">x</span></code>:</dt>
<dd>A <code class="docutils literal"><span class="pre">num_vars</span></code> x 1 input vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">y</span></code>:</dt>
<dd>A <code class="docutils literal"><span class="pre">num_outputs</span></code> x 1 output vector.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.EvaluatorBase.get_description">
<code class="descname">get_description</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.EvaluatorBase</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.EvaluatorBase.get_description" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for a human-friendly description for the evaluator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.EvaluatorBase.gradient_sparsity_pattern">
<code class="descname">gradient_sparsity_pattern</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.EvaluatorBase</em><span class="sig-paren">)</span> &#x2192; Optional[List[Tuple[int, int]]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.EvaluatorBase.gradient_sparsity_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vector of (row_index, col_index) that contains all the
entries in the gradient of Eval function (∂y/∂x) whose value could be
non-zero, namely if ∂yᵢ/∂xⱼ could be non-zero, then the pair (i, j) is
in gradient_sparsity_pattern.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal"><span class="pre">gradient_sparsity_pattern</span></code>:</dt>
<dd>If nullopt, then we regard all entries of the gradient as
potentially non-zero.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.EvaluatorBase.num_outputs">
<code class="descname">num_outputs</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.EvaluatorBase</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.EvaluatorBase.num_outputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for the number of outputs, namely the number of rows in y, as
used in Eval(x, y).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.EvaluatorBase.num_vars">
<code class="descname">num_vars</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.EvaluatorBase</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.EvaluatorBase.num_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for the number of variables, namely the number of rows in x, as
used in Eval(x, y).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.EvaluatorBase.set_description">
<code class="descname">set_description</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.EvaluatorBase</em>, <em>arg0: str</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.EvaluatorBase.set_description" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a human-friendly description for the evaluator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.EvaluatorBase.SetGradientSparsityPattern">
<code class="descname">SetGradientSparsityPattern</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.EvaluatorBase, gradient_sparsity_pattern: List[Tuple[int, int]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.EvaluatorBase.SetGradientSparsityPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the sparsity pattern of the gradient matrix ∂y/∂x (the gradient of
y value in Eval, w.r.t x in Eval) . gradient_sparsity_pattern contains
<em>all</em> the pairs of (row_index, col_index) for which the corresponding
entries could have non-zero value in the gradient matrix ∂y/∂x.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.ExponentialConeConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">ExponentialConeConstraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.ExponentialConeConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.mathematicalprogram.Constraint" title="pydrake.solvers.mathematicalprogram.Constraint"><code class="xref py py-class docutils literal"><span class="pre">pydrake.solvers.mathematicalprogram.Constraint</span></code></a></p>
<p>An exponential cone constraint is a special type of convex cone
constraint. We constrain A * x + b to be in the exponential cone,
where A has 3 rows, and b is in ℝ³, x is the decision variable. A
vector z in ℝ³ is in the exponential cone, if {z₀, z₁, z₂ | z₀ ≥ z₁ *
exp(z₂ / z₁), z₁ &gt; 0}. Equivalently, this constraint can be
refomulated with logarithm function {z₀, z₁, z₂ | z₂ ≤ z₁ * log(z₀ /
z₁), z₀ &gt; 0, z₁ &gt; 0}</p>
<p>The Eval function implemented in this class is z₀ - z₁ * exp(z₂ / z₁)
&gt;= 0, z₁ &gt; 0 where z = A * x + b. It is not recommended to solve an
exponential cone constraint through generic nonlinear optimization. It
is possible that the nonlinear solver can accidentally set z₁ = 0,
where the constraint is not well defined. Instead, the user should
consider to solve the program through conic solvers that can exploit
exponential cone, such as Mosek and SCS.</p>
<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.ExponentialConeConstraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.ExponentialConeConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.LinearComplementarityConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">LinearComplementarityConstraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearComplementarityConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.mathematicalprogram.Constraint" title="pydrake.solvers.mathematicalprogram.Constraint"><code class="xref py py-class docutils literal"><span class="pre">pydrake.solvers.mathematicalprogram.Constraint</span></code></a></p>
<p>Implements a constraint of the form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Mx</span> <span class="o">+</span> <span class="n">q</span> <span class="o">&gt;=</span> <span class="mi">0</span>
  <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span>
  <span class="n">x</span><span class="s1">&#39;(Mx + q) == 0</span>
</pre></div>
</div>
<p>An implied slack variable complements any 0 component of x. To get the
slack values at a given solution x, use Eval(x).</p>
<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.LinearComplementarityConstraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearComplementarityConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.LinearConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">LinearConstraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.mathematicalprogram.Constraint" title="pydrake.solvers.mathematicalprogram.Constraint"><code class="xref py py-class docutils literal"><span class="pre">pydrake.solvers.mathematicalprogram.Constraint</span></code></a></p>
<p>Implements a constraint of the form <span class="math">\(lb &lt;= Ax &lt;= ub\)</span></p>
<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.LinearConstraint.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.LinearConstraint, A: numpy.ndarray[numpy.float64[m, n]], lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.LinearConstraint.A">
<code class="descname">A</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.LinearConstraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearConstraint.A" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.LinearConstraint.set_bounds">
<code class="descname">set_bounds</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.LinearConstraint, new_lb: numpy.ndarray[numpy.float64[m, 1]], new_ub: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearConstraint.set_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the upper and lower bounds of the constraint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">lower_bound</span></code>:</dt>
<dd>. A <code class="docutils literal"><span class="pre">num_constraints</span></code> x 1 vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">upper_bound</span></code>:</dt>
<dd>. A <code class="docutils literal"><span class="pre">num_constraints</span></code> x 1 vector.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the users want to expose this method in a sub-class, do using
Constraint::set_bounds, as in LinearConstraint.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.LinearConstraint.UpdateCoefficients">
<code class="descname">UpdateCoefficients</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.LinearConstraint, new_A: numpy.ndarray[numpy.float64[m, n]], new_lb: numpy.ndarray[numpy.float64[m, 1]], new_ub: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearConstraint.UpdateCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the linear term, upper and lower bounds in the linear
constraint. The updated constraint is: new_lb &lt;= new_A * x &lt;= new_ub
Note that the size of constraints (number of rows) can change, but the
number of variables (number of cols) cannot.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">new_A</span></code>:</dt>
<dd>new linear term</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">new_lb</span></code>:</dt>
<dd>new lower bound</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">new_up</span></code>:</dt>
<dd>new upper bound</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.LinearConstraint.UpdateLowerBound">
<code class="descname">UpdateLowerBound</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.LinearConstraint, new_lb: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearConstraint.UpdateLowerBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the lower bound.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if the users want to expose this method in a sub-class, do using
Constraint::UpdateLowerBound, as in LinearConstraint.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.LinearConstraint.UpdateUpperBound">
<code class="descname">UpdateUpperBound</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.LinearConstraint, new_ub: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearConstraint.UpdateUpperBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the upper bound.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if the users want to expose this method in a sub-class, do using
Constraint::UpdateUpperBound, as in LinearConstraint.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.LinearCost">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">LinearCost</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.mathematicalprogram.Cost" title="pydrake.solvers.mathematicalprogram.Cost"><code class="xref py py-class docutils literal"><span class="pre">pydrake.solvers.mathematicalprogram.Cost</span></code></a></p>
<p>Implements a cost of the form</p>
<div class="math">
\[a'x + b\]</div>
<p>.</p>
<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.LinearCost.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.LinearCost, a: numpy.ndarray[numpy.float64[m, 1]], b: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearCost.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a linear cost of the form</p>
<div class="math">
\[a'x + b\]</div>
<p>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">a</span></code>:</dt>
<dd>Linear term.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">b</span></code>:</dt>
<dd>(optional) Constant term.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.LinearCost.a">
<code class="descname">a</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.LinearCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearCost.a" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.LinearCost.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.LinearCost</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearCost.b" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.LinearCost.UpdateCoefficients">
<code class="descname">UpdateCoefficients</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.LinearCost, new_a: numpy.ndarray[numpy.float64[m, 1]], new_b: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearCost.UpdateCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the linear term, upper and lower bounds in the linear
constraint. The updated constraint is</p>
<div class="math">
\[a_new' x + b_new\]</div>
<p>. Note that the number of variables (number of cols) cannot change.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">new_a</span></code>:</dt>
<dd>New linear term.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">new_b</span></code>:</dt>
<dd>(optional) New constant term.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.LinearEqualityConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">LinearEqualityConstraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearEqualityConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.mathematicalprogram.LinearConstraint" title="pydrake.solvers.mathematicalprogram.LinearConstraint"><code class="xref py py-class docutils literal"><span class="pre">pydrake.solvers.mathematicalprogram.LinearConstraint</span></code></a></p>
<p>Implements a constraint of the form <span class="math">\(Ax = b\)</span></p>
<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.LinearEqualityConstraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearEqualityConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.LinearEqualityConstraint.UpdateCoefficients">
<code class="descname">UpdateCoefficients</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.LinearEqualityConstraint, Aeq: numpy.ndarray[numpy.float64[m, n]], beq: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LinearEqualityConstraint.UpdateCoefficients" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.LorentzConeConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">LorentzConeConstraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LorentzConeConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.mathematicalprogram.Constraint" title="pydrake.solvers.mathematicalprogram.Constraint"><code class="xref py py-class docutils literal"><span class="pre">pydrake.solvers.mathematicalprogram.Constraint</span></code></a></p>
<p>Constraining the linear expression <span class="math">\(z=Ax+b\)</span> lies within the
Lorentz cone. A vector z ∈ ℝ ⁿ lies within Lorentz cone if</p>
<div class="math">
\[z_0 \ge \sqrt{z_1^2+...+z_{n-1}^2}\]</div>
<p>where A ∈ ℝ ⁿˣᵐ, b ∈ ℝ ⁿ are given matrices. Ideally this constraint
should be handled by a second-order cone solver. In case the user
wants to enforce this constraint through general nonlinear
optimization, we provide three different formulations on the Lorentz
cone constraint 1. g(z) = z₀ - sqrt(z₁² + … + zₙ₋₁²) ≥ 0 This
formulation is not differentiable at z₁=…=zₙ₋₁=0 2. g(z) = z₀ -
sqrt(z₁² + … + zₙ₋₁²) ≥ 0 but the gradient of g(z) is approximated
as ∂g(z)/∂z = [1, -z₁/sqrt(z₁² + … zₙ₋₁² + ε), …,
-zₙ₋₁/sqrt(z₁²+…+zₙ₋₁²+ε)] where ε is a small positive number. 3.
z₀²-(z₁²+…+zₙ₋₁²) ≥ 0 z₀ ≥ 0 This constraint is differentiable
everywhere, but z₀²-(z₁²+…+zₙ₋₁²) ≥ 0 is non-convex. The default is
to use the first formulation. For more information and visualization,
please refer to
<a class="reference external" href="https://inst.eecs.berkeley.edu/~ee127a/book/login/l_socp_soc.html">https://inst.eecs.berkeley.edu/~ee127a/book/login/l_socp_soc.html</a></p>
<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.LorentzConeConstraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LorentzConeConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.LorentzConeConstraint.A">
<code class="descname">A</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.LorentzConeConstraint</em><span class="sig-paren">)</span> &#x2192; scipy.sparse.csc_matrix[numpy.float64]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.LorentzConeConstraint.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for A.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.solvers.mathematicalprogram.MakeSolver">
<code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">MakeSolver</code><span class="sig-paren">(</span><em>id: pydrake.solvers.mathematicalprogram.SolverId</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.SolverInterface<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MakeSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the solver ID, create the solver with the matching ID.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">invalid_argument if there is no matching solver.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">MathematicalProgram</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram" title="Permalink to this definition">¶</a></dt>
<dd><p>MathematicalProgram stores the decision variables, the constraints and
costs of an optimization problem. The user can solve the problem by
calling solvers::Solve() function, and obtain the results of the
optimization.</p>
<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddBoundingBoxConstraint">
<code class="descname">AddBoundingBoxConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddBoundingBoxConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddBoundingBoxConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: numpy.ndarray[numpy.float64[m, 1]], arg1: numpy.ndarray[numpy.float64[m, 1]], arg2: numpy.ndarray[object[m, 1]]) -&gt; drake::solvers::Binding&lt;drake::solvers::BoundingBoxConstraint&gt;</li>
</ol>
<p>Adds bounding box constraints referencing potentially a subset of the
decision variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">lb</span></code>:</dt>
<dd>The lower bound.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">ub</span></code>:</dt>
<dd>The upper bound.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">vars</span></code>:</dt>
<dd>Will imposes constraint lb(i) &lt;= vars(i) &lt;= ub(i).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The newly constructed BoundingBoxConstraint.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>AddBoundingBoxConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: float, arg1: float, arg2: pydrake.symbolic.Variable) -&gt; drake::solvers::Binding&lt;drake::solvers::BoundingBoxConstraint&gt;</li>
</ol>
<p>Adds bounds for a single variable.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">lb</span></code>:</dt>
<dd>Lower bound.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">ub</span></code>:</dt>
<dd>Upper bound.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">var</span></code>:</dt>
<dd>The decision variable.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>AddBoundingBoxConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: float, arg1: float, arg2: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; drake::solvers::Binding&lt;drake::solvers::BoundingBoxConstraint&gt;</li>
</ol>
<p>Adds the same scalar lower and upper bound to every variable in
<code class="docutils literal"><span class="pre">vars</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">Derived</span></code>:</dt>
<dd>An Eigen::Matrix with Variable as the scalar type. The matrix has
unknown number of columns at compile time, or has more than one
column.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">lb</span></code>:</dt>
<dd>Lower bound.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">ub</span></code>:</dt>
<dd>Upper bound.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">vars</span></code>:</dt>
<dd>The decision variables.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddConstraint">
<code class="descname">AddConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, func: function, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]], description: str = ‘’) -&gt; drake::solvers::Binding&lt;drake::solvers::Constraint&gt;</li>
</ol>
<p>Adds a constraint using a Python function.</p>
<ol class="arabic simple" start="2">
<li>AddConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: pydrake.symbolic.Expression, arg1: float, arg2: float) -&gt; drake::solvers::Binding&lt;drake::solvers::Constraint&gt;</li>
</ol>
<p>Adds one row of constraint lb &lt;= e &lt;= ub where <code class="docutils literal"><span class="pre">e</span></code> is a symbolic
expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if 1. <code class="docutils literal"><span class="pre">lb</span> <span class="pre">&lt;=</span> <span class="pre">e</span> <span class="pre">&lt;=</span> <span class="pre">ub</span></code> is a trivial constraint such</li>
<li>as 1 &lt;= 2 &lt;= 3. 2. <code class="docutils literal"><span class="pre">lb</span> <span class="pre">&lt;=</span> <span class="pre">e</span> <span class="pre">&lt;=</span> <span class="pre">ub</span></code> is unsatisfiable such as 1 &lt;=</li>
<li>-5 &lt;= 3</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">e</span></code>:</dt>
<dd>A symbolic expression of the the decision variables.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">lb</span></code>:</dt>
<dd>A scalar, the lower bound.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">ub</span></code>:</dt>
<dd>A scalar, the upper bound.</dd>
</dl>
<p>The resulting constraint may be a BoundingBoxConstraint,
LinearConstraint, LinearEqualityConstraint, or ExpressionConstraint,
depending on the arguments. Constraints of the form x == 1 (which
could be created as a BoundingBoxConstraint or
LinearEqualityConstraint) will be constructed as a
LinearEqualityConstraint.</p>
<ol class="arabic simple" start="3">
<li>AddConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: pydrake.symbolic.Formula) -&gt; drake::solvers::Binding&lt;drake::solvers::Constraint&gt;</li>
</ol>
<p>Add a constraint represented by a symbolic formula to the program. The
input formula <code class="docutils literal"><span class="pre">f</span></code> can be of the following forms:</p>
<ol class="arabic simple">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
<li>A conjunction of relational formulas where each conjunct is
a relational formula matched by 1, 2, or 3.</li>
</ol>
<p>Note that first two cases might return an object of
Binding&lt;BoundingBoxConstraint&gt;, Binding&lt;LinearConstraint&gt;, or
Binding&lt;ExpressionConstraint&gt;, depending on <code class="docutils literal"><span class="pre">f</span></code>. Also the third case
might return an object of Binding&lt;LinearEqualityConstraint&gt; or
Binding&lt;ExpressionConstraint&gt;.</p>
<p>It throws an exception if 1. <code class="docutils literal"><span class="pre">f</span></code> is not matched with one of the
above patterns. Especially, strict inequalities (&lt;, &gt;) are not
allowed. 2. <code class="docutils literal"><span class="pre">f</span></code> is either a trivial constraint such as “1 &lt;= 2” or
an unsatisfiable constraint such as “2 &lt;= 1”. 3. It is not possible to
find numerical bounds of <code class="docutils literal"><span class="pre">e1</span></code> and <code class="docutils literal"><span class="pre">e2</span></code> where <code class="docutils literal"><span class="pre">f</span></code> = e1 ≃ e2. We
allow <code class="docutils literal"><span class="pre">e1</span></code> and <code class="docutils literal"><span class="pre">e2</span></code> to be infinite but only if there are no other
terms. For example, <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">∞</span></code> is allowed. However, <code class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">∞</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code> is
not allowed because <code class="docutils literal"><span class="pre">x</span> <span class="pre">↦</span> <span class="pre">∞</span></code> introduces <code class="docutils literal"><span class="pre">nan</span></code> in the evaluation.</p>
<ol class="arabic simple" start="4">
<li>AddConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, constraint: drake::solvers::Constraint, vars: numpy.ndarray[object[m, 1]]) -&gt; drake::solvers::Binding&lt;drake::solvers::Constraint&gt;</li>
</ol>
<p>Adds a generic constraint to the program. This should only be used if
a more specific type of constraint is not available, as it may require
the use of a significantly more expensive solver.</p>
<ol class="arabic simple" start="5">
<li>AddConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, formulas: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; drake::solvers::Binding&lt;drake::solvers::Constraint&gt;</li>
</ol>
<p>Add a constraint represented by an Eigen::Matrix&lt;symbolic::Formula&gt; to
the program.</p>
<p>A formula in <code class="docutils literal"><span class="pre">formulas</span></code> can be of the following forms:</p>
<ol class="arabic simple">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
</ol>
<p>It throws an exception if AddConstraint(const symbolic::Formula&amp; f)
throws an exception for any f ∈ formulas.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">Derived</span></code>:</dt>
<dd>An Eigen Matrix type of Formula.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddCost">
<code class="descname">AddCost</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddCost(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, func: function, vars: numpy.ndarray[object[m, 1]], description: str = ‘’) -&gt; drake::solvers::Binding&lt;drake::solvers::Cost&gt;</li>
</ol>
<p>Adds a cost function</p>
<ol class="arabic simple" start="2">
<li>AddCost(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: pydrake.symbolic.Expression) -&gt; drake::solvers::Binding&lt;drake::solvers::Cost&gt;</li>
</ol>
<p>Adds a cost expression</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddDecisionVariables">
<code class="descname">AddDecisionVariables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram, decision_variables: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddDecisionVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends new variables to the end of the existing variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">decision_variables</span></code>:</dt>
<dd>The newly added decision_variables.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">decision_variables</span></code> should not intersect with the existing
variables or indeterminates in the optimization program.</dd>
<dt>Precondition:</dt>
<dd>Each entry in <code class="docutils literal"><span class="pre">decision_variables</span></code> should not be a dummy
variable.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the preconditions are not satisfied.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddEqualityConstraintBetweenPolynomials">
<code class="descname">AddEqualityConstraintBetweenPolynomials</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em>, <em>p1: pydrake.symbolic.Polynomial</em>, <em>p2: pydrake.symbolic.Polynomial</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddEqualityConstraintBetweenPolynomials" title="Permalink to this definition">¶</a></dt>
<dd><p>Constraining that two polynomials are the same (i.e., they have the
same coefficients for each monomial). This function is often used in
sum-of-squares optimization. We will impose the linear equality
constraint that the coefficient of a monomial in <code class="docutils literal"><span class="pre">p1</span></code> is the same as
the coefficient of the same monomial in <code class="docutils literal"><span class="pre">p2</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p1</span></code>:</dt>
<dd>Note that p1’s indeterminates should have been registered as
indeterminates in this MathematicalProgram object, and p1’s
coefficients are affine functions of decision variables in this
MathematicalProgram object.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">p2</span></code>:</dt>
<dd>Note that p2’s indeterminates should have been registered as
indeterminates in this MathematicalProgram object, and p2’s
coefficients are affine functions of decision variables in this
MathematicalProgram object.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It calls <code class="docutils literal"><span class="pre">Reparse</span></code> to enforce <code class="docutils literal"><span class="pre">p1</span></code> and <code class="docutils literal"><span class="pre">p2</span></code> to have this
MathematicalProgram’s indeterminates.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddExponentialConeConstraint">
<code class="descname">AddExponentialConeConstraint</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; drake::solvers::Binding&lt;drake::solvers::ExponentialConeConstraint&gt;<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddExponentialConeConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the constraint that z is in the exponential cone.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">z</span></code>:</dt>
<dd>The expression in the exponential cone.</dd>
<dt>Precondition:</dt>
<dd>each entry in <code class="docutils literal"><span class="pre">z</span></code> is a linear expression of the decision
variables.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddIndeterminates">
<code class="descname">AddIndeterminates</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram, new_indeterminates: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddIndeterminates" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds indeterminates. This method appends some indeterminates to the
end of the program’s old indeterminates.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">new_indeterminates</span></code>:</dt>
<dd>The indeterminates to be appended to the program’s old
indeterminates.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">new_indeterminates</span></code> should not intersect with the program’s old
indeterminates or decision variables.</dd>
<dt>Precondition:</dt>
<dd>Each entry in new_indeterminates should not be dummy.</dd>
<dt>Precondition:</dt>
<dd>Each entry in new_indeterminates should be of CONTINUOUS type.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddL2NormCost">
<code class="descname">AddL2NormCost</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; drake::solvers::Binding&lt;drake::solvers::QuadraticCost&gt;<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddL2NormCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a cost term of the form | Ax - b <a href="#id1"><span class="problematic" id="id2">|</span></a>^2.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddLinearComplementarityConstraint">
<code class="descname">AddLinearComplementarityConstraint</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], arg1: numpy.ndarray[numpy.float64[m, 1]], arg2: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; drake::solvers::Binding&lt;drake::solvers::LinearComplementarityConstraint&gt;<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddLinearComplementarityConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a linear complementarity constraints referencing a subset of the
decision variables.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddLinearConstraint">
<code class="descname">AddLinearConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddLinearConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddLinearConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; drake::solvers::Binding&lt;drake::solvers::LinearConstraint&gt;</li>
</ol>
<p>Adds linear constraints referencing potentially a subset of the
decision variables (defined in the vars parameter).</p>
<ol class="arabic simple" start="2">
<li>AddLinearConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, e: pydrake.symbolic.Expression, lb: float, ub: float) -&gt; drake::solvers::Binding&lt;drake::solvers::LinearConstraint&gt;</li>
</ol>
<p>Adds one row of linear constraint lb &lt;= e &lt;= ub where <code class="docutils literal"><span class="pre">e</span></code> is a
symbolic expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if 1. <code class="docutils literal"><span class="pre">e</span></code> is a non-linear expression. 2. <a href="#id3"><span class="problematic" id="id4">``</span></a>lb &lt;= e</li>
<li>&lt;= ub`` is a trivial constraint such as 1 &lt;= 2 &lt;= 3. 3. <a href="#id5"><span class="problematic" id="id6">``</span></a>lb &lt;= e</li>
<li>&lt;= ub`` is unsatisfiable such as 1 &lt;= -5 &lt;= 3</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">e</span></code>:</dt>
<dd>A linear symbolic expression in the form of <code class="docutils literal"><span class="pre">c0</span> <span class="pre">+</span> <span class="pre">c1</span> <span class="pre">*</span> <span class="pre">v1</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span>
<span class="pre">cn</span> <span class="pre">*</span> <span class="pre">vn</span></code> where <code class="docutils literal"><span class="pre">c_i</span></code> is a constant and &#64;v_i is a variable.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">lb</span></code>:</dt>
<dd>A scalar, the lower bound.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">ub</span></code>:</dt>
<dd>A scalar, the upper bound.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>AddLinearConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, v: numpy.ndarray[object[m, 1]], lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -&gt; drake::solvers::Binding&lt;drake::solvers::LinearConstraint&gt;</li>
</ol>
<p>Adds linear constraints represented by symbolic expressions to the
program. It throws if &#64;v includes a non-linear expression or <code class="docutils literal"><span class="pre">lb</span> <span class="pre">&lt;=</span> <span class="pre">v</span>
<span class="pre">&lt;=</span> <span class="pre">ub</span></code> includes trivial/unsatisfiable constraints.</p>
<ol class="arabic simple" start="4">
<li>AddLinearConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, f: pydrake.symbolic.Formula) -&gt; drake::solvers::Binding&lt;drake::solvers::LinearConstraint&gt;</li>
</ol>
<p>Add a linear constraint represented by a symbolic formula to the
program. The input formula <code class="docutils literal"><span class="pre">f</span></code> can be of the following forms:</p>
<ol class="arabic simple">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
<li>A conjunction of relational formulas where each conjunct is
a relational formula matched by 1, 2, or 3.</li>
</ol>
<p>Note that first two cases might return an object of
Binding&lt;BoundingBoxConstraint&gt; depending on <code class="docutils literal"><span class="pre">f</span></code>. Also the third case
returns an object of Binding&lt;LinearEqualityConstraint&gt;.</p>
<p>It throws an exception if 1. <code class="docutils literal"><span class="pre">f</span></code> is not matched with one of the
above patterns. Especially, strict inequalities (&lt;, &gt;) are not
allowed. 2. <code class="docutils literal"><span class="pre">f</span></code> includes a non-linear expression. 3. <code class="docutils literal"><span class="pre">f</span></code> is either
a trivial constraint such as “1 &lt;= 2” or an unsatisfiable constraint
such as “2 &lt;= 1”. 4. It is not possible to find numerical bounds of
<code class="docutils literal"><span class="pre">e1</span></code> and <code class="docutils literal"><span class="pre">e2</span></code> where <code class="docutils literal"><span class="pre">f</span></code> = e1 ≃ e2. We allow <code class="docutils literal"><span class="pre">e1</span></code> and <code class="docutils literal"><span class="pre">e2</span></code> to
be infinite but only if there are no other terms. For example, <code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;=</span>
<span class="pre">∞</span></code> is allowed. However, <code class="docutils literal"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">∞</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code> is not allowed because <code class="docutils literal"><span class="pre">x</span> <span class="pre">↦</span>
<span class="pre">∞</span></code> introduces <code class="docutils literal"><span class="pre">nan</span></code> in the evaluation.</p>
<ol class="arabic simple" start="5">
<li>AddLinearConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, formulas: numpy.ndarray[object[m, 1]]) -&gt; drake::solvers::Binding&lt;drake::solvers::LinearConstraint&gt;</li>
</ol>
<p>Add a linear constraint represented by an
Eigen::Array&lt;symbolic::Formula&gt; to the program. A common use-case of
this function is to add a linear constraint with the element-wise
comparison between two Eigen matrices, using <code class="docutils literal"><span class="pre">A.array()</span> <span class="pre">&lt;=</span>
<span class="pre">B.array()</span></code>. See the following example.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MathematicalProgram</span> <span class="n">prog</span><span class="p">;</span>
  <span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">;</span>
  <span class="n">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">NewContinuousVariables</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">);</span>
  <span class="n">Eigen</span><span class="p">::</span><span class="n">Vector2d</span> <span class="n">b</span><span class="p">;</span>
  <span class="o">...</span> <span class="o">//</span> <span class="nb">set</span> <span class="n">up</span> <span class="n">A</span> <span class="ow">and</span> <span class="n">b</span>
  <span class="n">prog</span><span class="o">.</span><span class="n">AddLinearConstraint</span><span class="p">((</span><span class="n">A</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">());</span>
</pre></div>
</div>
<p>A formula in <code class="docutils literal"><span class="pre">formulas</span></code> can be of the following forms:</p>
<ol class="arabic simple">
<li>e1 &lt;= e2 2. e1 &gt;= e2 3. e1 == e2</li>
</ol>
<p>It throws an exception if AddLinearConstraint(const symbolic::Formula&amp;
f) throws an exception for f ∈ <code class="docutils literal"><span class="pre">formulas</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">Derived</span></code>:</dt>
<dd>An Eigen Array type of Formula.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddLinearCost">
<code class="descname">AddLinearCost</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddLinearCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddLinearCost(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: pydrake.symbolic.Expression) -&gt; drake::solvers::Binding&lt;drake::solvers::LinearCost&gt;</li>
</ol>
<p>Adds a linear cost term of the form a’<a href="#id7"><span class="problematic" id="id8">*</span></a>x + b.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">e</span></code>:</dt>
<dd>A linear symbolic expression.</dd>
<dt>Precondition:</dt>
<dd>e is a linear expression a’<a href="#id9"><span class="problematic" id="id10">*</span></a>x + b, where each entry of x is a
decision variable in the mathematical program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The newly added linear constraint, together with the bound
variables.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>AddLinearCost(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, a: numpy.ndarray[numpy.float64[m, 1]], b: float, vars: numpy.ndarray[object[m, 1]]) -&gt; drake::solvers::Binding&lt;drake::solvers::LinearCost&gt;</li>
</ol>
<p>Adds a linear cost term of the form a’<a href="#id11"><span class="problematic" id="id12">*</span></a>x + b. Applied to a subset of
the variables and pushes onto the linear cost data structure.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddLinearEqualityConstraint">
<code class="descname">AddLinearEqualityConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddLinearEqualityConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddLinearEqualityConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, Aeq: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], beq: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; drake::solvers::Binding&lt;drake::solvers::LinearEqualityConstraint&gt;</li>
</ol>
<p>AddLinearEqualityConstraint</p>
<p>Adds linear equality constraints referencing potentially a subset of
the decision variables.</p>
<p>Example: to add two equality constraints which only depend on two of
the elements of x, you could use</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">NewContinuousVariables</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="s2">&quot;myvar&quot;</span><span class="p">);</span>
  <span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix2d</span> <span class="n">Aeq</span><span class="p">;</span>
  <span class="n">Aeq</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
          <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">Eigen</span><span class="p">::</span><span class="n">Vector2d</span> <span class="n">beq</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="o">//</span> <span class="n">Imposes</span> <span class="n">constraint</span>
  <span class="o">//</span> <span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="o">//</span>  <span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>  <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="n">prog</span><span class="o">.</span><span class="n">AddLinearEqualityConstraint</span><span class="p">(</span><span class="n">Aeq</span><span class="p">,</span> <span class="n">beq</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">head</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>AddLinearEqualityConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, e: pydrake.symbolic.Expression, b: float) -&gt; drake::solvers::Binding&lt;drake::solvers::LinearEqualityConstraint&gt;</li>
</ol>
<p>Adds one row of linear constraint e = b where <code class="docutils literal"><span class="pre">e</span></code> is a symbolic
expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if 1. <code class="docutils literal"><span class="pre">e</span></code> is a non-linear expression. 2. <code class="docutils literal"><span class="pre">e</span></code> is a</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">constant.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">e</span></code>:</dt>
<dd>A linear symbolic expression in the form of <code class="docutils literal"><span class="pre">c0</span> <span class="pre">+</span> <span class="pre">c1</span> <span class="pre">*</span> <span class="pre">x1</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span>
<span class="pre">cn</span> <span class="pre">*</span> <span class="pre">xn</span></code> where <code class="docutils literal"><span class="pre">c_i</span></code> is a constant and &#64;x_i is a variable.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">b</span></code>:</dt>
<dd>A scalar.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The newly added linear equality constraint, together with the
bound variable.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>AddLinearEqualityConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, f: pydrake.symbolic.Formula) -&gt; drake::solvers::Binding&lt;drake::solvers::LinearEqualityConstraint&gt;</li>
</ol>
<p>Adds a linear equality constraint represented by a symbolic formula to
the program. The input formula <code class="docutils literal"><span class="pre">f</span></code> is either an equality formula
(<code class="docutils literal"><span class="pre">e1</span> <span class="pre">==</span> <span class="pre">e2</span></code>) or a conjunction of equality formulas.</p>
<p>It throws an exception if</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">f</span></code> is neither an equality formula nor a conjunction of equalities.</li>
<li><code class="docutils literal"><span class="pre">f</span></code> includes a non-linear expression.</li>
</ol>
<ol class="arabic simple" start="4">
<li>AddLinearEqualityConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, v: numpy.ndarray[object[m, 1]], b: numpy.ndarray[numpy.float64[m, 1]]) -&gt; drake::solvers::Binding&lt;drake::solvers::LinearEqualityConstraint&gt;</li>
</ol>
<p>Adds linear equality constraints <span class="math">\(v = b\)</span>, where <code class="docutils literal"><span class="pre">v(i)</span></code> is a
symbolic linear expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if 1. <code class="docutils literal"><span class="pre">v(i)</span></code> is a non-linear expression. 2.</li>
<li><code class="docutils literal"><span class="pre">v(i)</span></code> is a constant.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">DerivedV</span></code>:</dt>
<dd>An Eigen Matrix type of Expression. A column vector.</dd>
<dt>Template parameter <code class="docutils literal"><span class="pre">DerivedB</span></code>:</dt>
<dd>An Eigen Matrix type of double. A column vector.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">v</span></code>:</dt>
<dd>v(i) is a linear symbolic expression in the form of `` c0 + c1 *
x1 + … + cn * xn `` where ci is a constant and &#64;xi is a
variable.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">b</span></code>:</dt>
<dd>A vector of doubles.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The newly added linear equality constraint, together with the
bound variables.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddLorentzConeConstraint">
<code class="descname">AddLorentzConeConstraint</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; drake::solvers::Binding&lt;drake::solvers::LorentzConeConstraint&gt;<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddLorentzConeConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds Lorentz cone constraint referencing potentially a subset of the
decision variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">v</span></code>:</dt>
<dd>An Eigen::Vector of symbolic::Expression. Constraining that</dd>
</dl>
<div class="math">
\[v_0 \ge \sqrt{v_1^2 + ... + v_{n-1}^2}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The newly constructed Lorentz cone constraint with the bounded
variables.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddMaximizeGeometricMeanCost">
<code class="descname">AddMaximizeGeometricMeanCost</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddMaximizeGeometricMeanCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddMaximizeGeometricMeanCost(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], x: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>An overloaded version of maximize_geometric_mean.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>A.rows() == b.rows(), A.rows() &gt;= 2.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>AddMaximizeGeometricMeanCost(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, x: numpy.ndarray[object[m, 1]], c: float) -&gt; None</li>
</ol>
<p>An overloaded version of maximize_geometric_mean. We add the cost to
maximize the geometric mean of x, i.e., c*power(∏ᵢx(i), 1/n).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">c</span></code>:</dt>
<dd>The positive coefficient of the geometric mean cost, $*Default:*
is 1.</dd>
<dt>Precondition:</dt>
<dd>x.rows() &gt;= 2.</dd>
<dt>Precondition:</dt>
<dd>c &gt; 0.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddMaximizeLogDeterminantSymmetricMatrixCost">
<code class="descname">AddMaximizeLogDeterminantSymmetricMatrixCost</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram, X: numpy.ndarray[object[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddMaximizeLogDeterminantSymmetricMatrixCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the cost to maximize the log determinant of symmetric matrix X.
log(det(X)) is a concave function of X, so we can maximize it through
convex optimization. In order to do that, we introduce slack variables
t, and a lower triangular matrix Z, with the constraints ⌈X Z⌉ is
positive semidifinite. ⌊Zᵀ diag(Z)⌋ log(Z(i, i)) &gt;= t(i) and we will
minimize -∑ᵢt(i).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">X</span></code>:</dt>
<dd>A symmetric positive semidefinite matrix X, whose log(det(X)) will
be maximized.</dd>
<dt>Precondition:</dt>
<dd>X is a symmetric matrix.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The constraint log(Z(i, i)) &gt;= t(i) is imposed as an exponential
cone constraint. Please make sure your have a solver that supports
exponential cone constraint (currently SCS does).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddPositiveSemidefiniteConstraint">
<code class="descname">AddPositiveSemidefiniteConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddPositiveSemidefiniteConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddPositiveSemidefiniteConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; drake::solvers::Binding&lt;drake::solvers::PositiveSemidefiniteConstraint&gt;</li>
</ol>
<p>Adds a positive semidefinite constraint on a symmetric matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in Debug mode if <code class="docutils literal"><span class="pre">symmetric_matrix_var</span></code> is not</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">symmetric.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">symmetric_matrix_var</span></code>:</dt>
<dd>A symmetric MatrixDecisionVariable object.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>AddPositiveSemidefiniteConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; drake::solvers::Binding&lt;drake::solvers::PositiveSemidefiniteConstraint&gt;</li>
</ol>
<p>Adds a positive semidefinite constraint on a symmetric matrix of
symbolic expressions <code class="docutils literal"><span class="pre">e</span></code>. We create a new symmetric matrix of
variables M being positive semidefinite, with the linear equality
constraint e == M.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">Derived</span></code>:</dt>
<dd>An Eigen Matrix of symbolic expressions.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">e</span></code>:</dt>
<dd>Imposes constraint “e is positive semidefinite”.</dd>
<dt>Precondition:</dt>
<dd>{1. e is symmetric. 2. e(i, j) is linear for all i, j }</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The newly added positive semidefinite constraint, with the bound
variable M that are also newly added.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddQuadraticCost">
<code class="descname">AddQuadraticCost</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddQuadraticCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddQuadraticCost(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; drake::solvers::Binding&lt;drake::solvers::QuadraticCost&gt;</li>
</ol>
<p>Adds a cost term of the form 0.5*x’<a href="#id13"><span class="problematic" id="id14">*</span></a>Q*x + b’x Applied to subset of the
variables.</p>
<ol class="arabic simple" start="2">
<li>AddQuadraticCost(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], c: float, vars: numpy.ndarray[object[m, 1]]) -&gt; drake::solvers::Binding&lt;drake::solvers::QuadraticCost&gt;</li>
</ol>
<p>Adds a cost term of the form 0.5*x’<a href="#id15"><span class="problematic" id="id16">*</span></a>Q*x + b’x + c Applied to subset of
the variables.</p>
<ol class="arabic simple" start="3">
<li>AddQuadraticCost(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, e: pydrake.symbolic.Expression) -&gt; drake::solvers::Binding&lt;drake::solvers::QuadraticCost&gt;</li>
</ol>
<p>Add a quadratic cost term of the form 0.5*x’<a href="#id17"><span class="problematic" id="id18">*</span></a>Q*x + b’<a href="#id19"><span class="problematic" id="id20">*</span></a>x + c. Notice
that in the optimization program, the constant term <code class="docutils literal"><span class="pre">c</span></code> in the cost
is ignored.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">e</span></code>:</dt>
<dd>A quadratic symbolic expression.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">std::runtime error if the expression is not quadratic.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The newly added cost together with the bound variables.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddQuadraticErrorCost">
<code class="descname">AddQuadraticErrorCost</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram, Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], x_desired: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; drake::solvers::Binding&lt;drake::solvers::QuadraticCost&gt;<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddQuadraticErrorCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a cost term of the form (x-x_desired)’<a href="#id21"><span class="problematic" id="id22">*</span></a>Q*(x-x_desired).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddSosConstraint">
<code class="descname">AddSosConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddSosConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddSosConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: pydrake.symbolic.Polynomial, arg1: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
<p>Adds constraints that a given polynomial <code class="docutils literal"><span class="pre">p</span></code> is a sums-of-squares
(SOS), that is, <code class="docutils literal"><span class="pre">p</span></code> can be decomposed into <code class="docutils literal"><span class="pre">mᵀQm</span></code>, where m is the
<code class="docutils literal"><span class="pre">monomial_basis</span></code>. It returns the coefficients matrix Q, which is
positive semidefinite.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It calls <code class="docutils literal"><span class="pre">Reparse</span></code> to enforce <code class="docutils literal"><span class="pre">p</span></code> to have this
MathematicalProgram’s indeterminates if necessary.</p>
</div>
<ol class="arabic simple" start="2">
<li>AddSosConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: pydrake.symbolic.Polynomial) -&gt; Tuple[numpy.ndarray[object[m, n]], numpy.ndarray[object[m, 1]]]</li>
</ol>
<p>Adds constraints that a given polynomial <code class="docutils literal"><span class="pre">p</span></code> is a sums-of-squares
(SOS), that is, <code class="docutils literal"><span class="pre">p</span></code> can be decomposed into <code class="docutils literal"><span class="pre">mᵀQm</span></code>, where m is a
monomial basis selected from the sparsity of <code class="docutils literal"><span class="pre">p</span></code>. It returns a pair
of constraint bindings expressing:</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It calls <code class="docutils literal"><span class="pre">Reparse</span></code> to enforce <code class="docutils literal"><span class="pre">p</span></code> to have this
MathematicalProgram’s indeterminates if necessary.</p>
</div>
<ul class="simple">
<li>The coefficients matrix Q, which is positive semidefinite. - The</li>
</ul>
<p>monomial basis m.</p>
<ol class="arabic simple" start="3">
<li>AddSosConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: pydrake.symbolic.Expression, arg1: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
<p>Adds constraints that a given symbolic expression <code class="docutils literal"><span class="pre">e</span></code> is a
sums-of-squares (SOS), that is, <code class="docutils literal"><span class="pre">p</span></code> can be decomposed into <code class="docutils literal"><span class="pre">mᵀQm</span></code>,
where m is the <code class="docutils literal"><span class="pre">monomial_basis</span></code>. Note that it decomposes <code class="docutils literal"><span class="pre">e</span></code> into
a polynomial with respect to <code class="docutils literal"><span class="pre">indeterminates()</span></code> in this mathematical
program. It returns the coefficients matrix Q, which is positive
semidefinite.</p>
<ol class="arabic simple" start="4">
<li>AddSosConstraint(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: pydrake.symbolic.Expression) -&gt; Tuple[numpy.ndarray[object[m, n]], numpy.ndarray[object[m, 1]]]</li>
</ol>
<p>Adds constraints that a given symbolic expression <code class="docutils literal"><span class="pre">e</span></code> is a
sums-of-squares (SOS), that is, <code class="docutils literal"><span class="pre">e</span></code> can be decomposed into <code class="docutils literal"><span class="pre">mᵀQm</span></code>.
Note that it decomposes <code class="docutils literal"><span class="pre">e</span></code> into a polynomial with respect to
<code class="docutils literal"><span class="pre">indeterminates()</span></code> in this mathematical program. It returns a pair
expressing:</p>
<ul class="simple">
<li>The coefficients matrix Q, which is positive semidefinite. - The</li>
</ul>
<p>monomial basis m.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.AddVisualizationCallback">
<code class="descname">AddVisualizationCallback</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: Callable[[numpy.ndarray[numpy.float64[m, 1]]], None], arg1: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; drake::solvers::Binding&lt;drake::solvers::VisualizationCallback&gt;<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.AddVisualizationCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a callback method to visualize intermediate results of the
optimization.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just like other costs/constraints, not all solvers support
callbacks. Adding a callback here will force
MathematicalProgram::Solve to select a solver that support
callbacks. For instance, adding a visualization callback to a
quadratic programming problem may result in using a nonlinear
programming solver as the default solver.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">callback</span></code>:</dt>
<dd>a std::function that accepts an Eigen::Vector of doubles
representing the bound decision variables.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">vars</span></code>:</dt>
<dd>the decision variables that should be passed to the callback.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.bounding_box_constraints">
<code class="descname">bounding_box_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[drake::solvers::Binding&lt;drake::solvers::BoundingBoxConstraint&gt;]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.bounding_box_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for all bounding box constraints</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.decision_variable_index">
<code class="descname">decision_variable_index</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; Dict[int, int]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.decision_variable_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mapping from a decision variable ID to its index in the
vector containing all the decision variables in the mathematical
program.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.decision_variables">
<code class="descname">decision_variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.decision_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for all decision variables in the program.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.EvalBinding">
<code class="descname">EvalBinding</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.EvalBinding" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>EvalBinding(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, binding: drake::solvers::Binding&lt;drake::solvers::EvaluatorBase&gt;, prog_var_vals: numpy.ndarray[numpy.float64[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Evaluates the value of some binding, for some input value for all
decision variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">binding</span></code>:</dt>
<dd>A Binding whose variables are decision variables in this program.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">prog_var_vals</span></code>:</dt>
<dd>The value of all the decision variables in this program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the size of <code class="docutils literal"><span class="pre">prog_var_vals</span></code> is invalid.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>EvalBinding(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, binding: drake::solvers::Binding&lt;drake::solvers::EvaluatorBase&gt;, prog_var_vals: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Evaluates the value of some binding, for some input value for all
decision variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">binding</span></code>:</dt>
<dd>A Binding whose variables are decision variables in this program.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">prog_var_vals</span></code>:</dt>
<dd>The value of all the decision variables in this program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the size of <code class="docutils literal"><span class="pre">prog_var_vals</span></code> is invalid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.EvalBindings">
<code class="descname">EvalBindings</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.EvalBindings" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>EvalBindings(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, bindings: List[drake::solvers::Binding&lt;drake::solvers::EvaluatorBase&gt;], prog_var_vals: numpy.ndarray[numpy.float64[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Evaluates a set of bindings (plural version of <code class="docutils literal"><span class="pre">EvalBinding</span></code>).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">bindings</span></code>:</dt>
<dd>List of bindings.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">prog</span></code>:</dt>
<dd>$Parameter <code class="docutils literal"><span class="pre">prog_var_vals</span></code>:</dd>
</dl>
<p>The value of all the decision variables in this program.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">All binding values, concatenated into a single vector.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the size of <code class="docutils literal"><span class="pre">prog_var_vals</span></code> is invalid.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>EvalBindings(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, bindings: List[drake::solvers::Binding&lt;drake::solvers::EvaluatorBase&gt;], prog_var_vals: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Evaluates a set of bindings (plural version of <code class="docutils literal"><span class="pre">EvalBinding</span></code>).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">bindings</span></code>:</dt>
<dd>List of bindings.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">prog</span></code>:</dt>
<dd>$Parameter <code class="docutils literal"><span class="pre">prog_var_vals</span></code>:</dd>
</dl>
<p>The value of all the decision variables in this program.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">All binding values, concatenated into a single vector.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the size of <code class="docutils literal"><span class="pre">prog_var_vals</span></code> is invalid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.FindDecisionVariableIndex">
<code class="descname">FindDecisionVariableIndex</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em>, <em>var: pydrake.symbolic.Variable</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.FindDecisionVariableIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the decision variable. Internally the solvers
thinks all variables are stored in an array, and it accesses each
individual variable using its index. This index is used when adding
constraints and costs for each solver.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>{<code class="docutils literal"><span class="pre">var</span></code> is a decision variable in the mathematical program,
otherwise this function throws a runtime error.}</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.FindDecisionVariableIndices">
<code class="descname">FindDecisionVariableIndices</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram, vars: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; List[int]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.FindDecisionVariableIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices of the decision variables. Internally the solvers
thinks all variables are stored in an array, and it accesses each
individual variable using its index. This index is used when adding
constraints and costs for each solver.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>{<code class="docutils literal"><span class="pre">vars</span></code> are decision variables in the mathematical program,
otherwise this function throws a runtime error.}</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.generic_constraints">
<code class="descname">generic_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[drake::solvers::Binding&lt;drake::solvers::Constraint&gt;]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.generic_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for all generic constraints</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.generic_costs">
<code class="descname">generic_costs</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[drake::solvers::Binding&lt;drake::solvers::Cost&gt;]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.generic_costs" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for all generic costs.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.GetAllConstraints">
<code class="descname">GetAllConstraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[drake::solvers::Binding&lt;drake::solvers::Constraint&gt;]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.GetAllConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for returning all constraints.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Vector of all constraint bindings.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The group ordering may change as more constraint types are added.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.GetAllCosts">
<code class="descname">GetAllCosts</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[drake::solvers::Binding&lt;drake::solvers::Cost&gt;]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.GetAllCosts" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter returning all costs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Vector of all cost bindings.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The group ordering may change as more cost types are added.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.GetBindingVariableValues">
<code class="descname">GetBindingVariableValues</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram, binding: drake::solvers::Binding&lt;drake::solvers::EvaluatorBase&gt;, prog_var_vals: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.GetBindingVariableValues" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the value of all decision variables, namely
this.decision_variable(i) takes the value prog_var_vals(i), returns
the vector that contains the value of the variables in
binding.variables().</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">binding</span></code>:</dt>
<dd>binding.variables() must be decision variables in this
MathematicalProgram.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">prog_var_vals</span></code>:</dt>
<dd>The value of ALL the decision variables in this program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">binding_variable_vals binding_variable_vals(i) is the value of
binding.variables()(i) in prog_var_vals.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.GetInitialGuess">
<code class="descname">GetInitialGuess</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.GetInitialGuess" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetInitialGuess(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: pydrake.symbolic.Variable) -&gt; float</li>
</ol>
<p>Gets the initial guess for a single variable.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">decision_variable</span></code> has been registered in the optimization
program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the pre condition is not satisfied.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetInitialGuess(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Gets the initial guess for some variables.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Each variable in <code class="docutils literal"><span class="pre">decision_variable_mat</span></code> has been registered in
the optimization program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the pre condition is not satisfied.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>GetInitialGuess(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[numpy.float64[m, n]]</li>
</ol>
<p>Gets the initial guess for some variables.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Each variable in <code class="docutils literal"><span class="pre">decision_variable_mat</span></code> has been registered in
the optimization program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the pre condition is not satisfied.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.GetLinearConstraints">
<code class="descname">GetLinearConstraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[drake::solvers::Binding&lt;drake::solvers::LinearConstraint&gt;]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.GetLinearConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter returning all linear constraints (both linear equality and
inequality constraints).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Vector of all linear constraint bindings.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.GetSolverOptions">
<code class="descname">GetSolverOptions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.GetSolverOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetSolverOptions(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: pydrake.solvers.mathematicalprogram.SolverId) -&gt; dict</li>
<li>GetSolverOptions(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: pydrake.solvers.mathematicalprogram.SolverType) -&gt; dict</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.indeterminate">
<code class="descname">indeterminate</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em>, <em>i: int</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Variable<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.indeterminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for the indeterminate with index <code class="docutils literal"><span class="pre">i</span></code> in the program.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.indeterminates">
<code class="descname">indeterminates</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.indeterminates" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for all indeterminates in the program.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.indeterminates_index">
<code class="descname">indeterminates_index</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; Dict[int, int]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.indeterminates_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mapping from an indeterminate ID to its index in the
vector containing all the indeterminates in the mathematical program.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.linear_constraints">
<code class="descname">linear_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[drake::solvers::Binding&lt;drake::solvers::LinearConstraint&gt;]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.linear_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for linear constraints.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.linear_costs">
<code class="descname">linear_costs</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[drake::solvers::Binding&lt;drake::solvers::LinearCost&gt;]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.linear_costs" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for linear costs.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.linear_equality_constraints">
<code class="descname">linear_equality_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[drake::solvers::Binding&lt;drake::solvers::LinearEqualityConstraint&gt;]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.linear_equality_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for linear equality constraints.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.MakePolynomial">
<code class="descname">MakePolynomial</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em>, <em>e: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Polynomial<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.MakePolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a symbolic polynomial from the given expression <code class="docutils literal"><span class="pre">e</span></code>. It uses
this MathematicalProgram’s <code class="docutils literal"><span class="pre">indeterminates()</span></code> in constructing the
polynomial.</p>
<p>This method helps a user create a polynomial with the right set of
indeterminates which are declared in this MathematicalProgram. We
recommend users to use this method over an explicit call to Polynomial
constructors to avoid a possible mismatch between this
MathematicalProgram’s indeterminates and the user-specified
indeterminates (or unspecified, which then includes all symbolic
variables in the expression <code class="docutils literal"><span class="pre">e</span></code>). Consider the following example.</p>
<p>e = ax + bx + c</p>
<p>MP.indeterminates() = {x} MP.decision_variables() = {a, b}</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">MP.MakePolynomial(e)</span></code> create a polynomial, <code class="docutils literal"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)x</span> <span class="pre">+</span> <span class="pre">c</span></code>.  Here only
<code class="docutils literal"><span class="pre">x</span></code> is an indeterminate of this polynomial.</li>
<li>In contrast, <code class="docutils literal"><span class="pre">symbolic::Polynomial(e)</span></code> returns <code class="docutils literal"><span class="pre">ax</span> <span class="pre">+</span> <span class="pre">bx</span> <span class="pre">+</span> <span class="pre">c</span></code> where all
variables <code class="docutils literal"><span class="pre">{a,</span> <span class="pre">b,</span> <span class="pre">x}</span></code> are indeterminates. Note that this is problematic
as its indeterminates, <code class="docutils literal"><span class="pre">{a,</span> <span class="pre">b,</span> <span class="pre">x}</span></code> and the MathematicalProgram’s decision
variables, <code class="docutils literal"><span class="pre">{a,</span> <span class="pre">b}</span></code> overlap.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function does not require that the decision variables in
<code class="docutils literal"><span class="pre">e</span></code> is a subset of the decision variables in
MathematicalProgram.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.NewBinaryVariables">
<code class="descname">NewBinaryVariables</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.NewBinaryVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>NewBinaryVariables(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, rows: int, name: str = ‘b’) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Adds binary variables to this MathematicalProgram. The new variables
are viewed as a column vector, with size <code class="docutils literal"><span class="pre">rows</span></code> x 1.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">NewBinaryVariables(int rows, int cols, const
std::vector&lt;std::string&gt;&amp; names);</p>
</div>
<ol class="arabic simple" start="2">
<li>NewBinaryVariables(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, rows: int, cols: int, name: str = ‘b’) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
<p>Adds binary variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">Rows</span></code>:</dt>
<dd>The number of rows in the new variables.</dd>
<dt>Template parameter <code class="docutils literal"><span class="pre">Cols</span></code>:</dt>
<dd>The number of columns in the new variables.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">rows</span></code>:</dt>
<dd>The number of rows in the new variables.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">cols</span></code>:</dt>
<dd>The number of columns in the new variables.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The commonly shared name of the new variables.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The MatrixDecisionVariable of size rows x cols, containing the new
vars (not all the vars stored).</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MathematicalProgram</span> <span class="n">prog</span><span class="p">;</span>
<span class="n">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">NewBinaryVariables</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This adds a 2 x 3 matrix decision variables into the program.</p>
<p>The name of the variable is only used for the user in order to ease
readability.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.NewContinuousVariables">
<code class="descname">NewContinuousVariables</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.NewContinuousVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>NewContinuousVariables(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, rows: int, name: str = ‘x’) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Adds continuous variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rows</span></code>:</dt>
<dd>The number of rows in the new variables.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The name of the newly added variables</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The VectorDecisionVariable of size rows x 1, containing the new
vars (not all the vars stored).</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MathematicalProgram</span> <span class="n">prog</span><span class="p">;</span>
<span class="n">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">NewContinuousVariables</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This adds a 2 x 1 vector containing decision variables into the
program. The names of the variables are “x(0)” and “x(1)”.</p>
<p>The name of the variable is only used for the user in order to ease
readability.</p>
<ol class="arabic simple" start="2">
<li>NewContinuousVariables(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, rows: int, cols: int, name: str = ‘x’) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
<p>Adds continuous variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">Rows</span></code>:</dt>
<dd>The number of rows of the new variables, in the compile time.</dd>
<dt>Template parameter <code class="docutils literal"><span class="pre">Cols</span></code>:</dt>
<dd>The number of columns of the new variables, in the compile time.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">rows</span></code>:</dt>
<dd>The number of rows in the new variables. When Rows is not
Eigen::Dynamic, rows is ignored.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">cols</span></code>:</dt>
<dd>The number of columns in the new variables. When Cols is not
Eigen::Dynamic, cols is ignored.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>All variables will share the same name, but different index.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The MatrixDecisionVariable of size Rows x Cols, containing the new
vars (not all the vars stored).</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MathematicalProgram</span> <span class="n">prog</span><span class="p">;</span>
<span class="n">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">NewContinuousVariables</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">);</span>
<span class="n">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">NewContinuousVariables</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This adds a 2 x 3 matrix decision variables into the program.</p>
<p>The name of the variable is only used for the user in order to ease
readability.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.NewEvenDegreeDsosPolynomial">
<code class="descname">NewEvenDegreeDsosPolynomial</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em>, <em>indeterminates: pydrake.symbolic.Variables</em>, <em>degree: int</em><span class="sig-paren">)</span> &#x2192; Tuple[pydrake.symbolic.Polynomial, numpy.ndarray[object[m, n]], numpy.ndarray[object[m, n]]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.NewEvenDegreeDsosPolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>see even_degree_nonnegative_polynomial for details. Variant that
produces a DSOS polynomial. Same as NewEvenDegreeSosPolynomial, except
the returned polynomial is diagonally dominant sum of squares (dsos).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.NewEvenDegreeFreePolynomial">
<code class="descname">NewEvenDegreeFreePolynomial</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em>, <em>indeterminates: pydrake.symbolic.Variables</em>, <em>degree: int</em>, <em>coeff_name: str = 'a'</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Polynomial<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.NewEvenDegreeFreePolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a free polynomial that only contains even degree monomials. A
monomial is even degree if its total degree (sum of all variables’
degree) is even. For example, xy is an even degree monomial (degree 2)
while x²y is not (degree 3).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">indeterminates</span></code>:</dt>
<dd>The monomial basis is over these indeterminates.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">degree</span></code>:</dt>
<dd>The highest degree of the polynomial.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">coeff_name</span></code>:</dt>
<dd>The coefficients of the polynomial are decision variables with
this name as a base. The variable name would be “a1”, “a2”, etc.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.NewEvenDegreeSdsosPolynomial">
<code class="descname">NewEvenDegreeSdsosPolynomial</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em>, <em>indeterminates: pydrake.symbolic.Variables</em>, <em>degree: int</em><span class="sig-paren">)</span> &#x2192; Tuple[pydrake.symbolic.Polynomial, numpy.ndarray[object[m, n]], numpy.ndarray[object[m, n]]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.NewEvenDegreeSdsosPolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>see even_degree_nonnegative_polynomial for details. Variant that
produces an SDSOS polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.NewEvenDegreeSosPolynomial">
<code class="descname">NewEvenDegreeSosPolynomial</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em>, <em>indeterminates: pydrake.symbolic.Variables</em>, <em>degree: int</em><span class="sig-paren">)</span> &#x2192; Tuple[pydrake.symbolic.Polynomial, numpy.ndarray[object[m, n]], numpy.ndarray[object[m, n]]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.NewEvenDegreeSosPolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>See even_degree_nonnegative_polynomial for more details. Variant that
produces a SOS polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.NewFreePolynomial">
<code class="descname">NewFreePolynomial</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em>, <em>indeterminates: pydrake.symbolic.Variables</em>, <em>deg: int</em>, <em>coeff_name: str = 'a'</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Polynomial<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.NewFreePolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a free polynomial in a monomial basis over <code class="docutils literal"><span class="pre">indeterminates</span></code>
of a given <code class="docutils literal"><span class="pre">degree</span></code>. It uses <code class="docutils literal"><span class="pre">coeff_name</span></code> to make new decision
variables and use them as coefficients. For example,
<code class="docutils literal"><span class="pre">NewFreePolynomial({x₀,</span> <span class="pre">x₁},</span> <span class="pre">2)</span></code> returns a₀x₁² + a₁x₀x₁ + a₂x₀² +
a₃x₁ + a₄x₀ + a₅.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.NewIndeterminates">
<code class="descname">NewIndeterminates</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.NewIndeterminates" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>NewIndeterminates(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, rows: int, name: str = ‘x’) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Adds indeterminates to this MathematicalProgram, with default name
“x”.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">NewIndeterminates(int rows, int cols, const
std::vector&lt;std::string&gt;&amp; names);</p>
</div>
<ol class="arabic simple" start="2">
<li>NewIndeterminates(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, rows: int, cols: int, name: str = ‘X’) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
<p>Adds indeterminates to this MathematicalProgram, with default name
“X”. The new variables are returned and viewed as a matrix, with size
<code class="docutils literal"><span class="pre">rows</span></code> x <code class="docutils literal"><span class="pre">cols</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">NewIndeterminates(int rows, int cols, const
std::vector&lt;std::string&gt;&amp; names);</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.NewOddDegreeFreePolynomial">
<code class="descname">NewOddDegreeFreePolynomial</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em>, <em>indeterminates: pydrake.symbolic.Variables</em>, <em>degree: int</em>, <em>coeff_name: str = 'a'</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Polynomial<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.NewOddDegreeFreePolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a free polynomial that only contains odd degree monomials. A
monomial is odd degree if its total degree (sum of all variables’
degree) is even. For example, xy is not an odd degree monomial (degree
2) while x²y is (degree 3).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">indeterminates</span></code>:</dt>
<dd>The monomial basis is over these indeterminates.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">degree</span></code>:</dt>
<dd>The highest degree of the polynomial.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">coeff_name</span></code>:</dt>
<dd>The coefficients of the polynomial are decision variables with
this name as a base. The variable name would be “a1”, “a2”, etc.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.NewSosPolynomial">
<code class="descname">NewSosPolynomial</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.NewSosPolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>NewSosPolynomial(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, monomial_basis: numpy.ndarray[object[m, 1]]) -&gt; Tuple[pydrake.symbolic.Polynomial, numpy.ndarray[object[m, n]]]</li>
</ol>
<p>Returns a pair of a SOS polynomial p = mᵀQm and the Grammian matrix Q,
where m is the <code class="docutils literal"><span class="pre">monomial</span></code> basis. For example,
<code class="docutils literal"><span class="pre">NewSosPolynomial(Vector2&lt;Monomial&gt;{x,y})</span></code> returns a polynomial p =
Q₍₀,₀₎x² + 2Q₍₁,₀₎xy + Q₍₁,₁₎y² and Q.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Q is a symmetric monomial_basis.rows() x monomial_basis.rows()
matrix.</p>
</div>
<ol class="arabic simple" start="2">
<li>NewSosPolynomial(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, indeterminates: pydrake.symbolic.Variables, degree: int) -&gt; Tuple[pydrake.symbolic.Polynomial, numpy.ndarray[object[m, n]]]</li>
</ol>
<p>Returns a pair of a SOS polynomial p = m(x)ᵀQm(x) of degree <code class="docutils literal"><span class="pre">degree</span></code>
and the Grammian matrix Q that should be PSD, where m(x) is the result
of calling <code class="docutils literal"><span class="pre">MonomialBasis(indeterminates,</span> <span class="pre">degree/2)</span></code>. For example,
<code class="docutils literal"><span class="pre">NewSosPolynomial({x},</span> <span class="pre">4)</span></code> returns a pair of a polynomial p =
Q₍₀,₀₎x⁴ + 2Q₍₁,₀₎ x³ + (2Q₍₂,₀₎ + Q₍₁,₁₎)x² + 2Q₍₂,₁₎x + Q₍₂,₂₎ and
Q.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal"><span class="pre">degree</span></code> is not a positive even integer.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MonomialBasis.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.NewSymmetricContinuousVariables">
<code class="descname">NewSymmetricContinuousVariables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em>, <em>rows: int</em>, <em>name: str = 'Symmetric'</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.NewSymmetricContinuousVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a runtime sized symmetric matrix as decision variables to this
MathematicalProgram. The optimization will only use the stacked
columns of the lower triangular part of the symmetric matrix as
decision variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">rows</span></code>:</dt>
<dd>The number of rows in the symmetric matrix.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">name</span></code>:</dt>
<dd>The name of the matrix. It is only used the for user to understand
the optimization program. The default name is “Symmetric”, and
each variable will be named as</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Symmetric</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>     <span class="n">Symmetric</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>     <span class="o">...</span> <span class="n">Symmetric</span><span class="p">(</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">Symmetric</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>     <span class="n">Symmetric</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>     <span class="o">...</span> <span class="n">Symmetric</span><span class="p">(</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
           <span class="o">...</span>
<span class="n">Symmetric</span><span class="p">(</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">Symmetric</span><span class="p">(</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">...</span> <span class="n">Symmetric</span><span class="p">(</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that the (i,j)’th entry and (j,i)’th entry has the same name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The newly added decision variables.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.num_vars">
<code class="descname">num_vars</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.num_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for number of variables in the optimization program</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.quadratic_costs">
<code class="descname">quadratic_costs</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[drake::solvers::Binding&lt;drake::solvers::QuadraticCost&gt;]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.quadratic_costs" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for quadratic costs.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.Reparse">
<code class="descname">Reparse</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em>, <em>p: pydrake.symbolic.Polynomial</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.Reparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reparses the polynomial <code class="docutils literal"><span class="pre">p</span></code> using this MathematicalProgram’s
indeterminates.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.SetDecisionVariableValueInVector">
<code class="descname">SetDecisionVariableValueInVector</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.SetDecisionVariableValueInVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetDecisionVariableValueInVector(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, decision_variable: pydrake.symbolic.Variable, decision_variable_new_value: float, values: numpy.ndarray[numpy.float64[m, 1], flags.writeable]) -&gt; None</li>
</ol>
<p>Updates the value of a single <code class="docutils literal"><span class="pre">decision_variable</span></code> inside the
<code class="docutils literal"><span class="pre">values</span></code> vector to be <code class="docutils literal"><span class="pre">decision_variable_new_value</span></code>. The other
decision variables’ values in <code class="docutils literal"><span class="pre">values</span></code> are unchanged.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">decision_variable</span></code>:</dt>
<dd>a registered decision variable in this program.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">decision_variable_new_value</span></code>:</dt>
<dd>the variable’s new values.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">values</span></code>:</dt>
<dd>The vector to be tweaked; must be of size num_vars().</dd>
</dl>
<ol class="arabic simple" start="2">
<li>SetDecisionVariableValueInVector(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, decision_variables: numpy.ndarray[object[m, n], flags.f_contiguous], decision_variables_new_values: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], values: numpy.ndarray[numpy.float64[m, 1], flags.writeable]) -&gt; None</li>
</ol>
<p>Updates the values of some <code class="docutils literal"><span class="pre">decision_variables</span></code> inside the
<code class="docutils literal"><span class="pre">values</span></code> vector to be <code class="docutils literal"><span class="pre">decision_variables_new_values</span></code>. The other
decision variables’ values in <code class="docutils literal"><span class="pre">values</span></code> are unchanged.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">decision_variables</span></code>:</dt>
<dd>registered decision variables in this program.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">decision_variables_new_values</span></code>:</dt>
<dd>the variables’ respective new values; must have the same rows()
and cols() sizes and <code class="docutils literal"><span class="pre">decision_variables</span></code>.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">values</span></code>:</dt>
<dd>The vector to be tweaked; must be of size num_vars().</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.SetInitialGuess">
<code class="descname">SetInitialGuess</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.SetInitialGuess" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetInitialGuess(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: pydrake.symbolic.Variable, arg1: float) -&gt; None</li>
</ol>
<p>Sets the initial guess for a single variable <code class="docutils literal"><span class="pre">decision_variable</span></code>.
The guess is stored as part of this program.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>decision_variable is a registered decision variable in the
program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if precondition is not satisfied.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetInitialGuess(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[numpy.float64[m, n]]) -&gt; None</li>
</ol>
<p>Sets the initial guess for the decision variables stored in
<code class="docutils literal"><span class="pre">decision_variable_mat</span></code> to be <code class="docutils literal"><span class="pre">x0</span></code>. The guess is stored as part of
this program.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.SetInitialGuessForAllVariables">
<code class="descname">SetInitialGuessForAllVariables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.SetInitialGuessForAllVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the initial guess for ALL decision variables. Note that variables
begin with a default initial guess of NaN to indicate that no guess is
available.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">x0</span></code>:</dt>
<dd>A vector of appropriate size (num_vars() x 1).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.SetSolverOption">
<code class="descname">SetSolverOption</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.SetSolverOption" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetSolverOption(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, solver_id: pydrake.solvers.mathematicalprogram.SolverId, solver_option: str, option_value: float) -&gt; None</li>
<li>SetSolverOption(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, solver_id: pydrake.solvers.mathematicalprogram.SolverId, solver_option: str, option_value: int) -&gt; None</li>
<li>SetSolverOption(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, solver_id: pydrake.solvers.mathematicalprogram.SolverId, solver_option: str, option_value: str) -&gt; None</li>
<li>SetSolverOption(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: pydrake.solvers.mathematicalprogram.SolverType, arg1: str, arg2: float) -&gt; None</li>
<li>SetSolverOption(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: pydrake.solvers.mathematicalprogram.SolverType, arg1: str, arg2: int) -&gt; None</li>
<li>SetSolverOption(self: pydrake.solvers.mathematicalprogram.MathematicalProgram, arg0: pydrake.solvers.mathematicalprogram.SolverType, arg1: str, arg2: str) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgram.SetSolverOptions">
<code class="descname">SetSolverOptions</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgram</em>, <em>arg0: pydrake.solvers.mathematicalprogram.SolverOptions</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgram.SetSolverOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite the stored solver options inside MathematicalProgram with
the provided solver options.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">MathematicalProgramResult</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult" title="Permalink to this definition">¶</a></dt>
<dd><p>The result returned by MathematicalProgram::Solve(). It stores the
solvers::SolutionResult (whether the program is solved to optimality,
detected infeasibility, etc), the optimal value for the decision
variables, the optimal cost, and solver specific details.</p>
<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the result.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The solver_details is set to nullptr.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult.EvalBinding">
<code class="descname">EvalBinding</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult</em>, <em>arg0: drake::solvers::Binding&lt;drake::solvers::EvaluatorBase&gt;</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult.EvalBinding" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a Binding at the solution.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">binding</span></code>:</dt>
<dd>A binding between a constraint/cost and the variables.</dd>
<dt>Precondition:</dt>
<dd>The binding.variables() must be the within the decision variables
in the MathematicalProgram that generated this
MathematicalProgramResult.</dd>
<dt>Precondition:</dt>
<dd>The user must have called set_decision_variable_index() function.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult.get_optimal_cost">
<code class="descname">get_optimal_cost</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult.get_optimal_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the optimal cost.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult.get_solution_result">
<code class="descname">get_solution_result</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; drake::solvers::SolutionResult<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult.get_solution_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets SolutionResult.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult.get_solver_details">
<code class="descname">get_solver_details</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; object<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult.get_solver_details" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the solver details for the <code class="docutils literal"><span class="pre">Solver</span></code> that solved the program.
Throws an error if the solver_details has not been set.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult.get_solver_id">
<code class="descname">get_solver_id</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.SolverId<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult.get_solver_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the solver ID.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult.get_suboptimal_objective">
<code class="descname">get_suboptimal_objective</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult</em>, <em>solution_number: int</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult.get_suboptimal_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the suboptimal objective value. See solution_pools “solution
pools”.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">solution_number</span></code>:</dt>
<dd>The index of the sub-optimal solution.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">solution_number</span></code> should be in the range [0,
num_suboptimal_solution()).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult.get_x_val">
<code class="descname">get_x_val</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult.get_x_val" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the decision variable values.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult.GetDualSolution">
<code class="descname">GetDualSolution</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult</em>, <em>arg0: drake::solvers::Binding&lt;drake::solvers::EvaluatorBase&gt;</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult.GetDualSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the dual solution associated with a constraint.</p>
<p>We interpret the dual variable value as the “shadow price” of the
original problem. Namely if we change the constraint bound by one unit
(each unit is infinitesimally small), the change of the optimal cost
is the value of the dual solution times the unit. Mathematically
dual_solution = ∂optimal_cost / ∂bound.</p>
<p>For a linear equality constraint Ax = b where b ∈ ℝⁿ, the vector of
dual variables has n rows, and dual_solution(i) is the value of the
dual variable for the constraint A(i,:)*x = b(i).</p>
<p>For a linear inequality constraint lower &lt;= A*x &lt;= upper where lower
and upper ∈ ℝⁿ, dual_solution also has n rows. dual_solution(i) is the
value of the dual variable for constraint lower(i) &lt;= A(i,:)*x &lt;=
upper(i). If neither side of the constraint is active, then
dual_solution(i) is 0. If the left hand-side lower(i) &lt;= A(i, :)*x is
active (meaning lower(i) = A(i, :)*x at the solution), then
dual_solution(i) is non-negative (because the objective is to minimize
a cost, increasing the lower bound means the constraint set is
tighter, hence the optimal solution cannot decrease. Thus the shadow
price is non-negative). If the right hand-side A(i, :)*x&lt;=upper(i) is
active (meaning A(i,:)*x=upper(i) at the solution), then
dual_solution(i) is non-positive.</p>
<p>For a bounding box constraint lower &lt;= x &lt;= upper, the interpretation
of the dual solution is the same as the linear inequality constraint.</p>
<p>For a Lorentz cone or rotated Lorentz cone constraint that Ax + b is
in the cone, depending on the solver, the dual solution has different
meanings: 1. If the solver is Gurobi, then the user can only obtain
the dual solution by explicitly setting the options for computing dual
solution.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">constraint</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">AddLorentzConeConstraint</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
   <span class="n">GurobiSolver</span> <span class="n">solver</span><span class="p">;</span>
   <span class="o">//</span> <span class="n">Explicitly</span> <span class="n">tell</span> <span class="n">the</span> <span class="n">solver</span> <span class="n">to</span> <span class="n">compute</span> <span class="n">the</span> <span class="n">dual</span> <span class="n">solution</span> <span class="k">for</span> <span class="n">Lorentz</span>
   <span class="o">//</span> <span class="n">cone</span> <span class="ow">or</span> <span class="n">rotated</span> <span class="n">Lorentz</span> <span class="n">cone</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">check</span>
   <span class="o">//</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="o">.</span><span class="n">gurobi</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">documentation</span><span class="o">/</span><span class="mf">9.0</span><span class="o">/</span><span class="n">refman</span><span class="o">/</span><span class="n">qcpdual</span><span class="o">.</span><span class="n">html</span> <span class="k">for</span>
   <span class="o">//</span> <span class="n">more</span> <span class="n">information</span><span class="o">.</span>
   <span class="n">SolverOptions</span> <span class="n">options</span><span class="p">;</span>
   <span class="n">options</span><span class="o">.</span><span class="n">SetOption</span><span class="p">(</span><span class="n">GurobiSolver</span><span class="p">::</span><span class="nb">id</span><span class="p">(),</span> <span class="s2">&quot;QCPDual&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
   <span class="n">MathematicalProgramResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="p">{},</span> <span class="n">options</span><span class="p">);</span>
   <span class="n">Eigen</span><span class="p">::</span><span class="n">VectorXd</span> <span class="n">dual_solution</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">GetDualSolution</span><span class="p">(</span><span class="n">constraint</span><span class="p">);</span>
</pre></div>
</div>
<p>The dual solution has size 1, dual_solution(0) is the shadow price for
the constraint z₁² + … +zₙ² ≤ z₀² for Lorentz cone constraint, and
the shadow price for the constraint z₂² + … +zₙ² ≤ z₀z₁ for rotated
Lorentz cone constraint, where z is the slack variable representing z
= A*x+b and z in the Lorentz cone/rotated Lorentz cone. 2. For
nonlinear solvers like IPOPT, the dual solution for Lorentz cone
constraint (with EvalType::kConvex) is the shadow price for z₀ -
sqrt(z₁² + … +zₙ²) ≥ 0, where z = Ax+b.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult.GetInfeasibleConstraintNames">
<code class="descname">GetInfeasibleConstraintNames</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult</em>, <em>prog: drake::solvers::MathematicalProgram</em>, <em>tol: Optional[float] = None</em><span class="sig-paren">)</span> &#x2192; List[str]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult.GetInfeasibleConstraintNames" title="Permalink to this definition">¶</a></dt>
<dd><p>See get_infeasible_constraints for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">prog</span></code>:</dt>
<dd>The MathematicalProgram that was solved to obtain <code class="docutils literal"><span class="pre">this</span></code>
MathematicalProgramResult.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">tolerance</span></code>:</dt>
<dd>A positive tolerance to check the constraint violation. If no
tolerance is provided, this method will attempt to obtain the
constraint tolerance from the solver, or insert a conservative
default tolerance.</dd>
</dl>
<p>Note: Currently most constraints have the empty string as the
description, so the NiceTypeName of the Constraint is used instead.
Use e.g. <code class="docutils literal"><span class="pre">prog.AddConstraint(x</span> <span class="pre">==</span>
<span class="pre">1).evaluator().set_description(str)</span></code> to make this method more
specific/useful.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult.GetInfeasibleConstraints">
<code class="descname">GetInfeasibleConstraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult</em>, <em>prog: drake::solvers::MathematicalProgram</em>, <em>tol: Optional[float] = None</em><span class="sig-paren">)</span> &#x2192; List[drake::solvers::Binding&lt;drake::solvers::Constraint&gt;]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult.GetInfeasibleConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>See get_infeasible_constraints for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">prog</span></code>:</dt>
<dd>The MathematicalProgram that was solved to obtain <code class="docutils literal"><span class="pre">this</span></code>
MathematicalProgramResult.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">tolerance</span></code>:</dt>
<dd>A positive tolerance to check the constraint violation. If no
tolerance is provided, this method will attempt to obtain the
constraint tolerance from the solver, or insert a conservative
default tolerance.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">infeasible_bindings A vector of all infeasible bindings
(constraints together with the associated variables) at the
best-effort solution.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult.GetSolution">
<code class="descname">GetSolution</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult.GetSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetSolution(self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Gets the solution of all decision variables.</p>
<ol class="arabic simple" start="2">
<li>GetSolution(self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult, arg0: pydrake.symbolic.Variable) -&gt; float</li>
</ol>
<p>Gets the solution of a single decision variable.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">var</span></code>:</dt>
<dd>The decision variable.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The value of the decision variable after solving the problem.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>invalid_argument if <code class="docutils literal"><span class="pre">var</span></code> is not captured in the mapping</li>
<li><code class="docutils literal"><span class="pre">decision_variable_index</span></code>, as the input argument of</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">set_decision_variable_index().</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>GetSolution(self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult, arg0: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Gets the solution of an Eigen matrix of decision variables.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">Derived</span></code>:</dt>
<dd>An Eigen matrix containing Variable.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">var</span></code>:</dt>
<dd>The decision variables.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The value of the decision variable after solving the problem.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>GetSolution(self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult, arg0: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[numpy.float64[m, n]]</li>
</ol>
<p>Gets the solution of an Eigen matrix of decision variables.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal"><span class="pre">Derived</span></code>:</dt>
<dd>An Eigen matrix containing Variable.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">var</span></code>:</dt>
<dd>The decision variables.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The value of the decision variable after solving the problem.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="5">
<li>GetSolution(self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult, arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>Substitutes the value of all decision variables into the Expression.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">e</span></code>:</dt>
<dd>The decision variable.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the Expression that is the result of the substitution.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="6">
<li>GetSolution(self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult, arg0: pydrake.symbolic.Polynomial) -&gt; pydrake.symbolic.Polynomial</li>
</ol>
<p>Substitutes the value of all decision variables into the coefficients
of the symbolic polynomial.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">p</span></code>:</dt>
<dd>A symbolic polynomial. Its indeterminates can’t intersect with the
set of decision variables of the MathematicalProgram from which
this result is obtained.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the symbolic::Polynomial as the result of the substitution.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="7">
<li>GetSolution(self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult, arg0: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult.GetSuboptimalSolution">
<code class="descname">GetSuboptimalSolution</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult.GetSuboptimalSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetSuboptimalSolution(self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult, arg0: pydrake.symbolic.Variable, arg1: int) -&gt; float</li>
</ol>
<p>Gets the suboptimal solution of a decision variable. See
solution_pools “solution pools”</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">var</span></code>:</dt>
<dd>The decision variable.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">solution_number</span></code>:</dt>
<dd>The index of the sub-optimal solution.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">solution_number</span></code> should be in the range [0,
num_suboptimal_solution()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The suboptimal value of the decision variable after solving the
problem.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetSuboptimalSolution(self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult, arg0: numpy.ndarray[object[m, 1]], arg1: int) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>&#64;name Solution Pools Some solvers (like Gurobi, Cplex, etc) can store
a pool of (suboptimal) solutions for mixed integer programming model.
Gets the suboptimal solution corresponding to a matrix of decision
variables. See solution_pools “solution pools”</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">var</span></code>:</dt>
<dd>The decision variables.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">solution_number</span></code>:</dt>
<dd>The index of the sub-optimal solution.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">solution_number</span></code> should be in the range [0,
num_suboptimal_solution()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The suboptimal values of the decision variables after solving the
problem.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>GetSuboptimalSolution(self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult, arg0: numpy.ndarray[object[m, n]], arg1: int) -&gt; numpy.ndarray[numpy.float64[m, n]]</li>
</ol>
<p>&#64;name Solution Pools Some solvers (like Gurobi, Cplex, etc) can store
a pool of (suboptimal) solutions for mixed integer programming model.
Gets the suboptimal solution corresponding to a matrix of decision
variables. See solution_pools “solution pools”</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">var</span></code>:</dt>
<dd>The decision variables.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">solution_number</span></code>:</dt>
<dd>The index of the sub-optimal solution.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">solution_number</span></code> should be in the range [0,
num_suboptimal_solution()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The suboptimal values of the decision variables after solving the
problem.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult.is_success">
<code class="descname">is_success</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult.is_success" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the optimization problem is solved successfully; false
otherwise. For more information on the solution status, the user could
call get_solver_details() to obtain the solver-specific solution
status.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.MathematicalProgramResult.set_x_val">
<code class="descname">set_x_val</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.MathematicalProgramResult, x_val: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.MathematicalProgramResult.set_x_val" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the decision variable values.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.PositiveSemidefiniteConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">PositiveSemidefiniteConstraint</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.PositiveSemidefiniteConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.mathematicalprogram.Constraint" title="pydrake.solvers.mathematicalprogram.Constraint"><code class="xref py py-class docutils literal"><span class="pre">pydrake.solvers.mathematicalprogram.Constraint</span></code></a></p>
<p>Implements a positive semidefinite constraint on a symmetric matrix S</p>
<div class="math">
\[\text{
S is p.s.d\]</div>
<p>}</p>
<p>namely, all eigen values of S are non-negative.</p>
<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.PositiveSemidefiniteConstraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.PositiveSemidefiniteConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.QuadraticCost">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">QuadraticCost</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.QuadraticCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.mathematicalprogram.Cost" title="pydrake.solvers.mathematicalprogram.Cost"><code class="xref py py-class docutils literal"><span class="pre">pydrake.solvers.mathematicalprogram.Cost</span></code></a></p>
<p>Implements a cost of the form</p>
<div class="math">
\[.5 x'Qx + b'x + c\]</div>
<p>.</p>
<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.QuadraticCost.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.QuadraticCost, Q: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]], c: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.QuadraticCost.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a cost of the form</p>
<div class="math">
\[.5 x'Qx + b'x + c\]</div>
<p>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">Q</span></code>:</dt>
<dd>Quadratic term.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">b</span></code>:</dt>
<dd>Linear term.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">c</span></code>:</dt>
<dd>(optional) Constant term.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.QuadraticCost.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.QuadraticCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.QuadraticCost.b" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.QuadraticCost.c">
<code class="descname">c</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.QuadraticCost</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.QuadraticCost.c" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.QuadraticCost.Q">
<code class="descname">Q</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.QuadraticCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.QuadraticCost.Q" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the symmetric matrix Q, as the Hessian of the cost.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.QuadraticCost.UpdateCoefficients">
<code class="descname">UpdateCoefficients</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.QuadraticCost, new_Q: numpy.ndarray[numpy.float64[m, n]], new_b: numpy.ndarray[numpy.float64[m, 1]], new_c: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.QuadraticCost.UpdateCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the quadratic and linear term of the constraint. The new
matrices need to have the same dimension as before.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">new_Q</span></code>:</dt>
<dd>New quadratic term.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">new_b</span></code>:</dt>
<dd>New linear term.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">new_c</span></code>:</dt>
<dd>(optional) New constant term.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.SolutionResult">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">SolutionResult</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolutionResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Members:</p>
<blockquote>
<div><p>kSolutionFound : Found the optimal solution.</p>
<p>kInvalidInput : Invalid input.</p>
<p>kInfeasibleConstraints : The primal is infeasible.</p>
<p>kUnbounded : The primal is unbounded.</p>
<p>kUnknownError : Unknown error.</p>
<p>kInfeasible_Or_Unbounded :</p>
<p>kIterationLimit : Reaches the iteration limits.</p>
<p>kDualInfeasible : Dual problem is infeasible. In this case we cannot</p>
</div></blockquote>
<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.SolutionResult.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.SolutionResult</em>, <em>arg0: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolutionResult.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolutionResult.kDualInfeasible">
<code class="descname">kDualInfeasible</code><em class="property"> = SolutionResult.kDualInfeasible</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolutionResult.kDualInfeasible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolutionResult.kInfeasible_Or_Unbounded">
<code class="descname">kInfeasible_Or_Unbounded</code><em class="property"> = SolutionResult.kInfeasible_Or_Unbounded</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolutionResult.kInfeasible_Or_Unbounded" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolutionResult.kInfeasibleConstraints">
<code class="descname">kInfeasibleConstraints</code><em class="property"> = SolutionResult.kInfeasibleConstraints</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolutionResult.kInfeasibleConstraints" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolutionResult.kInvalidInput">
<code class="descname">kInvalidInput</code><em class="property"> = SolutionResult.kInvalidInput</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolutionResult.kInvalidInput" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolutionResult.kIterationLimit">
<code class="descname">kIterationLimit</code><em class="property"> = SolutionResult.kIterationLimit</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolutionResult.kIterationLimit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolutionResult.kSolutionFound">
<code class="descname">kSolutionFound</code><em class="property"> = SolutionResult.kSolutionFound</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolutionResult.kSolutionFound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolutionResult.kUnbounded">
<code class="descname">kUnbounded</code><em class="property"> = SolutionResult.kUnbounded</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolutionResult.kUnbounded" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolutionResult.kUnknownError">
<code class="descname">kUnknownError</code><em class="property"> = SolutionResult.kUnknownError</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolutionResult.kUnknownError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolutionResult.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolutionResult.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.solvers.mathematicalprogram.Solve">
<code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">Solve</code><span class="sig-paren">(</span><em>prog: pydrake.solvers.mathematicalprogram.MathematicalProgram</em>, <em>initial_guess: Optional[numpy.ndarray[numpy.float64[m</em>, <em>1]]] = None</em>, <em>solver_options: Optional[pydrake.solvers.mathematicalprogram.SolverOptions] = None</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.mathematicalprogram.MathematicalProgramResult<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.Solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an optimization program, with optional initial guess and solver
options. This function first chooses the best solver depending on the
availability of the solver and the program formulation; it then
constructs that solver and call the Solve function of that solver. The
optimization result is stored in the return argument.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">prog</span></code>:</dt>
<dd>Contains the formulation of the program, and possibly solver
options.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">initial_guess</span></code>:</dt>
<dd>The initial guess for the decision variables.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">solver_options</span></code>:</dt>
<dd>The options in addition to those stored in <code class="docutils literal"><span class="pre">prog</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">result The result of solving the program through the solver.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.SolverId">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">SolverId</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverId" title="Permalink to this definition">¶</a></dt>
<dd><p>Identifies a SolverInterface implementation.</p>
<p>A moved-from instance is guaranteed to be empty and will not compare
equal to any non-empty ID.</p>
<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.SolverId.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.SolverId</em>, <em>name: str</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverId.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a specific, known solver type. Internally, a hidden
identifier is allocated and assigned to this instance; all instances
that share an identifier (including copies of this instance) are
considered equal. The solver names are not enforced to be unique,
though we recommend that they remain so in practice.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.SolverId.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.SolverId</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverId.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.SolverInterface">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">SolverInterface</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverInterface" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface used by implementations of individual solvers.</p>
<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.SolverInterface.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.SolverInterface</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverInterface.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.SolverInterface.AreProgramAttributesSatisfied">
<code class="descname">AreProgramAttributesSatisfied</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.SolverInterface</em>, <em>prog: drake::solvers::MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverInterface.AreProgramAttributesSatisfied" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the program attributes are satisfied by the solver’s
capability.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.SolverInterface.available">
<code class="descname">available</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.SolverInterface</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverInterface.available" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true iff this solver was enabled at compile-time. Certain
solvers may be excluded at compile-time due to licensing or linking
restrictions. When this method returns false, the Solve method will
throw.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.SolverInterface.Solve">
<code class="descname">Solve</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverInterface.Solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Solve(self: pydrake.solvers.mathematicalprogram.SolverInterface, prog: drake::solvers::MathematicalProgram, initial_guess: Optional[numpy.ndarray[numpy.float64[m, 1]]], solver_options: Optional[drake::solvers::SolverOptions], result: drake::solvers::MathematicalProgramResult) -&gt; None</li>
</ol>
<p>Solves an optimization program with optional initial guess and solver
options. Note that these initial guess and solver options are not
written to <code class="docutils literal"><span class="pre">prog</span></code>. If the <code class="docutils literal"><span class="pre">prog</span></code> has set an option for a solver,
and <code class="docutils literal"><span class="pre">solver_options</span></code> contains a different value for the same option
on the same solver, then <code class="docutils literal"><span class="pre">solver_options</span></code> takes priority.</p>
<ol class="arabic simple" start="2">
<li>Solve(self: pydrake.solvers.mathematicalprogram.SolverInterface, prog: drake::solvers::MathematicalProgram, initial_guess: Optional[numpy.ndarray[numpy.float64[m, 1]]] = None, solver_options: Optional[drake::solvers::SolverOptions] = None) -&gt; drake::solvers::MathematicalProgramResult</li>
</ol>
<p>Like SolverInterface::Solve(), but the result is a return value
instead of an output argument.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.SolverInterface.solver_id">
<code class="descname">solver_id</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.SolverInterface</em><span class="sig-paren">)</span> &#x2192; drake::solvers::SolverId<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverInterface.solver_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the identifier of this solver.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.SolverInterface.solver_type">
<code class="descname">solver_type</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.SolverInterface</em><span class="sig-paren">)</span> &#x2192; Optional[drake::solvers::SolverType]<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverInterface.solver_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.SolverInterface.SolverName">
<code class="descname">SolverName</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.SolverInterface</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverInterface.SolverName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.SolverOptions">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">SolverOptions</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores options for multiple solvers. This interface does not do any
verification of solver parameters. It does not even verify that the
specified solver exists. Use this only when you have particular
knowledge of what solver is being invoked, and exactly what tuning is
required.</p>
<p>Supported solver names/options:</p>
<p>“SNOPT” – Parameter names and values as specified in SNOPT User’s
Guide section 7.7 “Description of the optional parameters”, used as
described in section 7.5 for snSet(). The SNOPT user guide can be
obtained from <a class="reference external" href="https://web.stanford.edu/group/SOL/guides/sndoc7.pdf">https://web.stanford.edu/group/SOL/guides/sndoc7.pdf</a></p>
<p>“IPOPT” – Parameter names and values as specified in IPOPT users
guide section “Options Reference”
<a class="reference external" href="http://www.coin-or.org/Ipopt/documentation/node40.html">http://www.coin-or.org/Ipopt/documentation/node40.html</a></p>
<p>“GUROBI” – Parameter name and values as specified in Gurobi Reference
Manual, section 10.2 “Parameter Descriptions”
<a class="reference external" href="https://www.gurobi.com/documentation/9.0/refman/parameters.html">https://www.gurobi.com/documentation/9.0/refman/parameters.html</a></p>
<p>“SCS” – Parameter name and values as specified in the struct
SCS_SETTINGS in SCS header file
<a class="reference external" href="https://github.com/cvxgrp/scs/blob/master/include/scs.h">https://github.com/cvxgrp/scs/blob/master/include/scs.h</a> Note that the
SCS code on github master might be more up-to-date than the version
used in Drake.</p>
<p>“MOSEK” – Parameter name and values as specified in Mosek Reference
<a class="reference external" href="https://docs.mosek.com/9.0/capi/parameters.html">https://docs.mosek.com/9.0/capi/parameters.html</a></p>
<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.SolverOptions.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.SolverOptions</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverOptions.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.SolverOptions.GetOptions">
<code class="descname">GetOptions</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.SolverOptions</em>, <em>solver_id: pydrake.solvers.mathematicalprogram.SolverId</em><span class="sig-paren">)</span> &#x2192; dict<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverOptions.GetOptions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.SolverOptions.SetOption">
<code class="descname">SetOption</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverOptions.SetOption" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetOption(self: pydrake.solvers.mathematicalprogram.SolverOptions, solver_id: pydrake.solvers.mathematicalprogram.SolverId, solver_option: str, option_value: float) -&gt; None</li>
</ol>
<p>Set common options for all solvers supporting that option (for
example, printing the progress in each iteration). If the solver
doesn’t support the option, the option is ignored.</p>
<ol class="arabic simple" start="2">
<li>SetOption(self: pydrake.solvers.mathematicalprogram.SolverOptions, solver_id: pydrake.solvers.mathematicalprogram.SolverId, solver_option: str, option_value: int) -&gt; None</li>
</ol>
<p>Set common options for all solvers supporting that option (for
example, printing the progress in each iteration). If the solver
doesn’t support the option, the option is ignored.</p>
<ol class="arabic simple" start="3">
<li>SetOption(self: pydrake.solvers.mathematicalprogram.SolverOptions, solver_id: pydrake.solvers.mathematicalprogram.SolverId, solver_option: str, option_value: str) -&gt; None</li>
</ol>
<p>Set common options for all solvers supporting that option (for
example, printing the progress in each iteration). If the solver
doesn’t support the option, the option is ignored.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.SolverType">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">SolverType</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverType" title="Permalink to this definition">¶</a></dt>
<dd><p>Members:</p>
<blockquote>
<div><p>kCsdp :</p>
<p>kDReal :</p>
<p>kEqualityConstrainedQP :</p>
<p>kGurobi :</p>
<p>kIpopt :</p>
<p>kLinearSystem :</p>
<p>kMobyLCP :</p>
<p>kMosek :</p>
<p>kNlopt :</p>
<p>kOsqp :</p>
<p>kScs :</p>
<p>kSnopt :</p>
</div></blockquote>
<dl class="method">
<dt id="pydrake.solvers.mathematicalprogram.SolverType.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.mathematicalprogram.SolverType</em>, <em>arg0: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverType.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolverType.kCsdp">
<code class="descname">kCsdp</code><em class="property"> = SolverType.kCsdp</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverType.kCsdp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolverType.kDReal">
<code class="descname">kDReal</code><em class="property"> = SolverType.kDReal</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverType.kDReal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolverType.kEqualityConstrainedQP">
<code class="descname">kEqualityConstrainedQP</code><em class="property"> = SolverType.kEqualityConstrainedQP</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverType.kEqualityConstrainedQP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolverType.kGurobi">
<code class="descname">kGurobi</code><em class="property"> = SolverType.kGurobi</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverType.kGurobi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolverType.kIpopt">
<code class="descname">kIpopt</code><em class="property"> = SolverType.kIpopt</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverType.kIpopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolverType.kLinearSystem">
<code class="descname">kLinearSystem</code><em class="property"> = SolverType.kLinearSystem</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverType.kLinearSystem" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolverType.kMobyLCP">
<code class="descname">kMobyLCP</code><em class="property"> = SolverType.kMobyLCP</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverType.kMobyLCP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolverType.kMosek">
<code class="descname">kMosek</code><em class="property"> = SolverType.kMosek</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverType.kMosek" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolverType.kNlopt">
<code class="descname">kNlopt</code><em class="property"> = SolverType.kNlopt</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverType.kNlopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolverType.kOsqp">
<code class="descname">kOsqp</code><em class="property"> = SolverType.kOsqp</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverType.kOsqp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolverType.kScs">
<code class="descname">kScs</code><em class="property"> = SolverType.kScs</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverType.kScs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolverType.kSnopt">
<code class="descname">kSnopt</code><em class="property"> = SolverType.kSnopt</em><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverType.kSnopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.SolverType.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.SolverType.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.mathematicalprogram.VisualizationCallback">
<em class="property">class </em><code class="descclassname">pydrake.solvers.mathematicalprogram.</code><code class="descname">VisualizationCallback</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.VisualizationCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.mathematicalprogram.EvaluatorBase" title="pydrake.solvers.mathematicalprogram.EvaluatorBase"><code class="xref py py-class docutils literal"><span class="pre">pydrake.solvers.mathematicalprogram.EvaluatorBase</span></code></a></p>
<p>Defines a simple evaluator with no outputs that takes a callback
function pointer. This is intended for debugging / visualization of
intermediate results during an optimization (for solvers that support
it).</p>
<dl class="attribute">
<dt id="pydrake.solvers.mathematicalprogram.VisualizationCallback.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.mathematicalprogram.VisualizationCallback.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pydrake.solvers.mixed_integer_optimization_util.html" class="btn btn-neutral float-right" title="pydrake.solvers.mixed_integer_optimization_util" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pydrake.solvers.ipopt.html" class="btn btn-neutral" title="pydrake.solvers.ipopt" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>